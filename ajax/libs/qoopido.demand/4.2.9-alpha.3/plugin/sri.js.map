{"version":3,"sources":["plugin/sri.js"],"names":["SUPPORTED_ALGS","global","K_sha2","K_sha512","r_sha3","rc_sha3","TWO_PWR_32","Int_64","msint_32","lsint_32","this","highOrder","lowOrder","packed2hex","packed","outputLength","bigEndianMod","formatOpts","i","srcByte","shiftModifier","hex_tab","str","length","charAt","toUpperCase","packed2b64","j","triplet","int1","int2","packed2bytes","String","fromCharCode","packed2arraybuffer","arrView","retVal","ArrayBuffer","Uint8Array","getOutputOpts","options","outputOptions","outputUpper","b64Pad","shakeLen","hasOwnProperty","Error","getStrConverter","format","utfType","existingBin","existingBinLen","existingPacked","existingPackedLen","num","intOffset","byteOffset","existingByteLen","parseInt","substr","isNaN","push","value","binLen","hex2packed","codePnt","codePntArr","transposeBytes","byteCnt","charCodeAt","str2packed","tmpInt","strPart","firstEqual","search","indexOf","replace","b642packed","bytes2packed","ignore","arr","byteLength","arraybuffer2packed","rotl_32","x","n","rotl_64","rotr_32","rotr_64","tmp","shr_32","shr_64","parity_32","y","z","ch_32","ch_64","maj_32","maj_64","sigma0_32","sigma0_64","rotr28","rotr34","rotr39","sigma1_32","sigma1_64","rotr14","rotr18","rotr41","gamma0_32","gamma0_64","rotr1","rotr8","shr7","gamma1_32","gamma1_64","rotr19","rotr61","shr6","safeAdd_32_2","a","b","lsw","safeAdd_32_4","c","d","safeAdd_32_5","e","safeAdd_64_2","msw","safeAdd_64_4","safeAdd_64_5","xor_64_2","getNewState","variant","H_trunc","H_full","lastIndexOf","roundSHA1","block","H","T","t","W","ch","parity","maj","rotl","safeAdd_2","safeAdd_5","finalizeSHA1","remainder","remainderBinLen","processedBinLen","outputLen","appendedMessageLength","offset","totalLen","slice","roundSHA2","f","g","h","T1","T2","numRounds","binaryStringMult","safeAdd_4","gamma0","gamma1","sigma0","sigma1","Int","K","Number","roundSHA3","state","round","B","C","D","jsSHA","inputFormat","intermediateState","converterFunc","outputBinLen","variantBlockSize","roundFunc","finalizeFunc","stateCloneFunc","inputOptions","processedLen","remainderLen","shaVariant","hmacKeySet","keyWithIPad","keyWithOPad","updatedCalled","isSHAKE","binaryStringInc","finalizeSHA2","delimiter","clone","cloneSHA3State","blockSize","temp","state_offset","remainderIntLen","finalizeSHA3","setHMACKey","key","convertRet","keyBinLen","keyToUse","blockByteSize","lastArrayIndex","keyConverterFunc","update","srcString","chunkBinLen","chunkIntLen","chunk","updateProcessedLen","variantBlockIntInc","getHash","formatFunc","finalizedState","binarray","getHMAC","firstHash","define","exports","module","provide","path","Failure","iterate","isObject","settings","demand","on","dependency","sha","hash","match","type","source","dfd","reject","id","error"],"mappings":";AA0BA,IAAIA,eAAiB,IAEpB,SAASC,GACN,aAGA,IAqvCIC,EAAQC,EAAUC,EAAQC,EArvC1BC,EAAa,WAWjB,SAASC,EAAOC,EAAUC,GACtBC,KAAKC,UAAYH,EACjBE,KAAKE,SAAWH,EAoTpB,SAASI,EAAWC,EAAQC,EAAcC,EAAcC,GACpD,IAGIC,EAAGC,EAASC,EAHZC,EAAU,mBACVC,EAAM,GACNC,EAASR,EAAe,EAK5B,IAFAK,GAAmC,IAAlBJ,EAAuB,EAAI,EAEvCE,EAAI,EAAGA,EAAIK,EAAQL,GAAK,EAEzBC,EAAUL,EAAOI,IAAM,KAAQ,GAAKE,EAAgBJ,GAAgBE,EAAI,IACxEI,GAAOD,EAAQG,OAAQL,IAAY,EAAK,IACpCE,EAAQG,OAAiB,GAAVL,GAGvB,OAAQF,EAAyB,YAAIK,EAAIG,cAAgBH,EAiB7D,SAASI,EAAWZ,EAAQC,EAAcC,EAAcC,GACpD,IAEIC,EAAGS,EAAGC,EAASC,EAAMC,EAAMV,EAF3BE,EAAM,GACNC,EAASR,EAAe,EAM5B,IAFAK,GAAmC,IAAlBJ,EAAuB,EAAI,EAEvCE,EAAI,EAAGA,EAAIK,EAAQL,GAAK,EAMzB,IALAW,EAASX,EAAI,EAAKK,EAAUT,EAAQI,EAAI,IAAO,GAAK,EACpDY,EAASZ,EAAI,EAAKK,EAAUT,EAAQI,EAAI,IAAO,GAAK,EACpDU,GAAad,EAAOI,IAAM,KAAQ,GAAKE,EAAgBJ,GAAgBE,EAAI,IAAQ,MAAS,IACrFW,IAAU,GAAKT,EAAgBJ,IAAiBE,EAAI,GAAK,IAAQ,MAAS,EAC3EY,IAAU,GAAKV,EAAgBJ,IAAiBE,EAAI,GAAK,IAAQ,IAClES,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAEhBL,GADI,EAAJJ,EAAY,EAAJS,GAASZ,EAXhB,mEAYaS,OAAQI,IAAY,GAAK,EAAID,GAAM,IAE1CV,EAAmB,OAItC,OAAOK,EAeX,SAASS,EAAajB,EAAQC,EAAcC,GACxC,IAEIE,EAAGC,EAASC,EAFZE,EAAM,GACNC,EAASR,EAAe,EAK5B,IAFAK,GAAmC,IAAlBJ,EAAuB,EAAI,EAEvCE,EAAI,EAAGA,EAAIK,EAAQL,GAAK,EACzBC,EAAWL,EAAOI,IAAM,KAAQ,GAAKE,EAAgBJ,GAAgBE,EAAI,IAAQ,IACjFI,GAAOU,OAAOC,aAAad,GAG/B,OAAOG,EAeX,SAASY,EAAmBpB,EAAQC,EAAcC,GAC9C,IACIE,EACAE,EAAee,EAFfZ,EAASR,EAAe,EACrBqB,EAAS,IAAIC,YAAYd,GAMhC,IAJAY,EAAU,IAAIG,WAAWF,GAEzBhB,GAAmC,IAAlBJ,EAAuB,EAAI,EAEvCE,EAAI,EAAGA,EAAIK,EAAQL,GAAK,EACzBiB,EAAQjB,GAAMJ,EAAOI,IAAM,KAAQ,GAAKE,EAAgBJ,GAAgBE,EAAI,IAAQ,IAGxF,OAAOkB,EAaX,SAASG,EAAcC,GACnB,IAKIC,EALAL,GACIM,aAAe,EACfC,OAAU,IACVC,UAAa,GAWrB,GARAH,EAAgBD,MAEhBJ,EAAoB,YAAIK,EAA2B,cAAK,GAEpD,IAASA,EAAcI,eAAe,YACtCT,EAAe,OAAIK,EAAsB,SAGxC,IAASA,EAAcI,eAAe,aAA0C,IAAxB,EAAI7C,gBAAwB,CACrF,GAAIyC,EAAwB,SAAI,GAAM,EAClC,MAAM,IAAIK,MAAM,oCAEpBV,EAAiB,SAAIK,EAAwB,SAGjD,GAAI,kBAAqBL,EAAqB,YAC1C,MAAM,IAAIU,MAAM,yCAGpB,GAAI,iBAAoBV,EAAgB,OACpC,MAAM,IAAIU,MAAM,oCAGpB,OAAOV,EAiBX,SAASW,EAAgBC,EAAQC,EAASjC,GACtC,IAAIoB,EAGJ,OAAQa,GACJ,IAAK,OAEL,IAAK,UAEL,IAAK,UAED,MACJ,QACI,MAAM,IAAIH,MAAM,8CAIxB,OAAQE,GACJ,IAAK,MAWDZ,EAAS,SAASd,EAAK4B,EAAaC,GAChC,OAtYhB,SAAoB7B,EAAK8B,EAAgBC,EAAmBrC,GACxD,IAAIF,EACAI,EAAGoC,EAAKC,EAAWC,EACnBC,EAAiBrC,EAFTG,EAASD,EAAIC,OAIzB,GAAI,GAAOA,EAAS,EAChB,MAAM,IAAIuB,MAAM,iDAQpB,IALAhC,EAASsC,IAAmB,GAE5BK,GADAJ,EAAoBA,GAAqB,KACD,EACxCjC,GAAmC,IAAlBJ,EAAuB,EAAI,EAEvCE,EAAI,EAAGA,EAAIK,EAAQL,GAAK,EAAG,CAE5B,GADAoC,EAAMI,SAASpC,EAAIqC,OAAOzC,EAAG,GAAI,IAC5B0C,MAAMN,GAQP,MAAM,IAAIR,MAAM,kDALhB,IADAS,GADAC,GAActC,IAAM,GAAKuC,KACE,EACpB3C,EAAOS,QAAUgC,GACpBzC,EAAO+C,KAAK,GAEhB/C,EAAOyC,IAAcD,GAAQ,GAAKlC,EAAgBJ,GAAgBwC,EAAa,IAMvF,OACIM,MAAShD,EACTiD,OAAmB,EAATxC,EAAa8B,GAwWRW,CAAW1C,EAAK4B,EAAaC,EAAgBnC,IAExD,MACJ,IAAK,OAWDoB,EAAS,SAASd,EAAK4B,EAAaC,GAChC,OAhfhB,SAAoB7B,EAAK2B,EAASG,EAAgBC,EAAmBrC,GACjE,IAAIF,EAAQmD,EAASC,EACjBhD,EAAGS,EAAG8B,EACNF,EAAWC,EAAYpC,EAAe+C,EAFTC,EAAU,EAQ3C,GAJAtD,EAASsC,IAAmB,GAE5BK,GADAJ,EAAoBA,GAAqB,KACD,EAEpC,SAAWJ,EAEX,IADA7B,GAAmC,IAAlBJ,EAAuB,EAAI,EACvCE,EAAI,EAAGA,EAAII,EAAIC,OAAQL,GAAK,EA0B7B,IAxBAgD,KAEI,KAHJD,EAAU3C,EAAI+C,WAAWnD,IAIrBgD,EAAWL,KAAKI,GACT,KAAQA,GACfC,EAAWL,KAAK,IAAQI,IAAY,GACpCC,EAAWL,KAAK,IAAkB,GAAVI,IAChB,MAASA,GAAa,OAAUA,EACxCC,EAAWL,KACP,IAAQI,IAAY,GACpB,IAASA,IAAY,EAAK,GAC1B,IAAkB,GAAVA,IAGZ/C,GAAK,EACL+C,EAAU,QAAuB,KAAVA,IAAoB,GAA2B,KAApB3C,EAAI+C,WAAWnD,IACjEgD,EAAWL,KACP,IAAQI,IAAY,GACpB,IAASA,IAAY,GAAM,GAC3B,IAASA,IAAY,EAAK,GAC1B,IAAkB,GAAVA,IAIXtC,EAAI,EAAGA,EAAIuC,EAAW3C,OAAQI,GAAK,EAAG,CAGvC,IADA4B,GADAC,EAAaY,EAAUX,KACI,EACpB3C,EAAOS,QAAUgC,GACpBzC,EAAO+C,KAAK,GAGhB/C,EAAOyC,IAAcW,EAAWvC,IAAO,GAAKP,EAAgBJ,GAAgBwC,EAAa,IACzFY,GAAW,OAGhB,GAAK,YAAcnB,GAAY,YAAcA,EAMhD,IALA7B,GAAmC,IAAlBJ,EAAuB,EAAI,EAI5CmD,EAAmB,YAAclB,GAA8B,IAAjBjC,GAA0B,YAAciC,GAA8B,IAAjBjC,EAC9FE,EAAI,EAAGA,EAAII,EAAIC,OAAQL,GAAK,EAAG,CAShC,IARA+C,EAAU3C,EAAI+C,WAAWnD,IACF,IAAnBiD,IAEAF,GADAtC,EAAc,IAAVsC,IACY,EAAMA,IAAY,GAItCV,GADAC,EAAaY,EAAUX,KACI,EACpB3C,EAAOS,QAAUgC,GACpBzC,EAAO+C,KAAK,GAEhB/C,EAAOyC,IAAcU,GAAY,GAAK7C,EAAgBJ,GAAgBwC,EAAa,IACnFY,GAAW,EAGnB,OACIN,MAAShD,EACTiD,OAAoB,EAAVK,EAAcf,GAwaTiB,CAAWhD,EAAK2B,EAASC,EAAaC,EAAgBnC,IAEjE,MACJ,IAAK,MAWDoB,EAAS,SAASd,EAAK4B,EAAaC,GAChC,OA1UhB,SAAoB7B,EAAK8B,EAAgBC,EAAmBrC,GACxD,IAAIF,EACOI,EAAGS,EAAG4C,EAAQC,EAASC,EAE9BhB,EAAiBF,EAAWC,EAAYpC,EAHhCgD,EAAU,EAKtB,IAAK,IAAM9C,EAAIoD,OAAO,sBAClB,MAAM,IAAI5B,MAAM,uCAKpB,GAFA2B,EAAanD,EAAIqD,QAAQ,KACzBrD,EAAMA,EAAIsD,QAAQ,MAAO,KACnB,IAAMH,GAAgBA,EAAanD,EAAIC,OACzC,MAAM,IAAIuB,MAAM,uCAQpB,IALAhC,EAASsC,IAAmB,GAE5BK,GADAJ,EAAoBA,GAAqB,KACD,EACxCjC,GAAmC,IAAlBJ,EAAuB,EAAI,EAEvCE,EAAI,EAAGA,EAAII,EAAIC,OAAQL,GAAK,EAAG,CAIhC,IAHAsD,EAAUlD,EAAIqC,OAAOzC,EAAG,GACxBqD,EAAS,EAEJ5C,EAAI,EAAGA,EAAI6C,EAAQjD,OAAQI,GAAK,EAEjC4C,GAxBK,mEAuBUI,QAAQH,EAAQ7C,KACX,GAAM,EAAIA,EAGlC,IAAKA,EAAI,EAAGA,EAAI6C,EAAQjD,OAAS,EAAGI,GAAK,EAAG,CAGxC,IADA4B,GADAC,EAAaY,EAAUX,KACI,EACpB3C,EAAOS,QAAUgC,GACpBzC,EAAO+C,KAAK,GAEhB/C,EAAOyC,KAAgBgB,IAAY,GAAU,EAAJ5C,EAAW,MAC/C,GAAKP,EAAgBJ,GAAgBwC,EAAa,IACvDY,GAAW,GAInB,OACIN,MAAShD,EACTiD,OAAoB,EAAVK,EAAcf,GA8RTwB,CAAWvD,EAAK4B,EAAaC,EAAgBnC,IAExD,MACJ,IAAK,QAWDoB,EAAS,SAASd,EAAK4B,EAAaC,GAChC,OAlYhB,SAAsB7B,EAAK8B,EAAgBC,EAAmBrC,GAC1D,IAAIF,EAAQmD,EAAS/C,EAAGuC,EAAiBF,EACrCC,EAAYpC,EAOhB,IALAN,EAASsC,IAAmB,GAE5BK,GADAJ,EAAoBA,GAAqB,KACD,EACxCjC,GAAmC,IAAlBJ,EAAuB,EAAI,EAEvCE,EAAI,EAAGA,EAAII,EAAIC,OAAQL,GAAK,EAC7B+C,EAAU3C,EAAI+C,WAAWnD,GAGzBqC,GADAC,EAAatC,EAAIuC,KACU,EACvB3C,EAAOS,QAAUgC,GACjBzC,EAAO+C,KAAK,GAEhB/C,EAAOyC,IAAcU,GAAY,GAAK7C,EAAgBJ,GAAgBwC,EAAa,IAGvF,OACIM,MAAShD,EACTiD,OAAuB,EAAbzC,EAAIC,OAAa8B,GA4WZyB,CAAaxD,EAAK4B,EAAaC,EAAgBnC,IAE1D,MACJ,IAAK,cACD,IACIoB,EAAS,IAAIC,YAAY,GAC3B,MAAO0C,GACL,MAAM,IAAIjC,MAAM,iDAapBV,EAAS,SAAS4C,EAAK9B,EAAaC,GAChC,OA9ShB,SAA4B6B,EAAK5B,EAAgBC,EAAmBrC,GAChE,IAAIF,EAAQI,EAAGuC,EAAiBF,EAAWC,EAAYpC,EAAee,EAQtE,IANArB,EAASsC,IAAmB,GAE5BK,GADAJ,EAAoBA,GAAqB,KACD,EACxCjC,GAAmC,IAAlBJ,EAAuB,EAAI,EAC5CmB,EAAU,IAAIG,WAAW0C,GAEpB9D,EAAI,EAAGA,EAAI8D,EAAIC,WAAY/D,GAAK,EAEjCqC,GADAC,EAAatC,EAAIuC,KACU,EACvB3C,EAAOS,QAAUgC,GACjBzC,EAAO+C,KAAK,GAEhB/C,EAAOyC,IAAcpB,EAAQjB,IAAO,GAAKE,EAAgBJ,GAAgBwC,EAAa,IAG1F,OACIM,MAAShD,EACTiD,OAA2B,EAAjBiB,EAAIC,WAAiB5B,GA0RhB6B,CAAmBF,EAAK9B,EAAaC,EAAgBnC,IAEhE,MACJ,QACI,MAAM,IAAI8B,MAAM,wDAGxB,OAAOV,EAWX,SAAS+C,EAAQC,EAAGC,GAChB,OAAQD,GAAKC,EAAMD,IAAO,GAAKC,EAWnC,SAASC,EAAQF,EAAGC,GAChB,OAAIA,EAAI,IACJA,GAAQ,GACD,IAAI9E,EACP6E,EAAExE,UAAYyE,EAAID,EAAEzE,YAAe,GAAK0E,EACxCD,EAAEzE,WAAa0E,EAAID,EAAExE,WAAc,GAAKyE,IAErC,IAAMA,EACN,IAAI9E,EACP6E,EAAEzE,WAAa0E,EAAID,EAAExE,WAAc,GAAKyE,EACxCD,EAAExE,UAAYyE,EAAID,EAAEzE,YAAe,GAAK0E,GAGrCD,EAYf,SAASG,EAAQH,EAAGC,GAChB,OAAQD,IAAMC,EAAMD,GAAM,GAAKC,EAWnC,SAASG,EAAQJ,EAAGC,GAChB,IACII,EAAM,IAAIlF,EAAO6E,EAAEzE,UAAWyE,EAAExE,UAcpC,OAZI,IAAMyE,EACG,IAAI9E,EACRkF,EAAI9E,YAAc0E,EAAOI,EAAI7E,UAAa,GAAKyE,EAAM,WACrDI,EAAI7E,WAAayE,EAAOI,EAAI9E,WAAc,GAAK0E,EAAM,YAGjD,IAAI9E,EACRkF,EAAI7E,WAAcyE,EAAI,GAASI,EAAI9E,WAAc,GAAK0E,EAAM,WAC5DI,EAAI9E,YAAe0E,EAAI,GAASI,EAAI7E,UAAa,GAAKyE,EAAM,YAezE,SAASK,EAAON,EAAGC,GACf,OAAOD,IAAMC,EAWjB,SAASM,EAAOP,EAAGC,GAef,OAZI,IAAMA,EACG,IAAI9E,EACT6E,EAAEzE,YAAc0E,EAChBD,EAAExE,WAAayE,EAAMD,EAAEzE,WAAc,GAAK0E,EAAM,YAG3C,IAAI9E,EACT,EACA6E,EAAEzE,YAAe0E,EAAI,IAgBjC,SAASO,EAAUR,EAAGS,EAAGC,GACrB,OAAOV,EAAIS,EAAIC,EAYnB,SAASC,EAAMX,EAAGS,EAAGC,GACjB,OAAQV,EAAIS,GAAOT,EAAIU,EAY3B,SAASE,EAAMZ,EAAGS,EAAGC,GACjB,OAAO,IAAIvF,EACN6E,EAAEzE,UAAYkF,EAAElF,WAAeyE,EAAEzE,UAAYmF,EAAEnF,UAC/CyE,EAAExE,SAAWiF,EAAEjF,UAAcwE,EAAExE,SAAWkF,EAAElF,UAarD,SAASqF,EAAOb,EAAGS,EAAGC,GAClB,OAAQV,EAAIS,EAAMT,EAAIU,EAAMD,EAAIC,EAYpC,SAASI,EAAOd,EAAGS,EAAGC,GAClB,OAAO,IAAIvF,EACN6E,EAAEzE,UAAYkF,EAAElF,UAChByE,EAAEzE,UAAYmF,EAAEnF,UAChBkF,EAAElF,UAAYmF,EAAEnF,UAChByE,EAAExE,SAAWiF,EAAEjF,SACfwE,EAAExE,SAAWkF,EAAElF,SACfiF,EAAEjF,SAAWkF,EAAElF,UAWxB,SAASuF,EAAUf,GACf,OAAOG,EAAQH,EAAG,GAAKG,EAAQH,EAAG,IAAMG,EAAQH,EAAG,IAUvD,SAASgB,EAAUhB,GACf,IAAIiB,EAASb,EAAQJ,EAAG,IACpBkB,EAASd,EAAQJ,EAAG,IACpBmB,EAASf,EAAQJ,EAAG,IAExB,OAAO,IAAI7E,EACP8F,EAAO1F,UAAY2F,EAAO3F,UAAY4F,EAAO5F,UAC7C0F,EAAOzF,SAAW0F,EAAO1F,SAAW2F,EAAO3F,UAUnD,SAAS4F,EAAUpB,GACf,OAAOG,EAAQH,EAAG,GAAKG,EAAQH,EAAG,IAAMG,EAAQH,EAAG,IAUvD,SAASqB,EAAUrB,GACf,IAAIsB,EAASlB,EAAQJ,EAAG,IACpBuB,EAASnB,EAAQJ,EAAG,IACpBwB,EAASpB,EAAQJ,EAAG,IAExB,OAAO,IAAI7E,EACPmG,EAAO/F,UAAYgG,EAAOhG,UAAYiG,EAAOjG,UAC7C+F,EAAO9F,SAAW+F,EAAO/F,SAAWgG,EAAOhG,UAUnD,SAASiG,EAAUzB,GACf,OAAOG,EAAQH,EAAG,GAAKG,EAAQH,EAAG,IAAMM,EAAON,EAAG,GAUtD,SAAS0B,EAAU1B,GACf,IAAI2B,EAAQvB,EAAQJ,EAAG,GACnB4B,EAAQxB,EAAQJ,EAAG,GACnB6B,EAAOtB,EAAOP,EAAG,GAErB,OAAO,IAAI7E,EACPwG,EAAMpG,UAAYqG,EAAMrG,UAAYsG,EAAKtG,UACzCoG,EAAMnG,SAAWoG,EAAMpG,SAAWqG,EAAKrG,UAW/C,SAASsG,EAAU9B,GACf,OAAOG,EAAQH,EAAG,IAAMG,EAAQH,EAAG,IAAMM,EAAON,EAAG,IAUvD,SAAS+B,EAAU/B,GACf,IAAIgC,EAAS5B,EAAQJ,EAAG,IACpBiC,EAAS7B,EAAQJ,EAAG,IACpBkC,EAAO3B,EAAOP,EAAG,GAErB,OAAO,IAAI7E,EACP6G,EAAOzG,UAAY0G,EAAO1G,UAAY2G,EAAK3G,UAC3CyG,EAAOxG,SAAWyG,EAAOzG,SAAW0G,EAAK1G,UAajD,SAAS2G,EAAaC,EAAGC,GACrB,IAAIC,GAAW,MAAJF,IAAmB,MAAJC,GAG1B,OAAe,OAFJD,IAAM,KAAOC,IAAM,KAAOC,IAAQ,MAEnB,GAAa,MAANA,EAcrC,SAASC,EAAaH,EAAGC,EAAGG,EAAGC,GAC3B,IAAIH,GAAW,MAAJF,IAAmB,MAAJC,IAAmB,MAAJG,IAAmB,MAAJC,GAIxD,OAAe,OAHJL,IAAM,KAAOC,IAAM,KAAOG,IAAM,KAAOC,IAAM,KACnDH,IAAQ,MAEa,GAAa,MAANA,EAerC,SAASI,EAAaN,EAAGC,EAAGG,EAAGC,EAAGE,GAC9B,IAAIL,GAAW,MAAJF,IAAmB,MAAJC,IAAmB,MAAJG,IAAmB,MAAJC,IAC/C,MAAJE,GAIL,OAAe,OAHJP,IAAM,KAAOC,IAAM,KAAOG,IAAM,KAAOC,IAAM,KACnDE,IAAM,KAAOL,IAAQ,MAEA,GAAa,MAANA,EAYrC,SAASM,EAAa5C,EAAGS,GACrB,IAAI6B,EAAKO,EAAKrH,EAUd,OARA8G,GAAoB,MAAbtC,EAAExE,WAAmC,MAAbiF,EAAEjF,UAEjCA,GAAmB,OADnBqH,GAAO7C,EAAExE,WAAa,KAAOiF,EAAEjF,WAAa,KAAO8G,IAAQ,OAC7B,GAAa,MAANA,EAErCA,GAAqB,MAAdtC,EAAEzE,YAAqC,MAAdkF,EAAElF,YAAuBsH,IAAQ,IAI1D,IAAI1H,GAFS,OADpB0H,GAAO7C,EAAEzE,YAAc,KAAOkF,EAAElF,YAAc,KAAO+G,IAAQ,OAC9B,GAAa,MAANA,EAET9G,GAcjC,SAASsH,EAAaV,EAAGC,EAAGG,EAAGC,GAC3B,IAAIH,EAAKO,EAAKrH,EAcd,OAZA8G,GAAoB,MAAbF,EAAE5G,WAAmC,MAAb6G,EAAE7G,WACf,MAAbgH,EAAEhH,WAAmC,MAAbiH,EAAEjH,UAG/BA,GAAmB,OAFnBqH,GAAOT,EAAE5G,WAAa,KAAO6G,EAAE7G,WAAa,KACvCgH,EAAEhH,WAAa,KAAOiH,EAAEjH,WAAa,KAAO8G,IAAQ,OAC3B,GAAa,MAANA,EAErCA,GAAqB,MAAdF,EAAE7G,YAAqC,MAAd8G,EAAE9G,YACf,MAAdiH,EAAEjH,YAAqC,MAAdkH,EAAElH,YAAuBsH,IAAQ,IAKxD,IAAI1H,GAFS,OAFpB0H,GAAOT,EAAE7G,YAAc,KAAO8G,EAAE9G,YAAc,KACzCiH,EAAEjH,YAAc,KAAOkH,EAAElH,YAAc,KAAO+G,IAAQ,OAC5B,GAAa,MAANA,EAET9G,GAejC,SAASuH,EAAaX,EAAGC,EAAGG,EAAGC,EAAGE,GAC9B,IAAIL,EAAKO,EAAKrH,EAkBd,OAhBA8G,GAAoB,MAAbF,EAAE5G,WAAmC,MAAb6G,EAAE7G,WACf,MAAbgH,EAAEhH,WAAmC,MAAbiH,EAAEjH,WACb,MAAbmH,EAAEnH,UAIPA,GAAmB,OAHnBqH,GAAOT,EAAE5G,WAAa,KAAO6G,EAAE7G,WAAa,KACvCgH,EAAEhH,WAAa,KAAOiH,EAAEjH,WAAa,KAAOmH,EAAEnH,WAAa,KAC3D8G,IAAQ,OACiB,GAAa,MAANA,EAErCA,GAAqB,MAAdF,EAAE7G,YAAqC,MAAd8G,EAAE9G,YACf,MAAdiH,EAAEjH,YAAqC,MAAdkH,EAAElH,YACb,MAAdoH,EAAEpH,YAAuBsH,IAAQ,IAM/B,IAAI1H,GAFS,OAHpB0H,GAAOT,EAAE7G,YAAc,KAAO8G,EAAE9G,YAAc,KACzCiH,EAAEjH,YAAc,KAAOkH,EAAElH,YAAc,KACvCoH,EAAEpH,YAAc,KAAO+G,IAAQ,OACL,GAAa,MAANA,EAET9G,GAWjC,SAASwH,EAASZ,EAAGC,GACjB,OAAO,IAAIlH,EACPiH,EAAE7G,UAAY8G,EAAE9G,UAChB6G,EAAE5G,SAAW6G,EAAE7G,UA6CvB,SAASyH,EAAYC,GACjB,IACIC,EAASC,EAAQtH,EADjBkB,KAGJ,GAAK,UAAYkG,GAAsC,IAAxB,EAAItI,gBAC/BoC,GACI,WAAY,WAAY,WAAY,UAAY,iBAEjD,GAAwC,IAAnCkG,EAAQG,YAAY,OAAQ,IAAuC,IAAxB,EAAIzI,gBAUvD,OATAuI,GACI,WAAY,UAAY,UAAY,WACpC,WAAY,WAAY,WAAY,YAExCC,GACI,WAAY,WAAY,WAAY,WACpC,WAAY,WAAY,UAAY,YAGhCF,GACJ,IAAK,UACDlG,EAASmG,EACT,MACJ,IAAK,UACDnG,EAASoG,EACT,MACJ,IAAK,UACDpG,GACI,IAAI7B,EAAO,WAAYgI,EAAQ,IAC/B,IAAIhI,EAAO,WAAagI,EAAQ,IAChC,IAAIhI,EAAO,WAAYgI,EAAQ,IAC/B,IAAIhI,EAAO,UAAagI,EAAQ,IAChC,IAAIhI,EAAO,WAAYgI,EAAQ,IAC/B,IAAIhI,EAAO,YAAagI,EAAQ,IAChC,IAAIhI,EAAO,WAAYgI,EAAQ,IAC/B,IAAIhI,EAAO,WAAagI,EAAQ,KAEpC,MACJ,IAAK,UACDnG,GACI,IAAI7B,EAAOiI,EAAO,GAAI,YACtB,IAAIjI,EAAOiI,EAAO,GAAI,YACtB,IAAIjI,EAAOiI,EAAO,GAAI,YACtB,IAAIjI,EAAOiI,EAAO,GAAI,YACtB,IAAIjI,EAAOiI,EAAO,GAAI,YACtB,IAAIjI,EAAOiI,EAAO,GAAI,WACtB,IAAIjI,EAAOiI,EAAO,GAAI,YACtB,IAAIjI,EAAOiI,EAAO,GAAI,YAE1B,MACJ,QACI,MAAM,IAAI1F,MAAM,2BAErB,CAAA,GAA0C,IAApCwF,EAAQG,YAAY,QAAS,IAAkD,IAApCH,EAAQG,YAAY,QAAS,IACvD,IAAxB,EAAIzI,gBAKN,MAAM,IAAI8C,MAAM,6BAJhB,IAAK5B,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpBkB,EAAOlB,IAAM,IAAIX,EAAO,EAAG,GAAI,IAAIA,EAAO,EAAG,GAAI,IAAIA,EAAO,EAAG,GAAI,IAAIA,EAAO,EAAG,GAAI,IAAIA,EAAO,EAAG,IAM3G,OAAO6B,EAaX,SAASsG,EAAUC,EAAOC,GACtB,IACIpB,EAAGC,EAAGG,EAAGC,EAAGE,EAAGc,EAKfC,EANAC,KACkBC,EAAKjD,EACvBkD,EAASrD,EACTsD,EAAMjD,EACNkD,EAAOhE,EACPiE,EAAY7B,EAEZ8B,EAAYvB,EAQhB,IANAN,EAAIoB,EAAE,GACNnB,EAAImB,EAAE,GACNhB,EAAIgB,EAAE,GACNf,EAAIe,EAAE,GACNb,EAAIa,EAAE,GAEDE,EAAI,EAAGA,EAAI,GAAIA,GAAK,EAEjBC,EAAED,GADFA,EAAI,GACGH,EAAMG,GAENK,EAAKJ,EAAED,EAAI,GAAKC,EAAED,EAAI,GAAKC,EAAED,EAAI,IAAMC,EAAED,EAAI,IAAK,GAIzDD,EADAC,EAAI,GACAO,EAAUF,EAAK3B,EAAG,GAAIwB,EAAGvB,EAAGG,EAAGC,GAAIE,EAAG,WAAYgB,EAAED,IACjDA,EAAI,GACPO,EAAUF,EAAK3B,EAAG,GAAIyB,EAAOxB,EAAGG,EAAGC,GAAIE,EAAG,WAAYgB,EAAED,IACrDA,EAAI,GACPO,EAAUF,EAAK3B,EAAG,GAAI0B,EAAIzB,EAAGG,EAAGC,GAAIE,EAAG,WAAYgB,EAAED,IAErDO,EAAUF,EAAK3B,EAAG,GAAIyB,EAAOxB,EAAGG,EAAGC,GAAIE,EAAG,WAAYgB,EAAED,IAGhEf,EAAIF,EACJA,EAAID,EACJA,EAAIuB,EAAK1B,EAAG,IACZA,EAAID,EACJA,EAAIqB,EASR,OANAD,EAAE,GAAKQ,EAAU5B,EAAGoB,EAAE,IACtBA,EAAE,GAAKQ,EAAU3B,EAAGmB,EAAE,IACtBA,EAAE,GAAKQ,EAAUxB,EAAGgB,EAAE,IACtBA,EAAE,GAAKQ,EAAUvB,EAAGe,EAAE,IACtBA,EAAE,GAAKQ,EAAUrB,EAAGa,EAAE,IAEfA,EAkBX,SAASU,EAAaC,EAAWC,EAAiBC,EAAiBb,EAAGc,GAClE,IAAIxI,EAAGyI,EAAuBC,EAAQC,EAOtC,IADAD,EAAiD,IAArCJ,EAAkB,KAAQ,GAAM,GACrCD,EAAUhI,QAAUqI,GACvBL,EAAU1F,KAAK,GAkBnB,IAfA0F,EAAUC,IAAoB,IAAM,KAAS,GAAMA,EAAkB,GAMrEK,EAAWL,EAAkBC,EAC7BF,EAAUK,GAAqB,WAAXC,EAGpBN,EAAUK,EAAS,GAAMC,EAAWvJ,EAAc,EAElDqJ,EAAwBJ,EAAUhI,OAG7BL,EAAI,EAAGA,EAAIyI,EAAuBzI,GAAK,GACxC0H,EAAIF,EAAUa,EAAUO,MAAM5I,EAAGA,EAAI,IAAK0H,GAG9C,OAAOA,EA0GX,SAASmB,EAAUpB,EAAOC,EAAGN,GACzB,IAAId,EAAGC,EAAGG,EAAGC,EAAGE,EAAGiC,EAAGC,EAAGC,EAAGC,EAAIC,EAAIC,EAAWvB,EAAGwB,EAC9ClB,EAAWmB,EAAWlB,EAAWmB,EAAQC,EAAQC,EAAQC,EACzD3B,EAAIE,EAAK0B,EACT/I,EAAMC,EAAM8H,EAAQiB,EADN9B,KAKlB,GAAiB,YAAZT,GAAqC,YAAZA,GACA,IAAxB,EAAItI,gBAeH,CAAA,GAAiB,YAAZsI,GAAqC,YAAZA,GACP,IAAxB,EAAItI,gBAgBN,MAAM,IAAI8C,MAAM,4CAdhBuH,EAAY,GACZC,EAAmB,EACnBM,EAAMrK,EACN6I,EAAYpB,EACZuC,EAAYrC,EACZmB,EAAYlB,EACZqC,EAAS1D,EACT2D,EAAStD,EACTuD,EAAStE,EACTuE,EAASlE,EACTyC,EAAMhD,EACN8C,EAAKhD,EACL6E,EAAI1K,OA5BJkK,EAAY,GACZC,EAAmB,EACnBM,EAAME,OACN1B,EAAY7B,EACZgD,EAAY5C,EACZ0B,EAAYvB,EACZ0C,EAAS3D,EACT4D,EAASvD,EACTwD,EAASvE,EACTwE,EAASnE,EACT0C,EAAMjD,EACN+C,EAAKjD,EACL8E,EAAI3K,EA8BR,IATAsH,EAAIoB,EAAE,GACNnB,EAAImB,EAAE,GACNhB,EAAIgB,EAAE,GACNf,EAAIe,EAAE,GACNb,EAAIa,EAAE,GACNoB,EAAIpB,EAAE,GACNqB,EAAIrB,EAAE,GACNsB,EAAItB,EAAE,GAEDE,EAAI,EAAGA,EAAIuB,EAAWvB,GAAK,EACxBA,EAAI,IACJc,EAASd,EAAIwB,EACbzI,EAAQ8G,EAAMpH,QAAUqI,EAAU,EAAIjB,EAAMiB,GAC5C9H,EAAQ6G,EAAMpH,QAAUqI,EAAS,EAAK,EAAIjB,EAAMiB,EAAS,GAEzDb,EAAED,GAAK,IAAI8B,EAAI/I,EAAMC,IAErBiH,EAAED,GAAKyB,EACHE,EAAO1B,EAAED,EAAI,IAAKC,EAAED,EAAI,GACxB0B,EAAOzB,EAAED,EAAI,KAAMC,EAAED,EAAI,KAIjCqB,EAAKd,EAAUa,EAAGS,EAAO5C,GAAIiB,EAAGjB,EAAGiC,EAAGC,GAAIY,EAAE/B,GAAIC,EAAED,IAClDsB,EAAKhB,EAAUsB,EAAOlD,GAAI0B,EAAI1B,EAAGC,EAAGG,IACpCsC,EAAID,EACJA,EAAID,EACJA,EAAIjC,EACJA,EAAIqB,EAAUvB,EAAGsC,GACjBtC,EAAID,EACJA,EAAIH,EACJA,EAAID,EACJA,EAAI4B,EAAUe,EAAIC,GAYtB,OATAxB,EAAE,GAAKQ,EAAU5B,EAAGoB,EAAE,IACtBA,EAAE,GAAKQ,EAAU3B,EAAGmB,EAAE,IACtBA,EAAE,GAAKQ,EAAUxB,EAAGgB,EAAE,IACtBA,EAAE,GAAKQ,EAAUvB,EAAGe,EAAE,IACtBA,EAAE,GAAKQ,EAAUrB,EAAGa,EAAE,IACtBA,EAAE,GAAKQ,EAAUY,EAAGpB,EAAE,IACtBA,EAAE,GAAKQ,EAAUa,EAAGrB,EAAE,IACtBA,EAAE,GAAKQ,EAAUc,EAAGtB,EAAE,IAEfA,EA6GX,SAASmC,EAAUpC,EAAOqC,GACtB,IAAIC,EAAO7F,EAAGS,EAAGqF,EAvfH1D,EAAGC,EAAGG,EAAGC,EAAGE,EAufNoD,KAChBC,KAEJ,GAAI,OAASzC,EACT,IAAKvD,EAAI,EAAGA,EAAIuD,EAAMpH,OAAQ6D,GAAK,EAC/B4F,GAAO5F,IAAM,GAAK,IAAKA,IAAM,GAAK,EAAK,GAAKgD,EACxC4C,GAAO5F,IAAM,GAAK,IAAKA,IAAM,GAAK,EAAK,GACvC,IAAI7E,EAAOoI,EAAMvD,EAAI,GAAIuD,EAAMvD,KAK3C,IAAK6F,EAAQ,EAAGA,EAAQ,GAAIA,GAAS,EAAG,CAOpC,IAHAC,EAAI7C,EAAY,SAGXjD,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpB+F,EAAE/F,IA3gBIoC,EA2gBUwD,EAAM5F,GAAG,GA3gBhBqC,EA2gBoBuD,EAAM5F,GAAG,GA3gB1BwC,EA2gB8BoD,EAAM5F,GAAG,GA3gBpCyC,EA4gBXmD,EAAM5F,GAAG,GA5gBK2C,EA4gBDiD,EAAM5F,GAAG,GA3gB3B,IAAI7E,EACPiH,EAAE7G,UAAY8G,EAAE9G,UAAYiH,EAAEjH,UAAYkH,EAAElH,UAAYoH,EAAEpH,UAC1D6G,EAAE5G,SAAW6G,EAAE7G,SAAWgH,EAAEhH,SAAWiH,EAAEjH,SAAWmH,EAAEnH,WA2gBtD,IAAKwE,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpBgG,EAAEhG,GAAKgD,EAAS+C,GAAG/F,EAAI,GAAK,GAAIE,EAAQ6F,GAAG/F,EAAI,GAAK,GAAI,IAE5D,IAAKA,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpB,IAAKS,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpBmF,EAAM5F,GAAGS,GAAKuC,EAAS4C,EAAM5F,GAAGS,GAAIuF,EAAEhG,IAK9C,IAAKA,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpB,IAAKS,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpBqF,EAAErF,IAAI,EAAIT,EAAI,EAAIS,GAAK,GAAKP,EACxB0F,EAAM5F,GAAGS,GACTzF,EAAOgF,GAAGS,IAMtB,IAAKT,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpB,IAAKS,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpBmF,EAAM5F,GAAGS,GAAKuC,EACV8C,EAAE9F,GAAGS,GACL,IAAItF,GAAS2K,GAAG9F,EAAI,GAAK,GAAGS,GAAY,UAAIqF,GAAG9F,EAAI,GAAK,GAAGS,GAAGlF,WAAauK,GAAG9F,EAAI,GAAK,GAAGS,GAAW,SAAIqF,GAAG9F,EAAI,GAAK,GAAGS,GAAGjF,WAMvIoK,EAAM,GAAG,GAAK5C,EAAS4C,EAAM,GAAG,GAAI3K,EAAQ4K,IAGhD,OAAOD,EAnWkB,IAAxB,EAAIhL,kBACLE,GACI,WAAY,WAAY,WAAY,WACpC,UAAY,WAAY,WAAY,WACpC,WAAY,UAAY,UAAY,WACpC,WAAY,WAAY,WAAY,WACpC,WAAY,WAAY,UAAY,UACpC,UAAY,WAAY,WAAY,WACpC,WAAY,WAAY,WAAY,WACpC,WAAY,WAAY,UAAY,UACpC,UAAY,UAAY,WAAY,WACpC,WAAY,WAAY,WAAY,WACpC,WAAY,WAAY,WAAY,WACpC,WAAY,WAAY,WAAY,UACpC,UAAY,UAAY,UAAY,UACpC,UAAY,WAAY,WAAY,WACpC,WAAY,WAAY,WAAY,WACpC,WAAY,WAAY,WAAY,YAGX,IAAxB,EAAIF,kBACLG,GACI,IAAII,EAAOL,EAAO,GAAI,YAAa,IAAIK,EAAOL,EAAO,GAAI,WACzD,IAAIK,EAAOL,EAAO,GAAI,YAAa,IAAIK,EAAOL,EAAO,GAAI,YACzD,IAAIK,EAAOL,EAAO,GAAI,YAAa,IAAIK,EAAOL,EAAO,GAAI,YACzD,IAAIK,EAAOL,EAAO,GAAI,YAAa,IAAIK,EAAOL,EAAO,GAAI,YACzD,IAAIK,EAAOL,EAAO,GAAI,YAAa,IAAIK,EAAOL,EAAO,GAAI,YACzD,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,WAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,WAC3D,IAAIK,EAAOL,EAAO,IAAK,WAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAOL,EAAO,IAAK,YAAa,IAAIK,EAAOL,EAAO,IAAK,YAC3D,IAAIK,EAAO,WAAY,YAAa,IAAIA,EAAO,WAAY,WAC3D,IAAIA,EAAO,WAAY,YAAa,IAAIA,EAAO,WAAY,YAC3D,IAAIA,EAAO,UAAY,YAAa,IAAIA,EAAO,UAAY,YAC3D,IAAIA,EAAO,UAAY,YAAa,IAAIA,EAAO,UAAY,WAC3D,IAAIA,EAAO,UAAY,WAAa,IAAIA,EAAO,UAAY,YAC3D,IAAIA,EAAO,WAAY,WAAa,IAAIA,EAAO,WAAY,YAC3D,IAAIA,EAAO,WAAY,YAAa,IAAIA,EAAO,WAAY,YAC3D,IAAIA,EAAO,WAAY,WAAa,IAAIA,EAAO,WAAY,eAI1C,IAAxB,EAAIP,kBACLK,GACI,IAAIE,EAAO,EAAY,GAAa,IAAIA,EAAO,EAAY,OAC3D,IAAIA,EAAO,WAAY,OAAa,IAAIA,EAAO,WAAY,YAC3D,IAAIA,EAAO,EAAY,OAAa,IAAIA,EAAO,EAAY,YAC3D,IAAIA,EAAO,WAAY,YAAa,IAAIA,EAAO,WAAY,OAC3D,IAAIA,EAAO,EAAY,KAAa,IAAIA,EAAO,EAAY,KAC3D,IAAIA,EAAO,EAAY,YAAa,IAAIA,EAAO,EAAY,YAC3D,IAAIA,EAAO,EAAY,YAAa,IAAIA,EAAO,WAAY,KAC3D,IAAIA,EAAO,WAAY,OAAa,IAAIA,EAAO,WAAY,OAC3D,IAAIA,EAAO,WAAY,OAAa,IAAIA,EAAO,WAAY,KAC3D,IAAIA,EAAO,EAAY,OAAa,IAAIA,EAAO,WAAY,YAC3D,IAAIA,EAAO,WAAY,YAAa,IAAIA,EAAO,WAAY,OAC3D,IAAIA,EAAO,EAAY,YAAa,IAAIA,EAAO,WAAY,aAG/DH,IACK,EAAG,GAAI,EAAG,GAAI,KACd,EAAG,GAAI,GAAI,GAAI,IACf,GAAI,EAAG,GAAI,GAAI,KACf,GAAI,GAAI,GAAI,GAAI,KAChB,GAAI,GAAI,GAAI,EAAG,MA6VxB,IAAIiL,EAAQ,SAAS/C,EAASgD,EAAa9I,GACvC,IAGIS,EACAsI,EAAmBC,EACnBC,EACAC,EAAkBC,EAAWC,EAAcC,EAI3CxB,EAEAyB,EAZAC,EAAe,EACfxC,KACAyC,EAAe,EAEmBC,EAAa3D,EAG/C4D,GAAa,EACbC,KACAC,KAEAC,GAAgB,EACFC,GAAU,EACxBtL,GAAgB,EAMpB,GAHAiC,GADA6I,EAAetJ,OACkB,UAAK,QACtC6H,EAAYyB,EAAwB,WAAK,KAEtBpI,SAAS2G,EAAW,KAAS,EAAIA,EAChD,MAAM,IAAIvH,MAAM,iCAGpB,GAAK,UAAYmJ,GAAyC,IAAxB,EAAIjM,gBAClC0L,EAAmB,IACnBC,EAAYjD,EACZkD,EAAetC,EACfmC,EAAe,IACfI,EAAiB,SAASb,GACtB,OAAOA,EAAMlB,cAEd,GAA2C,IAAtCmC,EAAWxD,YAAY,OAAQ,IAAuC,IAAxB,EAAIzI,gBAW1D,GAVA2L,EAAY,SAAShD,EAAOC,GACxB,OAAOmB,EAAUpB,EAAOC,EAAGqD,IAE/BL,EAAe,SAASrC,EAAWC,EAAiBC,EAAiBb,EAAGc,GACpE,OAxQZ,SAAsBH,EAAWC,EAAiBC,EAAiBb,EAAGN,EAASoB,GAC3E,IAAIxI,EAAGyI,EAAuBC,EAAQxH,EAAQmK,EAAiB1C,EAE/D,GAAiB,YAAZvB,GAAqC,YAAZA,GACA,IAAxB,EAAItI,gBAQH,CAAA,GAAiB,YAAZsI,GAAqC,YAAZA,GACP,IAAxB,EAAItI,gBASN,MAAM,IAAI8C,MAAM,4CAHhB8G,EAAmD,IAAvCJ,EAAkB,MAAS,IAAO,GAC9C+C,EAAkB,QAVlB3C,EAAiD,IAArCJ,EAAkB,KAAQ,GAAM,GAC5C+C,EAAkB,GActB,KAAOhD,EAAUhI,QAAUqI,GACvBL,EAAU1F,KAAK,GAgBnB,IAbA0F,EAAUC,IAAoB,IAAM,KAAS,GAAKA,EAAkB,GAIpEK,EAAWL,EAAkBC,EAC7BF,EAAUK,GAAqB,WAAXC,EAGpBN,EAAUK,EAAS,GAAMC,EAAWvJ,EAAc,EAElDqJ,EAAwBJ,EAAUhI,OAG7BL,EAAI,EAAGA,EAAIyI,EAAuBzI,GAAKqL,EACxC3D,EAAImB,EAAUR,EAAUO,MAAM5I,EAAGA,EAAIqL,GAAkB3D,EAAGN,GAG9D,GAAK,YAAcA,GAAsC,IAAxB,EAAItI,gBACjCoC,GACIwG,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GACpBA,EAAE,GAAIA,EAAE,GAAIA,EAAE,SAEf,GAAK,YAAcN,GAAsC,IAAxB,EAAItI,gBACxCoC,EAASwG,OACN,GAAK,YAAcN,GAAsC,IAAxB,EAAItI,gBACxCoC,GACIwG,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,cAEtB,CAAA,GAAK,YAAc0H,GAAsC,IAAxB,EAAItI,gBAYxC,MAAM,IAAI8C,MAAM,4CAXhBV,GACIwG,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,SACrBgI,EAAE,GAAGjI,UAAWiI,EAAE,GAAGhI,UAM7B,OAAOwB,EA2LQoK,CAAajD,EAAWC,EAAiBC,EAAiBb,EAAGqD,IAExEJ,EAAiB,SAASb,GACtB,OAAOA,EAAMlB,SAGZ,YAAcmC,GAAyC,IAAxB,EAAIjM,gBACpC0L,EAAmB,IACnBD,EAAe,SACZ,GAAK,YAAcQ,GAAyC,IAAxB,EAAIjM,gBAC3C0L,EAAmB,IACnBD,EAAe,SACZ,GAAK,YAAcQ,GAAyC,IAAxB,EAAIjM,gBAC3C0L,EAAmB,KACnBD,EAAe,QACZ,CAAA,GAAK,YAAcQ,GAAyC,IAAxB,EAAIjM,gBAI3C,MAAM,IAAI8C,MAAM,uCAHhB4I,EAAmB,KACnBD,EAAe,QAIhB,CAAA,GAA6C,IAAvCQ,EAAWxD,YAAY,QAAS,IAAqD,IAAvCwD,EAAWxD,YAAY,QAAS,IAC7D,IAAxB,EAAIzI,gBAuCN,MAAM,IAAI8C,MAAM,uCAtChB,IAAI2J,EAAY,EAQhB,GANAd,EAAYZ,EACZc,EAAiB,SAASb,GACtB,OAjrBZ,SAAwBA,GACpB,IACI9J,EADAwL,KAEJ,IAAKxL,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACpBwL,EAAMxL,GAAK8J,EAAM9J,GAAG4I,QAGxB,OAAO4C,EA0qBQC,CAAe3B,IAE1BhK,EAAe,EAEX,aAAeiL,EACfP,EAAmB,KACnBD,EAAe,SAEZ,GAAI,aAAeQ,EACtBP,EAAmB,KACnBD,EAAe,SACZ,GAAI,aAAeQ,EACtBP,EAAmB,IACnBD,EAAe,SACZ,GAAI,aAAeQ,EACtBP,EAAmB,IACnBD,EAAe,SACZ,GAAI,aAAeQ,EACtBP,EAAmB,KACnBD,GAAgB,EAChBgB,EAAY,GACZH,GAAU,MACP,CAAA,GAAI,aAAeL,EAMtB,MAAM,IAAInJ,MAAM,uCALhB4I,EAAmB,KACnBD,GAAgB,EAChBgB,EAAY,GACZH,GAAU,EAIdV,EAAe,SAASrC,EAAWC,EAAiBC,EAAiBuB,EAAOtB,GACxE,OA5JZ,SAAsBH,EAAWC,EAAiBC,EAAiBuB,EAAO4B,EAAWH,EAAW/C,GAC5F,IAAIxI,EAIA2L,EAJGzK,KACHmK,EAAkBK,IAAc,EAChCE,EAAe,EACfC,EAAkBvD,IAAoB,EAO1C,IAAKtI,EAAI,EAAGA,EAAI6L,GAAmBvD,GAAmBoD,EAAW1L,GAAKqL,EAClEvB,EAAQD,EAAUxB,EAAUO,MAAM5I,EAAGA,EAAIqL,GAAkBvB,GAC3DxB,GAAmBoD,EAOvB,IAJArD,EAAYA,EAAUO,MAAM5I,GAC5BsI,GAAoCoD,EAG7BrD,EAAUhI,OAASgL,GACtBhD,EAAU1F,KAAK,GAUnB,IALA0F,GADArI,EAAIsI,IAAoB,IACT,IAAMiD,GAAmBvL,EAAI,EAAT,EAEnCqI,EAAUgD,EAAkB,IAAM,WAClCvB,EAAQD,EAAUxB,EAAWyB,GAEN,GAAhB5I,EAAOb,OAAcmI,IACxBmD,EAAO7B,EAAM8B,EAAe,GAAIA,EAAe,EAAK,GACpD1K,EAAOyB,KAAKgJ,EAAKjM,YACG,GAAhBwB,EAAOb,QAAemI,KAG1BtH,EAAOyB,KAAKgJ,EAAKlM,WAGb,GAAuB,IAF3BmM,GAAgB,GAEiBF,GAC7B7B,EAAU,KAAMC,GAIxB,OAAO5I,EA+GQ4K,CAAazD,EAAWC,EAAiBC,EAAiBuB,EAAOU,EAAkBe,EAAW/C,IAK7G8B,EAAgBzI,EAAgBuI,EAAarI,EAASjC,GACtDuK,EAAoBlD,EAAY4D,GAahCvL,KAAKuM,WAAa,SAASC,EAAK5B,EAAa9I,GACzC,IAAsB2K,EAAYC,EAAWC,EAAUC,EACnDpM,EAAGqM,EAEP,IAAI,IAASrB,EACT,MAAM,IAAIpJ,MAAM,wBAGpB,IAAI,IAASuJ,EACT,MAAM,IAAIvJ,MAAM,4CAGpB,IAAiB,IAAZwJ,GAA+C,IAAxB,EAAItM,gBAC5B,MAAM,IAAI8C,MAAM,mCAmBpB,GAVAsK,GADAD,EAFmBpK,EAAgBuI,EAFnCrI,GADaT,OACkB,UAAK,OAEqBxB,EAE5CwM,CAAiBN,IACC,OAC/BG,EAAWF,EAAkB,MAK7BI,GAHAD,EAAgB5B,IAAqB,GAGH,EAAK,EAInC4B,EAAiBF,EAAY,EAAI,CAMjC,IAJAC,EAAWzB,EAAayB,EAAUD,EAAW,EAAG/E,EAAY4D,GAAaR,GAIlE4B,EAAS9L,QAAUgM,GACtBF,EAASxJ,KAAK,GAElBwJ,EAASE,IAAmB,gBACzB,GAAID,EAAiBF,EAAY,EAAI,CAIxC,KAAOC,EAAS9L,QAAUgM,GACtBF,EAASxJ,KAAK,GAElBwJ,EAASE,IAAmB,WAIhC,IAAKrM,EAAI,EAAGA,GAAKqM,EAAgBrM,GAAK,EAClCiL,EAAYjL,GAAmB,UAAdmM,EAASnM,GAC1BkL,EAAYlL,GAAmB,WAAdmM,EAASnM,GAG9BqK,EAAoBI,EAAUQ,EAAaZ,GAC3CQ,EAAeL,EAEfQ,GAAa,GAUjBxL,KAAK+M,OAAS,SAASC,GACnB,IAAIP,EAAYQ,EAAaC,EAAaC,EAAO3M,EAAG4M,EAAqB,EACrEC,EAAqBrC,IAAqB,EAO9C,IAJAiC,GADAR,EAAa3B,EAAckC,EAAWnE,EAAWyC,IAChB,OACjC6B,EAAQV,EAAkB,MAE1BS,EAAcD,IAAgB,EACzBzM,EAAI,EAAGA,EAAI0M,EAAa1M,GAAK6M,EAC1BD,EAAqBpC,GAAoBiC,IACzCpC,EAAoBI,EAChBkC,EAAM/D,MAAM5I,EAAGA,EAAI6M,GACnBxC,GAEJuC,GAAsBpC,GAG9BK,GAAgB+B,EAChBvE,EAAYsE,EAAM/D,MAAMgE,IAAuB,GAC/C9B,EAAe2B,EAAcjC,EAC7BW,GAAgB,GAgBpB3L,KAAKsN,QAAU,SAAShL,EAAQR,GAC5B,IAAIyL,EAAY/M,EAAGuB,EAAeyL,EAElC,IAAI,IAAShC,EACT,MAAM,IAAIpJ,MAAM,8CAKpB,GAFAL,EAAgBF,EAAcC,IAEb,IAAZ8J,GAA+C,IAAxB,EAAItM,gBAAwB,CACpD,IAAmC,IAA/ByC,EAAwB,SACxB,MAAM,IAAIK,MAAM,yCAEpB2I,EAAehJ,EAAwB,SAI3C,OAAQO,GACJ,IAAK,MACDiL,EAAa,SAASE,GAClB,OAAOtN,EAAWsN,EAAU1C,EAAczK,EAAcyB,IAE5D,MACJ,IAAK,MACDwL,EAAa,SAASE,GAClB,OAAOzM,EAAWyM,EAAU1C,EAAczK,EAAcyB,IAE5D,MACJ,IAAK,QACDwL,EAAa,SAASE,GAClB,OAAOpM,EAAaoM,EAAU1C,EAAczK,IAEhD,MACJ,IAAK,cACD,IACIE,EAAI,IAAImB,YAAY,GACtB,MAAO0C,GACL,MAAM,IAAIjC,MAAM,iDAEpBmL,EAAa,SAASE,GAClB,OAAOjM,EAAmBiM,EAAU1C,EAAczK,IAEtD,MACJ,QACI,MAAM,IAAI8B,MAAM,kDAIxB,IADAoL,EAAiBtC,EAAarC,EAAUO,QAASkC,EAAcD,EAAcF,EAAeN,GAAoBE,GAC3GvK,EAAI,EAAGA,EAAImJ,EAAWnJ,GAAK,EAOE,IAAxB,EAAIlB,kBAAuC,IAAZsM,GAAsBb,EAAe,IAAO,IAC7EyC,EAAeA,EAAe3M,OAAS,IAAM,WAAe,GAAMkK,EAAe,IAErFyC,EAAiBtC,EAAasC,EAAgBzC,EAAc,EAAGpD,EAAY4D,GAAaR,GAG5F,OAAOwC,EAAWC,IAgBtBxN,KAAK0N,QAAU,SAASpL,EAAQR,GAC5B,IAAIyL,EAAYI,EAAW5L,EAAeyL,EAE1C,IAAI,IAAUhC,EACV,MAAM,IAAIpJ,MAAM,sDAMpB,OAHAL,EAAgBF,EAAcC,GAGtBQ,GACJ,IAAK,MACDiL,EAAa,SAASE,GAClB,OAAOtN,EAAWsN,EAAU1C,EAAczK,EAAcyB,IAE5D,MACJ,IAAK,MACDwL,EAAa,SAASE,GAClB,OAAOzM,EAAWyM,EAAU1C,EAAczK,EAAcyB,IAE5D,MACJ,IAAK,QACDwL,EAAa,SAASE,GAClB,OAAOpM,EAAaoM,EAAU1C,EAAczK,IAEhD,MACJ,IAAK,cACD,IACIiN,EAAa,IAAI5L,YAAY,GAC/B,MAAO0C,GACL,MAAM,IAAIjC,MAAM,iDAEpBmL,EAAa,SAASE,GAClB,OAAOjM,EAAmBiM,EAAU1C,EAAczK,IAEtD,MACJ,QACI,MAAM,IAAI8B,MAAM,wDAOxB,OAJAuL,EAAYzC,EAAarC,EAAUO,QAASkC,EAAcD,EAAcF,EAAeN,GAAoBE,GAC3GyC,EAAiBvC,EAAUS,EAAa/D,EAAY4D,IAG7CgC,EAFPC,EAAiBtC,EAAayC,EAAW5C,EAAcC,EAAkBwC,EAAgBzC,MAM5F,mBAAsB6C,QAAYA,OAAa,IAChDA,OAAO,WACH,OAAOjD,IAEJ,oBAAuBkD,QACzB,oBAAuBC,QAAWA,OAAgB,SACnDA,OAAgB,QAAInD,EACpBkD,QAAUlD,GAEVkD,QAAUlD,EAGdpL,EAAc,MAAIoL,EAphE1B,CAshEE3K,MAGD,SAAST,GACN,aA8CAwO,SAAS,OAAQ,kBAAmB,2BAA4B,8BA5ChE,SAAoBC,EAAMC,EAASC,EAASC,GACxC,IAAIC,EAwCJ,OAtCAC,OACKC,GAAG,iBAAmBN,EAAM,SAASlM,GAC9BqM,EAASrM,KACTsM,EAAWtM,KAGlBwM,GAAG,cAAe,SAASC,GACxB,IAAIzM,EAAS0M,EAAKC,EAiBPT,EACXU,EAhBA,GAeWV,EAfaO,EAAWP,KAkBvCE,EAAQE,EAAU,SAAS5B,EAAKpJ,GAC5B,GAAIoJ,IAAQwB,EAGR,OAFAU,EAAQtL,GAED,IAtBPtB,EA0BD4M,IAAS,EAzBR,KACIF,EAAM,IAAIjP,EAAOoL,MAAM7I,EAAQ6M,KAAM,SAEjC5B,OAAOwB,EAAWK,SAEjBH,EAAOD,EAAIlB,QAAQ,UAAYxL,EAAQ2M,MACxCF,EAAWM,IAAIC,OAAO,IAAIb,EAAQ,6BAA+BnM,EAAQ2M,KAAO,aAAeA,EAAO,UAAWF,EAAWQ,KAElI,MAAOC,GACLT,EAAWM,IAAIC,OAAO,IAAIb,EAAQ,sCAAuCM,EAAWQ,SAmB7F,IA5Cf,CAgDE/O","file":"sri.js","sourcesContent":["/* global\n\tjsSHA\n*/\n\n/**\n * @preserve A JavaScript implementation of the SHA family of hashes, as\n * defined in FIPS PUB 180-4 and FIPS PUB 202, as well as the corresponding\n * HMAC implementation as defined in FIPS PUB 198a\n *\n * Copyright 2008-2018 Brian Turek, 1998-2009 Paul Johnston & Contributors\n * Distributed under the BSD License\n * See http://caligatio.github.com/jsSHA/ for more information\n */\n\n/*jslint\n\tbitwise: true, multivar: true, for: true, this: true, sub: true, esversion: 3\n*/\n\n/**\n * SUPPORTED_ALGS is the stub for a compile flag that will cause pruning of\n * functions that are not needed when a limited number of SHA families are\n * selected\n *\n * @define {number} ORed value of SHA variants to be supported\n *   1 = SHA-1, 2 = SHA-224/SHA-256, 4 = SHA-384/SHA-512, 8 = SHA3\n */\nvar SUPPORTED_ALGS = 8 | 4 | 2 | 1;\n\n(function(global) {\n    \"use strict\";\n\n    /* Globals */\n    var TWO_PWR_32 = 4294967296;\n\n    /**\n     * Int_64 is a object for 2 32-bit numbers emulating a 64-bit number\n     *\n     * @private\n     * @constructor\n     * @this {Int_64}\n     * @param {number} msint_32 The most significant 32-bits of a 64-bit number\n     * @param {number} lsint_32 The least significant 32-bits of a 64-bit number\n     */\n    function Int_64(msint_32, lsint_32) {\n        this.highOrder = msint_32;\n        this.lowOrder = lsint_32;\n    }\n\n    /**\n     * Convert a string to an array of big-endian words\n     *\n     * There is a known bug with an odd number of existing bytes and using a\n     * UTF-16 encoding.  However, this function is used such that the existing\n     * bytes are always a result of a previous UTF-16 str2packed call and\n     * therefore there should never be an odd number of existing bytes\n     *\n     * @private\n     * @param {string} str String to be converted to binary representation\n     * @param {string} utfType The Unicode type, UTF8 or UTF16BE, UTF16LE, to\n     *   use to encode the source string\n     * @param {Array<number>} existingPacked A packed int array of bytes to\n     *   append the results to\n     * @param {number} existingPackedLen The number of bits in the existingPacked\n     *   array\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {{value : Array<number>, binLen : number}} Hash list where\n     *   \"value\" contains the output number array and \"binLen\" is the binary\n     *   length of \"value\"\n     */\n    function str2packed(str, utfType, existingPacked, existingPackedLen, bigEndianMod) {\n        var packed, codePnt, codePntArr, byteCnt = 0,\n            i, j, existingByteLen,\n            intOffset, byteOffset, shiftModifier, transposeBytes;\n\n        packed = existingPacked || [0];\n        existingPackedLen = existingPackedLen || 0;\n        existingByteLen = existingPackedLen >>> 3;\n\n        if (\"UTF8\" === utfType) {\n            shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n            for (i = 0; i < str.length; i += 1) {\n                codePnt = str.charCodeAt(i);\n                codePntArr = [];\n\n                if (0x80 > codePnt) {\n                    codePntArr.push(codePnt);\n                } else if (0x800 > codePnt) {\n                    codePntArr.push(0xC0 | (codePnt >>> 6));\n                    codePntArr.push(0x80 | (codePnt & 0x3F));\n                } else if ((0xd800 > codePnt) || (0xe000 <= codePnt)) {\n                    codePntArr.push(\n                        0xe0 | (codePnt >>> 12),\n                        0x80 | ((codePnt >>> 6) & 0x3f),\n                        0x80 | (codePnt & 0x3f)\n                    );\n                } else {\n                    i += 1;\n                    codePnt = 0x10000 + (((codePnt & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n                    codePntArr.push(\n                        0xf0 | (codePnt >>> 18),\n                        0x80 | ((codePnt >>> 12) & 0x3f),\n                        0x80 | ((codePnt >>> 6) & 0x3f),\n                        0x80 | (codePnt & 0x3f)\n                    );\n                }\n\n                for (j = 0; j < codePntArr.length; j += 1) {\n                    byteOffset = byteCnt + existingByteLen;\n                    intOffset = byteOffset >>> 2;\n                    while (packed.length <= intOffset) {\n                        packed.push(0);\n                    }\n                    /* Known bug kicks in here */\n                    packed[intOffset] |= codePntArr[j] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n                    byteCnt += 1;\n                }\n            }\n        } else if ((\"UTF16BE\" === utfType) || \"UTF16LE\" === utfType) {\n            shiftModifier = (bigEndianMod === -1) ? 2 : 0;\n            /* Internally strings are UTF-16BE so transpose bytes under two conditions:\n             * need LE and not switching endianness due to SHA-3\n             * need BE and switching endianness due to SHA-3 */\n            transposeBytes = ((\"UTF16LE\" === utfType) && (bigEndianMod !== 1)) || ((\"UTF16LE\" !== utfType) && (bigEndianMod === 1));\n            for (i = 0; i < str.length; i += 1) {\n                codePnt = str.charCodeAt(i);\n                if (transposeBytes === true) {\n                    j = codePnt & 0xFF;\n                    codePnt = (j << 8) | (codePnt >>> 8);\n                }\n\n                byteOffset = byteCnt + existingByteLen;\n                intOffset = byteOffset >>> 2;\n                while (packed.length <= intOffset) {\n                    packed.push(0);\n                }\n                packed[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n                byteCnt += 2;\n            }\n        }\n        return {\n            \"value\": packed,\n            \"binLen\": byteCnt * 8 + existingPackedLen\n        };\n    }\n\n    /**\n     * Convert a hex string to an array of big-endian words\n     *\n     * @private\n     * @param {string} str String to be converted to binary representation\n     * @param {Array<number>} existingPacked A packed int array of bytes to\n     *   append the results to\n     * @param {number} existingPackedLen The number of bits in the existingPacked\n     *   array\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {{value : Array<number>, binLen : number}} Hash list where\n     *   \"value\" contains the output number array and \"binLen\" is the binary\n     *   length of \"value\"\n     */\n    function hex2packed(str, existingPacked, existingPackedLen, bigEndianMod) {\n        var packed, length = str.length,\n            i, num, intOffset, byteOffset,\n            existingByteLen, shiftModifier;\n\n        if (0 !== (length % 2)) {\n            throw new Error(\"String of HEX type must be in byte increments\");\n        }\n\n        packed = existingPacked || [0];\n        existingPackedLen = existingPackedLen || 0;\n        existingByteLen = existingPackedLen >>> 3;\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n        for (i = 0; i < length; i += 2) {\n            num = parseInt(str.substr(i, 2), 16);\n            if (!isNaN(num)) {\n                byteOffset = (i >>> 1) + existingByteLen;\n                intOffset = byteOffset >>> 2;\n                while (packed.length <= intOffset) {\n                    packed.push(0);\n                }\n                packed[intOffset] |= num << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n            } else {\n                throw new Error(\"String of HEX type contains invalid characters\");\n            }\n        }\n\n        return {\n            \"value\": packed,\n            \"binLen\": length * 4 + existingPackedLen\n        };\n    }\n\n    /**\n     * Convert a string of raw bytes to an array of big-endian words\n     *\n     * @private\n     * @param {string} str String of raw bytes to be converted to binary representation\n     * @param {Array<number>} existingPacked A packed int array of bytes to\n     *   append the results to\n     * @param {number} existingPackedLen The number of bits in the existingPacked\n     *   array\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {{value : Array<number>, binLen : number}} Hash list where\n     *   \"value\" contains the output number array and \"binLen\" is the binary\n     *   length of \"value\"\n     */\n    function bytes2packed(str, existingPacked, existingPackedLen, bigEndianMod) {\n        var packed, codePnt, i, existingByteLen, intOffset,\n            byteOffset, shiftModifier;\n\n        packed = existingPacked || [0];\n        existingPackedLen = existingPackedLen || 0;\n        existingByteLen = existingPackedLen >>> 3;\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n        for (i = 0; i < str.length; i += 1) {\n            codePnt = str.charCodeAt(i);\n\n            byteOffset = i + existingByteLen;\n            intOffset = byteOffset >>> 2;\n            if (packed.length <= intOffset) {\n                packed.push(0);\n            }\n            packed[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n        }\n\n        return {\n            \"value\": packed,\n            \"binLen\": str.length * 8 + existingPackedLen\n        };\n    }\n\n    /**\n     * Convert a base-64 string to an array of big-endian words\n     *\n     * @private\n     * @param {string} str String to be converted to binary representation\n     * @param {Array<number>} existingPacked A packed int array of bytes to\n     *   append the results to\n     * @param {number} existingPackedLen The number of bits in the existingPacked\n     *   array\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {{value : Array<number>, binLen : number}} Hash list where\n     *   \"value\" contains the output number array and \"binLen\" is the binary\n     *   length of \"value\"\n     */\n    function b642packed(str, existingPacked, existingPackedLen, bigEndianMod) {\n        var packed, byteCnt = 0,\n            index, i, j, tmpInt, strPart, firstEqual,\n            b64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n            existingByteLen, intOffset, byteOffset, shiftModifier;\n\n        if (-1 === str.search(/^[a-zA-Z0-9=+\\/]+$/)) {\n            throw new Error(\"Invalid character in base-64 string\");\n        }\n\n        firstEqual = str.indexOf(\"=\");\n        str = str.replace(/\\=/g, \"\");\n        if ((-1 !== firstEqual) && (firstEqual < str.length)) {\n            throw new Error(\"Invalid '=' found in base-64 string\");\n        }\n\n        packed = existingPacked || [0];\n        existingPackedLen = existingPackedLen || 0;\n        existingByteLen = existingPackedLen >>> 3;\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n        for (i = 0; i < str.length; i += 4) {\n            strPart = str.substr(i, 4);\n            tmpInt = 0;\n\n            for (j = 0; j < strPart.length; j += 1) {\n                index = b64Tab.indexOf(strPart[j]);\n                tmpInt |= index << (18 - (6 * j));\n            }\n\n            for (j = 0; j < strPart.length - 1; j += 1) {\n                byteOffset = byteCnt + existingByteLen;\n                intOffset = byteOffset >>> 2;\n                while (packed.length <= intOffset) {\n                    packed.push(0);\n                }\n                packed[intOffset] |= ((tmpInt >>> (16 - (j * 8))) & 0xFF) <<\n                    (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n                byteCnt += 1;\n            }\n        }\n\n        return {\n            \"value\": packed,\n            \"binLen\": byteCnt * 8 + existingPackedLen\n        };\n    }\n\n    /**\n     * Convert an ArrayBuffer to an array of big-endian words\n     *\n     * @private\n     * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary\n     *   representation\n     * @param {Array<number>} existingPacked A packed int array of bytes to\n     *   append the results to\n     * @param {number} existingPackedLen The number of bits in the existingPacked\n     *   array\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {{value : Array<number>, binLen : number}} Hash list where\n     *   \"value\" contains the output number array and \"binLen\" is the binary\n     *   length of \"value\"\n     */\n    function arraybuffer2packed(arr, existingPacked, existingPackedLen, bigEndianMod) {\n        var packed, i, existingByteLen, intOffset, byteOffset, shiftModifier, arrView;\n\n        packed = existingPacked || [0];\n        existingPackedLen = existingPackedLen || 0;\n        existingByteLen = existingPackedLen >>> 3;\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n        arrView = new Uint8Array(arr);\n\n        for (i = 0; i < arr.byteLength; i += 1) {\n            byteOffset = i + existingByteLen;\n            intOffset = byteOffset >>> 2;\n            if (packed.length <= intOffset) {\n                packed.push(0);\n            }\n            packed[intOffset] |= arrView[i] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));\n        }\n\n        return {\n            \"value\": packed,\n            \"binLen\": arr.byteLength * 8 + existingPackedLen\n        };\n    }\n\n    /**\n     * Convert an array of big-endian words to a hex string.\n     *\n     * @private\n     * @param {Array<number>} packed Array of integers to be converted to\n     *   hexidecimal representation\n     * @param {number} outputLength Length of output in bits\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n     *   containing validated output formatting options\n     * @return {string} Hexidecimal representation of the parameter in string\n     *   form\n     */\n    function packed2hex(packed, outputLength, bigEndianMod, formatOpts) {\n        var hex_tab = \"0123456789abcdef\",\n            str = \"\",\n            length = outputLength / 8,\n            i, srcByte, shiftModifier;\n\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n        for (i = 0; i < length; i += 1) {\n            /* The below is more than a byte but it gets taken care of later */\n            srcByte = packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)));\n            str += hex_tab.charAt((srcByte >>> 4) & 0xF) +\n                hex_tab.charAt(srcByte & 0xF);\n        }\n\n        return (formatOpts[\"outputUpper\"]) ? str.toUpperCase() : str;\n    }\n\n    /**\n     * Convert an array of big-endian words to a base-64 string\n     *\n     * @private\n     * @param {Array<number>} packed Array of integers to be converted to\n     *   base-64 representation\n     * @param {number} outputLength Length of output in bits\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n     *   containing validated output formatting options\n     * @return {string} Base-64 encoded representation of the parameter in\n     *   string form\n     */\n    function packed2b64(packed, outputLength, bigEndianMod, formatOpts) {\n        var str = \"\",\n            length = outputLength / 8,\n            i, j, triplet, int1, int2, shiftModifier,\n            b64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n        for (i = 0; i < length; i += 3) {\n            int1 = ((i + 1) < length) ? packed[(i + 1) >>> 2] : 0;\n            int2 = ((i + 2) < length) ? packed[(i + 2) >>> 2] : 0;\n            triplet = (((packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF) << 16) |\n                (((int1 >>> (8 * (shiftModifier + bigEndianMod * ((i + 1) % 4)))) & 0xFF) << 8) |\n                ((int2 >>> (8 * (shiftModifier + bigEndianMod * ((i + 2) % 4)))) & 0xFF);\n            for (j = 0; j < 4; j += 1) {\n                if (i * 8 + j * 6 <= outputLength) {\n                    str += b64Tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);\n                } else {\n                    str += formatOpts[\"b64Pad\"];\n                }\n            }\n        }\n        return str;\n    }\n\n    /**\n     * Convert an array of big-endian words to raw bytes string\n     *\n     * @private\n     * @param {Array<number>} packed Array of integers to be converted to\n     *   a raw bytes string representation\n     * @param {number} outputLength Length of output in bits\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {string} Raw bytes representation of the parameter in string\n     *   form\n     */\n    function packed2bytes(packed, outputLength, bigEndianMod) {\n        var str = \"\",\n            length = outputLength / 8,\n            i, srcByte, shiftModifier;\n\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n        for (i = 0; i < length; i += 1) {\n            srcByte = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;\n            str += String.fromCharCode(srcByte);\n        }\n\n        return str;\n    }\n\n    /**\n     * Convert an array of big-endian words to an ArrayBuffer\n     *\n     * @private\n     * @param {Array<number>} packed Array of integers to be converted to\n     *   an ArrayBuffer\n     * @param {number} outputLength Length of output in bits\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {ArrayBuffer} Raw bytes representation of the parameter in an\n     *   ArrayBuffer\n     */\n    function packed2arraybuffer(packed, outputLength, bigEndianMod) {\n        var length = outputLength / 8,\n            i, retVal = new ArrayBuffer(length),\n            shiftModifier, arrView;\n        arrView = new Uint8Array(retVal);\n\n        shiftModifier = (bigEndianMod === -1) ? 3 : 0;\n\n        for (i = 0; i < length; i += 1) {\n            arrView[i] = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Validate hash list containing output formatting options, ensuring\n     * presence of every option or adding the default value\n     *\n     * @private\n     * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n     *   shakeLen : (number|undefined)}=} options Hash list of output formatting options\n     * @return {{outputUpper : boolean, b64Pad : string, shakeLen : number}} Validated\n     *   hash list containing output formatting options\n     */\n    function getOutputOpts(options) {\n        var retVal = {\n                \"outputUpper\": false,\n                \"b64Pad\": \"=\",\n                \"shakeLen\": -1\n            },\n            outputOptions;\n        outputOptions = options || {};\n\n        retVal[\"outputUpper\"] = outputOptions[\"outputUpper\"] || false;\n\n        if (true === outputOptions.hasOwnProperty(\"b64Pad\")) {\n            retVal[\"b64Pad\"] = outputOptions[\"b64Pad\"];\n        }\n\n        if ((true === outputOptions.hasOwnProperty(\"shakeLen\")) && ((8 & SUPPORTED_ALGS) !== 0)) {\n            if (outputOptions[\"shakeLen\"] % 8 !== 0) {\n                throw new Error(\"shakeLen must be a multiple of 8\");\n            }\n            retVal[\"shakeLen\"] = outputOptions[\"shakeLen\"];\n        }\n\n        if (\"boolean\" !== typeof(retVal[\"outputUpper\"])) {\n            throw new Error(\"Invalid outputUpper formatting option\");\n        }\n\n        if (\"string\" !== typeof(retVal[\"b64Pad\"])) {\n            throw new Error(\"Invalid b64Pad formatting option\");\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Function that takes an input format and UTF encoding and returns the\n     * appropriate function used to convert the input.\n     *\n     * @private\n     * @param {string} format The format of the string to be converted\n     * @param {string} utfType The string encoding to use (UTF8, UTF16BE,\n     *\tUTF16LE)\n     * @param {number} bigEndianMod Modifier for whether hash function is\n     *   big or small endian\n     * @return {function((string|ArrayBuffer), Array<number>=, number=): {value :\n     *   Array<number>, binLen : number}} Function that will convert an input\n     *   string to a packed int array\n     */\n    function getStrConverter(format, utfType, bigEndianMod) {\n        var retVal;\n\n        /* Validate encoding */\n        switch (utfType) {\n            case \"UTF8\":\n                /* Fallthrough */\n            case \"UTF16BE\":\n                /* Fallthrough */\n            case \"UTF16LE\":\n                /* Fallthrough */\n                break;\n            default:\n                throw new Error(\"encoding must be UTF8, UTF16BE, or UTF16LE\");\n        }\n\n        /* Map inputFormat to the appropriate converter */\n        switch (format) {\n            case \"HEX\":\n                /**\n                 * @param {string} str String of raw bytes to be converted to binary representation\n                 * @param {Array<number>} existingBin A packed int array of bytes to\n                 *   append the results to\n                 * @param {number} existingBinLen The number of bits in the existingBin\n                 *   array\n                 * @return {{value : Array<number>, binLen : number}} Hash list where\n                 *   \"value\" contains the output number array and \"binLen\" is the binary\n                 *   length of \"value\"\n                 */\n                retVal = function(str, existingBin, existingBinLen) {\n                    return hex2packed(str, existingBin, existingBinLen, bigEndianMod);\n                };\n                break;\n            case \"TEXT\":\n                /**\n                 * @param {string} str String of raw bytes to be converted to binary representation\n                 * @param {Array<number>} existingBin A packed int array of bytes to\n                 *   append the results to\n                 * @param {number} existingBinLen The number of bits in the existingBin\n                 *   array\n                 * @return {{value : Array<number>, binLen : number}} Hash list where\n                 *   \"value\" contains the output number array and \"binLen\" is the binary\n                 *   length of \"value\"\n                 */\n                retVal = function(str, existingBin, existingBinLen) {\n                    return str2packed(str, utfType, existingBin, existingBinLen, bigEndianMod);\n                };\n                break;\n            case \"B64\":\n                /**\n                 * @param {string} str String of raw bytes to be converted to binary representation\n                 * @param {Array<number>} existingBin A packed int array of bytes to\n                 *   append the results to\n                 * @param {number} existingBinLen The number of bits in the existingBin\n                 *   array\n                 * @return {{value : Array<number>, binLen : number}} Hash list where\n                 *   \"value\" contains the output number array and \"binLen\" is the binary\n                 *   length of \"value\"\n                 */\n                retVal = function(str, existingBin, existingBinLen) {\n                    return b642packed(str, existingBin, existingBinLen, bigEndianMod);\n                };\n                break;\n            case \"BYTES\":\n                /**\n                 * @param {string} str String of raw bytes to be converted to binary representation\n                 * @param {Array<number>} existingBin A packed int array of bytes to\n                 *   append the results to\n                 * @param {number} existingBinLen The number of bits in the existingBin\n                 *   array\n                 * @return {{value : Array<number>, binLen : number}} Hash list where\n                 *   \"value\" contains the output number array and \"binLen\" is the binary\n                 *   length of \"value\"\n                 */\n                retVal = function(str, existingBin, existingBinLen) {\n                    return bytes2packed(str, existingBin, existingBinLen, bigEndianMod);\n                };\n                break;\n            case \"ARRAYBUFFER\":\n                try {\n                    retVal = new ArrayBuffer(0);\n                } catch (ignore) {\n                    throw new Error(\"ARRAYBUFFER not supported by this environment\");\n                }\n                /**\n                 * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary\n                 *   representation\n                 * @param {Array<number>} existingBin A packed int array of bytes to\n                 *   append the results to\n                 * @param {number} existingBinLen The number of bits in the existingBin\n                 *   array\n                 * @return {{value : Array<number>, binLen : number}} Hash list where\n                 *   \"value\" contains the output number array and \"binLen\" is the binary\n                 *   length of \"value\"\n                 */\n                retVal = function(arr, existingBin, existingBinLen) {\n                    return arraybuffer2packed(arr, existingBin, existingBinLen, bigEndianMod);\n                };\n                break;\n            default:\n                throw new Error(\"format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER\");\n        }\n\n        return retVal;\n    }\n\n    /**\n     * The 32-bit implementation of circular rotate left\n     *\n     * @private\n     * @param {number} x The 32-bit integer argument\n     * @param {number} n The number of bits to shift\n     * @return {number} The x shifted circularly by n bits\n     */\n    function rotl_32(x, n) {\n        return (x << n) | (x >>> (32 - n));\n    }\n\n    /**\n     * The 64-bit implementation of circular rotate left\n     *\n     * @private\n     * @param {Int_64} x The 64-bit integer argument\n     * @param {number} n The number of bits to shift\n     * @return {Int_64} The x shifted circularly by n bits\n     */\n    function rotl_64(x, n) {\n        if (n > 32) {\n            n = n - 32;\n            return new Int_64(\n                x.lowOrder << n | x.highOrder >>> (32 - n),\n                x.highOrder << n | x.lowOrder >>> (32 - n)\n            );\n        } else if (0 !== n) {\n            return new Int_64(\n                x.highOrder << n | x.lowOrder >>> (32 - n),\n                x.lowOrder << n | x.highOrder >>> (32 - n)\n            );\n        } else {\n            return x;\n        }\n    }\n\n    /**\n     * The 32-bit implementation of circular rotate right\n     *\n     * @private\n     * @param {number} x The 32-bit integer argument\n     * @param {number} n The number of bits to shift\n     * @return {number} The x shifted circularly by n bits\n     */\n    function rotr_32(x, n) {\n        return (x >>> n) | (x << (32 - n));\n    }\n\n    /**\n     * The 64-bit implementation of circular rotate right\n     *\n     * @private\n     * @param {Int_64} x The 64-bit integer argument\n     * @param {number} n The number of bits to shift\n     * @return {Int_64} The x shifted circularly by n bits\n     */\n    function rotr_64(x, n) {\n        var retVal = null,\n            tmp = new Int_64(x.highOrder, x.lowOrder);\n\n        if (32 >= n) {\n            retVal = new Int_64(\n                (tmp.highOrder >>> n) | ((tmp.lowOrder << (32 - n)) & 0xFFFFFFFF),\n                (tmp.lowOrder >>> n) | ((tmp.highOrder << (32 - n)) & 0xFFFFFFFF)\n            );\n        } else {\n            retVal = new Int_64(\n                (tmp.lowOrder >>> (n - 32)) | ((tmp.highOrder << (64 - n)) & 0xFFFFFFFF),\n                (tmp.highOrder >>> (n - 32)) | ((tmp.lowOrder << (64 - n)) & 0xFFFFFFFF)\n            );\n        }\n\n        return retVal;\n    }\n\n    /**\n     * The 32-bit implementation of shift right\n     *\n     * @private\n     * @param {number} x The 32-bit integer argument\n     * @param {number} n The number of bits to shift\n     * @return {number} The x shifted by n bits\n     */\n    function shr_32(x, n) {\n        return x >>> n;\n    }\n\n    /**\n     * The 64-bit implementation of shift right\n     *\n     * @private\n     * @param {Int_64} x The 64-bit integer argument\n     * @param {number} n The number of bits to shift\n     * @return {Int_64} The x shifted by n bits\n     */\n    function shr_64(x, n) {\n        var retVal = null;\n\n        if (32 >= n) {\n            retVal = new Int_64(\n                x.highOrder >>> n,\n                x.lowOrder >>> n | ((x.highOrder << (32 - n)) & 0xFFFFFFFF)\n            );\n        } else {\n            retVal = new Int_64(\n                0,\n                x.highOrder >>> (n - 32)\n            );\n        }\n\n        return retVal;\n    }\n\n    /**\n     * The 32-bit implementation of the NIST specified Parity function\n     *\n     * @private\n     * @param {number} x The first 32-bit integer argument\n     * @param {number} y The second 32-bit integer argument\n     * @param {number} z The third 32-bit integer argument\n     * @return {number} The NIST specified output of the function\n     */\n    function parity_32(x, y, z) {\n        return x ^ y ^ z;\n    }\n\n    /**\n     * The 32-bit implementation of the NIST specified Ch function\n     *\n     * @private\n     * @param {number} x The first 32-bit integer argument\n     * @param {number} y The second 32-bit integer argument\n     * @param {number} z The third 32-bit integer argument\n     * @return {number} The NIST specified output of the function\n     */\n    function ch_32(x, y, z) {\n        return (x & y) ^ (~x & z);\n    }\n\n    /**\n     * The 64-bit implementation of the NIST specified Ch function\n     *\n     * @private\n     * @param {Int_64} x The first 64-bit integer argument\n     * @param {Int_64} y The second 64-bit integer argument\n     * @param {Int_64} z The third 64-bit integer argument\n     * @return {Int_64} The NIST specified output of the function\n     */\n    function ch_64(x, y, z) {\n        return new Int_64(\n            (x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),\n            (x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)\n        );\n    }\n\n    /**\n     * The 32-bit implementation of the NIST specified Maj function\n     *\n     * @private\n     * @param {number} x The first 32-bit integer argument\n     * @param {number} y The second 32-bit integer argument\n     * @param {number} z The third 32-bit integer argument\n     * @return {number} The NIST specified output of the function\n     */\n    function maj_32(x, y, z) {\n        return (x & y) ^ (x & z) ^ (y & z);\n    }\n\n    /**\n     * The 64-bit implementation of the NIST specified Maj function\n     *\n     * @private\n     * @param {Int_64} x The first 64-bit integer argument\n     * @param {Int_64} y The second 64-bit integer argument\n     * @param {Int_64} z The third 64-bit integer argument\n     * @return {Int_64} The NIST specified output of the function\n     */\n    function maj_64(x, y, z) {\n        return new Int_64(\n            (x.highOrder & y.highOrder) ^\n            (x.highOrder & z.highOrder) ^\n            (y.highOrder & z.highOrder),\n            (x.lowOrder & y.lowOrder) ^\n            (x.lowOrder & z.lowOrder) ^\n            (y.lowOrder & z.lowOrder)\n        );\n    }\n\n    /**\n     * The 32-bit implementation of the NIST specified Sigma0 function\n     *\n     * @private\n     * @param {number} x The 32-bit integer argument\n     * @return {number} The NIST specified output of the function\n     */\n    function sigma0_32(x) {\n        return rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22);\n    }\n\n    /**\n     * The 64-bit implementation of the NIST specified Sigma0 function\n     *\n     * @private\n     * @param {Int_64} x The 64-bit integer argument\n     * @return {Int_64} The NIST specified output of the function\n     */\n    function sigma0_64(x) {\n        var rotr28 = rotr_64(x, 28),\n            rotr34 = rotr_64(x, 34),\n            rotr39 = rotr_64(x, 39);\n\n        return new Int_64(\n            rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,\n            rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder);\n    }\n\n    /**\n     * The 32-bit implementation of the NIST specified Sigma1 function\n     *\n     * @private\n     * @param {number} x The 32-bit integer argument\n     * @return {number} The NIST specified output of the function\n     */\n    function sigma1_32(x) {\n        return rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25);\n    }\n\n    /**\n     * The 64-bit implementation of the NIST specified Sigma1 function\n     *\n     * @private\n     * @param {Int_64} x The 64-bit integer argument\n     * @return {Int_64} The NIST specified output of the function\n     */\n    function sigma1_64(x) {\n        var rotr14 = rotr_64(x, 14),\n            rotr18 = rotr_64(x, 18),\n            rotr41 = rotr_64(x, 41);\n\n        return new Int_64(\n            rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,\n            rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);\n    }\n\n    /**\n     * The 32-bit implementation of the NIST specified Gamma0 function\n     *\n     * @private\n     * @param {number} x The 32-bit integer argument\n     * @return {number} The NIST specified output of the function\n     */\n    function gamma0_32(x) {\n        return rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3);\n    }\n\n    /**\n     * The 64-bit implementation of the NIST specified Gamma0 function\n     *\n     * @private\n     * @param {Int_64} x The 64-bit integer argument\n     * @return {Int_64} The NIST specified output of the function\n     */\n    function gamma0_64(x) {\n        var rotr1 = rotr_64(x, 1),\n            rotr8 = rotr_64(x, 8),\n            shr7 = shr_64(x, 7);\n\n        return new Int_64(\n            rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,\n            rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder\n        );\n    }\n\n    /**\n     * The 32-bit implementation of the NIST specified Gamma1 function\n     *\n     * @private\n     * @param {number} x The 32-bit integer argument\n     * @return {number} The NIST specified output of the function\n     */\n    function gamma1_32(x) {\n        return rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10);\n    }\n\n    /**\n     * The 64-bit implementation of the NIST specified Gamma1 function\n     *\n     * @private\n     * @param {Int_64} x The 64-bit integer argument\n     * @return {Int_64} The NIST specified output of the function\n     */\n    function gamma1_64(x) {\n        var rotr19 = rotr_64(x, 19),\n            rotr61 = rotr_64(x, 61),\n            shr6 = shr_64(x, 6);\n\n        return new Int_64(\n            rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,\n            rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder\n        );\n    }\n\n    /**\n     * Add two 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n     * internally to work around bugs in some JS interpreters.\n     *\n     * @private\n     * @param {number} a The first 32-bit integer argument to be added\n     * @param {number} b The second 32-bit integer argument to be added\n     * @return {number} The sum of a + b\n     */\n    function safeAdd_32_2(a, b) {\n        var lsw = (a & 0xFFFF) + (b & 0xFFFF),\n            msw = (a >>> 16) + (b >>> 16) + (lsw >>> 16);\n\n        return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n    }\n\n    /**\n     * Add four 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n     * internally to work around bugs in some JS interpreters.\n     *\n     * @private\n     * @param {number} a The first 32-bit integer argument to be added\n     * @param {number} b The second 32-bit integer argument to be added\n     * @param {number} c The third 32-bit integer argument to be added\n     * @param {number} d The fourth 32-bit integer argument to be added\n     * @return {number} The sum of a + b + c + d\n     */\n    function safeAdd_32_4(a, b, c, d) {\n        var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF),\n            msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +\n            (lsw >>> 16);\n\n        return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n    }\n\n    /**\n     * Add five 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n     * internally to work around bugs in some JS interpreters.\n     *\n     * @private\n     * @param {number} a The first 32-bit integer argument to be added\n     * @param {number} b The second 32-bit integer argument to be added\n     * @param {number} c The third 32-bit integer argument to be added\n     * @param {number} d The fourth 32-bit integer argument to be added\n     * @param {number} e The fifth 32-bit integer argument to be added\n     * @return {number} The sum of a + b + c + d + e\n     */\n    function safeAdd_32_5(a, b, c, d, e) {\n        var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) +\n            (e & 0xFFFF),\n            msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +\n            (e >>> 16) + (lsw >>> 16);\n\n        return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n    }\n\n    /**\n     * Add two 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n     * internally to work around bugs in some JS interpreters.\n     *\n     * @private\n     * @param {Int_64} x The first 64-bit integer argument to be added\n     * @param {Int_64} y The second 64-bit integer argument to be added\n     * @return {Int_64} The sum of x + y\n     */\n    function safeAdd_64_2(x, y) {\n        var lsw, msw, lowOrder, highOrder;\n\n        lsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);\n        msw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);\n        lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n        lsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);\n        msw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);\n        highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n        return new Int_64(highOrder, lowOrder);\n    }\n\n    /**\n     * Add four 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n     * internally to work around bugs in some JS interpreters.\n     *\n     * @private\n     * @param {Int_64} a The first 64-bit integer argument to be added\n     * @param {Int_64} b The second 64-bit integer argument to be added\n     * @param {Int_64} c The third 64-bit integer argument to be added\n     * @param {Int_64} d The fouth 64-bit integer argument to be added\n     * @return {Int_64} The sum of a + b + c + d\n     */\n    function safeAdd_64_4(a, b, c, d) {\n        var lsw, msw, lowOrder, highOrder;\n\n        lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +\n            (c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF);\n        msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +\n            (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16);\n        lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n        lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +\n            (c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (msw >>> 16);\n        msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +\n            (c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16);\n        highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n        return new Int_64(highOrder, lowOrder);\n    }\n\n    /**\n     * Add five 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n     * internally to work around bugs in some JS interpreters.\n     *\n     * @private\n     * @param {Int_64} a The first 64-bit integer argument to be added\n     * @param {Int_64} b The second 64-bit integer argument to be added\n     * @param {Int_64} c The third 64-bit integer argument to be added\n     * @param {Int_64} d The fouth 64-bit integer argument to be added\n     * @param {Int_64} e The fouth 64-bit integer argument to be added\n     * @return {Int_64} The sum of a + b + c + d + e\n     */\n    function safeAdd_64_5(a, b, c, d, e) {\n        var lsw, msw, lowOrder, highOrder;\n\n        lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +\n            (c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) +\n            (e.lowOrder & 0xFFFF);\n        msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +\n            (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) +\n            (lsw >>> 16);\n        lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n        lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +\n            (c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) +\n            (e.highOrder & 0xFFFF) + (msw >>> 16);\n        msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +\n            (c.highOrder >>> 16) + (d.highOrder >>> 16) +\n            (e.highOrder >>> 16) + (lsw >>> 16);\n        highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n        return new Int_64(highOrder, lowOrder);\n    }\n\n    /**\n     * XORs two given arguments.\n     *\n     * @private\n     * @param {Int_64} a First argument to be XORed\n     * @param {Int_64} b Second argument to be XORed\n     * @return {Int_64} The XOR of the arguments\n     */\n    function xor_64_2(a, b) {\n        return new Int_64(\n            a.highOrder ^ b.highOrder,\n            a.lowOrder ^ b.lowOrder\n        );\n    }\n\n    /**\n     * XORs five given arguments.\n     *\n     * @private\n     * @param {Int_64} a First argument to be XORed\n     * @param {Int_64} b Second argument to be XORed\n     * @param {Int_64} c Third argument to be XORed\n     * @param {Int_64} d Fourth argument to be XORed\n     * @param {Int_64} e Fifth argument to be XORed\n     * @return {Int_64} The XOR of the arguments\n     */\n    function xor_64_5(a, b, c, d, e) {\n        return new Int_64(\n            a.highOrder ^ b.highOrder ^ c.highOrder ^ d.highOrder ^ e.highOrder,\n            a.lowOrder ^ b.lowOrder ^ c.lowOrder ^ d.lowOrder ^ e.lowOrder\n        );\n    }\n\n    /**\n     * Returns a clone of the given SHA3 state\n     *\n     * @private\n     * @param {Array<Array<Int_64>>} state The state to be cloned\n     * @return {Array<Array<Int_64>>} The cloned state\n     */\n    function cloneSHA3State(state) {\n        var clone = [],\n            i;\n        for (i = 0; i < 5; i += 1) {\n            clone[i] = state[i].slice();\n        }\n\n        return clone;\n    }\n\n    /**\n     * Gets the state values for the specified SHA variant\n     *\n     * @param {string} variant The SHA variant\n     * @return {Array<number|Int_64|Array<null>>} The initial state values\n     */\n    function getNewState(variant) {\n        var retVal = [],\n            H_trunc, H_full, i;\n\n        if ((\"SHA-1\" === variant) && ((1 & SUPPORTED_ALGS) !== 0)) {\n            retVal = [\n                0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0\n            ];\n        } else if ((variant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0)) {\n            H_trunc = [\n                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n            ];\n            H_full = [\n                0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n                0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n            ];\n\n            switch (variant) {\n                case \"SHA-224\":\n                    retVal = H_trunc;\n                    break;\n                case \"SHA-256\":\n                    retVal = H_full;\n                    break;\n                case \"SHA-384\":\n                    retVal = [\n                        new Int_64(0xcbbb9d5d, H_trunc[0]),\n                        new Int_64(0x0629a292a, H_trunc[1]),\n                        new Int_64(0x9159015a, H_trunc[2]),\n                        new Int_64(0x0152fecd8, H_trunc[3]),\n                        new Int_64(0x67332667, H_trunc[4]),\n                        new Int_64(0x98eb44a87, H_trunc[5]),\n                        new Int_64(0xdb0c2e0d, H_trunc[6]),\n                        new Int_64(0x047b5481d, H_trunc[7])\n                    ];\n                    break;\n                case \"SHA-512\":\n                    retVal = [\n                        new Int_64(H_full[0], 0xf3bcc908),\n                        new Int_64(H_full[1], 0x84caa73b),\n                        new Int_64(H_full[2], 0xfe94f82b),\n                        new Int_64(H_full[3], 0x5f1d36f1),\n                        new Int_64(H_full[4], 0xade682d1),\n                        new Int_64(H_full[5], 0x2b3e6c1f),\n                        new Int_64(H_full[6], 0xfb41bd6b),\n                        new Int_64(H_full[7], 0x137e2179)\n                    ];\n                    break;\n                default:\n                    throw new Error(\"Unknown SHA variant\");\n            }\n        } else if (((variant.lastIndexOf(\"SHA3-\", 0) === 0) || (variant.lastIndexOf(\"SHAKE\", 0) === 0)) &&\n            ((8 & SUPPORTED_ALGS) !== 0)) {\n            for (i = 0; i < 5; i += 1) {\n                retVal[i] = [new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0)];\n            }\n        } else {\n            throw new Error(\"No SHA variants supported\");\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Performs a round of SHA-1 hashing over a 512-byte block\n     *\n     * @private\n     * @param {Array<number>} block The binary array representation of the\n     *   block to hash\n     * @param {Array<number>} H The intermediate H values from a previous\n     *   round\n     * @return {Array<number>} The resulting H values\n     */\n    function roundSHA1(block, H) {\n        var W = [],\n            a, b, c, d, e, T, ch = ch_32,\n            parity = parity_32,\n            maj = maj_32,\n            rotl = rotl_32,\n            safeAdd_2 = safeAdd_32_2,\n            t,\n            safeAdd_5 = safeAdd_32_5;\n\n        a = H[0];\n        b = H[1];\n        c = H[2];\n        d = H[3];\n        e = H[4];\n\n        for (t = 0; t < 80; t += 1) {\n            if (t < 16) {\n                W[t] = block[t];\n            } else {\n                W[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n            }\n\n            if (t < 20) {\n                T = safeAdd_5(rotl(a, 5), ch(b, c, d), e, 0x5a827999, W[t]);\n            } else if (t < 40) {\n                T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0x6ed9eba1, W[t]);\n            } else if (t < 60) {\n                T = safeAdd_5(rotl(a, 5), maj(b, c, d), e, 0x8f1bbcdc, W[t]);\n            } else {\n                T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0xca62c1d6, W[t]);\n            }\n\n            e = d;\n            d = c;\n            c = rotl(b, 30);\n            b = a;\n            a = T;\n        }\n\n        H[0] = safeAdd_2(a, H[0]);\n        H[1] = safeAdd_2(b, H[1]);\n        H[2] = safeAdd_2(c, H[2]);\n        H[3] = safeAdd_2(d, H[3]);\n        H[4] = safeAdd_2(e, H[4]);\n\n        return H;\n    }\n\n    /**\n     * Finalizes the SHA-1 hash\n     *\n     * @private\n     * @param {Array<number>} remainder Any leftover unprocessed packed ints\n     *   that still need to be processed\n     * @param {number} remainderBinLen The number of bits in remainder\n     * @param {number} processedBinLen The number of bits already\n     *   processed\n     * @param {Array<number>} H The intermediate H values from a previous\n     *   round\n     * @param {number} outputLen Unused for this variant\n     * @return {Array<number>} The array of integers representing the SHA-1\n     *   hash of message\n     */\n    function finalizeSHA1(remainder, remainderBinLen, processedBinLen, H, outputLen) {\n        var i, appendedMessageLength, offset, totalLen;\n\n        /* The 65 addition is a hack but it works.  The correct number is\n           actually 72 (64 + 8) but the below math fails if\n           remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n           \"shorting\" the addition is OK. */\n        offset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n        while (remainder.length <= offset) {\n            remainder.push(0);\n        }\n        /* Append '1' at the end of the binary string */\n        remainder[remainderBinLen >>> 5] |= 0x80 << (24 - (remainderBinLen % 32));\n        /* Append length of binary string in the position such that the new\n         * length is a multiple of 512.  Logic does not work for even multiples\n         * of 512 but there can never be even multiples of 512. JavaScript\n         * numbers are limited to 2^53 so it's \"safe\" to treat the totalLen as\n         * a 64-bit integer. */\n        totalLen = remainderBinLen + processedBinLen;\n        remainder[offset] = totalLen & 0xFFFFFFFF;\n        /* Bitwise operators treat the operand as a 32-bit number so need to\n         * use hacky division and round to get access to upper 32-ish bits */\n        remainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;\n\n        appendedMessageLength = remainder.length;\n\n        /* This will always be at least 1 full chunk */\n        for (i = 0; i < appendedMessageLength; i += 16) {\n            H = roundSHA1(remainder.slice(i, i + 16), H);\n        }\n\n        return H;\n    }\n\n    /* Put this here so the K arrays aren't put on the stack for every block */\n    var K_sha2, K_sha512, r_sha3, rc_sha3;\n    if ((6 & SUPPORTED_ALGS) !== 0) {\n        K_sha2 = [\n            0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n            0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n            0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n            0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n            0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n            0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n            0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n            0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n            0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n            0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n            0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n            0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n            0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n            0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n            0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n            0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n        ];\n\n        if ((4 & SUPPORTED_ALGS) !== 0) {\n            K_sha512 = [\n                new Int_64(K_sha2[0], 0xd728ae22), new Int_64(K_sha2[1], 0x23ef65cd),\n                new Int_64(K_sha2[2], 0xec4d3b2f), new Int_64(K_sha2[3], 0x8189dbbc),\n                new Int_64(K_sha2[4], 0xf348b538), new Int_64(K_sha2[5], 0xb605d019),\n                new Int_64(K_sha2[6], 0xaf194f9b), new Int_64(K_sha2[7], 0xda6d8118),\n                new Int_64(K_sha2[8], 0xa3030242), new Int_64(K_sha2[9], 0x45706fbe),\n                new Int_64(K_sha2[10], 0x4ee4b28c), new Int_64(K_sha2[11], 0xd5ffb4e2),\n                new Int_64(K_sha2[12], 0xf27b896f), new Int_64(K_sha2[13], 0x3b1696b1),\n                new Int_64(K_sha2[14], 0x25c71235), new Int_64(K_sha2[15], 0xcf692694),\n                new Int_64(K_sha2[16], 0x9ef14ad2), new Int_64(K_sha2[17], 0x384f25e3),\n                new Int_64(K_sha2[18], 0x8b8cd5b5), new Int_64(K_sha2[19], 0x77ac9c65),\n                new Int_64(K_sha2[20], 0x592b0275), new Int_64(K_sha2[21], 0x6ea6e483),\n                new Int_64(K_sha2[22], 0xbd41fbd4), new Int_64(K_sha2[23], 0x831153b5),\n                new Int_64(K_sha2[24], 0xee66dfab), new Int_64(K_sha2[25], 0x2db43210),\n                new Int_64(K_sha2[26], 0x98fb213f), new Int_64(K_sha2[27], 0xbeef0ee4),\n                new Int_64(K_sha2[28], 0x3da88fc2), new Int_64(K_sha2[29], 0x930aa725),\n                new Int_64(K_sha2[30], 0xe003826f), new Int_64(K_sha2[31], 0x0a0e6e70),\n                new Int_64(K_sha2[32], 0x46d22ffc), new Int_64(K_sha2[33], 0x5c26c926),\n                new Int_64(K_sha2[34], 0x5ac42aed), new Int_64(K_sha2[35], 0x9d95b3df),\n                new Int_64(K_sha2[36], 0x8baf63de), new Int_64(K_sha2[37], 0x3c77b2a8),\n                new Int_64(K_sha2[38], 0x47edaee6), new Int_64(K_sha2[39], 0x1482353b),\n                new Int_64(K_sha2[40], 0x4cf10364), new Int_64(K_sha2[41], 0xbc423001),\n                new Int_64(K_sha2[42], 0xd0f89791), new Int_64(K_sha2[43], 0x0654be30),\n                new Int_64(K_sha2[44], 0xd6ef5218), new Int_64(K_sha2[45], 0x5565a910),\n                new Int_64(K_sha2[46], 0x5771202a), new Int_64(K_sha2[47], 0x32bbd1b8),\n                new Int_64(K_sha2[48], 0xb8d2d0c8), new Int_64(K_sha2[49], 0x5141ab53),\n                new Int_64(K_sha2[50], 0xdf8eeb99), new Int_64(K_sha2[51], 0xe19b48a8),\n                new Int_64(K_sha2[52], 0xc5c95a63), new Int_64(K_sha2[53], 0xe3418acb),\n                new Int_64(K_sha2[54], 0x7763e373), new Int_64(K_sha2[55], 0xd6b2b8a3),\n                new Int_64(K_sha2[56], 0x5defb2fc), new Int_64(K_sha2[57], 0x43172f60),\n                new Int_64(K_sha2[58], 0xa1f0ab72), new Int_64(K_sha2[59], 0x1a6439ec),\n                new Int_64(K_sha2[60], 0x23631e28), new Int_64(K_sha2[61], 0xde82bde9),\n                new Int_64(K_sha2[62], 0xb2c67915), new Int_64(K_sha2[63], 0xe372532b),\n                new Int_64(0xca273ece, 0xea26619c), new Int_64(0xd186b8c7, 0x21c0c207),\n                new Int_64(0xeada7dd6, 0xcde0eb1e), new Int_64(0xf57d4f7f, 0xee6ed178),\n                new Int_64(0x06f067aa, 0x72176fba), new Int_64(0x0a637dc5, 0xa2c898a6),\n                new Int_64(0x113f9804, 0xbef90dae), new Int_64(0x1b710b35, 0x131c471b),\n                new Int_64(0x28db77f5, 0x23047d84), new Int_64(0x32caab7b, 0x40c72493),\n                new Int_64(0x3c9ebe0a, 0x15c9bebc), new Int_64(0x431d67c4, 0x9c100d4c),\n                new Int_64(0x4cc5d4be, 0xcb3e42b6), new Int_64(0x597f299c, 0xfc657e2a),\n                new Int_64(0x5fcb6fab, 0x3ad6faec), new Int_64(0x6c44198c, 0x4a475817)\n            ];\n        }\n    }\n    if ((8 & SUPPORTED_ALGS) !== 0) {\n        rc_sha3 = [\n            new Int_64(0x00000000, 0x00000001), new Int_64(0x00000000, 0x00008082),\n            new Int_64(0x80000000, 0x0000808A), new Int_64(0x80000000, 0x80008000),\n            new Int_64(0x00000000, 0x0000808B), new Int_64(0x00000000, 0x80000001),\n            new Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008009),\n            new Int_64(0x00000000, 0x0000008A), new Int_64(0x00000000, 0x00000088),\n            new Int_64(0x00000000, 0x80008009), new Int_64(0x00000000, 0x8000000A),\n            new Int_64(0x00000000, 0x8000808B), new Int_64(0x80000000, 0x0000008B),\n            new Int_64(0x80000000, 0x00008089), new Int_64(0x80000000, 0x00008003),\n            new Int_64(0x80000000, 0x00008002), new Int_64(0x80000000, 0x00000080),\n            new Int_64(0x00000000, 0x0000800A), new Int_64(0x80000000, 0x8000000A),\n            new Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008080),\n            new Int_64(0x00000000, 0x80000001), new Int_64(0x80000000, 0x80008008)\n        ];\n\n        r_sha3 = [\n            [0, 36, 3, 41, 18],\n            [1, 44, 10, 45, 2],\n            [62, 6, 43, 15, 61],\n            [28, 55, 25, 21, 56],\n            [27, 20, 39, 8, 14]\n        ];\n    }\n\n    /**\n     * Performs a round of SHA-2 hashing over a block\n     *\n     * @private\n     * @param {Array<number>} block The binary array representation of the\n     *   block to hash\n     * @param {Array<number|Int_64>} H The intermediate H values from a previous\n     *   round\n     * @param {string} variant The desired SHA-2 variant\n     * @return {Array<number|Int_64>} The resulting H values\n     */\n    function roundSHA2(block, H, variant) {\n        var a, b, c, d, e, f, g, h, T1, T2, numRounds, t, binaryStringMult,\n            safeAdd_2, safeAdd_4, safeAdd_5, gamma0, gamma1, sigma0, sigma1,\n            ch, maj, Int, W = [],\n            int1, int2, offset, K;\n\n        /* Set up the various function handles and variable for the specific\n         * variant */\n        if ((variant === \"SHA-224\" || variant === \"SHA-256\") &&\n            ((2 & SUPPORTED_ALGS) !== 0)) {\n            /* 32-bit variant */\n            numRounds = 64;\n            binaryStringMult = 1;\n            Int = Number;\n            safeAdd_2 = safeAdd_32_2;\n            safeAdd_4 = safeAdd_32_4;\n            safeAdd_5 = safeAdd_32_5;\n            gamma0 = gamma0_32;\n            gamma1 = gamma1_32;\n            sigma0 = sigma0_32;\n            sigma1 = sigma1_32;\n            maj = maj_32;\n            ch = ch_32;\n            K = K_sha2;\n        } else if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&\n            ((4 & SUPPORTED_ALGS) !== 0)) {\n            /* 64-bit variant */\n            numRounds = 80;\n            binaryStringMult = 2;\n            Int = Int_64;\n            safeAdd_2 = safeAdd_64_2;\n            safeAdd_4 = safeAdd_64_4;\n            safeAdd_5 = safeAdd_64_5;\n            gamma0 = gamma0_64;\n            gamma1 = gamma1_64;\n            sigma0 = sigma0_64;\n            sigma1 = sigma1_64;\n            maj = maj_64;\n            ch = ch_64;\n            K = K_sha512;\n        } else {\n            throw new Error(\"Unexpected error in SHA-2 implementation\");\n        }\n\n        a = H[0];\n        b = H[1];\n        c = H[2];\n        d = H[3];\n        e = H[4];\n        f = H[5];\n        g = H[6];\n        h = H[7];\n\n        for (t = 0; t < numRounds; t += 1) {\n            if (t < 16) {\n                offset = t * binaryStringMult;\n                int1 = (block.length <= offset) ? 0 : block[offset];\n                int2 = (block.length <= offset + 1) ? 0 : block[offset + 1];\n                /* Bit of a hack - for 32-bit, the second term is ignored */\n                W[t] = new Int(int1, int2);\n            } else {\n                W[t] = safeAdd_4(\n                    gamma1(W[t - 2]), W[t - 7],\n                    gamma0(W[t - 15]), W[t - 16]\n                );\n            }\n\n            T1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);\n            T2 = safeAdd_2(sigma0(a), maj(a, b, c));\n            h = g;\n            g = f;\n            f = e;\n            e = safeAdd_2(d, T1);\n            d = c;\n            c = b;\n            b = a;\n            a = safeAdd_2(T1, T2);\n        }\n\n        H[0] = safeAdd_2(a, H[0]);\n        H[1] = safeAdd_2(b, H[1]);\n        H[2] = safeAdd_2(c, H[2]);\n        H[3] = safeAdd_2(d, H[3]);\n        H[4] = safeAdd_2(e, H[4]);\n        H[5] = safeAdd_2(f, H[5]);\n        H[6] = safeAdd_2(g, H[6]);\n        H[7] = safeAdd_2(h, H[7]);\n\n        return H;\n    }\n\n    /**\n     * Finalizes the SHA-2 hash\n     *\n     * @private\n     * @param {Array<number>} remainder Any leftover unprocessed packed ints\n     *   that still need to be processed\n     * @param {number} remainderBinLen The number of bits in remainder\n     * @param {number} processedBinLen The number of bits already\n     *   processed\n     * @param {Array<number|Int_64>} H The intermediate H values from a previous\n     *   round\n     * @param {string} variant The desired SHA-2 variant\n     * @param {number} outputLen Unused for this variant\n     * @return {Array<number>} The array of integers representing the SHA-2\n     *   hash of message\n     */\n    function finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, variant, outputLen) {\n        var i, appendedMessageLength, offset, retVal, binaryStringInc, totalLen;\n\n        if ((variant === \"SHA-224\" || variant === \"SHA-256\") &&\n            ((2 & SUPPORTED_ALGS) !== 0)) {\n            /* 32-bit variant */\n            /* The 65 addition is a hack but it works.  The correct number is\n               actually 72 (64 + 8) but the below math fails if\n               remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n               \"shorting\" the addition is OK. */\n            offset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n            binaryStringInc = 16;\n        } else if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&\n            ((4 & SUPPORTED_ALGS) !== 0)) {\n            /* 64-bit variant */\n            /* The 129 addition is a hack but it works.  The correct number is\n               actually 136 (128 + 8) but the below math fails if\n               remainderBinLen + 136 % 1024 = 0. Since remainderBinLen % 8 = 0,\n               \"shorting\" the addition is OK. */\n            offset = (((remainderBinLen + 129) >>> 10) << 5) + 31;\n            binaryStringInc = 32;\n        } else {\n            throw new Error(\"Unexpected error in SHA-2 implementation\");\n        }\n\n        while (remainder.length <= offset) {\n            remainder.push(0);\n        }\n        /* Append '1' at the end of the binary string */\n        remainder[remainderBinLen >>> 5] |= 0x80 << (24 - remainderBinLen % 32);\n        /* Append length of binary string in the position such that the new\n         * length is correct. JavaScript numbers are limited to 2^53 so it's\n         * \"safe\" to treat the totalLen as a 64-bit integer. */\n        totalLen = remainderBinLen + processedBinLen;\n        remainder[offset] = totalLen & 0xFFFFFFFF;\n        /* Bitwise operators treat the operand as a 32-bit number so need to\n         * use hacky division and round to get access to upper 32-ish bits */\n        remainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;\n\n        appendedMessageLength = remainder.length;\n\n        /* This will always be at least 1 full chunk */\n        for (i = 0; i < appendedMessageLength; i += binaryStringInc) {\n            H = roundSHA2(remainder.slice(i, i + binaryStringInc), H, variant);\n        }\n\n        if ((\"SHA-224\" === variant) && ((2 & SUPPORTED_ALGS) !== 0)) {\n            retVal = [\n                H[0], H[1], H[2], H[3],\n                H[4], H[5], H[6]\n            ];\n        } else if ((\"SHA-256\" === variant) && ((2 & SUPPORTED_ALGS) !== 0)) {\n            retVal = H;\n        } else if ((\"SHA-384\" === variant) && ((4 & SUPPORTED_ALGS) !== 0)) {\n            retVal = [\n                H[0].highOrder, H[0].lowOrder,\n                H[1].highOrder, H[1].lowOrder,\n                H[2].highOrder, H[2].lowOrder,\n                H[3].highOrder, H[3].lowOrder,\n                H[4].highOrder, H[4].lowOrder,\n                H[5].highOrder, H[5].lowOrder\n            ];\n        } else if ((\"SHA-512\" === variant) && ((4 & SUPPORTED_ALGS) !== 0)) {\n            retVal = [\n                H[0].highOrder, H[0].lowOrder,\n                H[1].highOrder, H[1].lowOrder,\n                H[2].highOrder, H[2].lowOrder,\n                H[3].highOrder, H[3].lowOrder,\n                H[4].highOrder, H[4].lowOrder,\n                H[5].highOrder, H[5].lowOrder,\n                H[6].highOrder, H[6].lowOrder,\n                H[7].highOrder, H[7].lowOrder\n            ];\n        } else /* This should never be reached */ {\n            throw new Error(\"Unexpected error in SHA-2 implementation\");\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Performs a round of SHA-3 hashing over a block\n     *\n     * @private\n     * @param {Array<number>|null} block The binary array representation of the\n     *   block to hash\n     * @param {Array<Array<Int_64>>} state The binary array representation of the\n     *   block to hash\n     * @return {Array<Array<Int_64>>} The resulting state value\n     */\n    function roundSHA3(block, state) {\n        var round, x, y, B, C = [],\n            D = [];\n\n        if (null !== block) {\n            for (x = 0; x < block.length; x += 2) {\n                state[(x >>> 1) % 5][((x >>> 1) / 5) | 0] = xor_64_2(\n                    state[(x >>> 1) % 5][((x >>> 1) / 5) | 0],\n                    new Int_64(block[x + 1], block[x])\n                );\n            }\n        }\n\n        for (round = 0; round < 24; round += 1) {\n            /* getNewState doesn't care about variant beyond SHA3 so feed it a\n               value that triggers the getNewState \"if\" statement\n            */\n            B = getNewState(\"SHA3-\");\n\n            /* Perform theta step */\n            for (x = 0; x < 5; x += 1) {\n                C[x] = xor_64_5(state[x][0], state[x][1], state[x][2],\n                    state[x][3], state[x][4]);\n            }\n            for (x = 0; x < 5; x += 1) {\n                D[x] = xor_64_2(C[(x + 4) % 5], rotl_64(C[(x + 1) % 5], 1));\n            }\n            for (x = 0; x < 5; x += 1) {\n                for (y = 0; y < 5; y += 1) {\n                    state[x][y] = xor_64_2(state[x][y], D[x]);\n                }\n            }\n\n            /* Perform combined ro and pi steps */\n            for (x = 0; x < 5; x += 1) {\n                for (y = 0; y < 5; y += 1) {\n                    B[y][(2 * x + 3 * y) % 5] = rotl_64(\n                        state[x][y],\n                        r_sha3[x][y]\n                    );\n                }\n            }\n\n            /* Perform chi step */\n            for (x = 0; x < 5; x += 1) {\n                for (y = 0; y < 5; y += 1) {\n                    state[x][y] = xor_64_2(\n                        B[x][y],\n                        new Int_64(~(B[(x + 1) % 5][y].highOrder) & B[(x + 2) % 5][y].highOrder, ~(B[(x + 1) % 5][y].lowOrder) & B[(x + 2) % 5][y].lowOrder)\n                    );\n                }\n            }\n\n            /* Perform iota step */\n            state[0][0] = xor_64_2(state[0][0], rc_sha3[round]);\n        }\n\n        return state;\n    }\n\n    /**\n     * Finalizes the SHA-3 hash\n     *\n     * @private\n     * @param {Array<number>} remainder Any leftover unprocessed packed ints\n     *   that still need to be processed\n     * @param {number} remainderBinLen The number of bits in remainder\n     * @param {number} processedBinLen The number of bits already\n     *   processed\n     * @param {Array<Array<Int_64>>} state The state from a previous round\n     * @param {number} blockSize The block size/rate of the variant in bits\n     * @param {number} delimiter The delimiter value for the variant\n     * @param {number} outputLen The output length for the variant in bits\n     * @return {Array<number>} The array of integers representing the SHA-3\n     *   hash of message\n     */\n    function finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, blockSize, delimiter, outputLen) {\n        var i, retVal = [],\n            binaryStringInc = blockSize >>> 5,\n            state_offset = 0,\n            remainderIntLen = remainderBinLen >>> 5,\n            temp;\n\n\n        /* Process as many blocks as possible, some may be here for multiple rounds\n           with SHAKE\n        */\n        for (i = 0; i < remainderIntLen && remainderBinLen >= blockSize; i += binaryStringInc) {\n            state = roundSHA3(remainder.slice(i, i + binaryStringInc), state);\n            remainderBinLen -= blockSize;\n        }\n\n        remainder = remainder.slice(i);\n        remainderBinLen = remainderBinLen % blockSize;\n\n        /* Pad out the remainder to a full block */\n        while (remainder.length < binaryStringInc) {\n            remainder.push(0);\n        }\n\n        /* Find the next \"empty\" byte for the 0x80 and append it via an xor */\n        i = remainderBinLen >>> 3;\n        remainder[i >> 2] ^= delimiter << (8 * (i % 4));\n\n        remainder[binaryStringInc - 1] ^= 0x80000000;\n        state = roundSHA3(remainder, state);\n\n        while (retVal.length * 32 < outputLen) {\n            temp = state[state_offset % 5][(state_offset / 5) | 0];\n            retVal.push(temp.lowOrder);\n            if (retVal.length * 32 >= outputLen) {\n                break;\n            }\n            retVal.push(temp.highOrder);\n            state_offset += 1;\n\n            if (0 === ((state_offset * 64) % blockSize)) {\n                roundSHA3(null, state);\n            }\n        }\n\n        return retVal;\n    }\n\n    /**\n     * jsSHA is the workhorse of the library.  Instantiate it with the string to\n     * be hashed as the parameter\n     *\n     * @constructor\n     * @this {jsSHA}\n     * @param {string} variant The desired SHA variant (SHA-1, SHA-224, SHA-256,\n     *   SHA-384, SHA-512, SHA3-224, SHA3-256, SHA3-384, or SHA3-512)\n     * @param {string} inputFormat The format of srcString: HEX, TEXT, B64,\n     *   BYTES, or ARRAYBUFFER\n     * @param {{encoding: (string|undefined), numRounds: (number|undefined)}=}\n     *   options Optional values\n     */\n    var jsSHA = function(variant, inputFormat, options) {\n        var processedLen = 0,\n            remainder = [],\n            remainderLen = 0,\n            utfType,\n            intermediateState, converterFunc, shaVariant = variant,\n            outputBinLen,\n            variantBlockSize, roundFunc, finalizeFunc, stateCloneFunc,\n            hmacKeySet = false,\n            keyWithIPad = [],\n            keyWithOPad = [],\n            numRounds,\n            updatedCalled = false,\n            inputOptions, isSHAKE = false,\n            bigEndianMod = -1;\n\n        inputOptions = options || {};\n        utfType = inputOptions[\"encoding\"] || \"UTF8\";\n        numRounds = inputOptions[\"numRounds\"] || 1;\n\n        if ((numRounds !== parseInt(numRounds, 10)) || (1 > numRounds)) {\n            throw new Error(\"numRounds must a integer >= 1\");\n        }\n\n        if ((\"SHA-1\" === shaVariant) && ((1 & SUPPORTED_ALGS) !== 0)) {\n            variantBlockSize = 512;\n            roundFunc = roundSHA1;\n            finalizeFunc = finalizeSHA1;\n            outputBinLen = 160;\n            stateCloneFunc = function(state) {\n                return state.slice();\n            };\n        } else if ((shaVariant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0)) {\n            roundFunc = function(block, H) {\n                return roundSHA2(block, H, shaVariant);\n            };\n            finalizeFunc = function(remainder, remainderBinLen, processedBinLen, H, outputLen) {\n                return finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, shaVariant, outputLen);\n            };\n            stateCloneFunc = function(state) {\n                return state.slice();\n            };\n\n            if ((\"SHA-224\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0)) {\n                variantBlockSize = 512;\n                outputBinLen = 224;\n            } else if ((\"SHA-256\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0)) {\n                variantBlockSize = 512;\n                outputBinLen = 256;\n            } else if ((\"SHA-384\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0)) {\n                variantBlockSize = 1024;\n                outputBinLen = 384;\n            } else if ((\"SHA-512\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0)) {\n                variantBlockSize = 1024;\n                outputBinLen = 512;\n            } else {\n                throw new Error(\"Chosen SHA variant is not supported\");\n            }\n        } else if (((shaVariant.lastIndexOf(\"SHA3-\", 0) === 0) || (shaVariant.lastIndexOf(\"SHAKE\", 0) === 0)) &&\n            ((8 & SUPPORTED_ALGS) !== 0)) {\n            var delimiter = 0x06;\n\n            roundFunc = roundSHA3;\n            stateCloneFunc = function(state) {\n                return cloneSHA3State(state);\n            };\n            bigEndianMod = 1;\n\n            if (\"SHA3-224\" === shaVariant) {\n                variantBlockSize = 1152;\n                outputBinLen = 224;\n\n            } else if (\"SHA3-256\" === shaVariant) {\n                variantBlockSize = 1088;\n                outputBinLen = 256;\n            } else if (\"SHA3-384\" === shaVariant) {\n                variantBlockSize = 832;\n                outputBinLen = 384;\n            } else if (\"SHA3-512\" === shaVariant) {\n                variantBlockSize = 576;\n                outputBinLen = 512;\n            } else if (\"SHAKE128\" === shaVariant) {\n                variantBlockSize = 1344;\n                outputBinLen = -1;\n                delimiter = 0x1F;\n                isSHAKE = true;\n            } else if (\"SHAKE256\" === shaVariant) {\n                variantBlockSize = 1088;\n                outputBinLen = -1;\n                delimiter = 0x1F;\n                isSHAKE = true;\n            } else {\n                throw new Error(\"Chosen SHA variant is not supported\");\n            }\n            finalizeFunc = function(remainder, remainderBinLen, processedBinLen, state, outputLen) {\n                return finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, variantBlockSize, delimiter, outputLen);\n            };\n        } else {\n            throw new Error(\"Chosen SHA variant is not supported\");\n        }\n        converterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);\n        intermediateState = getNewState(shaVariant);\n\n        /**\n         * Sets the HMAC key for an eventual getHMAC call.  Must be called\n         * immediately after jsSHA object instantiation\n         *\n         * @expose\n         * @param {string|ArrayBuffer} key The key used to calculate the HMAC\n         * @param {string} inputFormat The format of key, HEX, TEXT, B64, BYTES,\n         *   or ARRAYBUFFER\n         * @param {{encoding : (string|undefined)}=} options Associative array\n         *   of input format options\n         */\n        this.setHMACKey = function(key, inputFormat, options) {\n            var keyConverterFunc, convertRet, keyBinLen, keyToUse, blockByteSize,\n                i, lastArrayIndex, keyOptions;\n\n            if (true === hmacKeySet) {\n                throw new Error(\"HMAC key already set\");\n            }\n\n            if (true === updatedCalled) {\n                throw new Error(\"Cannot set HMAC key after calling update\");\n            }\n\n            if ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0)) {\n                throw new Error(\"SHAKE is not supported for HMAC\");\n            }\n\n            keyOptions = options || {};\n            utfType = keyOptions[\"encoding\"] || \"UTF8\";\n\n            keyConverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);\n\n            convertRet = keyConverterFunc(key);\n            keyBinLen = convertRet[\"binLen\"];\n            keyToUse = convertRet[\"value\"];\n\n            blockByteSize = variantBlockSize >>> 3;\n\n            /* These are used multiple times, calculate and store them */\n            lastArrayIndex = (blockByteSize / 4) - 1;\n\n            /* Figure out what to do with the key based on its size relative to\n             * the hash's block size */\n            if (blockByteSize < (keyBinLen / 8)) {\n\n                keyToUse = finalizeFunc(keyToUse, keyBinLen, 0, getNewState(shaVariant), outputBinLen);\n                /* For all variants, the block size is bigger than the output\n                 * size so there will never be a useful byte at the end of the\n                 * string */\n                while (keyToUse.length <= lastArrayIndex) {\n                    keyToUse.push(0);\n                }\n                keyToUse[lastArrayIndex] &= 0xFFFFFF00;\n            } else if (blockByteSize > (keyBinLen / 8)) {\n                /* If the blockByteSize is greater than the key length, there\n                 * will always be at LEAST one \"useless\" byte at the end of the\n                 * string */\n                while (keyToUse.length <= lastArrayIndex) {\n                    keyToUse.push(0);\n                }\n                keyToUse[lastArrayIndex] &= 0xFFFFFF00;\n            }\n\n            /* Create ipad and opad */\n            for (i = 0; i <= lastArrayIndex; i += 1) {\n                keyWithIPad[i] = keyToUse[i] ^ 0x36363636;\n                keyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;\n            }\n\n            intermediateState = roundFunc(keyWithIPad, intermediateState);\n            processedLen = variantBlockSize;\n\n            hmacKeySet = true;\n        };\n\n        /**\n         * Takes strString and hashes as many blocks as possible.  Stores the\n         * rest for either a future update or getHash call.\n         *\n         * @expose\n         * @param {string|ArrayBuffer} srcString The string to be hashed\n         */\n        this.update = function(srcString) {\n            var convertRet, chunkBinLen, chunkIntLen, chunk, i, updateProcessedLen = 0,\n                variantBlockIntInc = variantBlockSize >>> 5;\n\n            convertRet = converterFunc(srcString, remainder, remainderLen);\n            chunkBinLen = convertRet[\"binLen\"];\n            chunk = convertRet[\"value\"];\n\n            chunkIntLen = chunkBinLen >>> 5;\n            for (i = 0; i < chunkIntLen; i += variantBlockIntInc) {\n                if (updateProcessedLen + variantBlockSize <= chunkBinLen) {\n                    intermediateState = roundFunc(\n                        chunk.slice(i, i + variantBlockIntInc),\n                        intermediateState\n                    );\n                    updateProcessedLen += variantBlockSize;\n                }\n            }\n            processedLen += updateProcessedLen;\n            remainder = chunk.slice(updateProcessedLen >>> 5);\n            remainderLen = chunkBinLen % variantBlockSize;\n            updatedCalled = true;\n\n        };\n\n        /**\n         * Returns the desired SHA hash of the string specified at instantiation\n         * using the specified parameters\n         *\n         * @expose\n         * @param {string} format The desired output formatting (B64, HEX,\n         *   BYTES, or ARRAYBUFFER)\n         * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n         *   shakeLen : (number|undefined)}=} options Hash list of output formatting options\n         * @return {string|ArrayBuffer} The string representation of the hash\n         *   in the format specified.\n         */\n        this.getHash = function(format, options) {\n            var formatFunc, i, outputOptions, finalizedState;\n\n            if (true === hmacKeySet) {\n                throw new Error(\"Cannot call getHash after setting HMAC key\");\n            }\n\n            outputOptions = getOutputOpts(options);\n\n            if ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0)) {\n                if (outputOptions[\"shakeLen\"] === -1) {\n                    throw new Error(\"shakeLen must be specified in options\");\n                }\n                outputBinLen = outputOptions[\"shakeLen\"];\n            }\n\n            /* Validate the output format selection */\n            switch (format) {\n                case \"HEX\":\n                    formatFunc = function(binarray) {\n                        return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);\n                    };\n                    break;\n                case \"B64\":\n                    formatFunc = function(binarray) {\n                        return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);\n                    };\n                    break;\n                case \"BYTES\":\n                    formatFunc = function(binarray) {\n                        return packed2bytes(binarray, outputBinLen, bigEndianMod);\n                    };\n                    break;\n                case \"ARRAYBUFFER\":\n                    try {\n                        i = new ArrayBuffer(0);\n                    } catch (ignore) {\n                        throw new Error(\"ARRAYBUFFER not supported by this environment\");\n                    }\n                    formatFunc = function(binarray) {\n                        return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);\n                    };\n                    break;\n                default:\n                    throw new Error(\"format must be HEX, B64, BYTES, or ARRAYBUFFER\");\n            }\n\n            finalizedState = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n            for (i = 1; i < numRounds; i += 1) {\n                /* This weird fix-up is only for the case of SHAKE algorithms\n                 * and outputBinLen is not a multiple of 32.  In this case, the\n                 * very last block of finalizedState has data that needs to be\n                 * ignored because all the finalizeFunc calls need to have\n                 * unneeded bits set to 0.\n                 */\n                if (((8 & SUPPORTED_ALGS) !== 0) && (isSHAKE === true) && (outputBinLen % 32 !== 0)) {\n                    finalizedState[finalizedState.length - 1] &= 0x00FFFFFF >>> 24 - (outputBinLen % 32);\n                }\n                finalizedState = finalizeFunc(finalizedState, outputBinLen, 0, getNewState(shaVariant), outputBinLen);\n            }\n\n            return formatFunc(finalizedState);\n        };\n\n        /**\n         * Returns the the HMAC in the specified format using the key given by\n         * a previous setHMACKey call.\n         *\n         * @expose\n         * @param {string} format The desired output formatting\n         *   (B64, HEX, BYTES, or ARRAYBUFFER)\n         * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),\n         *   shakeLen : (number|undefined)}=} options associative array of output\n         *   formatting options\n         * @return {string|ArrayBuffer} The string representation of the hash in the\n         *   format specified.\n         */\n        this.getHMAC = function(format, options) {\n            var formatFunc, firstHash, outputOptions, finalizedState;\n\n            if (false === hmacKeySet) {\n                throw new Error(\"Cannot call getHMAC without first setting HMAC key\");\n            }\n\n            outputOptions = getOutputOpts(options);\n\n            /* Validate the output format selection */\n            switch (format) {\n                case \"HEX\":\n                    formatFunc = function(binarray) {\n                        return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);\n                    };\n                    break;\n                case \"B64\":\n                    formatFunc = function(binarray) {\n                        return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);\n                    };\n                    break;\n                case \"BYTES\":\n                    formatFunc = function(binarray) {\n                        return packed2bytes(binarray, outputBinLen, bigEndianMod);\n                    };\n                    break;\n                case \"ARRAYBUFFER\":\n                    try {\n                        formatFunc = new ArrayBuffer(0);\n                    } catch (ignore) {\n                        throw new Error(\"ARRAYBUFFER not supported by this environment\");\n                    }\n                    formatFunc = function(binarray) {\n                        return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);\n                    };\n                    break;\n                default:\n                    throw new Error(\"outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER\");\n            }\n\n            firstHash = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);\n            finalizedState = roundFunc(keyWithOPad, getNewState(shaVariant));\n            finalizedState = finalizeFunc(firstHash, outputBinLen, variantBlockSize, finalizedState, outputBinLen);\n\n            return formatFunc(finalizedState);\n        };\n    };\n\n    if ((\"function\" === typeof define) && (define[\"amd\"])) /* AMD Support */ {\n        define(function() {\n            return jsSHA;\n        });\n    } else if (\"undefined\" !== typeof exports) /* Node Support */ {\n        if ((\"undefined\" !== typeof module) && module[\"exports\"]) {\n            module[\"exports\"] = jsSHA;\n            exports = jsSHA;\n        } else {\n            exports = jsSHA;\n        }\n    } else { /* Browsers and Web Workers*/\n        global[\"jsSHA\"] = jsSHA;\n    }\n}(this));\n\n\n(function(global) {\n    'use strict';\n\n    function definition(path, Failure, iterate, isObject) {\n        var settings;\n\n        demand\n            .on('postConfigure:' + path, function(options) {\n                if (isObject(options)) {\n                    settings = options;\n                }\n            })\n            .on('postRequest', function(dependency) {\n                var options, sha, hash;\n\n                if (options = isEnabled(dependency.path)) {\n                    try {\n                        sha = new global.jsSHA(options.type, 'TEXT');\n\n                        sha.update(dependency.source);\n\n                        if ((hash = sha.getHash('B64')) !== options.hash) {\n                            dependency.dfd.reject(new Failure('hash mismatch, should be \"' + options.hash + '\" but is \"' + hash + '\" (sri)', dependency.id));\n                        }\n                    } catch (error) {\n                        dependency.dfd.reject(new Failure('unsupported hashing algorithm (sri)', dependency.id));\n                    }\n                }\n            });\n\n        function isEnabled(path) {\n            var match;\n\n            iterate(settings, function(key, value) {\n                if (key === path) {\n                    match = value;\n\n                    return false;\n                }\n            });\n\n            return match || false;\n        }\n\n        return true;\n    }\n\n    provide(['path', '/demand/failure', '/demand/function/iterate', '/demand/validator/isObject'], definition);\n}(this));"]}