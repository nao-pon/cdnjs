{"version":3,"sources":["node_modules/browser-pack/_prelude.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/core/events/EventsBase.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/MssEvents.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/MssFragmentInfoController.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/MssFragmentMoofProcessor.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/MssFragmentMoovProcessor.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/MssFragmentProcessor.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/MssHandler.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/index.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/mss/parser/MssParser.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/streaming/vo/DataChunk.js","/Users/dsparaci/Repositories/git/dash/dash.js/src/streaming/vo/FragmentRequest.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","_dereq_","module","EventsBase","events","config","override","publicOnly","evt","hasOwnProperty","this","indexOf","MssEvents","_EventsBase","_get","Object","getPrototypeOf","prototype","FRAGMENT_INFO_LOADING_COMPLETED","mssEvents","MssFragmentInfoController","setup","initialize","started","startFragmentInfoDate","startTimeStampValue","deltaTime","segmentDuration","NaN","streamProcessor","registerExternalController","instance","type","getType","fragmentModel","getFragmentModel","indexHandler","getIndexHandler","getCurrentRepresentation","getRepresentationController","sendRequest","request","executeRequest","asFragmentInfoRequest","url","replace","onFragmentRequest","action","ACTION_COMPLETE","doStop","_fragmentInfoTime","startTime","duration","isFragmentLoadedOrPending","getNextSegmentRequest","log","bufferFragmentInfo","segmentTime","representation","getSegmentRequestForTime","delayLoadNextFragmentInfo","delay","delayMs","Math","round","min","clearTimeout","bufferTimeout","setTimeout","onFragmentInfoLoadedCompleted","fragmentInfo","deltaDate","undefined","deltaTimeStamp","response","_MssFragmentMoofProcessor2","context","create","metricsModel","playbackController","ISOBoxer","updateSegmentList","Date","getTime","startPlayback","doStart","segments","eventBus","on","_MssEvents2","presentationStartTime","off","reset","unregisterExternalController","start","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory","MssFragmentMoofProcessor","processTfrf","tfrf","tfdt","representationController","manifest","adaptation","period","mpd","Period_asArray","index","AdaptationSet_asArray","segmentsUpdated","SegmentTemplate","SegmentTimeline","S","entries","entry","fragment_absolute_time","fragment_duration","segment","j","segmentId","availabilityStartTime","range","push","d","baseMediaDecodeTime","timeShiftBufferDepth","splice","timescale","end","dvrInfos","getMetricsFor","mediaType","DVRInfo","addDVRInfo","getStreamInfo","manifestInfo","getBoxOffset","parent","offset","boxes","size","convertFragment","sp","isoFile","parseBuffer","tfhd","fetch","track_ID","mediaInfo","traf","createFullBox","version","flags","floor","trun","tfxd","_parent","sepiff","usertype","_saio","entry_count","saiz","sample_count","default_sample_info_size","sample_info_size","NumberOfEntries","moof","getLength","data_offset","saio","trafPosInMoof","sencPosInTraf","write","MssFragmentMoovProcessor","createFtypBox","ftyp","createBox","major_brand","minor_version","compatible_brands","createMoovBox","moov","createMvhdBox","trak","createTkhdBox","mdia","createMdhdBox","createHdlrBox","minf","adaptationSet","constants","VIDEO","createVmhdBox","AUDIO","createSmhdBox","createDrefBox","stbl","_data","createStsdBox","createTrexBox","contentProtection","protectionController","createProtectionSystemSpecificHeaderBox","getSupportedKeySystemsFromContentProtection","mvhd","creation_time","modification_time","TIME_SCALE","rate","volume","reserved1","reserved2","matrix","pre_defined","next_track_ID","trackId","tkhd","layer","alternate_group","reserved3","width","height","mdhd","language","lang","hdlr","handler_type","name","id","reserved","vmhd","graphicsmode","opcolor","smhd","balance","dinf","dref","location","stsd","createSampleEntry","codec","codecs","substring","createAVCVisualSampleEntry","createMP4AudioSampleEntry","message","data","avc1","data_reference_index","pre_defined1","pre_defined2","horizresolution","vertresolution","frame_count","compressorname","depth","pre_defined3","createAVC1ConfigurationRecord","sinf","createOriginalFormatBox","createSchemeTypeBox","createSchemeInformationBox","avcC","avcCLength","sps","pps","AVCProfileIndication","AVCLevelIndication","profile_compatibility","nalus","codecPrivateData","split","slice","naluBytes","_i","hexStringtoBuffer","NALUTYPE_SPS","NALUTYPE_PPS","Uint8Array","set","mp4a","channelcount","audioChannels","samplesize","reserved_3","samplerate","audioSamplingRate","esds","createMPEG4AACESDescriptor","audioSpecificConfig","esdsLength","bandwidth","data_format","stringToCharCode","schm","scheme_type","scheme_version","createTrackEncryptionBox","keySystems","pssh_bytes","pssh","parsedBuffer","initData","Utils","appendBox","schi","tenc","default_IsEncrypted","default_IV_size","default_KID","trex","default_sample_description_index","default_sample_duration","default_sample_size","default_sample_flags","str","buf","parseInt","charCodeAt","generateMoov","rep","ContentProtection","createFile","arrayEqual","arr1","arr2","every","element","saioProcessor","_procFullBox","_procField","_procFieldArray","saizProcessor","sencProcessor","_procEntries","_procEntryField","_procSubEntries","clearAndCryptedData","uuidProcessor","tfxdUserType","tfrfUserType","sepiffUserType","_parsing","fragment_count","MssFragmentProcessor","addBoxProcessor","_MssFragmentMoovProcessor2","processFragment","mssFragmentMoofProcessor","trigger","sender","MssHandler","onInitializationRequested","getStreamProcessor","_streamingVoFragmentRequest2","initSegmentType","quality","getMediaInfo","representationId","chunk","createDataChunk","bytes","mssFragmentProcessor","INIT_FRAGMENT_LOADED","streamId","_streamingVoDataChunk2","segmentType","onSegmentMediaLoaded","onPlaybackSeekAsked","getIsDynamic","streamController","getStreamController","getActiveStreamProcessors","forEach","processor","FRAGMENTED_TEXT","fragmentInfoController","_MssFragmentInfoController2","registerEvents","INIT_REQUESTED","getSingletonFactoryByName","getClassName","EVENT_PRIORITY_HIGH","PLAYBACK_SEEK_ASKED","FRAGMENT_LOADING_COMPLETED","createMssParser","mssParser","_parserMssParser2","_MssFragmentProcessor2","window","global","_MssHandler2","MssParser","mediaPlayerModel","mapPeriod","smoothStreamingMedia","streams","parseFloat","getAttribute","Infinity","TIME_SCALE_100_NANOSECOND_UNIT","getElementsByTagName","mapAdaptationSet","AdaptationSet","streamIndex","representations","segmentTemplate","qualityLevels","contentType","mimeType","mimeTypeMap","subType","maxWidth","maxHeight","mapSegmentTemplate","BaseURL","Id","mapRepresentation","Representation","Representation_asArray","S_asArray","qualityLevel","fourCCValue","SUPPORTED_CODECS","toUpperCase","getH264Codec","getAACCodec","STPP","toString","nalHeader","exec","substr","objectType","samplingRate","codecPrivateDataHex","arr16","indexFreq","extensionSamplingFrequencyIndex","samplingFrequencyIndex","Channels","Uint16Array","setAttribute","mediaUrl","media","mapSegmentTimeline","segmentTimeline","chunks","prevSegment","tManifest","getKIDFromProtectionHeader","protectionHeader","prHeader","wrmHeader","xmlReader","KID","BASE64","decodeArray","firstChild","getWRMHeaderFromPRHeader","buffer","String","fromCharCode","apply","DOMParser","parseFromString","querySelector","textContent","convertUuidEndianness","recordType","recordLength","recordValue","subarray","uuid","swapBytes","pos1","pos2","temp","createPRContentProtection","getKeySystems","ksPlayReady","systemString","pro","__text","__prefix","schemeIdUri","schemeIdURI","value","pro_asArray","createWidevineContentProtection","ksWidevine","processManifest","xmlDoc","manifestLoadedTime","contentProtections","protection","adaptations","timestampOffset","protocol","profiles","mediaPresentationDuration","minBufferTime","getStableBufferTime","ttmlTimeIsRelative","refreshManifestOnSwitchTrack","doNotUpdateDVRWindowOnBufferUpdated","ignorePostponeTimePeriod","Period","ContentProtection_asArray","initialization","toFixed","max","parseDOM","parser","errorHandler","manifestError","getMatchers","getIron","internalParse","performance","now","xmlParseTime","mss2dashTime","toPrecision","errHandler","96000","88200","64000","48000","44100","32000","24000","22050","16000","12000","11025","8000","7350","video","audio","text","parse","DataChunk","FragmentRequest","ACTION_DOWNLOAD","serviceLocation","requestStartDate","firstByteDate","requestEndDate","availabilityEndTime","wallStartTime","bytesLoaded","bytesTotal","delayLoadingTime","responseType"],"mappings":"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","file":"dash.mss.min.js","sourceRoot":"./src/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * @class\n * @ignore\n */\nclass EventsBase {\n    extend (events, config) {\n        if (!events) return;\n\n        let override = config ? config.override : false;\n        let publicOnly = config ? config.publicOnly : false;\n\n\n        for (const evt in events) {\n            if (!events.hasOwnProperty(evt) || (this[evt] && !override)) continue;\n            if (publicOnly && events[evt].indexOf('public_') === -1) continue;\n            this[evt] = events[evt];\n\n        }\n    }\n}\n\nexport default EventsBase;","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventsBase from '../core/events/EventsBase';\n\nclass MssEvents extends EventsBase {\n\n    constructor() {\n        super();\n\n        this.FRAGMENT_INFO_LOADING_COMPLETED = 'fragmentInfoLoadingCompleted';\n    }\n}\n\nlet mssEvents = new MssEvents();\nexport default mssEvents;\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport MssEvents from './MssEvents';\nimport MSSFragmentMoofProcessor from './MssFragmentMoofProcessor';\n\nfunction MssFragmentInfoController(config) {\n\n    let context = this.context;\n\n    let instance;\n    let fragmentModel;\n    let indexHandler;\n    let started;\n    let type;\n    let bufferTimeout;\n    let _fragmentInfoTime;\n    let startFragmentInfoDate;\n    let startTimeStampValue;\n    let deltaTime;\n    let segmentDuration;\n\n    let streamProcessor = config.streamProcessor;\n    let eventBus = config.eventBus;\n    let metricsModel = config.metricsModel;\n    let playbackController = config.playbackController;\n    const ISOBoxer = config.ISOBoxer;\n    const log = config.log;\n\n    function setup() {\n    }\n\n    function initialize() {\n        started = false;\n\n        startFragmentInfoDate = null;\n        startTimeStampValue = null;\n        deltaTime = 0;\n        segmentDuration = NaN;\n\n        // register to stream processor as external controller\n        streamProcessor.registerExternalController(instance);\n        type = streamProcessor.getType();\n        fragmentModel = streamProcessor.getFragmentModel();\n        indexHandler = streamProcessor.getIndexHandler();\n    }\n\n    function getCurrentRepresentation() {\n        let representationController = streamProcessor.getRepresentationController();\n        let representation = representationController.getCurrentRepresentation();\n\n        return representation;\n    }\n\n    function sendRequest(request) {\n        fragmentModel.executeRequest(request);\n    }\n\n    function asFragmentInfoRequest(request) {\n        if (request && request.url) {\n            request.url = request.url.replace('Fragments', 'FragmentInfo');\n            request.type = 'FragmentInfoSegment';\n        }\n\n        return request;\n    }\n\n    function onFragmentRequest(request) {\n\n        // Check if current request signals end of stream\n        if ((request !== null) && (request.action === request.ACTION_COMPLETE)) {\n            doStop();\n            return;\n        }\n\n        if (request !== null) {\n            _fragmentInfoTime = request.startTime + request.duration;\n            request = asFragmentInfoRequest(request);\n\n            if (streamProcessor.getFragmentModel().isFragmentLoadedOrPending(request)) {\n                request = indexHandler.getNextSegmentRequest(getCurrentRepresentation());\n                onFragmentRequest(request);\n                return;\n            }\n\n            log('[FragmentInfoController][' + type + '] onFragmentRequest ' + request.url);\n\n            // Download the fragment info segment\n            sendRequest(request);\n        } else {\n            // No more fragment in current list\n            log('[FragmentInfoController][' + type + '] bufferFragmentInfo failed');\n        }\n    }\n\n    function bufferFragmentInfo() {\n        var segmentTime;\n\n        // Check if running state\n        if (!started) {\n            return;\n        }\n\n        log('[FragmentInfoController][' + type + '] Start buffering process...');\n\n        // Get next segment time\n        segmentTime = _fragmentInfoTime;\n\n        log('[FragmentInfoController][' + type + '] loadNextFragment for time: ' + segmentTime);\n\n        let representation = getCurrentRepresentation();\n        let request = indexHandler.getSegmentRequestForTime(representation, segmentTime);\n        onFragmentRequest(request);\n    }\n\n    function delayLoadNextFragmentInfo(delay) {\n        var delayMs = Math.round(Math.min((delay * 1000), 2000));\n\n        log('[FragmentInfoController][' + type + '] Check buffer delta = ' + delayMs + ' ms');\n\n        clearTimeout(bufferTimeout);\n        bufferTimeout = setTimeout(function () {\n            bufferTimeout = null;\n            bufferFragmentInfo();\n        }, delayMs);\n    }\n\n    function onFragmentInfoLoadedCompleted(e) {\n        if (e.streamProcessor !== streamProcessor) {\n            return;\n        }\n\n        let request = e.fragmentInfo.request;\n        let deltaDate,\n            deltaTimeStamp;\n\n\n        if (!e.fragmentInfo.response) {\n            log('[FragmentInfoController][' + type + '] ERROR loading ', request.url);\n            return;\n        }\n\n        segmentDuration = request.duration;\n        log('[FragmentInfoController][' + type + '] FragmentInfo loaded ', request.url);\n        try {\n\n            // update segment list\n            let mssFragmentMoofProcessor = MSSFragmentMoofProcessor(context).create({\n                metricsModel: metricsModel,\n                playbackController: playbackController,\n                ISOBoxer: ISOBoxer,\n                log: log\n            });\n            mssFragmentMoofProcessor.updateSegmentList(e.fragmentInfo, streamProcessor);\n\n            deltaDate = (new Date().getTime() - startFragmentInfoDate) / 1000;\n            deltaTimeStamp = (_fragmentInfoTime + segmentDuration) - startTimeStampValue;\n            deltaTime = (deltaTimeStamp - deltaDate) > 0 ? (deltaTimeStamp - deltaDate) : 0;\n            delayLoadNextFragmentInfo(deltaTime);\n        } catch (e) {\n            log('[FragmentInfoController][' + type + '] ERROR - Internal error while processing fragment info segment ');\n        }\n    }\n\n    function startPlayback() {\n        if (!started) {\n            return;\n        }\n\n        startFragmentInfoDate = new Date().getTime();\n        startTimeStampValue = _fragmentInfoTime;\n\n        log('[FragmentInfoController][' + type + '] startPlayback');\n\n        // Start buffering process\n        bufferFragmentInfo.call(this);\n    }\n\n    function doStart() {\n\n        let segments;\n\n        if (started === true) {\n            return;\n        }\n\n        eventBus.on(MssEvents.FRAGMENT_INFO_LOADING_COMPLETED, onFragmentInfoLoadedCompleted, instance);\n\n        started = true;\n        log('[FragmentInfoController][' + type + '] START');\n\n        let representation = getCurrentRepresentation();\n        segments = representation.segments;\n\n        if (segments) {\n            _fragmentInfoTime = segments[segments.length - 1].presentationStartTime - segments[segments.length - 1].duration;\n\n            startPlayback();\n        } else {\n            indexHandler.updateSegmentList(representation);\n            segments = representation.segments;\n            _fragmentInfoTime = segments[segments.length - 1].presentationStartTime - segments[segments.length - 1].duration;\n\n            startPlayback();\n        }\n    }\n\n    function doStop() {\n        if (!started) {\n            return;\n        }\n        log('[FragmentInfoController][' + type + '] STOP');\n\n        eventBus.off(MssEvents.FRAGMENT_INFO_LOADING_COMPLETED, onFragmentInfoLoadedCompleted, instance);\n\n        // Stop buffering process\n        clearTimeout(bufferTimeout);\n        started = false;\n\n        startFragmentInfoDate = null;\n        startTimeStampValue = null;\n    }\n\n    function reset() {\n        doStop();\n        streamProcessor.unregisterExternalController(instance);\n    }\n\n    instance = {\n        initialize: initialize,\n        start: doStart,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nMssFragmentInfoController.__dashjs_factory_name = 'MssFragmentInfoController';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentInfoController); /* jshint ignore:line */","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @module MssFragmentMoovProcessor\n * @param {Object} config object\n */\nfunction MssFragmentMoofProcessor(config) {\n\n    let instance;\n    let metricsModel = config.metricsModel;\n    let playbackController = config.playbackController;\n    const ISOBoxer = config.ISOBoxer;\n    const log = config.log;\n\n    function setup() {\n    }\n\n    function processTfrf(request, tfrf, tfdt, streamProcessor) {\n        let representationController = streamProcessor.getRepresentationController();\n        let representation = representationController.getCurrentRepresentation();\n        let indexHandler = streamProcessor.getIndexHandler();\n\n        let manifest = representation.adaptation.period.mpd.manifest;\n        let adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\n\n        let segmentsUpdated = false;\n        // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\n        let segments = adaptation.SegmentTemplate.SegmentTimeline.S;\n        let entries = tfrf.entry;\n        let fragment_absolute_time = 0;\n        let fragment_duration = 0;\n        let segment = null;\n        let t = 0;\n        let i = 0;\n        let j = 0;\n        let segmentId = -1;\n        let availabilityStartTime = null;\n        let range;\n\n        if (manifest.type !== 'dynamic') {\n            return false;\n        }\n\n        // Go through tfrf entries\n        while (i < entries.length) {\n            fragment_absolute_time = entries[i].fragment_absolute_time;\n            fragment_duration = entries[i].fragment_duration;\n\n            // Get timestamp of the last segment\n            segment = segments[segments.length - 1];\n            t = segment.t;\n\n            if (fragment_absolute_time > t) {\n                log('[MssFragmentMoofProcessor]Add new segment - t = ' + (fragment_absolute_time / 10000000.0));\n                segments.push({\n                    t: fragment_absolute_time,\n                    d: fragment_duration\n                });\n                segmentsUpdated = true;\n            }\n\n            i += 1;\n        }\n\n        for (j = segments.length - 1; j >= 0; j -= 1) {\n            if (segments[j].t === tfdt.baseMediaDecodeTime) {\n                segmentId = j;\n                break;\n            }\n        }\n\n        if (segmentId >= 0) {\n            for (i = 0; i < entries.length; i += 1) {\n                if (segmentId + i < segments.length) {\n                    t = segments[segmentId + i].t;\n                    if ((t + segments[segmentId + i].d) !== entries[i].fragment_absolute_time) {\n                        segments[segmentId + i].t = entries[i].fragment_absolute_time;\n                        segments[segmentId + i].d = entries[i].fragment_duration;\n                        log('[MssFragmentMoofProcessor]Correct tfrf time  = ' + entries[i].fragment_absolute_time + 'and duration = ' + entries[i].fragment_duration + '! ********');\n                        segmentsUpdated = true;\n                    }\n                }\n            }\n        }\n\n        //\n        if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\n            if (segmentsUpdated) {\n                // Get timestamp of the last segment\n                segment = segments[segments.length - 1];\n                t = segment.t;\n\n                // Determine the segments' availability start time\n                availabilityStartTime = t - (manifest.timeShiftBufferDepth * 10000000);\n\n                // Remove segments prior to availability start time\n                segment = segments[0];\n                while (segment.t < availabilityStartTime) {\n                    log('[MssFragmentMoofProcessor]Remove segment  - t = ' + (segment.t / 10000000.0));\n                    segments.splice(0, 1);\n                    segment = segments[0];\n                }\n            }\n\n            // Update DVR window range\n            // => set range end to end time of current segment\n            range = {\n                start: segments[0].t / adaptation.SegmentTemplate.timescale,\n                end: (tfdt.baseMediaDecodeTime / adaptation.SegmentTemplate.timescale) + request.duration\n            };\n\n            var dvrInfos = metricsModel.getMetricsFor(request.mediaType).DVRInfo;\n            if (dvrInfos) {\n                if (dvrInfos.length === 0 || (dvrInfos.length > 0 && range.end > dvrInfos[dvrInfos.length - 1].range.end)) {\n                    log('[MssFragmentMoofProcessor][' + request.mediaType + '] Update DVR Infos [' + range.start + ' - ' + range.end + ']');\n                    metricsModel.addDVRInfo(request.mediaType, playbackController.getTime(), streamProcessor.getStreamInfo().manifestInfo, range);\n                }\n            }\n        }\n\n        if (segmentsUpdated) {\n            indexHandler.updateSegmentList(representation);\n        }\n        return segmentsUpdated;\n    }\n\n    // This function returns the offset of the 1st byte of a child box within a container box\n    function getBoxOffset(parent, type) {\n        let offset = 8;\n        let i = 0;\n\n        for (i = 0; i < parent.boxes.length; i++) {\n            if (parent.boxes[i].type === type) {\n                return offset;\n            }\n            offset += parent.boxes[i].size;\n        }\n        return offset;\n    }\n\n    function convertFragment(e, sp) {\n\n        let i;\n\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        if (!e.response) {\n            return;\n        }\n        let isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        let tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        let traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        let trun = isoFile.fetch('trun');\n\n        // Process tfxd boxes\n        // This box provide absolute timestamp but we take the segment start time for tfdt\n        let tfxd = isoFile.fetch('tfxd');\n        if (tfxd) {\n            tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1);\n            tfxd = null;\n        }\n        let tfrf = isoFile.fetch('tfrf');\n        if (tfrf) {\n            processTfrf(e.request, tfrf, tfdt, sp);\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n\n        // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\n        // => convert sepiff box it into a senc box\n        // => create saio and saiz boxes (if not already present)\n        let sepiff = isoFile.fetch('sepiff');\n        if (sepiff !== null) {\n            sepiff.type = 'senc';\n            sepiff.usertype = undefined;\n\n            let saio = isoFile.fetch('saio');\n            if (saio === null) {\n                // Create Sample Auxiliary Information Offsets Box box (saio)\n                saio = ISOBoxer.createFullBox('saio', traf);\n                saio.version = 0;\n                saio.flags = 0;\n                saio.entry_count = 1;\n                saio.offset = [0];\n\n                let saiz = ISOBoxer.createFullBox('saiz', traf);\n                saiz.version = 0;\n                saiz.flags = 0;\n                saiz.sample_count = sepiff.sample_count;\n                saiz.default_sample_info_size = 0;\n                saiz.sample_info_size = [];\n\n                if (sepiff.flags & 0x02) {\n                    // Sub-sample encryption => set sample_info_size for each sample\n                    for (i = 0; i < sepiff.sample_count; i += 1) {\n                        // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\n                        // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\n                        saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\n                    }\n                } else {\n                    // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\n                    saiz.default_sample_info_size = 8;\n                }\n            }\n        }\n\n        tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\n        tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\n        trun.flags |= 0x000001; // set trun.data-offset-present to true\n\n        // Update trun.data_offset field that corresponds to first data byte (inside mdat box)\n        let moof = isoFile.fetch('moof');\n        let length = moof.getLength();\n        trun.data_offset = length + 8;\n\n        // Update saio box offset field according to new senc box offset\n        let saio = isoFile.fetch('saio');\n        if (saio !== null) {\n            let trafPosInMoof = getBoxOffset(moof, 'traf');\n            let sencPosInTraf = getBoxOffset(traf, 'senc');\n            // Set offset from begin fragment to the first IV field in senc box\n            saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\n        }\n\n        // Write transformed/processed fragment into request reponse data\n        e.response = isoFile.write();\n    }\n\n    function updateSegmentList(e, sp) {\n\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        if (!e.response) {\n            return;\n        }\n\n        let isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        let tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        let traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        let tfrf = isoFile.fetch('tfrf');\n        if (tfrf) {\n            processTfrf(e.request, tfrf, tfdt, sp);\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n    }\n\n    instance = {\n        convertFragment: convertFragment,\n        updateSegmentList: updateSegmentList\n    };\n\n    setup();\n    return instance;\n}\n\nMssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @module MssFragmentMoovProcessor\n * @param {Object} config object\n */\nfunction MssFragmentMoovProcessor(config) {\n    const TIME_SCALE = 10000000;\n    const NALUTYPE_SPS = 7;\n    const NALUTYPE_PPS = 8;\n    const constants = config.constants;\n    const ISOBoxer = config.ISOBoxer;\n\n    let protectionController = config.protectionController;\n    let instance,\n        period,\n        adaptationSet,\n        representation,\n        contentProtection,\n        trackId;\n\n    function createFtypBox(isoFile) {\n        let ftyp = ISOBoxer.createBox('ftyp', isoFile);\n        ftyp.major_brand = 'iso6';\n        ftyp.minor_version = 1; // is an informative integer for the minor version of the major brand\n        ftyp.compatible_brands = []; //is a list, to the end of the box, of brands isom, iso6 and msdh\n        ftyp.compatible_brands[0] = 'isom'; // => decimal ASCII value for isom\n        ftyp.compatible_brands[1] = 'iso6'; // => decimal ASCII value for iso6\n        ftyp.compatible_brands[2] = 'msdh'; // => decimal ASCII value for msdh\n\n        return ftyp;\n    }\n\n    function createMoovBox(isoFile) {\n\n        // moov box\n        let moov = ISOBoxer.createBox('moov', isoFile);\n\n        // moov/mvhd\n        createMvhdBox(moov);\n\n        // moov/trak\n        let trak = ISOBoxer.createBox('trak', moov);\n\n        // moov/trak/tkhd\n        createTkhdBox(trak);\n\n        // moov/trak/mdia\n        let mdia = ISOBoxer.createBox('mdia', trak);\n\n        // moov/trak/mdia/mdhd\n        createMdhdBox(mdia);\n\n        // moov/trak/mdia/hdlr\n        createHdlrBox(mdia);\n\n        // moov/trak/mdia/minf\n        let minf = ISOBoxer.createBox('minf', mdia);\n\n        switch (adaptationSet.type) {\n            case constants.VIDEO:\n                // moov/trak/mdia/minf/vmhd\n                createVmhdBox(minf);\n                break;\n            case constants.AUDIO:\n                // moov/trak/mdia/minf/smhd\n                createSmhdBox(minf);\n                break;\n            default:\n                break;\n        }\n\n        // moov/trak/mdia/minf/dinf\n        let dinf = ISOBoxer.createBox('dinf', minf);\n\n        // moov/trak/mdia/minf/dinf/dref\n        createDrefBox(dinf);\n\n        // moov/trak/mdia/minf/stbl\n        let stbl = ISOBoxer.createBox('stbl', minf);\n\n        // Create empty stts, stsc, stco and stsz boxes\n        // Use data field as for codem-isoboxer unknown boxes for setting fields value\n\n        // moov/trak/mdia/minf/stbl/stts\n        let stts = ISOBoxer.createFullBox('stts', stbl);\n        stts._data = [0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, entry_count = 0\n\n        // moov/trak/mdia/minf/stbl/stsc\n        let stsc = ISOBoxer.createFullBox('stsc', stbl);\n        stsc._data = [0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, entry_count = 0\n\n        // moov/trak/mdia/minf/stbl/stco\n        let stco = ISOBoxer.createFullBox('stco', stbl);\n        stco._data = [0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, entry_count = 0\n\n        // moov/trak/mdia/minf/stbl/stsz\n        let stsz = ISOBoxer.createFullBox('stsz', stbl);\n        stsz._data = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // version = 0, flags = 0, sample_size = 0, sample_count = 0\n\n        // moov/trak/mdia/minf/stbl/stsd\n        createStsdBox(stbl);\n\n        // moov/mvex\n        let mvex = ISOBoxer.createBox('mvex', moov);\n\n        // moov/mvex/trex\n        createTrexBox(mvex);\n\n        if (contentProtection && protectionController) {\n            let supportedKS = protectionController.getSupportedKeySystemsFromContentProtection(contentProtection);\n            createProtectionSystemSpecificHeaderBox(moov, supportedKS);\n        }\n    }\n\n    function createMvhdBox(moov) {\n\n        let mvhd = ISOBoxer.createFullBox('mvhd', moov);\n\n        mvhd.version = 1; // version = 1  in order to have 64bits duration value\n\n        mvhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)\n        mvhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)\n        mvhd.timescale = TIME_SCALE; // the time-scale for the entire presentation => 10000000 for MSS\n        mvhd.duration = Math.round(period.duration * TIME_SCALE); // the length of the presentation (in the indicated timescale) =>  take duration of period\n        mvhd.rate = 1.0; // 16.16 number, '1.0' = normal playback\n        mvhd.volume = 1.0; // 8.8 number, '1.0' = full volume\n        mvhd.reserved1 = 0;\n        mvhd.reserved2 = [0x0, 0x0];\n        mvhd.matrix = [\n            1, 0, 0, // provides a transformation matrix for the video;\n            0, 1, 0, // (u,v,w) are restricted here to (0,0,1)\n            0, 0, 16384\n        ];\n        mvhd.pre_defined = [0, 0, 0, 0, 0, 0];\n        mvhd.next_track_ID = trackId + 1; // indicates a value to use for the track ID of the next track to be added to this presentation\n\n        return mvhd;\n    }\n\n    function createTkhdBox(trak) {\n\n        let tkhd = ISOBoxer.createFullBox('tkhd', trak);\n\n        tkhd.version = 1; // version = 1  in order to have 64bits duration value\n        tkhd.flags = 0x1 | // Track_enabled (0x000001): Indicates that the track is enabled\n            0x2 | // Track_in_movie (0x000002):  Indicates that the track is used in the presentation\n            0x4; // Track_in_preview (0x000004):  Indicates that the track is used when previewing the presentation\n\n        tkhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)\n        tkhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)\n        tkhd.track_ID = trackId; // uniquely identifies this track over the entire life-time of this presentation\n        tkhd.reserved1 = 0;\n        tkhd.duration = Math.round(period.duration * TIME_SCALE); // the duration of this track (in the timescale indicated in the Movie Header Box) =>  take duration of period\n        tkhd.reserved2 = [0x0, 0x0];\n        tkhd.layer = 0; // specifies the front-to-back ordering of video tracks; tracks with lower numbers are closer to the viewer => 0 since only one video track\n        tkhd.alternate_group = 0; // specifies a group or collection of tracks => ignore\n        tkhd.volume = 1.0; // '1.0' = full volume\n        tkhd.reserved3 = 0;\n        tkhd.matrix = [\n            1, 0, 0, // provides a transformation matrix for the video;\n            0, 1, 0, // (u,v,w) are restricted here to (0,0,1)\n            0, 0, 16384\n        ];\n        tkhd.width = representation.width; // visual presentation width\n        tkhd.height = representation.height; // visual presentation height\n\n        return tkhd;\n    }\n\n    function createMdhdBox(mdia) {\n\n        let mdhd = ISOBoxer.createFullBox('mdhd', mdia);\n\n        mdhd.version = 1; // version = 1  in order to have 64bits duration value\n\n        mdhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)\n        mdhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)\n        mdhd.timescale = TIME_SCALE; // the time-scale for the entire presentation\n        mdhd.duration = Math.round(period.duration * TIME_SCALE); // the duration of this media (in the scale of the timescale). If the duration cannot be determined then duration is set to all 1s.\n        mdhd.language = adaptationSet.lang || 'und'; // declares the language code for this media (see getLanguageCode())\n        mdhd.pre_defined = 0;\n\n        return mdhd;\n    }\n\n    function createHdlrBox(mdia) {\n\n        let hdlr = ISOBoxer.createFullBox('hdlr', mdia);\n\n        hdlr.pre_defined = 0;\n        switch (adaptationSet.type) {\n            case constants.VIDEO:\n                hdlr.handler_type = 'vide';\n                break;\n            case constants.AUDIO:\n                hdlr.handler_type = 'soun';\n                break;\n            default:\n                hdlr.handler_type = 'meta';\n                break;\n        }\n        hdlr.name = representation.id;\n        hdlr.reserved = [0, 0, 0];\n\n        return hdlr;\n    }\n\n    function createVmhdBox(minf) {\n\n        let vmhd = ISOBoxer.createFullBox('vmhd', minf);\n\n        vmhd.flags = 1;\n\n        vmhd.graphicsmode = 0; // specifies a composition mode for this video track, from the following enumerated set, which may be extended by derived specifications: copy = 0 copy over the existing image\n        vmhd.opcolor = [0, 0, 0]; // is a set of 3 colour values (red, green, blue) available for use by graphics modes\n\n        return vmhd;\n    }\n\n    function createSmhdBox(minf) {\n\n        let smhd = ISOBoxer.createFullBox('smhd', minf);\n\n        smhd.flags = 1;\n\n        smhd.balance = 0; // is a fixed-point 8.8 number that places mono audio tracks in a stereo space; 0 is centre (the normal value); full left is -1.0 and full right is 1.0.\n        smhd.reserved = 0;\n\n        return smhd;\n    }\n\n    function createDrefBox(dinf) {\n\n        let dref = ISOBoxer.createFullBox('dref', dinf);\n\n        dref.entry_count = 1;\n        dref.entries = [];\n\n        let url = ISOBoxer.createFullBox('url ', dref, false);\n        url.location = '';\n        url.flags = 1;\n\n        dref.entries.push(url);\n\n        return dref;\n    }\n\n    function createStsdBox(stbl) {\n\n        let stsd = ISOBoxer.createFullBox('stsd', stbl);\n\n        stsd.entries = [];\n        switch (adaptationSet.type) {\n            case constants.VIDEO:\n            case constants.AUDIO:\n                stsd.entries.push(createSampleEntry(stsd));\n                break;\n            default:\n                break;\n        }\n\n        stsd.entry_count = stsd.entries.length; // is an integer that counts the actual entries\n        return stsd;\n    }\n\n    function createSampleEntry(stsd) {\n        let codec = representation.codecs.substring(0, representation.codecs.indexOf('.'));\n\n        switch (codec) {\n            case 'avc1':\n                return createAVCVisualSampleEntry(stsd, codec);\n            case 'mp4a':\n                return createMP4AudioSampleEntry(stsd, codec);\n            default:\n                throw {\n                    name: 'Unsupported codec',\n                    message: 'Unsupported codec',\n                    data: {\n                        codec: codec\n                    }\n                };\n        }\n    }\n\n    function createAVCVisualSampleEntry(stsd, codec) {\n        let avc1;\n\n        if (contentProtection) {\n            avc1 = ISOBoxer.createBox('encv', stsd, false);\n        } else {\n            avc1 = ISOBoxer.createBox('avc1', stsd, false);\n        }\n\n        // SampleEntry fields\n        avc1.reserved1 = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0];\n        avc1.data_reference_index = 1;\n\n        // VisualSampleEntry fields\n        avc1.pre_defined1 = 0;\n        avc1.reserved2 = 0;\n        avc1.pre_defined2 = [0, 0, 0];\n        avc1.height = representation.height;\n        avc1.width = representation.width;\n        avc1.horizresolution = 72; // 72 dpi\n        avc1.vertresolution = 72; // 72 dpi\n        avc1.reserved3 = 0;\n        avc1.frame_count = 1; // 1 compressed video frame per sample\n        avc1.compressorname = [\n            0x0A, 0x41, 0x56, 0x43, 0x20, 0x43, 0x6F, 0x64, // = 'AVC Coding';\n            0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n        ];\n        avc1.depth = 0x0018; // 0x0018 – images are in colour with no alpha.\n        avc1.pre_defined3 = 65535;\n        avc1.config = createAVC1ConfigurationRecord();\n        if (contentProtection) {\n            // Create and add Protection Scheme Info Box\n            let sinf = ISOBoxer.createBox('sinf', avc1);\n\n            // Create and add Original Format Box => indicate codec type of the encrypted content\n            createOriginalFormatBox(sinf, codec);\n\n            // Create and add Scheme Type box\n            createSchemeTypeBox(sinf);\n\n            // Create and add Scheme Information Box\n            createSchemeInformationBox(sinf);\n        }\n\n        return avc1;\n    }\n\n    function createAVC1ConfigurationRecord() {\n\n        let avcC = null;\n        let avcCLength = 15; // length = 15 by default (0 SPS and 0 PPS)\n\n        // First get all SPS and PPS from codecPrivateData\n        let sps = [];\n        let pps = [];\n        let AVCProfileIndication = 0;\n        let AVCLevelIndication = 0;\n        let profile_compatibility = 0;\n\n\n        let nalus = representation.codecPrivateData.split('00000001').slice(1);\n        let naluBytes, naluType;\n\n        for (let i = 0; i < nalus.length; i++) {\n            naluBytes = hexStringtoBuffer(nalus[i]);\n\n            naluType = naluBytes[0] & 0x1F;\n\n            switch (naluType) {\n                case NALUTYPE_SPS:\n                    sps.push(naluBytes);\n                    avcCLength += naluBytes.length + 2; // 2 = sequenceParameterSetLength field length\n                    break;\n                case NALUTYPE_PPS:\n                    pps.push(naluBytes);\n                    avcCLength += naluBytes.length + 2; // 2 = pictureParameterSetLength field length\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        // Get profile and level from SPS\n        if (sps.length > 0) {\n            AVCProfileIndication = sps[0][1];\n            profile_compatibility = sps[0][2];\n            AVCLevelIndication = sps[0][3];\n        }\n\n        // Generate avcC buffer\n        avcC = new Uint8Array(avcCLength);\n\n        let i = 0;\n        // length\n        avcC[i++] = (avcCLength & 0xFF000000) >> 24;\n        avcC[i++] = (avcCLength & 0x00FF0000) >> 16;\n        avcC[i++] = (avcCLength & 0x0000FF00) >> 8;\n        avcC[i++] = (avcCLength & 0x000000FF);\n        avcC.set([0x61, 0x76, 0x63, 0x43], i); // type = 'avcC'\n        i += 4;\n        avcC[i++] = 1; // configurationVersion = 1\n        avcC[i++] = AVCProfileIndication;\n        avcC[i++] = profile_compatibility;\n        avcC[i++] = AVCLevelIndication;\n        avcC[i++] = 0xFF; // '11111' + lengthSizeMinusOne = 3\n        avcC[i++] = 0xE0 | sps.length; // '111' + numOfSequenceParameterSets\n        for (let n = 0; n < sps.length; n++) {\n            avcC[i++] = (sps[n].length & 0xFF00) >> 8;\n            avcC[i++] = (sps[n].length & 0x00FF);\n            avcC.set(sps[n], i);\n            i += sps[n].length;\n        }\n        avcC[i++] = pps.length; // numOfPictureParameterSets\n        for (let n = 0; n < pps.length; n++) {\n            avcC[i++] = (pps[n].length & 0xFF00) >> 8;\n            avcC[i++] = (pps[n].length & 0x00FF);\n            avcC.set(pps[n], i);\n            i += pps[n].length;\n        }\n\n        return avcC;\n    }\n\n    function createMP4AudioSampleEntry(stsd, codec) {\n        let mp4a;\n\n        if (contentProtection) {\n            mp4a = ISOBoxer.createBox('enca', stsd, false);\n        } else {\n            mp4a = ISOBoxer.createBox('mp4a', stsd, false);\n        }\n\n        // SampleEntry fields\n        mp4a.reserved1 = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0];\n        mp4a.data_reference_index = 1;\n\n        // AudioSampleEntry fields\n        mp4a.reserved2 = [0x0, 0x0];\n        mp4a.channelcount = representation.audioChannels;\n        mp4a.samplesize = 16;\n        mp4a.pre_defined = 0;\n        mp4a.reserved_3 = 0;\n        mp4a.samplerate = representation.audioSamplingRate << 16;\n\n        mp4a.esds = createMPEG4AACESDescriptor();\n\n        if (contentProtection) {\n            // Create and add Protection Scheme Info Box\n            let sinf = ISOBoxer.createBox('sinf', mp4a);\n\n            // Create and add Original Format Box => indicate codec type of the encrypted content\n            createOriginalFormatBox(sinf, codec);\n\n            // Create and add Scheme Type box\n            createSchemeTypeBox(sinf);\n\n            // Create and add Scheme Information Box\n            createSchemeInformationBox(sinf);\n        }\n\n        return mp4a;\n    }\n\n    function createMPEG4AACESDescriptor() {\n\n        // AudioSpecificConfig (see ISO/IEC 14496-3, subpart 1) => corresponds to hex bytes contained in 'codecPrivateData' field\n        let audioSpecificConfig = hexStringtoBuffer(representation.codecPrivateData);\n\n        // ESDS length = esds box header length (= 12) +\n        //               ES_Descriptor header length (= 5) +\n        //               DecoderConfigDescriptor header length (= 15) +\n        //               decoderSpecificInfo header length (= 2) +\n        //               AudioSpecificConfig length (= codecPrivateData length)\n        let esdsLength = 34 + audioSpecificConfig.length;\n        let esds = new Uint8Array(esdsLength);\n\n        let i = 0;\n        // esds box\n        esds[i++] = (esdsLength & 0xFF000000) >> 24; // esds box length\n        esds[i++] = (esdsLength & 0x00FF0000) >> 16; // ''\n        esds[i++] = (esdsLength & 0x0000FF00) >> 8; // ''\n        esds[i++] = (esdsLength & 0x000000FF); // ''\n        esds.set([0x65, 0x73, 0x64, 0x73], i); // type = 'esds'\n        i += 4;\n        esds.set([0, 0, 0, 0], i); // version = 0, flags = 0\n        i += 4;\n        // ES_Descriptor (see ISO/IEC 14496-1 (Systems))\n        esds[i++] = 0x03; // tag = 0x03 (ES_DescrTag)\n        esds[i++] = 20 + audioSpecificConfig.length; // size\n        esds[i++] = (trackId & 0xFF00) >> 8; // ES_ID = track_id\n        esds[i++] = (trackId & 0x00FF); // ''\n        esds[i++] = 0; // flags and streamPriority\n\n        // DecoderConfigDescriptor (see ISO/IEC 14496-1 (Systems))\n        esds[i++] = 0x04; // tag = 0x04 (DecoderConfigDescrTag)\n        esds[i++] = 15 + audioSpecificConfig.length; // size\n        esds[i++] = 0x40; // objectTypeIndication = 0x40 (MPEG-4 AAC)\n        esds[i] = 0x05 << 2; // streamType = 0x05 (Audiostream)\n        esds[i] |= 0 << 1; // upStream = 0\n        esds[i++] |= 1; // reserved = 1\n        esds[i++] = 0xFF; // buffersizeDB = undefined\n        esds[i++] = 0xFF; // ''\n        esds[i++] = 0xFF; // ''\n        esds[i++] = (representation.bandwidth & 0xFF000000) >> 24; // maxBitrate\n        esds[i++] = (representation.bandwidth & 0x00FF0000) >> 16; // ''\n        esds[i++] = (representation.bandwidth & 0x0000FF00) >> 8; // ''\n        esds[i++] = (representation.bandwidth & 0x000000FF); // ''\n        esds[i++] = (representation.bandwidth & 0xFF000000) >> 24; // avgbitrate\n        esds[i++] = (representation.bandwidth & 0x00FF0000) >> 16; // ''\n        esds[i++] = (representation.bandwidth & 0x0000FF00) >> 8; // ''\n        esds[i++] = (representation.bandwidth & 0x000000FF); // ''\n\n        // DecoderSpecificInfo (see ISO/IEC 14496-1 (Systems))\n        esds[i++] = 0x05; // tag = 0x05 (DecSpecificInfoTag)\n        esds[i++] = audioSpecificConfig.length; // size\n        esds.set(audioSpecificConfig, i); // AudioSpecificConfig bytes\n\n        return esds;\n    }\n\n    function createOriginalFormatBox(sinf, codec) {\n        let frma = ISOBoxer.createBox('frma', sinf);\n        frma.data_format = stringToCharCode(codec);\n    }\n\n    function createSchemeTypeBox(sinf) {\n        let schm = ISOBoxer.createFullBox('schm', sinf);\n\n        schm.flags = 0;\n        schm.version = 0;\n        schm.scheme_type = 0x63656E63; // 'cenc' => common encryption\n        schm.scheme_version = 0x00010000; // version set to 0x00010000 (Major version 1, Minor version 0)\n    }\n\n    function createSchemeInformationBox(sinf) {\n        let schi = ISOBoxer.createBox('schi', sinf);\n\n        // Create and add Track Encryption Box\n        createTrackEncryptionBox(schi);\n    }\n\n    function createProtectionSystemSpecificHeaderBox(moov, keySystems) {\n        let pssh_bytes;\n        let pssh;\n        let i;\n        let parsedBuffer;\n\n        for (i = 0; i < keySystems.length; i += 1) {\n            pssh_bytes = keySystems[i].initData;\n            parsedBuffer = ISOBoxer.parseBuffer(pssh_bytes);\n            pssh = parsedBuffer.fetch('pssh');\n            if (pssh) {\n                ISOBoxer.Utils.appendBox(moov, pssh);\n            }\n        }\n    }\n\n    function createTrackEncryptionBox(schi) {\n        let tenc = ISOBoxer.createFullBox('tenc', schi);\n\n        tenc.flags = 0;\n        tenc.version = 0;\n\n        tenc.default_IsEncrypted = 0x1;\n        tenc.default_IV_size = 8;\n        tenc.default_KID = (contentProtection && (contentProtection.length) > 0 && contentProtection[0]['cenc:default_KID']) ?\n            contentProtection[0]['cenc:default_KID'] : [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];\n    }\n\n    function createTrexBox(moov) {\n\n        let trex = ISOBoxer.createFullBox('trex', moov);\n\n        trex.track_ID = trackId;\n        trex.default_sample_description_index = 1;\n        trex.default_sample_duration = 0;\n        trex.default_sample_size = 0;\n        trex.default_sample_flags = 0;\n\n        return trex;\n    }\n\n    function hexStringtoBuffer(str) {\n        let buf = new Uint8Array(str.length / 2);\n        let i;\n\n        for (i = 0; i < str.length / 2; i += 1) {\n            buf[i] = parseInt('' + str[i * 2] + str[i * 2 + 1], 16);\n        }\n        return buf;\n    }\n\n    function stringToCharCode(str) {\n        let code = 0;\n        let i;\n\n        for (i = 0; i < str.length; i += 1) {\n            code |= str.charCodeAt(i) << ((str.length - i - 1) * 8);\n        }\n        return code;\n    }\n\n    function generateMoov(rep) {\n        if (!rep || !rep.adaptation) {\n            return;\n        }\n\n        let isoFile,\n            arrayBuffer;\n\n        representation = rep;\n        adaptationSet = representation.adaptation;\n\n        period = adaptationSet.period;\n        trackId = adaptationSet.index + 1;\n        contentProtection = period.mpd.manifest.Period_asArray[period.index].AdaptationSet_asArray[adaptationSet.index].ContentProtection;\n\n        isoFile = ISOBoxer.createFile();\n        createFtypBox(isoFile);\n        createMoovBox(isoFile);\n\n        arrayBuffer = isoFile.write();\n\n        return arrayBuffer;\n    }\n\n    instance = {\n        generateMoov: generateMoov\n    };\n\n    return instance;\n}\n\nMssFragmentMoovProcessor.__dashjs_factory_name = 'MssFragmentMoovProcessor';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoovProcessor); /* jshint ignore:line */","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport MSSFragmentMoofProcessor from './MssFragmentMoofProcessor';\nimport MSSFragmentMoovProcessor from './MssFragmentMoovProcessor';\nimport MssEvents from './MssEvents';\n\n\n// Add specific box processors not provided by codem-isoboxer library\n\nfunction arrayEqual(arr1, arr2) {\n    return (arr1.length === arr2.length) && arr1.every(function (element, index) {\n        return element === arr2[index];\n    });\n}\n\nfunction saioProcessor() {\n    this._procFullBox();\n    if (this.flags & 1) {\n        this._procField('aux_info_type', 'uint', 32);\n        this._procField('aux_info_type_parameter', 'uint', 32);\n    }\n    this._procField('entry_count', 'uint', 32);\n    this._procFieldArray('offset', this.entry_count, 'uint', (this.version === 1) ? 64 : 32);\n}\n\nfunction saizProcessor() {\n    this._procFullBox();\n    if (this.flags & 1) {\n        this._procField('aux_info_type', 'uint', 32);\n        this._procField('aux_info_type_parameter', 'uint', 32);\n    }\n    this._procField('default_sample_info_size', 'uint', 8);\n    this._procField('sample_count', 'uint', 32);\n    if (this.default_sample_info_size === 0) {\n        this._procFieldArray('sample_info_size', this.sample_count, 'uint', 8);\n    }\n}\n\nfunction sencProcessor() {\n    this._procFullBox();\n    this._procField('sample_count', 'uint', 32);\n    if (this.flags & 1) {\n        this._procField('IV_size', 'uint', 8);\n    }\n    this._procEntries('entry', this.sample_count, function (entry) {\n        this._procEntryField(entry, 'InitializationVector', 'data', 8);\n        if (this.flags & 2) {\n            this._procEntryField(entry, 'NumberOfEntries', 'uint', 16);\n            this._procSubEntries(entry, 'clearAndCryptedData', entry.NumberOfEntries, function (clearAndCryptedData) {\n                this._procEntryField(clearAndCryptedData, 'BytesOfClearData', 'uint', 16);\n                this._procEntryField(clearAndCryptedData, 'BytesOfEncryptedData', 'uint', 32);\n            });\n        }\n    });\n}\n\nfunction uuidProcessor() {\n    let tfxdUserType = [0x6D, 0x1D, 0x9B, 0x05, 0x42, 0xD5, 0x44, 0xE6, 0x80, 0xE2, 0x14, 0x1D, 0xAF, 0xF7, 0x57, 0xB2];\n    let tfrfUserType = [0xD4, 0x80, 0x7E, 0xF2, 0xCA, 0x39, 0x46, 0x95, 0x8E, 0x54, 0x26, 0xCB, 0x9E, 0x46, 0xA7, 0x9F];\n    let sepiffUserType = [0xA2, 0x39, 0x4F, 0x52, 0x5A, 0x9B, 0x4f, 0x14, 0xA2, 0x44, 0x6C, 0x42, 0x7C, 0x64, 0x8D, 0xF4];\n\n    if (arrayEqual(this.usertype, tfxdUserType)) {\n        this._procFullBox();\n        if (this._parsing) {\n            this.type = 'tfxd';\n        }\n        this._procField('fragment_absolute_time', 'uint', (this.version === 1) ? 64 : 32);\n        this._procField('fragment_duration', 'uint', (this.version === 1) ? 64 : 32);\n    }\n\n    if (arrayEqual(this.usertype, tfrfUserType)) {\n        this._procFullBox();\n        if (this._parsing) {\n            this.type = 'tfrf';\n        }\n        this._procField('fragment_count', 'uint', 8);\n        this._procEntries('entry', this.fragment_count, function (entry) {\n            this._procEntryField(entry, 'fragment_absolute_time', 'uint', (this.version === 1) ? 64 : 32);\n            this._procEntryField(entry, 'fragment_duration', 'uint', (this.version === 1) ? 64 : 32);\n        });\n    }\n\n    if (arrayEqual(this.usertype, sepiffUserType)) {\n        if (this._parsing) {\n            this.type = 'sepiff';\n        }\n        sencProcessor.call(this);\n    }\n}\n\nfunction MssFragmentProcessor(config) {\n\n    let context = this.context;\n    let metricsModel = config.metricsModel;\n    let playbackController = config.playbackController;\n    let eventBus = config.eventBus;\n    let protectionController = config.protectionController;\n    const ISOBoxer = config.ISOBoxer;\n    const log = config.log;\n    let instance;\n\n    function setup() {\n        ISOBoxer.addBoxProcessor('uuid', uuidProcessor);\n        ISOBoxer.addBoxProcessor('saio', saioProcessor);\n        ISOBoxer.addBoxProcessor('saiz', saizProcessor);\n        ISOBoxer.addBoxProcessor('senc', sencProcessor);\n    }\n\n    function generateMoov(rep) {\n        let mssFragmentMoovProcessor = MSSFragmentMoovProcessor(context).create({protectionController: protectionController, constants: config.constants, ISOBoxer: config.ISOBoxer});\n        return mssFragmentMoovProcessor.generateMoov(rep);\n    }\n\n    function processFragment(e, sp) {\n        if (!e) {\n            return;\n        }\n\n        let request = e.request;\n\n        if (!request) {\n            return;\n        }\n\n        if (request.type === 'MediaSegment') {\n\n            // it's a MediaSegment, let's convert fragment\n            let mssFragmentMoofProcessor = MSSFragmentMoofProcessor(context).create({\n                metricsModel: metricsModel,\n                playbackController: playbackController,\n                ISOBoxer: ISOBoxer,\n                log: log\n            });\n            mssFragmentMoofProcessor.convertFragment(e, sp);\n\n        } else if (request.type === 'FragmentInfoSegment') {\n\n            // it's a FragmentInfo, ask relative fragment info controller to handle it\n            eventBus.trigger(MssEvents.FRAGMENT_INFO_LOADING_COMPLETED, {\n                fragmentInfo: e,\n                streamProcessor: sp\n            });\n\n            // Change the sender value to stop event to be propagated (fragment info must not be added to buffer)\n            e.sender = null;\n        }\n    }\n\n    instance = {\n        generateMoov: generateMoov,\n        processFragment: processFragment\n    };\n\n    setup();\n\n    return instance;\n}\n\nMssFragmentProcessor.__dashjs_factory_name = 'MssFragmentProcessor';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentProcessor); /* jshint ignore:line */","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport DataChunk from '../streaming/vo/DataChunk';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport MssFragmentInfoController from './MssFragmentInfoController';\nimport MssFragmentProcessor from './MssFragmentProcessor';\nimport MssParser from './parser/MssParser';\n\nfunction MssHandler(config) {\n\n    let context = this.context;\n    let eventBus = config.eventBus;\n    const events = config.events;\n    const constants = config.constants;\n    const initSegmentType = config.initSegmentType;\n    let metricsModel = config.metricsModel;\n    let playbackController = config.playbackController;\n    let protectionController = config.protectionController;\n    let mssFragmentProcessor = MssFragmentProcessor(context).create({\n        metricsModel: metricsModel,\n        playbackController: playbackController,\n        protectionController: protectionController,\n        eventBus: eventBus,\n        constants: constants,\n        ISOBoxer: config.ISOBoxer,\n        log: config.log\n    });\n    let mssParser;\n\n    let instance;\n\n    function setup() {\n    }\n\n    function onInitializationRequested(e) {\n        let streamProcessor = e.sender.getStreamProcessor();\n        let request = new FragmentRequest();\n        let representationController = streamProcessor.getRepresentationController();\n        let representation = representationController.getCurrentRepresentation();\n        let period,\n            presentationStartTime;\n\n        period = representation.adaptation.period;\n\n        request.mediaType = representation.adaptation.type;\n        request.type = initSegmentType;\n        request.range = representation.range;\n        presentationStartTime = period.start;\n        //request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n        //request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamic);\n        request.quality = representation.index;\n        request.mediaInfo = streamProcessor.getMediaInfo();\n        request.representationId = representation.id;\n\n        const chunk = createDataChunk(request, streamProcessor.getStreamInfo().id);\n\n        // Generate initialization segment (moov)\n        chunk.bytes = mssFragmentProcessor.generateMoov(representation);\n\n        eventBus.trigger(events.INIT_FRAGMENT_LOADED, {\n            chunk: chunk,\n            fragmentModel: streamProcessor.getFragmentModel()\n        });\n\n        // Change the sender value to stop event to be propagated\n        e.sender = null;\n    }\n\n    function createDataChunk(request, streamId) {\n        const chunk = new DataChunk();\n\n        chunk.streamId = streamId;\n        chunk.mediaInfo = request.mediaInfo;\n        chunk.segmentType = request.type;\n        chunk.start = request.startTime;\n        chunk.duration = request.duration;\n        chunk.end = chunk.start + chunk.duration;\n        chunk.index = request.index;\n        chunk.quality = request.quality;\n        chunk.representationId = request.representationId;\n\n        return chunk;\n    }\n\n    function onSegmentMediaLoaded(e) {\n        // Process moof to transcode it from MSS to DASH\n        let streamProcessor = e.sender.getStreamProcessor();\n        mssFragmentProcessor.processFragment(e, streamProcessor);\n    }\n\n    function onPlaybackSeekAsked() {\n        if (playbackController.getIsDynamic() && playbackController.getTime() !== 0) {\n\n            //create fragment info controllers for each stream processors of active stream (only for audio, video or fragmentedText)\n            let streamController = playbackController.getStreamController();\n            if (streamController) {\n                let processors = streamController.getActiveStreamProcessors();\n                processors.forEach(function (processor) {\n                    if (processor.getType() === constants.VIDEO ||\n                        processor.getType() === constants.AUDIO ||\n                        processor.getType() === constants.FRAGMENTED_TEXT) {\n\n                        let fragmentInfoController = MssFragmentInfoController(context).create({\n                            streamProcessor: processor,\n                            eventBus: eventBus,\n                            metricsModel: metricsModel,\n                            playbackController: playbackController,\n                            ISOBoxer: config.ISOBoxer,\n                            log: config.log\n                        });\n                        fragmentInfoController.initialize();\n                        fragmentInfoController.start();\n                    }\n                });\n            }\n        }\n    }\n\n    function registerEvents() {\n        eventBus.on(events.INIT_REQUESTED, onInitializationRequested, instance, dashjs.FactoryMaker.getSingletonFactoryByName(eventBus.getClassName()).EVENT_PRIORITY_HIGH); /* jshint ignore:line */\n        eventBus.on(events.PLAYBACK_SEEK_ASKED, onPlaybackSeekAsked, instance, dashjs.FactoryMaker.getSingletonFactoryByName(eventBus.getClassName()).EVENT_PRIORITY_HIGH); /* jshint ignore:line */\n        eventBus.on(events.FRAGMENT_LOADING_COMPLETED, onSegmentMediaLoaded, instance, dashjs.FactoryMaker.getSingletonFactoryByName(eventBus.getClassName()).EVENT_PRIORITY_HIGH); /* jshint ignore:line */\n    }\n\n    function reset() {\n        eventBus.off(events.INIT_REQUESTED, onInitializationRequested, this);\n        eventBus.off(events.PLAYBACK_SEEK_ASKED, onPlaybackSeekAsked, this);\n        eventBus.off(events.FRAGMENT_LOADING_COMPLETED, onSegmentMediaLoaded, this);\n    }\n\n    function createMssParser() {\n        mssParser = MssParser(context).create(config);\n        return mssParser;\n    }\n\n    instance = {\n        reset: reset,\n        createMssParser: createMssParser,\n        registerEvents: registerEvents\n    };\n\n    setup();\n\n    return instance;\n}\n\nMssHandler.__dashjs_factory_name = 'MssHandler';\nexport default dashjs.FactoryMaker.getClassFactory(MssHandler); /* jshint ignore:line */\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport MssHandler from './MssHandler';\n\n// Shove both of these into the global scope\nvar context = (typeof window !== 'undefined' && window) || global;\n\nvar dashjs = context.dashjs;\nif (!dashjs) {\n    dashjs = context.dashjs = {};\n}\n\ndashjs.MssHandler = MssHandler;\n\nexport default dashjs;\nexport { MssHandler };\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @module MssParser\n * @param {Object} config object\n */\nfunction MssParser(config) {\n    const protectionController = config.protectionController;\n    const BASE64 = config.BASE64;\n    const log = config.log;\n    const errorHandler = config.errHandler;\n    const constants = config.constants;\n\n    const TIME_SCALE_100_NANOSECOND_UNIT = 10000000.0;\n    const SUPPORTED_CODECS = ['AAC', 'AACL', 'AVC1', 'H264', 'TTML', 'DFXP'];\n    const samplingFrequencyIndex = {\n        96000: 0x0,\n        88200: 0x1,\n        64000: 0x2,\n        48000: 0x3,\n        44100: 0x4,\n        32000: 0x5,\n        24000: 0x6,\n        22050: 0x7,\n        16000: 0x8,\n        12000: 0x9,\n        11025: 0xA,\n        8000: 0xB,\n        7350: 0xC\n    };\n    const mimeTypeMap = {\n        'video': 'video/mp4',\n        'audio': 'audio/mp4',\n        'text': 'application/mp4'\n    };\n\n    let instance,\n        mediaPlayerModel;\n\n\n    function setup() {\n        mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    function mapPeriod(smoothStreamingMedia) {\n        let period = {};\n        let streams,\n            adaptation;\n\n        period.duration = (parseFloat(smoothStreamingMedia.getAttribute('Duration')) === 0) ? Infinity : parseFloat(smoothStreamingMedia.getAttribute('Duration')) / TIME_SCALE_100_NANOSECOND_UNIT;\n\n        // For each StreamIndex node, create an AdaptationSet element\n        period.AdaptationSet_asArray = [];\n        streams = smoothStreamingMedia.getElementsByTagName('StreamIndex');\n        for (let i = 0; i < streams.length; i++) {\n            adaptation = mapAdaptationSet(streams[i]);\n            if (adaptation !== null) {\n                period.AdaptationSet_asArray.push(adaptation);\n            }\n        }\n\n        if (period.AdaptationSet_asArray.length > 0) {\n            period.AdaptationSet = (period.AdaptationSet_asArray.length > 1) ? period.AdaptationSet_asArray : period.AdaptationSet_asArray[0];\n        }\n\n        return period;\n    }\n\n    function mapAdaptationSet(streamIndex) {\n\n        let adaptationSet = {};\n        let representations = [];\n        let segmentTemplate = {};\n        let qualityLevels,\n            representation,\n            segments,\n            range,\n            i;\n\n        adaptationSet.id = streamIndex.getAttribute('Name') ? streamIndex.getAttribute('Name') : streamIndex.getAttribute('Type');\n        adaptationSet.contentType = streamIndex.getAttribute('Type');\n        adaptationSet.lang = streamIndex.getAttribute('Language') || 'und';\n        adaptationSet.mimeType = mimeTypeMap[adaptationSet.contentType];\n        adaptationSet.subType = streamIndex.getAttribute('Subtype');\n        adaptationSet.maxWidth = streamIndex.getAttribute('MaxWidth');\n        adaptationSet.maxHeight = streamIndex.getAttribute('MaxHeight');\n\n        // Create a SegmentTemplate with a SegmentTimeline\n        segmentTemplate = mapSegmentTemplate(streamIndex);\n\n        qualityLevels = streamIndex.getElementsByTagName('QualityLevel');\n        // For each QualityLevel node, create a Representation element\n        for (i = 0; i < qualityLevels.length; i++) {\n            // Propagate BaseURL and mimeType\n            qualityLevels[i].BaseURL = adaptationSet.BaseURL;\n            qualityLevels[i].mimeType = adaptationSet.mimeType;\n\n            // Set quality level id\n            qualityLevels[i].Id = adaptationSet.id + '_' + qualityLevels[i].getAttribute('Index');\n\n            // Map Representation to QualityLevel\n            representation = mapRepresentation(qualityLevels[i], streamIndex);\n\n            if (representation !== null) {\n                // Copy SegmentTemplate into Representation\n                representation.SegmentTemplate = segmentTemplate;\n\n                representations.push(representation);\n            }\n        }\n\n        if (representations.length === 0) {\n            return null;\n        }\n\n        adaptationSet.Representation = (representations.length > 1) ? representations : representations[0];\n        adaptationSet.Representation_asArray = representations;\n\n        // Set SegmentTemplate\n        adaptationSet.SegmentTemplate = segmentTemplate;\n\n        segments = segmentTemplate.SegmentTimeline.S_asArray;\n\n        range = {\n            start: segments[0].t / segmentTemplate.timescale,\n            end: (segments[segments.length - 1].t + segments[segments.length - 1].d) / segmentTemplate.timescale\n        };\n\n        return adaptationSet;\n    }\n\n    function mapRepresentation(qualityLevel, streamIndex) {\n\n        let representation = {};\n        let fourCCValue = null;\n\n        representation.id = qualityLevel.Id;\n        representation.bandwidth = parseInt(qualityLevel.getAttribute('Bitrate'), 10);\n        representation.mimeType = qualityLevel.mimeType;\n        representation.width = parseInt(qualityLevel.getAttribute('MaxWidth'), 10);\n        representation.height = parseInt(qualityLevel.getAttribute('MaxHeight'), 10);\n\n        fourCCValue = qualityLevel.getAttribute('FourCC');\n\n        // If FourCC not defined at QualityLevel level, then get it from StreamIndex level\n        if (fourCCValue === null) {\n            fourCCValue = streamIndex.getAttribute('FourCC');\n        }\n\n        // If still not defined (optionnal for audio stream, see https://msdn.microsoft.com/en-us/library/ff728116%28v=vs.95%29.aspx),\n        // then we consider the stream is an audio AAC stream\n        if (fourCCValue === null) {\n            fourCCValue = 'AAC';\n        }\n\n        // Check if codec is supported\n        if (SUPPORTED_CODECS.indexOf(fourCCValue.toUpperCase()) === -1) {\n            // Do not send warning\n            //this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Codec not supported', {codec: fourCCValue});\n            log('[MssParser] Codec not supported: ' + fourCCValue);\n            return null;\n        }\n\n        // Get codecs value according to FourCC field\n        if (fourCCValue === 'H264' || fourCCValue === 'AVC1') {\n            representation.codecs = getH264Codec(qualityLevel);\n        } else if (fourCCValue.indexOf('AAC') >= 0) {\n            representation.codecs = getAACCodec(qualityLevel, fourCCValue);\n            representation.audioSamplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10);\n            representation.audioChannels = parseInt(qualityLevel.getAttribute('Channels'), 10);\n        } else if (fourCCValue.indexOf('TTML') || fourCCValue.indexOf('DFXP')) {\n            representation.codecs = constants.STPP;\n        }\n\n        representation.codecPrivateData = '' + qualityLevel.getAttribute('CodecPrivateData');\n        representation.BaseURL = qualityLevel.BaseURL;\n\n        return representation;\n    }\n\n    function getH264Codec(qualityLevel) {\n        let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString();\n        let nalHeader,\n            avcoti;\n\n\n        // Extract from the CodecPrivateData field the hexadecimal representation of the following\n        // three bytes in the sequence parameter set NAL unit.\n        // => Find the SPS nal header\n        nalHeader = /00000001[0-9]7/.exec(codecPrivateData);\n        // => Find the 6 characters after the SPS nalHeader (if it exists)\n        avcoti = nalHeader && nalHeader[0] ? (codecPrivateData.substr(codecPrivateData.indexOf(nalHeader[0]) + 10, 6)) : undefined;\n\n        return 'avc1.' + avcoti;\n    }\n\n    function getAACCodec(qualityLevel, fourCCValue) {\n        let objectType = 0;\n        let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString();\n        let samplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10);\n        let codecPrivateDataHex,\n            arr16,\n            indexFreq,\n            extensionSamplingFrequencyIndex;\n\n        //chrome problem, in implicit AAC HE definition, so when AACH is detected in FourCC\n        //set objectType to 5 => strange, it should be 2\n        if (fourCCValue === 'AACH') {\n            objectType = 0x05;\n        }\n        //if codecPrivateData is empty, build it :\n        if (codecPrivateData === undefined || codecPrivateData === '') {\n            objectType = 0x02; //AAC Main Low Complexity => object Type = 2\n            indexFreq = samplingFrequencyIndex[samplingRate];\n            if (fourCCValue === 'AACH') {\n                // 4 bytes :     XXXXX         XXXX          XXXX             XXXX                  XXXXX      XXX   XXXXXXX\n                //           ' ObjectType' 'Freq Index' 'Channels value'   'Extens Sampl Freq'  'ObjectType'  'GAS' 'alignment = 0'\n                objectType = 0x05; // High Efficiency AAC Profile = object Type = 5 SBR\n                codecPrivateData = new Uint8Array(4);\n                extensionSamplingFrequencyIndex = samplingFrequencyIndex[samplingRate * 2]; // in HE AAC Extension Sampling frequence\n                // equals to SamplingRate*2\n                //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                codecPrivateData[1] = (indexFreq << 7) | (qualityLevel.Channels << 3) | (extensionSamplingFrequencyIndex >> 1);\n                codecPrivateData[2] = (extensionSamplingFrequencyIndex << 7) | (0x02 << 2); // origin object type equals to 2 => AAC Main Low Complexity\n                codecPrivateData[3] = 0x0; //alignment bits\n\n                arr16 = new Uint16Array(2);\n                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                arr16[1] = (codecPrivateData[2] << 8) + codecPrivateData[3];\n                //convert decimal to hex value\n                codecPrivateDataHex = arr16[0].toString(16);\n                codecPrivateDataHex = arr16[0].toString(16) + arr16[1].toString(16);\n\n            } else {\n                // 2 bytes :     XXXXX         XXXX          XXXX              XXX\n                //           ' ObjectType' 'Freq Index' 'Channels value'   'GAS = 000'\n                codecPrivateData = new Uint8Array(2);\n                //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                codecPrivateData[1] = (indexFreq << 7) | (parseInt(qualityLevel.getAttribute('Channels'), 10) << 3);\n                // put the 2 bytes in an 16 bits array\n                arr16 = new Uint16Array(1);\n                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                //convert decimal to hex value\n                codecPrivateDataHex = arr16[0].toString(16);\n            }\n\n            codecPrivateData = '' + codecPrivateDataHex;\n            codecPrivateData = codecPrivateData.toUpperCase();\n            qualityLevel.setAttribute('CodecPrivateData', codecPrivateData);\n        } else if (objectType === 0) {\n            objectType = (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3;\n        }\n\n        return 'mp4a.40.' + objectType;\n    }\n\n    function mapSegmentTemplate(streamIndex) {\n\n        let segmentTemplate = {};\n        let mediaUrl;\n\n        mediaUrl = streamIndex.getAttribute('Url').replace('{bitrate}', '$Bandwidth$');\n        mediaUrl = mediaUrl.replace('{start time}', '$Time$');\n\n        segmentTemplate.media = mediaUrl;\n        segmentTemplate.timescale = TIME_SCALE_100_NANOSECOND_UNIT;\n\n        segmentTemplate.SegmentTimeline = mapSegmentTimeline(streamIndex);\n\n        return segmentTemplate;\n    }\n\n    function mapSegmentTimeline(streamIndex) {\n\n        let segmentTimeline = {};\n        let chunks = streamIndex.getElementsByTagName('c');\n        let segments = [];\n        let segment;\n        let prevSegment;\n        let tManifest;\n        let i;\n        let duration = 0;\n\n        for (i = 0; i < chunks.length; i++) {\n            segment = {};\n\n            // Get time 't' attribute value\n            tManifest = chunks[i].getAttribute('t');\n\n            // => segment.tManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler)\n            // => segment.t = number value of timestamp (maybe rounded value, but only for 0.1 microsecond)\n            segment.tManifest = parseFloat(tManifest);\n            segment.t = parseFloat(tManifest);\n\n            // Get duration 'd' attribute value\n            segment.d = parseFloat(chunks[i].getAttribute('d'));\n\n            // If 't' not defined for first segment then t=0\n            if ((i === 0) && !segment.t) {\n                segment.t = 0;\n            }\n\n            if (i > 0) {\n                prevSegment = segments[segments.length - 1];\n                // Update previous segment duration if not defined\n                if (!prevSegment.d) {\n                    if (prevSegment.tManifest) {\n                        prevSegment.d = parseFloat(tManifest) - parseFloat(prevSegment.tManifest);\n                    } else {\n                        prevSegment.d = segment.t - prevSegment.t;\n                    }\n                }\n                // Set segment absolute timestamp if not set in manifest\n                if (!segment.t) {\n                    if (prevSegment.tManifest) {\n                        segment.tManifest = parseFloat(prevSegment.tManifest) + prevSegment.d;\n                        segment.t = parseFloat(segment.tManifest);\n                    } else {\n                        segment.t = prevSegment.t + prevSegment.d;\n                    }\n                }\n            }\n\n            duration += segment.d;\n\n            // Create new segment\n            segments.push(segment);\n        }\n\n        segmentTimeline.S = segments;\n        segmentTimeline.S_asArray = segments;\n        segmentTimeline.duration = duration / TIME_SCALE_100_NANOSECOND_UNIT;\n\n        return segmentTimeline;\n    }\n\n    function getKIDFromProtectionHeader(protectionHeader) {\n        let prHeader,\n            wrmHeader,\n            xmlReader,\n            KID;\n\n        // Get PlayReady header as byte array (base64 decoded)\n        prHeader = BASE64.decodeArray(protectionHeader.firstChild.data);\n\n        // Get Right Management header (WRMHEADER) from PlayReady header\n        wrmHeader = getWRMHeaderFromPRHeader(prHeader);\n\n        // Convert from multi-byte to unicode\n        wrmHeader = new Uint16Array(wrmHeader.buffer);\n\n        // Convert to string\n        wrmHeader = String.fromCharCode.apply(null, wrmHeader);\n\n        // Parse <WRMHeader> to get KID field value\n        xmlReader = (new DOMParser()).parseFromString(wrmHeader, 'application/xml');\n        KID = xmlReader.querySelector('KID').textContent;\n\n        // Get KID (base64 decoded) as byte array\n        KID = BASE64.decodeArray(KID);\n\n        // Convert UUID from little-endian to big-endian\n        convertUuidEndianness(KID);\n\n        return KID;\n    }\n\n    function getWRMHeaderFromPRHeader(prHeader) {\n        let length,\n            recordCount,\n            recordType,\n            recordLength,\n            recordValue;\n        let i = 0;\n\n        // Parse PlayReady header\n\n        // Length - 32 bits (LE format)\n        length = (prHeader[i + 3] << 24) + (prHeader[i + 2] << 16) + (prHeader[i + 1] << 8) + prHeader[i];\n        i += 4;\n\n        // Record count - 16 bits (LE format)\n        recordCount = (prHeader[i + 1] << 8) + prHeader[i];\n        i += 2;\n\n        // Parse records\n        while (i < prHeader.length) {\n            // Record type - 16 bits (LE format)\n            recordType = (prHeader[i + 1] << 8) + prHeader[i];\n            i += 2;\n\n            // Check if Rights Management header (record type = 0x01)\n            if (recordType === 0x01) {\n\n                // Record length - 16 bits (LE format)\n                recordLength = (prHeader[i + 1] << 8) + prHeader[i];\n                i += 2;\n\n                // Record value => contains <WRMHEADER>\n                recordValue = new Uint8Array(recordLength);\n                recordValue.set(prHeader.subarray(i, i + recordLength));\n                return recordValue;\n            }\n        }\n\n        return null;\n    }\n\n    function convertUuidEndianness(uuid) {\n        swapBytes(uuid, 0, 3);\n        swapBytes(uuid, 1, 2);\n        swapBytes(uuid, 4, 5);\n        swapBytes(uuid, 6, 7);\n    }\n\n    function swapBytes(bytes, pos1, pos2) {\n        let temp = bytes[pos1];\n        bytes[pos1] = bytes[pos2];\n        bytes[pos2] = temp;\n    }\n\n\n    function createPRContentProtection(protectionHeader) {\n        const keySystems = protectionController ? protectionController.getKeySystems() : null;\n        let ksPlayReady;\n\n        for (let i = 0; i < keySystems.length; i++) {\n            if (keySystems[i].systemString && keySystems[i].systemString.indexOf('playready') !== -1) {\n                ksPlayReady = keySystems[i];\n                break;\n            }\n        }\n\n        let contentProtection = {};\n        let pro;\n\n        pro = {\n            __text: protectionHeader.firstChild.data,\n            __prefix: 'mspr'\n        };\n\n        if (ksPlayReady) {\n            contentProtection.schemeIdUri = ksPlayReady.schemeIdURI;\n            contentProtection.value = ksPlayReady.systemString;\n            contentProtection.pro = pro;\n            contentProtection.pro_asArray = pro;\n        }\n\n        return contentProtection;\n    }\n\n    function createWidevineContentProtection(/*protectionHeader*/) {\n        const keySystems = protectionController ? protectionController.getKeySystems() : null;\n        let ksWidevine;\n\n        for (let i = 0; i < keySystems.length; i++) {\n            if (keySystems[i].systemString && keySystems[i].systemString.indexOf('widevine') !== -1) {\n                ksWidevine = keySystems[i];\n                break;\n            }\n        }\n\n        var contentProtection = {};\n        if (ksWidevine) {\n            contentProtection.schemeIdUri = ksWidevine.schemeIdURI;\n            contentProtection.value = ksWidevine.systemString;\n        }\n\n        return contentProtection;\n    }\n\n    function processManifest(xmlDoc, manifestLoadedTime) {\n        let manifest = {};\n        let contentProtections = [];\n        let smoothStreamingMedia = xmlDoc.getElementsByTagName('SmoothStreamingMedia')[0];\n        let protection = xmlDoc.getElementsByTagName('Protection')[0];\n        let protectionHeader = null;\n        let period,\n            adaptations,\n            contentProtection,\n            KID,\n            timestampOffset,\n            startTime,\n            segments,\n            i, j;\n\n        // Set manifest node properties\n        manifest.protocol = 'MSS';\n        manifest.profiles = 'urn:mpeg:dash:profile:isoff-live:2011';\n        manifest.type = smoothStreamingMedia.getAttribute('IsLive') === 'TRUE' ? 'dynamic' : 'static';\n        manifest.timeShiftBufferDepth = parseFloat(smoothStreamingMedia.getAttribute('DVRWindowLength')) / TIME_SCALE_100_NANOSECOND_UNIT;\n        manifest.mediaPresentationDuration = (parseFloat(smoothStreamingMedia.getAttribute('Duration')) === 0) ? Infinity : parseFloat(smoothStreamingMedia.getAttribute('Duration')) / TIME_SCALE_100_NANOSECOND_UNIT;\n        manifest.minBufferTime = mediaPlayerModel.getStableBufferTime();\n        manifest.ttmlTimeIsRelative = true;\n\n        // In case of live streams, set availabilityStartTime property according to DVRWindowLength\n        if (manifest.type === 'dynamic') {\n            manifest.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (manifest.timeShiftBufferDepth * 1000));\n            manifest.refreshManifestOnSwitchTrack = true;\n            manifest.doNotUpdateDVRWindowOnBufferUpdated = true; // done by Mss fragment processor\n            manifest.ignorePostponeTimePeriod = true; // in Mss, manifest is never updated\n        }\n\n        // Map period node to manifest root node\n        manifest.Period = mapPeriod(smoothStreamingMedia);\n        manifest.Period_asArray = [manifest.Period];\n\n        // Initialize period start time\n        period = manifest.Period;\n        period.start = 0;\n\n        // ContentProtection node\n        if (protection !== undefined) {\n            protectionHeader = xmlDoc.getElementsByTagName('ProtectionHeader')[0];\n\n            // Some packagers put newlines into the ProtectionHeader base64 string, which is not good\n            // because this cannot be correctly parsed. Let's just filter out any newlines found in there.\n            protectionHeader.firstChild.data = protectionHeader.firstChild.data.replace(/\\n|\\r/g, '');\n\n            // Get KID (in CENC format) from protection header\n            KID = getKIDFromProtectionHeader(protectionHeader);\n\n            // Create ContentProtection for PlayReady\n            contentProtection = createPRContentProtection(protectionHeader);\n            contentProtection['cenc:default_KID'] = KID;\n            contentProtections.push(contentProtection);\n\n            // Create ContentProtection for Widevine (as a CENC protection)\n            contentProtection = createWidevineContentProtection(protectionHeader);\n            contentProtection['cenc:default_KID'] = KID;\n            contentProtections.push(contentProtection);\n\n            manifest.ContentProtection = contentProtections;\n            manifest.ContentProtection_asArray = contentProtections;\n        }\n\n        adaptations = period.AdaptationSet_asArray;\n\n        for (i = 0; i < adaptations.length; i += 1) {\n            adaptations[i].SegmentTemplate.initialization = '$Bandwidth$';\n            // Propagate content protection information into each adaptation\n            if (manifest.ContentProtection !== undefined) {\n                adaptations[i].ContentProtection = manifest.ContentProtection;\n                adaptations[i].ContentProtection_asArray = manifest.ContentProtection_asArray;\n            }\n\n            if (manifest.type === 'dynamic') {\n                // Match timeShiftBufferDepth to video segment timeline duration\n                if (manifest.timeShiftBufferDepth > 0 &&\n                    adaptations[i].contentType === 'video' &&\n                    manifest.timeShiftBufferDepth > adaptations[i].SegmentTemplate.SegmentTimeline.duration) {\n                    manifest.timeShiftBufferDepth = adaptations[i].SegmentTemplate.SegmentTimeline.duration;\n                }\n            }\n        }\n\n        if (manifest.timeShiftBufferDepth < manifest.minBufferTime) {\n            manifest.minBufferTime = manifest.timeShiftBufferDepth;\n        }\n\n        // Delete Content Protection under root manifest node\n        delete manifest.ContentProtection;\n        delete manifest.ContentProtection_asArray;\n\n        // In case of VOD streams, check if start time is greater than 0\n        // Then determine timestamp offset according to higher audio/video start time\n        // (use case = live stream delinearization)\n        if (manifest.type === 'static') {\n            for (i = 0; i < adaptations.length; i++) {\n                if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                    segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                    startTime = segments[0].t;\n                    if (!timestampOffset) {\n                        timestampOffset = startTime;\n                    }\n                    timestampOffset = Math.min(timestampOffset, startTime);\n                    // Correct content duration according to minimum adaptation's segments duration\n                    // in order to force <video> element sending 'ended' event\n                    manifest.mediaPresentationDuration = Math.min(manifest.mediaPresentationDuration, ((segments[segments.length - 1].t + segments[segments.length - 1].d) / TIME_SCALE_100_NANOSECOND_UNIT).toFixed(3));\n                }\n            }\n\n            // Patch segment templates timestamps and determine period start time (since audio/video should not be aligned to 0)\n            if (timestampOffset > 0) {\n                for (i = 0; i < adaptations.length; i++) {\n                    segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                    for (j = 0; j < segments.length; j++) {\n                        if (!segments[j].tManifest) {\n                            segments[j].tManifest = segments[j].t;\n                        }\n                        segments[j].t -= timestampOffset;\n                    }\n                    if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                        period.start = Math.max(segments[0].t, period.start);\n                    }\n                }\n                period.start /= TIME_SCALE_100_NANOSECOND_UNIT;\n            }\n        }\n\n        period.duration = manifest.mediaPresentationDuration;\n\n        return manifest;\n    }\n\n    function parseDOM(data) {\n\n        let xmlDoc = null;\n\n        if (window.DOMParser) {\n            try {\n                let parser = new window.DOMParser();\n\n                xmlDoc = parser.parseFromString(data, 'text/xml');\n                if (xmlDoc.getElementsByTagName('parsererror').length > 0) {\n                    throw new Error('Error parsing XML');\n                }\n            } catch (e) {\n                errorHandler.manifestError('parsing the manifest failed', 'parse', data, e);\n                xmlDoc = null;\n            }\n        }\n\n        return xmlDoc;\n    }\n\n    function getMatchers() {\n        return null;\n    }\n\n    function getIron() {\n        return null;\n    }\n\n    function internalParse(data) {\n        let xmlDoc = null;\n        let manifest = null;\n\n        const startTime = window.performance.now();\n\n        // Parse the MSS XML manifest\n        xmlDoc = parseDOM(data);\n\n        const xmlParseTime = window.performance.now();\n\n        if (xmlDoc === null) {\n            return null;\n        }\n\n        // Convert MSS manifest into DASH manifest\n        manifest = processManifest(xmlDoc, new Date());\n\n        const mss2dashTime = window.performance.now();\n\n        log('Parsing complete: (xmlParsing: ' + (xmlParseTime - startTime).toPrecision(3) + 'ms, mss2dash: ' + (mss2dashTime - xmlParseTime).toPrecision(3) + 'ms, total: ' + ((mss2dashTime - startTime) / 1000).toPrecision(3) + 's)');\n\n        return manifest;\n    }\n\n    instance = {\n        parse: internalParse,\n        getMatchers: getMatchers,\n        getIron: getIron\n    };\n\n    setup();\n\n    return instance;\n}\n\nMssParser.__dashjs_factory_name = 'MssParser';\nexport default dashjs.FactoryMaker.getClassFactory(MssParser); /* jshint ignore:line */\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @class\n * @ignore\n */\nclass DataChunk {\n    //Represents a data structure that keep all the necessary info about a single init/media segment\n    constructor() {\n        this.streamId = null;\n        this.mediaInfo = null;\n        this.segmentType = null;\n        this.quality = NaN;\n        this.index = NaN;\n        this.bytes = null;\n        this.start = NaN;\n        this.end = NaN;\n        this.duration = NaN;\n        this.representationId = null;\n    }\n}\n\nexport default DataChunk;","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * @class\n * @ignore\n */\nclass FragmentRequest {\n    constructor() {\n        this.action = FragmentRequest.ACTION_DOWNLOAD;\n        this.startTime = NaN;\n        this.mediaType = null;\n        this.mediaInfo = null;\n        this.type = null;\n        this.duration = NaN;\n        this.timescale = NaN;\n        this.range = null;\n        this.url = null;\n        this.serviceLocation = null;\n        this.requestStartDate = null;\n        this.firstByteDate = null;\n        this.requestEndDate = null;\n        this.quality = NaN;\n        this.index = NaN;\n        this.availabilityStartTime = null;\n        this.availabilityEndTime = null;\n        this.wallStartTime = null;\n        this.bytesLoaded = NaN;\n        this.bytesTotal = NaN;\n        this.delayLoadingTime = NaN;\n        this.responseType = 'arraybuffer';\n        this.representationId = null;\n    }\n}\n\nFragmentRequest.ACTION_DOWNLOAD = 'download';\nFragmentRequest.ACTION_COMPLETE = 'complete';\n\nexport default FragmentRequest;\n"]}