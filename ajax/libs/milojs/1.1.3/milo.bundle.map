{
  "version": 3,
  "sources": [
    "/Users/evgenypoberezkin/Work/CC/milo/lib/abstract/facet.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/abstract/faceted_object.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/abstract/registry.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/attributes/a_bind.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/attributes/a_class.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/attributes/a_load.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/attributes/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/binder.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/classes.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/command/actions_history.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/command/cmd_registry.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/command/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/command/transaction.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/command/transaction_history.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_class.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facet.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Container.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Css.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Data.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Dom.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Drag.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Drop.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Events.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Frame.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Item.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/List.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/ModelFacet.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Options.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Template.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/Transfer.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_facets/cf_registry.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_info.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_registry.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/c_utils.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/classes/View.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/msg_api/data.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/msg_api/de_data.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/msg_api/drop.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/msg_src/dom_events.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/msg_src/frame.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/components/scope.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/config.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/loader.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/milo.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/registry.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/services/de_constrs.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/services/dom_source.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/services/mail/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/services/mail/mail_api.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/services/mail/mail_source.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/services/window.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/use_facets.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/component_name.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/create_component_class.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/create_facet_class.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/deprecate.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/dom.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/dom_listeners.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/domready.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/dragdrop.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/error.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/fragment.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/json_parse.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/request.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/selection/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/storage/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/storage/model.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/storage/msg_src.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/unique_id.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/websocket/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/websocket/msg_api.js",
    "/Users/evgenypoberezkin/Work/CC/milo/lib/util/websocket/msg_src.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/base32/lib/base32.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/browserify/node_modules/browser-builtins/builtin/fs.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/abstract/mixin.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/classes.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/config.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/messenger/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/messenger/m_api.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/messenger/m_api_rx.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/messenger/m_source.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/messenger/msngr_source.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/milo-core.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/minder.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/change_data.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/connector.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/m_msg_api.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/m_path.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/model_utils.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/path_msg_api.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/path_utils.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/model/synthesize/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/util/check.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/util/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/util/logger.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/lib/util/logger_class.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/dot/doT.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/dot/index.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto_array.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto_function.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto_number.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto_object.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto_prototype.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto_string.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/proto_util.js",
    "/Users/evgenypoberezkin/Work/CC/milo/node_modules/milo-core/node_modules/mol-proto/lib/utils.js"
  ],
  "names": [],
  "mappings": ";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC35BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnMA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "'use strict';\n\n\nvar _ = require('milo-core').proto;\n\nmodule.exports = Facet;\n\n\n/**\n * `milo.classes.Facet`\n * Base Facet class is an ancestor of [ComponentFacet](../components/c_facet.js.html) class, the main building block in milo.\n * \n * @param {FacetedObject} owner an instance of FacetedObject subclass that stores the facet on its property  with the same name as `name` property of facet\n * @param {Object} config optional facet configuration, used in subclasses\n */\nfunction Facet(owner, config) {\n    this.name = _.firstLowerCase(this.constructor.name);\n    this.owner = owner;\n    this.config = config || {};\n    this.init.apply(this, arguments);\n}\n\n\n/**\n * `init` method of subclass will be called by Facet constructor.\n */\n_.extendProto(Facet, {\n    init: function() {}\n});\n",
    "'use strict';\n\n\nvar Facet = require('./facet')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger\n    , check = miloCore.util.check\n    , Match = check.Match;\n\nmodule.exports = FacetedObject;\n\n\n/**\n * `milo.classes.FacetedObject`\n * Component class is based on an abstract ```FacetedObject``` class. This class can be used in any situation where objects can be represented via collection of facets (a facet is an object of a certain class, it holds its own configuration, data and methods).\n * In a way, \"facets pattern\" is an inversion of \"adapter pattern\" - while the latter allows finding a class/methods that has specific functionality, faceted object is simply constructed to have these functionalities.\n * With this architecture it is possible to create a virtually unlimited number of component classes with a very limited number of building blocks without having any hierarchy of classes - all components inherit directly from Component class.\n *\n * This constructor should be called by all subclasses constructor (it will happen automatically if a subclass is created with `_.createSubclass`).\n *\n * @return {FacetedObject}\n */\nfunction FacetedObject() {\n    // this.facetsConfig and this.facetsClasses were stored on a specific class prototype\n    // when the class was created by FacetedObject.createFacetedClass\n    var facetsConfig = this.facetsConfig || {};\n\n    var facetsDescriptors = {}\n        , facets = {};\n\n    // FacetedObject class itself is not meant to be instantiated - it has no facets\n    // It may change, as adding facets is possible to instances\n    if (this.constructor == FacetedObject)      \n        throw new Error('FacetedObject is an abstract class, can\\'t be instantiated');\n\n    // instantiate class facets\n    if (this.facetsClasses)\n        _.eachKey(this.facetsClasses, instantiateFacet, this, true);\n\n    // add facets to the class as properties under their own name\n    Object.defineProperties(this, facetsDescriptors);\n\n    // store all facets on `facets` property so that they can be enumerated\n    _.defineProperty(this, 'facets', facets);   \n\n    // call `init`method if it is defined in subclass\n    if (this.init)\n        this.init.apply(this, arguments);\n\n    // instantiate facet with a given class (FacetClass) and name (facetName)\n    function instantiateFacet(FacetClass, facetName) {\n        // get facet configuration\n        var fctConfig = facetsConfig[facetName];\n\n        // instatiate facets\n        facets[facetName] = new FacetClass(this, fctConfig);\n\n        // add facet to property descriptors\n        facetsDescriptors[facetName] = {\n            enumerable: true,\n            value: facets[facetName]\n        };\n    }\n}\n\n\n/**\n * ####FacetedObject class methods####\n *\n * - [createFacetedClass](#FacetedObject$$createFacetedClass)\n * - [hasFacet](#FacetedObject$$hasFacet)\n */\n_.extend(FacetedObject, {\n    createFacetedClass: FacetedObject$$createFacetedClass,\n    hasFacet: FacetedObject$$hasFacet,\n    getFacetConfig: FacetedObject$$getFacetConfig\n});\n\n\n/**\n * ####FacetedObject instance methods####\n *\n * - [addFacet](#FacetedObject$addFacet)\n */\n_.extendProto(FacetedObject, {\n    addFacet: FacetedObject$addFacet\n});\n\n\n/**\n * FacetedObject instance method.\n * Adds a facet to the instance of FacetedObject subclass.\n * Returns an instance of the facet that was created.\n *\n * @param {Function} FacetClass facet class constructor\n * @param {Object} facetConfig optional facet configuration\n * @param {String} facetName optional facet name, FacetClass.name will be used if facetName is not passed.\n * @param {Boolean} throwOnErrors If set to false, then errors will only be logged to console. True by default.\n * @return {Facet}\n */\nfunction FacetedObject$addFacet(FacetClass, facetConfig, facetName, throwOnErrors) {\n    check(FacetClass, Function);\n    check(facetName, Match.Optional(String));\n\n    // first letter of facet name should be lowercase\n    facetName = _.firstLowerCase(facetName || FacetClass.name);\n\n    // get facets defined in class\n    var protoFacets = this.constructor.prototype.facetsClasses;\n\n    // check that this facetName was not already used in the class\n    if (protoFacets && protoFacets[facetName])\n        throw new Error('facet ' + facetName + ' is already part of the class ' + this.constructor.name);\n\n    // check that this faceName does not already exist on the faceted object\n    if (this[facetName]) {\n        var message = 'facet ' + facetName + ' is already present in object';\n        if (throwOnErrors === false)\n            return logger.error('FacetedObject addFacet: ', message);\n        else\n            throw new Error(message);\n    }\n\n    // instantiate the facet\n    var newFacet = this.facets[facetName] = new FacetClass(this, facetConfig);\n\n    // add facet to faceted object\n    _.defineProperty(this, facetName, newFacet, _.ENUM);\n\n    return newFacet;\n}\n\n\n/**\n * FacetedObject class method\n * Returns reference to the facet class if the facet with `facetName` is part of the class, `undefined` otherwise. If subclass is created using _.createSubclass (as it should be) it will also have this method.\n * \n * @param {Subclass(FacetedObject)} this this in this method refers to FacetedObject (or its subclass) that calls this method\n * @param {String} facetName\n * @return {Subclass(Facet)|undefined} \n */\nfunction FacetedObject$$hasFacet(facetName) {\n    // this refers to the FacetedObject class (or subclass), not instance\n    var protoFacets = this.prototype.facetsClasses;\n    return protoFacets && protoFacets[facetName];\n}\n\n/**\n * FacetedObject class method\n * Return the configuration of a facet\n * @param {String} facetName the facet which config should be retrieved\n * @return {Object} the configuration object that was passed to the facet\n */\nfunction FacetedObject$$getFacetConfig(facetName) {\n    return this.hasFacet(facetName) ? this.prototype.facetsConfig[facetName] : null;\n}\n\n\n/**\n * FacetedObject class method\n * Class factory that creates classes (constructor functions) from the maps of facets and their configurations.\n * Created class will be subclass of `FacetedObject`.\n *\n * @param {Subclass(FacetedObject)} this this in this method refers to FacetedObject (or its subclass) that calls this method\n * @param {String} name class name (will be function name of class constructor function)\n * @param {Object[Subclass(Facet)]} facetsClasses map of classes of facets that will constitute the created class\n * @param {Object<Object>} facetsConfig map of facets configuration, should have the same keys as the map of classes. Some facets may not have configuration, but the configuration for a facet that is not included in facetsClasses will throw an exception\n * @return {Subclass(FacetedObject)}\n */\nfunction FacetedObject$$createFacetedClass(name, facetsClasses, facetsConfig) {\n    check(name, String);\n    check(facetsClasses, Match.Optional(Match.ObjectHash(Match.Subclass(Facet, true))));\n    check(facetsConfig, Match.Optional(Object));\n\n    // throw exception if config passed for facet for which there is no class\n    if (facetsConfig)\n        _.eachKey(facetsConfig, function(fctConfig, fctName) {\n            if (! facetsClasses.hasOwnProperty(fctName))\n                throw new Error('configuration for facet (' + fctName + ') passed that is not in class');\n        });\n\n    // create subclass of the current class (this refers to the class that calls this method)\n    var FacetedClass = _.createSubclass(this, name, true);\n\n    // get facets classes and configurations from parent class\n    facetsClasses = addInheritedFacets(this, facetsClasses, 'facetsClasses');\n    facetsConfig = addInheritedFacets(this, facetsConfig, 'facetsConfig');\n\n    // store facets classes and configurations of class prototype\n    _.extendProto(FacetedClass, {\n        facetsClasses: facetsClasses,\n        facetsConfig: facetsConfig\n    });\n\n    return FacetedClass;\n\n\n    function addInheritedFacets(superClass, facetsInfo, facetsInfoName) {\n        var inheritedFacetsInfo = superClass.prototype[facetsInfoName];\n        if (inheritedFacetsInfo)\n            return _(inheritedFacetsInfo)\n                    .clone()\n                    .extend(facetsInfo || {})._();\n        else\n            return facetsInfo;\n    }\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\nmodule.exports = ClassRegistry;\n\n\n/**\n * `milo.classes.ClassRegistry` - the registry of classes class.\n * Components and Facets register themselves in registries. It allows to avoid requiring them from one module and prevents circular dependencies between modules.\n * \n * @param {Function} FoundationClass All classes that are registered in the registry should be subclasses of the FoundationClass\n * @return {Object}\n */\nfunction ClassRegistry (FoundationClass) {\n    if (FoundationClass)\n        this.setClass(FoundationClass);\n\n    this.__registeredClasses = {};\n}\n\n\n/**\n * ####ClassRegistry instance methods####\n *\n * - [add](#add)\n * - [get](#get)\n * - [remove](#remove)\n * - [clean](#clean)\n * - [setClass](#setClass)\n */\n_.extendProto(ClassRegistry, {\n    add: add,\n    get: get,\n    remove: remove,\n    clean: clean,\n    setClass: setClass\n});\n\n\n/**\n * ClassRegistry instance method that registers a class in the registry.\n * The method will throw an exception if a class is registered under the same name as previously registered class.\n * The method allows registering the same class under a different name, so class aliases can be created.\n *\n * @param {Function} aClass class to register in the registry. Should be subclass of `this.FoundationClass`.\n * @param {String} name Optional class name. If class name is not specified, it will be taken from constructor function name. Class name should be a valid identifier and cannot be an empty string.\n */\nfunction add(aClass, name) {\n    name = name || aClass.name;\n\n    check(name, Match.IdentifierString, 'class name must be identifier string');\n\n    if (this.FoundationClass) {\n        if (aClass != this.FoundationClass)\n            check(aClass, Match.Subclass(this.FoundationClass), 'class must be a sub(class) of a foundation class');\n    } else\n        throw new Error('foundation class must be set before adding classes to registry');\n\n    if (this.__registeredClasses[name])\n        throw new Error('class \"' + name + '\" is already registered');\n\n    this.__registeredClasses[name] = aClass;\n}\n\n\n/**\n * Gets class from registry by name\n *\n * @param {String} name Class name\n * @return {Function}\n */\nfunction get(name) {\n    check(name, String, 'class name must be string');\n    return this.__registeredClasses[name];\n}\n\n\n/**\n * Remove class from registry by its name.\n * If class is not registered, this method will throw an exception.\n * \n * @param {String|Function} nameOrClass Class name. If class constructor is supplied, its name will be used.\n */\nfunction remove(nameOrClass) {\n    check(nameOrClass, Match.OneOf(String, Function), 'class or name must be supplied');\n\n    var name = typeof nameOrClass == 'string'\n                        ? nameOrClass\n                        : nameOrClass.name;\n                        \n    if (! this.__registeredClasses[name])\n        throw new Error('class is not registered');\n\n    delete this.__registeredClasses[name];\n}\n\n\n/**\n * Removes all classes from registry.\n */\nfunction clean() {\n    this.__registeredClasses = {};\n}\n\n\n/**\n * Sets `FoundationClass` of the registry. It should be set before any class can be added.\n *\n * @param {Function} FoundationClass Any class that will be added to the registry should be a subclass of this class. FoundationClass itself can be added to the registry too.\n */\nfunction setClass(FoundationClass) {\n    check(FoundationClass, Function);\n    _.defineProperty(this, 'FoundationClass', FoundationClass, _.ENUM);\n}\n",
    "'use strict';\n\nvar Attribute = require('./a_class')\n    , config = require('../config')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match\n    , componentName = require('../util/component_name');\n\n\nvar ATTRIBUTE_REGEXP= /^([^\\:\\[\\]]*)(?:\\[([^\\:\\[\\]]*)\\])?\\:?([^:]*)$/\n    , FACETS_SPLIT_REGEXP = /\\s*(?:\\,|\\s)\\s*/\n    , ATTRIBUTE_TEMPLATE = '%compClass%compFacets:%compName';\n\n\n/**\n * `milo.attributes.bind`\n * BindAttribute class parses/validates/etc. an attribute that binds DOM elements to milo components.\n * Possible attribute values are:\n *\n * - `:myView` - only component name\n * - `View:myView` - class and component name\n * - `[Events, Data]:myView` - facets and component name\n * - `View[Events]:myView` - class, facet(s) and component name\n *\n * See [binder](../binder.js.html) for more information.\n */\nvar BindAttribute = _.createSubclass(Attribute, 'BindAttribute', true);\n\n\n/**\n * ####BindAttribute instance methods####\n *\n * - [attrName](#attrName)\n * - [parse](#parse)\n * - [validate](#validate)\n * - [render](#render)\n */\n_.extendProto(BindAttribute, {\n    attrName: attrName,\n    parse: parse,\n    validate: validate,\n    render: render\n});\n\n\n/**\n * BindAttribute class methods\n *\n * - [setInfo](#BindAttribute$$setInfo)\n */\n_.extend(BindAttribute, {\n    setInfo: BindAttribute$$setInfo\n});\n\n\nmodule.exports = BindAttribute;\n\n\n/**\n * BindAttribute instance method that returns attribute name, by default - `'ml-bind'`.\n * To configure bind attribute name use:\n * ```\n * milo.config({ attrs: { bind: 'cc-bind' } }); // will set bind attribute to 'cc-bind'\n * ```\n *\n * @return {String}\n */\nfunction attrName() {\n    return config.attrs.bind;\n}\n\n\n/**\n * BindAttribute instance method that parses bind attribute if it is present on the element.\n * It defines properties `compClass`, `compFacets` and `compName` on BindAttribute instance.\n * Returns the instance for method chaining.\n *\n * @return {BindAttribute}\n */\n function parse() {\n    if (! this.node) return;\n\n    var value = this.get();\n\n    if (value)\n        var bindTo = value.match(ATTRIBUTE_REGEXP);\n\n    if (! bindTo)\n        throw new Error('invalid bind attribute ' + value);\n\n    this.compClass = bindTo[1] || 'Component';\n    this.compFacets = (bindTo[2] && bindTo[2].split(FACETS_SPLIT_REGEXP)) || undefined;\n    this.compName = bindTo[3] || componentName();\n\n    return this;\n}\n\n\n/**\n * BindAttribute instance method that validates bind attribute, throws if it has an invalid value.\n * Returns the instance for method chaining.\n *\n * @return {BindAttribute}\n */\nfunction validate() {\n    check(this.compName, Match.IdentifierString);\n\n    if (! this.compClass)\n        throw new Error('empty component class name ' + this.compClass);\n\n    return this;\n}\n\n\n/**\n * BindAttribute instance method that returns the attribute value for given values of properties `compClass`, `compName` and `compFacets`.\n * If `this.compName` is not set it will be generated automatically.\n *\n * @return {String}\n */\nfunction render() {\n    this.compName = this.compName || componentName();\n    return ATTRIBUTE_TEMPLATE\n                .replace('%compClass', this.compClass || '')\n                .replace('%compFacets', this.compFacets && this.compFacets.length\n                                            ? '[' + this.compFacets.join(', ') + ']'\n                                            : '')\n                .replace('%compName', this.compName);\n}\n\n\n/**\n * BindAttribute class method\n * @param {Element} el\n * @param {String} componentClass optional class name\n * @param {String} componentName optional\n * @param {Array<String>} componentFacets optional extra facet to add to the class\n */\nfunction BindAttribute$$setInfo(el, componentClass, componentName, componentFacets) {\n    var attr = new BindAttribute(el);\n    _.extend(attr, {\n        compClass: componentClass,\n        compName: componentName,\n        compFacets: componentFacets\n    });\n    attr.decorate();\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\n\nmodule.exports = Attribute;\n\n\n/**\n * An absctract class for parsing and validation of element attributes.\n * Subclasses should define methods `attrName`, `parse`, `validate` and `render`.\n *\n * @param {Element} el DOM element where attribute is attached\n * @param {String} name Optional name of the attribute, usually supplied by subclass via `attrName` method\n */\nfunction Attribute(el, name) {\n    this.name = name || this.attrName();\n    this.el = el;\n\n    // attribute node\n    this.node = el.attributes[this.name];\n}\n\n\n_.extend(Attribute, {\n    remove: Attribute$$remove\n});\n\n\n/**\n * ####Attribute instance methods####\n *\n * - [get](#Attribute$get)\n * - [set](#Attribute$set)\n * - [decorate](#Attribute$decorate)\n *\n * The following instance methods should be defined by subclass\n *\n * - attrName - should return attribute name\n * - parse - should parse attribute value\n * - validate - should validate attribute value, throwing exception if it is incorrect \n * - render - should return attribute value for a given attribute state (other properties, as defined in subclass)\n */\n_.extendProto(Attribute, {\n    get: Attribute$get,\n    set: Attribute$set,\n    remove: Attribute$remove,\n    decorate: Attribute$decorate,\n\n    destroy: Attribute$destroy,\n\n    // should be defined in subclass\n    attrName: toBeImplemented,\n    parse: toBeImplemented,\n    validate: toBeImplemented,\n    render: toBeImplemented\n});\n\n\nfunction Attribute$$remove(el, deep) {\n    var name = this.prototype.attrName();\n    el.removeAttribute(name);\n\n    if (deep) {\n        var selector = '[' + name + ']';\n        var children = el.querySelectorAll(selector);\n        _.forEach(children, function(childEl) {\n            childEl.removeAttribute(name);\n        });\n    }\n}\n\n\nfunction Attribute$remove() {\n    delete this.node;\n}\n\n\nfunction Attribute$destroy() {\n    delete this.el;\n    delete this.node;\n}\n\n/**\n * Attribute instance method that returns attribute value as string.\n *\n * @return {String}\n */\nfunction Attribute$get() {\n    return this.el.getAttribute(this.name);\n}\n\n\n/**\n * Attribute instance method that sets attribute value.\n *\n * @param {String} value\n */\nfunction Attribute$set(value) {\n    this.el.setAttribute(this.name, value);\n}\n\n\n/**\n * Attribute instance method that decorates element with its rendered value.\n * Uses `render` method that should be defiend in subclass.\n */\nfunction Attribute$decorate() {\n    this.set(this.render());\n}\n\n\nfunction toBeImplemented() {\n    throw new Error('calling the method of an absctract class');\n}\n",
    "'use strict';\n\nvar Attribute = require('./a_class')\n    , config = require('../config')\n    , _ = require('milo-core').proto;\n\n\n/**\n * `milo.attributes.load`\n * LoadAttribute class parses/validates/etc. an attribute that loads sub-views into the page.\n * Attribute value should be URL of the file to load subview from.\n * See [loader](../loader.js.html) for more information.\n */\nvar LoadAttribute = _.createSubclass(Attribute, 'LoadAttribute', true);\n\n\n/**\n * ####LoadAttribute instance methods####\n *\n * - [attrName](#attrName)\n * - [parse](#parse)\n * - [validate](#validate)\n * - [render](#render)\n */\n_.extendProto(LoadAttribute, {\n    attrName: attrName,\n    parse: parse,\n    validate: validate,\n    render: render\n});\n\nmodule.exports = LoadAttribute;\n\n\n/**\n * BindAttribute instance method that returns attribute name, by default - `'ml-load'`.\n * To configure load attribute name use:\n * ```\n * milo.config({ attrs: { load: 'cc-load' } }); // will set bind attribute to 'cc-load'\n * ```\n *\n * @return {String}\n */\nfunction attrName() {\n    return config.attrs.load;\n}\n\n\n/**\n * LoadAttribute instance method that parses load attribute if it is present on the element.\n * It defines property `loadUrl` on LoadAttribute instance.\n * Returns the instance for method chaining.\n *\n * @return {LoadAttribute}\n */\nfunction parse() {\n    if (! this.node) return;\n\n    this.loadUrl = this.get();\n    return this;\n}\n\n\n/**\n * LoadAttribute instance method that should validate load attribute and throw if it has an invalid value.\n * TODO - implement url validation.\n * Returns the instance for method chaining.\n *\n * @return {LoadAttribute}\n */\nfunction validate() {\n    // TODO url validation\n    return this;\n}\n\n\n/**\n * LoadAttribute instance method - returns URL\n *\n * @return {String}\n */\nfunction render() {\n    return this.loadUrl;\n}\n",
    "'use strict';\n\n/**\n * Subclasses of [Attribute](./a_class.js.html) class\n *\n * - [BindAttribute](./a_bind.js.html)\n * - [LoadAttribute](./a_load.js.html)\n */\nvar attributes = module.exports = {\n    bind: require('./a_bind'),\n    load: require('./a_load')\n};\n",
    "'use strict';\n\nvar miloMail = require('./services/mail')\n    , componentsRegistry = require('./components/c_registry')\n    , facetsRegistry = require('./components/c_facets/cf_registry')\n    , Component = componentsRegistry.get('Component')\n    , ComponentInfo = require('./components/c_info')\n    , Scope = require('./components/scope')\n    , BindAttribute = require('./attributes/a_bind')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , utilDom = require('./util/dom')\n    , Match =  check.Match;\n\n\nbinder.scan = scan;\nbinder.create = create;\nbinder.twoPass = twoPass;\n\n\nmodule.exports = binder;\n\n\n/**\n * `milo.binder`\n *\n * Recursively scans the document tree inside `scopeEl` (document.body by default) looking for __ml-bind__ attribute that should contain the class, additional facets and the name of the component that should be created and bound to the element.\n *\n * Possible values of __ml-bind__ attribute:\n *\n * - `:myView` - only component name. An instance of Component class will be created without any facets.\n * - `View:myView` - class and component name. An instance of View class will be created.\n * - `[Events, Data]:myView` - facets and component name. An instance of Component class will be created with the addition of facets Events and Data.\n * - `View[Events, Data]:myView` - class, facet(s) and component name. An instance of View class will be created with the addition of facets Events and Data.\n *\n * Function returns an instance of [`Scope`](./components/scope.js.html) class containing all components created as a result of scanning DOM.\n *\n * If the component has [`Container`](./components/c_facets/Container.js) facet, children of this element will be stored in the `scope` object, available as scope property on the Container facet of this component. Names of components within the scope should be unique, but they can be the same as the names of components in outer scope (or some other scope).\n *\n * @param {Element} scopeEl root element inside which DOM will be scanned and bound\n * @param {Scope} rootScope Optional Root scope object where top level components will be saved.\n * @param {Boolean} bindRootElement If set to false, then the root element will not be bound. True by default.\n * @param {Boolean} throwOnErrors If set to false, then errors will only be logged to console. True by default.\n * @return {Scope}\n */\nfunction binder(scopeEl, rootScope, bindRootElement, throwOnErrors) {\n    return createBinderScope(scopeEl, function(scope, el, attr, throwOnErrors) {\n        var info = new ComponentInfo(scope, el, attr, throwOnErrors);\n        return Component.create(info, throwOnErrors);\n    }, rootScope, bindRootElement, throwOnErrors);\n}\n\n\n// bind in two passes\nfunction twoPass(scopeEl, rootScope, bindRootElement, throwOnErrors) {\n    var scanScope = binder.scan(scopeEl, rootScope, bindRootElement, throwOnErrors);\n    return binder.create(scanScope, undefined, throwOnErrors);\n}\n\n\n// scan DOM for BindAttribute\nfunction scan(scopeEl, rootScope, bindRootElement, throwOnErrors) {\n    return createBinderScope(scopeEl, function(scope, el, attr, throwOnErrors) {\n        return new ComponentInfo(scope, el, attr, throwOnErrors);\n    }, rootScope, bindRootElement, throwOnErrors);\n}\n\n\n// create bound components\nfunction create(scanScope, hostObject, throwOnErrors) {\n    var scope = new Scope(scanScope._rootEl, hostObject)\n        , addMethod = throwOnErrors === false ? '_safeAdd' : '_add';\n\n    scanScope._each(function(compInfo) {\n        // set correct component's scope\n        var info = _.clone(compInfo);\n        info.scope = scope;\n\n        // create component\n        var aComponent = Component.create(info, throwOnErrors);\n\n        scope[addMethod](aComponent, aComponent.name);\n        if (aComponent.container)\n            aComponent.container.scope = create(compInfo.container.scope, aComponent.container, throwOnErrors);\n    });\n\n    return scope;\n}\n\n/**\n * `createBinderScope`\n * @param  {Element} scopeEl             scopeEl root element inside which DOM will be scanned and bound (document.body by default).\n * @param  {Function} scopeObjectFactory See [binder](#milo.binder)\n * @param  {Scope} rootScope             Optional Root scope object where top level components will be saved.\n * @param  {Boolean} bindRootElement     If set to false, then the root element will not be bound. True by default.\n * @param  {Boolean} throwOnErrors       If set to false, then errors will only be logged to console. True by default.\n * @return {Scope}                       [description]\n */\nfunction createBinderScope(scopeEl, scopeObjectFactory, rootScope, bindRootElement, throwOnErrors) {\n    scopeEl = scopeEl || document.body;\n    var scope = rootScope || new Scope(scopeEl)\n        , addMethod = throwOnErrors === false ? '_safeAdd' : '_add';\n\n    createScopeForElement(scope, scopeEl, bindRootElement);\n\n    return scope;\n\n\n    function createScopeForElement(scope, el, bindRootElement) {\n        // get element's binding attribute (ml-bind by default)\n        var attr = new BindAttribute(el);\n\n        // if element has bind attribute crate scope object (Component or ComponentInfo)\n        if (attr.node && bindRootElement !== false) {\n            var scopedObject = scopeObjectFactory(scope, el, attr, throwOnErrors)\n                , isContainer = typeof scopedObject != 'undefined' && scopedObject.container;\n        }\n\n        // if there are childNodes add children to new scope if this element has component with Container facet\n        // otherwise create a new scope\n        if (el.childNodes && el.childNodes.length) {\n            if (isContainer) {\n                var innerScope = new Scope(el);\n                scopedObject.container.scope = innerScope;\n                innerScope._hostObject = scopedObject.container;\n            }\n\n            createScopeForChildren(el, isContainer ? innerScope : scope);\n        }\n\n        // if scope wasn't previously created on container facet, create empty scope anyway\n        if (isContainer && ! scopedObject.container.scope)\n            scopedObject.container.scope = new Scope(el);\n\n\n        // TODO condition after && is a hack, should not be used!\n        if (scopedObject) // && ! scope[attr.compName])\n            scope[addMethod](scopedObject, attr.compName);\n\n        // _.defer(postChildrenBoundMessage, el);\n        postChildrenBoundMessage(el);\n\n        return scopedObject;\n\n\n        function postChildrenBoundMessage(el) {\n            var elComp = Component.getComponent(el);\n\n            if (elComp)\n                elComp.postMessageSync('childrenbound');\n        }\n    }\n\n\n    function createScopeForChildren(containerEl, scope) {\n        var children = utilDom.children(containerEl);\n\n        _.forEach(children, function(node) {\n            createScopeForElement(scope, node, true);\n        });\n        return scope;\n    }\n}\n",
    "'use strict';\n\nvar coreClasses = require('milo-core').classes;\n\n// <a name=\"classes\"></a>\n// milo.classes\n// -----------\n\n// This module contains foundation classes and class registries.\n\nvar classes = {\n    Facet: require('./abstract/facet'),\n    FacetedObject: require('./abstract/faceted_object'),\n    Scope: require('./components/scope'),\n    ClassRegistry: require('./abstract/registry'),\n    Mixin: coreClasses.Mixin,\n    MessageSource: coreClasses.MessageSource,\n    MessengerMessageSource: coreClasses.MessengerMessageSource,\n    MessengerAPI: coreClasses.MessengerAPI,\n    DOMEventsSource: require('./components/msg_src/dom_events'),\n    Transaction: require('./command/transaction'),\n    TransactionHistory: require('./command/transaction_history')\n};\n\nmodule.exports = classes;\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger;\n\n\nmodule.exports = ActionsHistory;\n\n\n/**\n * Stores list of commands or transactions\n *\n * @constructor\n * @param {Number} maxLength\n */\nfunction ActionsHistory(maxLength) {\n    this._maxLength = maxLength || Infinity;\n    this.actions = [];\n    this.position = 0;\n}\n\n\n_.extendProto(ActionsHistory, {\n    store: ActionsHistory$store,\n    deleteLast: ActionsHistory$deleteLast,\n    undo: ActionsHistory$undo,\n    redo: ActionsHistory$redo,\n    undoAll: ActionsHistory$undoAll,\n    redoAll: ActionsHistory$redoAll,\n    undoAllAsync: ActionsHistory$undoAllAsync,\n    redoAllAsync: ActionsHistory$redoAllAsync,\n    each: ActionsHistory$each,\n    eachReverse: ActionsHistory$eachReverse,\n    getLastAction: ActionsHistory$getLastAction,\n\n    getDescription: ActionsHistory$getDescription\n});\n\n\nfunction ActionsHistory$store(command) {\n    _truncateToCurrentPosition.call(this);\n    this.actions.push(command);\n\n    if (this.actions.length > this._maxLength) {\n        var act = this.actions.shift();\n        act.destroy();\n    }\n\n    this.position = this.actions.length;\n    return this.position - 1;\n}\n\n\nfunction ActionsHistory$deleteLast() {\n    if (!this.actions.length) return;\n    this.position--;\n    this.actions.length--;\n}\n\n\nfunction _truncateToCurrentPosition() {\n    for (var i = this.position; i < this.actions.length; i++)\n        this.actions[i].destroy();\n    this.actions.length = this.position;\n}\n\n\nfunction ActionsHistory$undo(cb) {\n    if (this.position === 0) return; // nothing to undo\n    var act = this.actions[--this.position];\n    act.undo(cb);\n    return act;\n}\n\n\nfunction ActionsHistory$redo(cb) {\n    if (this.position == this.actions.length) return; // nothing to redo\n    var act = this.actions[this.position++];\n    act.redo(cb);\n    return act;\n}\n\n\nfunction ActionsHistory$undoAll() {\n    while (this.position) this.undo();\n}\n\n\nfunction ActionsHistory$redoAll() {\n    while (this.position < this.actions.length) this.redo();\n}\n\n\nfunction ActionsHistory$undoAllAsync(cb) {\n    if (this.position) {\n        this.undo();\n        if (this.position)\n            _.deferMethod(this, 'undoAllAsync', cb);\n        else\n            if (cb) _.defer(cb);\n    }\n}\n\n\nfunction ActionsHistory$redoAllAsync(cb) {\n    if (this.position < this.actions.length) {\n        this.redo();\n        if (this.position < this.actions.length) \n            _.deferMethod(this, 'redoAllAsync', cb);\n        else\n            if (cb) _.defer(cb);\n    }\n}\n\n\nfunction ActionsHistory$each(funcOrMethod, thisArg) {\n    var func = typeof funcOrMethod == 'string'\n                ? function(act) { act[funcOrMethod](); }\n                : funcOrMethod;\n\n    this.actions.forEach(func, thisArg || this);\n}\n\n\nfunction ActionsHistory$eachReverse(funcOrMethod, thisArg) {\n    this.actions.reverse();\n    this.each(funcOrMethod, thisArg);\n    this.actions.reverse();\n}\n\n\nfunction ActionsHistory$getLastAction() {\n    return this.position && this.actions[this.position - 1];\n}\n\n\nfunction ActionsHistory$getDescription() {\n    var actions = this.actions.map(function(act) {\n        return act.getDescription();\n    });\n    return {\n        actions: actions,\n        position: this.position,\n        length: actions.length\n    };\n}\n",
    "'use strict';\n\nvar ClassRegistry = require('../abstract/registry')\n    , Command = require('./index');\n\n/**\n * `milo.registry.components`\n * An instance of [ClassRegistry](../abstract/registry.js.html) class that is used by milo to register and find components.\n */\nvar commandsRegistry = new ClassRegistry(Command);\n\n// add common ancestor to all components to the registry.\ncommandsRegistry.add(Command);\n\nmodule.exports = commandsRegistry;\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match\n    , logger = miloCore.util.logger;\n\n\nvar UNDO_COMMAND = '_undoCommand';\n\n\nmodule.exports = Command;\n\n\n/**\n * Command class to implement \"command pattern\" - packaging ll information necessary for delayed method execution\n *\n * @constructor\n * @param {Function} func method name or function to be executed\n * @param {List} *arguments parameters to be passed to method or function\n */\nfunction Command(func) { // , ... arguments\n    this.init.apply(this, arguments);\n}\n\n\n/**\n * Command instance methods\n * \n * - [init](#Command$execute) - initialize command, should be overwritten by subclasses\n * - [execute](#Command$execute) - execute command\n * - [setUndo](#Command$setUndo) - set undo command for this command\n * - [getUndo](#Command$getUndo) - get undo command of this command\n * - [setArguments](#Command$setArguments) - set commands arguments\n * - [addArguments](#Command$addArguments) - add arguments to command\n * - [destroy](#Command$destroy)\n */\n_.extendProto(Command, {\n    init: Command$init,\n    execute: Command$execute,\n    setUndo: Command$setUndo,\n    getUndo: Command$getUndo,\n    undo: Command$undo,\n    redo: Command$execute, // same for command, different for transaction\n    setArguments: Command$setArguments,\n    addArguments: Command$addArguments,\n    getArguments: Command$getArguments,\n    changeArguments: Command$changeArguments,\n    destroy: Command$destroy,\n\n    setComment: Command$setComment,\n    getDescription: Command$getDescription\n});\n\n\n/**\n * Command class methods\n *\n * - [create](#Command$$create) - commands factory\n */\n_.extend(Command, {\n    create: Command$$create,\n    createWithUndo: Command$$createWithUndo\n});\n\n\nfunction Command$init(func) { // , ... arguments\n    check(func, Match.Optional(Function));\n    this.func = func || function(){};\n    this.args = _.slice(arguments, 1);    \n}\n\n\n/**\n * Execute command making command object available via function property. \n */\nfunction Command$execute(cb) {\n    var result = this.func.apply(this, this.args);\n    if (cb) _.defer(cb);\n    return result;\n}\n\n\n/**\n * Set undo command for this command. This command becomes undo command for undo command (so undo command can change this command during its execution).\n * \n * @param {Command} undoCommand\n */\nfunction Command$setUndo(undoCommand) {\n    if (this[UNDO_COMMAND])\n        logger.warn('Command setUndo: undo command is already set');\n\n    this[UNDO_COMMAND] = undoCommand;\n    undoCommand[UNDO_COMMAND] = this;\n}\n\n\n/**\n * Returns undo command of a given command\n *\n * @return {Command}\n */\nfunction Command$getUndo() {\n    return this[UNDO_COMMAND];\n}\n\n\n/**\n * Executes undo command of current command\n */\nfunction Command$undo(cb) {\n    var undoCmd = this.getUndo();\n    if (! undoCmd) return logger.error('Command undo called without undo command present');\n    var result = undoCmd.execute();\n    if (cb) _.defer(cb);\n    return result;\n}\n\n\n/**\n * Set command's arguments. If arguments were set during command's creation, this method will overwrite arguments and log warning.\n *\n * @param {List} *arguments\n */\nfunction Command$setArguments() { //, ... arguments\n    if (this.args && this.args.length)\n        logger.warn('Command setArguments: command arguments are already set');\n    this.args = _.toArray(arguments);\n}\n\n\nfunction Command$getArguments() {\n    return this.args;\n}\n\n\nfunction Command$changeArguments() { //, ... arguments\n    this.args = _.toArray(arguments);\n}\n\n\n/**\n * Add (append) arguments to command\n *\n * @param {List} *arguments arguments list to be appended to command\n */\nfunction Command$addArguments() { //, ... arguments\n    if (! this.args) this.args = [];\n    _.appendArray(this.args, arguments);\n}\n\n\n/**\n * Commands factory. Likely ot be overridden by subclasses to implement custom logic of command construction\n * \n * @this {Function} Class of command\n * @param {Function} func method name or function to be executed\n * @param {List} *arguments parameters to be passed to method or function\n * @return {Command}\n */\nfunction Command$$create(func) { // , ... arguments\n    return _.newApply(this, arguments);\n}\n\n\nfunction Command$$createWithUndo() {\n    throw new Error('createWithUndo should be implemented by subsclass');\n}\n\n\n/**\n * Destroy current command (to prevent potential memory leaks when commands point to DOM elements)\n */\nfunction Command$destroy() {\n    delete this.func;\n    delete this.args;\n    var undoCmd = this[UNDO_COMMAND];\n    if (undoCmd) {\n        delete this[UNDO_COMMAND][UNDO_COMMAND];\n        delete this[UNDO_COMMAND];\n        undoCmd.destroy();\n    }\n}\n\n\nfunction Command$setComment(comment) {\n    this.comment = comment;\n}\n\n\nfunction Command$getDescription() {\n    return {\n        func: this.func.name,\n        comment: this.comment\n    };\n}\n",
    "'use strict';\n\n\nvar ActionsHistory = require('./actions_history')\n    , _ = require('milo-core').proto;\n\n\nmodule.exports = Transaction;\n\n\nfunction Transaction() {\n    this.commands = new ActionsHistory;\n}\n\n\n_.extendProto(Transaction, {\n    execute: Transaction$execute,\n    undo: Transaction$undo,\n    redo: Transaction$redo,\n    destroy: Transaction$destroy,\n    storeCommand: Transaction$storeCommand,\n    merge: Transaction$merge,\n\n    setComment: Transaction$setComment,\n    getDescription: Transaction$getDescription\n});\n\n\nfunction Transaction$execute() {\n    this.commands.each('execute');\n}\n\n\nfunction Transaction$undo(cb) {\n    this.commands.undoAllAsync(cb);\n}\n\n\nfunction Transaction$redo(cb) {\n    this.commands.redoAllAsync(cb);\n}\n\n\nfunction Transaction$destroy() {\n    this.commands.each('destroy');\n}\n\n\nfunction Transaction$storeCommand(command) {\n    this.commands.store(command);\n}\n\n\nfunction Transaction$merge(transaction) {\n    transaction.commands.each(function(cmd) {\n        this.commands.store(cmd);\n    }, this);\n}\n\n\nfunction Transaction$setComment(comment) {\n    this.comment = comment;\n}\n\n\nfunction Transaction$getDescription() {\n    var commands = this.commands.getDescription();\n    return {\n        commands: commands.actions,\n        comment: this.comment\n    };\n}\n",
    "'use strict';\n\n\nvar ActionsHistory = require('./actions_history')\n    , Transaction = require('./transaction')\n    , miloCore = require('milo-core')\n    , logger = miloCore.util.logger\n    , Messenger = miloCore.Messenger\n    , _ = miloCore.proto;\n\n\nmodule.exports = TransactionHistory;\n\n\nvar SCHEDULED = '_scheduled';\n\n\nfunction TransactionHistory(maxLength) {\n    this.transactions = new ActionsHistory(maxLength);\n    this.currentBatch = undefined;\n    this.currentTransaction = undefined;\n    this[SCHEDULED] = false;\n}\n\n\n_.extendProto(TransactionHistory, {\n    storeCommand: TransactionHistory$storeCommand,\n    endTransaction: TransactionHistory$endTransaction,\n    storeTransaction: TransactionHistory$storeTransaction,\n    deleteLastTransaction: TransactionHistory$deleteLastTransaction,\n    undo: TransactionHistory$undo,\n    redo: TransactionHistory$redo,\n    inTransaction: TransactionHistory$inTransaction,\n\n    getDescription: TransactionHistory$getDescription,\n    useMessenger: TransactionHistory$useMessenger,\n    destroy: TransactionHistory$destroy\n});\n\n\n/**\n * Stores command in the history. \n * @param {Command} command           \n * @param {Boolean} appendTransaction If `true`, appends to the current or previous transaction if there is no current transaction.\n */\nfunction TransactionHistory$storeCommand(command, appendTransaction) {\n    if (appendTransaction && !(this.currentTransaction || this.currentBatch)) {\n        var transaction = this.transactions.getLastAction();\n        transaction.storeCommand(command);\n        _postTransactionMessage.call(this, 'appended', transaction);\n        return;\n    }\n\n    if (! this.currentBatch) this.currentBatch = new Transaction;\n    this.currentBatch.storeCommand(command);\n    if (! this[SCHEDULED]) {\n        this[SCHEDULED] = true;\n        _.deferMethod(this, _storeTransaction);\n    }\n}\n\n\nfunction TransactionHistory$deleteLastTransaction() {\n    if (this.currentBatch || this.currentTransaction) {\n        this.currentBatch = undefined;\n        this.currentTransaction = undefined;\n    } else {\n        this.transactions.deleteLast();\n    }\n}\n\n\nfunction _storeTransaction() {\n    if (this.currentBatch) {\n        _addBatchToTransaction.call(this);\n        _.deferMethod(this, _storeTransaction);\n    } else {\n        _storeCurrentTransaction.call(this);\n        this[SCHEDULED] = false;\n    }\n}\n\n\nfunction TransactionHistory$endTransaction() {\n    _addBatchToTransaction.call(this);\n    _storeCurrentTransaction.call(this);\n}\n\n\nfunction _addBatchToTransaction() {\n    if (this.currentBatch) {\n        if (! this.currentTransaction) this.currentTransaction = new Transaction;\n        this.currentTransaction.merge(this.currentBatch);\n        this.currentBatch = undefined;\n    } \n}\n\n\nfunction _storeCurrentTransaction() {\n    if (this.currentTransaction) {\n        var t = this.currentTransaction;\n        this.transactions.store(t);\n        _postTransactionMessage.call(this, 'stored', t);\n\n        this.currentTransaction = undefined;\n    }\n}\n\n\nfunction TransactionHistory$storeTransaction(transaction) {\n    this.endTransaction();\n\n    this.transactions.store(transaction);\n    _postTransactionMessage.call(this, 'stored', transaction);\n}\n\n\nfunction _postTransactionMessage(msg, transaction) {\n    if (this._messenger)\n        this._messenger.postMessage(msg, { transaction: transaction });\n}\n\n\nfunction TransactionHistory$undo(cb) {\n    var t = this.transactions.undo(cb);\n    if (t) _postTransactionMessage.call(this, 'undone', t);\n    return t;\n}\n\n\nfunction TransactionHistory$redo(cb) {\n    var t = this.transactions.redo(cb);\n    if (t) _postTransactionMessage.call(this, 'redone', t);\n    return t;\n}\n\n\nfunction TransactionHistory$inTransaction() {\n    return this[SCHEDULED];\n}\n\n\nfunction TransactionHistory$getDescription() {\n    return this.transactions.getDescription();\n}\n\n\nfunction TransactionHistory$useMessenger() {\n    this._messenger = new Messenger(this, Messenger.defaultMethods);\n    return this._messenger\n}\n\n\nfunction TransactionHistory$destroy() {\n    if (this._messenger) this._messenger.destroy();\n    delete this.transactions;\n}\n",
    "'use strict';\n\n\nvar FacetedObject = require('../abstract/faceted_object')\n    , facetsRegistry = require('./c_facets/cf_registry')\n    , ComponentFacet = facetsRegistry.get('ComponentFacet')\n    , componentUtils = require('./c_utils')\n    , miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match\n    , config = require('../config')\n    , miloComponentName = require('../util/component_name')\n    , logger = miloCore.util.logger\n    , domUtils = require('../util/dom')\n    , BindAttribute = require('../attributes/a_bind')\n    , Scope = require('./scope')\n    , DOMStorage = require('../util/storage');\n\nvar _makeComponentConditionFunc = componentUtils._makeComponentConditionFunc;\n\n\n/**\n * `milo.Component`\n * Base Component class. Subclass of [FacetedObject](../abstract/faceted_object.js.html), but none of this class methods should be directly used with component.\n * Its constructor passes its parameters, including its [scope](./scope.js.html), DOM element and name to [`init`](#init) method.\n * The constructor of Component class rarely needs to be used directly, as [milo.binder](../binder.js.html) creates components when it scans DOM tree.\n * [`Component.createComponentClass`](#createComponentClass) should be used to create a subclass of Component class with configured facets.\n *\n *\n * ####Component instance properties####\n *\n * - el - DOM element that component is attached to. If the second component is attached to the same DOM element, the warning will be logged to console. To get component reference from DOM element use [Component.getComponent](./c_utils.js.html#getComponent) class method. To inspect component via element in browser check `___milo_component` property of element (property name be changed using `milo.config`).\n * - scope - parent scope object, an instance of [Scope](./scope.js.html) class. To get parent component use [getScopeParent](#Component$getScopeParent) instance method of component. The actual path to get parent of conponent is `component.scope._hostObject.owner`, where `_hostObject` refers to [Container](c_facets/Container.js.html) facet of parent component and `owner` to the parent itself. The children of component are accessible via the scope of its container facet: `component.container.scope`. The scope hierarchy can be the same or different as the DOM hierarchy - DOM children of the component will be on the same scope as component if it does not have `Container` facet and in the scope of its Container facet if it has it. See [Scope](./scope.js.html).\n * - name - the name of component, should be unique for the scope where component belongs. To find component in scope the component's name should be used as property of scope object. See [Scope](./scope.js.html).\n * - facets - map of references of all component's facets (facet names are lowercase in this map). All facets can be accessed directly as properties of component, this property can be used to iterate facets (it is used in this way in [allFacets](#Component$allFacets) component's instance method that allows to call method with the same name on all facets).\n * - extraFacets - an array of names of facets that are added to component and do not form the part of component's class.\n * - _messenger - the reference to component's [messenger](../messenger/index.js.html). Rarely needs to be used directly as all commonly used methods of mesenger are available directly on component.\n *\n *\n * ####Component events####\n *\n * - 'childrenbound' - synchronously dispatched when children of DOM element which compnent is connected to are connected to components. The event is dispatched when component is created with `milo.binder` (as is almost always the case, as all Component class methods that create/copy components use `milo.binder` internally - component constructor and Component.create methods are not used in framework outside of `milo.binder` and rarely if ever need to be used in aplication).\n * - 'addedtoscope' - synchronously dispatched when component is added to scope.\n * - 'stateready' - aynchronously dispatched when component (together with its scope children) is created with [Component.createFromState](#Component$$createFromState) (or `createFromDataTransfer`) method. Can be dispatched by application if the component's state is set with some other mechanism. This event is not used in `milo`, it can be used in application in particular subclasses of component.\n * - 'getstatestarted' - emitted synchronously just before getState executes so components and facets can clean up their state for serialization. \n * - 'getstatecompleted' - emitted asynchronously after getState executes so components and facets can restore their state after serialization.\n *\n *\n * ####Component \"lifecycle\"####\n *\n * 1. Component constructor is called. Component's constructor simply calls constructor of [FacetedObject](../abstract/faceted_object.js.html) that is a superclass of Component. Subclasses of Component should not implement their own constructor, they can optionally implement `init` method, but most components do not need to do it.\n * 2. constructors and `init` methods of all facets are called in sequence. Same as components, facet do not implement their constructors, they can optionally implement `init` and `start` methods (see below). Inside `init` method there should be only general initialization code without any dependency on component itself (it is not ready yet) and other facets (as there is no specific facets creation order). If facet implements `init` method it MUST call inherited init with `ComponentFacet.prototype.init.apply(this, arguments)`.\n * 3. `init` method of component is called. At this point all facets are created but facets still can be not ready as they can have initialization code in `start` method. If component subclass implements `init` method it MUST call inherited method with `<Superclass>.prototype.init.apply(this, arguments)`, where <Superclass> is Component or another superclass the component is a subclass of.\n * 4. `check` method of all facets is called. This method adds facets that are not part of the component declaration (being part of the class or explicitely listed in bind attribute) but are required by facets that the compnent already has. Subclasses of [ComponentFacet](./c_facet.js.html) do not need to implement this method.\n * 5. `start` method of all facets is called. This method is usually implemented by ComponentFacet subclasses and it can have any initialization code that depends on component or on other facets that are the dependencies of a facet. Inherited `start` method should be called int he same way as written above.\n * 6. `start` method of component is called. This component method can be implemented by subclasses if they need to have some initialization code that depends on some facets and requires that these facets are fully inialized. Often such code also depends on component's scope children as well so this code should be inside `'childrenbound'` event subscriber.\n * 7. 'addedtoscope' event is dispatched when component is added to its parent's scope or to top level scope created by `milo.binder`.\n * 8. component's children are created (steps 1-6 above are followed for each child).\n * 9. 'childrenbound' event is dispatched when all component's children are created and added to their scope (see event description below).\n * 10. 'stateready' event is dispatched for component and all its children when component is create from state (see event description below).\n * 11. at this point component is in the \"interactive\" state when it and its facets will only respond to messages/events that they subscribed to during initialization.\n *\n *\n * @param {Scope} scope scope to which component will belong. It is usually a top level scope object returned by `milo.binder` or `scope` property of Container facet.\n * @param {Element} element DOM element that component is attached to\n * @param {String} name component name, should be unique in the scope of component\n * @param {ComponentInfo} componentInfo instance of ComponentInfo class that can be used to create a copy of component\n *  TODO try removing it\n * @return {Component}\n */\nvar Component = _.createSubclass(FacetedObject, 'Component', true);\n\nmodule.exports = Component;\n\n_registerWithDomStorage('Component');\n\n\n/**\n * ####Component class methods####\n *\n * - [createComponentClass](#Component$$createComponentClass)\n * - [create](#Component$$create)\n * - [copy](#Component$$copy)\n * - [createOnElement](#Component$$createOnElement)\n * - [isComponent](c_utils.js.html#isComponent)\n * - [getComponent](c_utils.js.html#getComponent)\n * - [getContainingComponent](c_utils.js.html#getContainingComponent)\n * - [createFromState](#Component$$createFromState)\n * - [createFromDataTransfer](#Component$$createFromDataTransfer)\n */\n_.extend(Component, {\n    createComponentClass: Component$$createComponentClass,\n    create: Component$$create,\n    copy: Component$$copy,\n    createOnElement: Component$$createOnElement,\n    isComponent: componentUtils.isComponent,\n    getComponent: componentUtils.getComponent,\n    getContainingComponent: componentUtils.getContainingComponent,\n    createFromState: Component$$createFromState,\n    createFromDataTransfer: Component$$createFromDataTransfer\n});\ndelete Component.createFacetedClass;\n\n\n/**\n * ####Component instance methods####\n *\n * - [init](#Component$init)\n * - [createElement](#Component$createElement)\n * - [hasFacet](#Component$hasFacet)\n * - [addFacet](#Component$addFacet)\n * - [allFacets](#Component$allFacets)\n * - [rename](#Component$rename)\n * - [remove](#Component$remove)\n * - [getState](#Component$getState)\n * - [getTransferState](#Component$getTransferState)\n * - [setState](#Component$setState)\n * - [getScopeParent](#Component$getScopeParent)\n * - [getTopScopeParent](#Component$getTopScopeParent)\n * - [getScopeParentWithClass](#Component$getScopeParentWithClass)\n * - [getTopScopeParentWithClass](#Component$getTopScopeParentWithClass)\n * - [walkScopeTree](#Component$walkScopeTree)\n * - [broadcast](#Component$broadcast)\n * - [destroy](#Component$destroy)\n * - [isDestroyed](#Component$isDestroyed)\n *\n *\n * #####[Messenger](../messenger/index.js.html) methods available on component#####\n *\n * - [on](../messenger/index.js.html#Messenger$on) - single subscribe\n * - [off](../messenger/index.js.html#Messenger$off) - single unsubscribe\n * - [onMessages](../messenger/index.js.html#Messenger$onMessages) - multiple subscribe\n * - [offMessages](../messenger/index.js.html#Messenger$offMessages) - multiple unsubscribe\n * - [postMessage](../messenger/index.js.html#Messenger$postMessage) - post message on component\n * - [getSubscribers](../messenger/index.js.html#Messenger$getSubscribers) - get subscribers for a given message\n */\n_.extendProto(Component, {\n    init: Component$init,\n    start: Component$start,\n    createElement: Component$createElement,\n    hasFacet: Component$hasFacet,\n    addFacet: Component$addFacet,\n    allFacets: Component$allFacets,\n    rename: Component$rename,\n    remove: Component$remove,\n    insertInto: Component$insertInto,\n\n    getState: Component$getState,\n    getTransferState: Component$getTransferState,\n    _getState: Component$_getState,\n    setState: Component$setState,\n    \n    getScopeParent: Component$getScopeParent,\n    getTopScopeParent: Component$getTopScopeParent,\n    getScopeParentWithClass: Component$getScopeParentWithClass,\n    getTopScopeParentWithClass: Component$getTopScopeParentWithClass,\n\n    setScopeParentFromDOM: Component$setScopeParentFromDOM,\n\n    walkScopeTree: Component$walkScopeTree,\n\n    treePathOf: Component$treePathOf,\n    getComponentAtTreePath: Component$getComponentAtTreePath,\n    insertAtTreePath: Component$insertAtTreePath,\n\n    broadcast: Component$broadcast,\n    destroy: Component$destroy,\n    isDestroyed: Component$isDestroyed\n});\n\n\n/**\n * Expose Messenger methods on Component prototype\n */\nvar MESSENGER_PROPERTY = '_messenger';\nMessenger.useWith(Component, MESSENGER_PROPERTY, Messenger.defaultMethods);\n\n\nvar COMPONENT_DATA_TYPE_PREFIX = 'x-application/milo-component';\nvar COMPONENT_DATA_TYPE_REGEX = /x-application\\/milo-component\\/([a-z_$][0-9a-z_$]*)(?:\\/())/i;\n\n/**\n * Component class method\n * Creates a subclass of component from the map of configured facets.\n * This method wraps and replaces [`createFacetedClass`](../abstract/faceted_object.js.html#createFacetedClass) class method of FacetedObject.\n * Unlike createFacetedClass, this method take facet classes from registry by their name, so only map of facets configuration needs to be passed. All facets classes should be subclasses of [ComponentFacet](./c_facet.js.html)\n *\n * @param {String} name class name\n * @param {Object<Object> | Array<String>} facetsConfig map of facets configuration.\n *  If some facet does not require configuration, `undefined` should be passed as the configuration for the facet.\n *  If no facet requires configuration, the array of facets names can be passed.\n * @return {Subclass<Component>}\n */\nfunction Component$$createComponentClass(name, facetsConfig) {\n    // convert array of facet names to map of empty facets configurations\n    if (Array.isArray(facetsConfig)) {\n        var configMap = {};\n        facetsConfig.forEach(function(fct) {\n            var fctName = _.firstLowerCase(fct);\n            configMap[fctName] = {};\n        });\n        facetsConfig = configMap;\n    }\n\n    // construct map of facets classes from facetRegistry\n    var facetsClasses;\n    if (typeof facetsConfig == 'object' && _.keys(facetsConfig).length) {\n        facetsClasses = {};\n        _.eachKey(facetsConfig, function(fctConfig, fct) {\n            var fctName = _.firstLowerCase(fct);\n            var fctClassName = _.firstUpperCase(fct);\n            facetsClasses[fctName] = facetsRegistry.get(fctClassName);\n        });\n    }\n\n    // create subclass of Component using method of FacetedObject\n    var ComponentClass = FacetedObject.createFacetedClass.call(this, name, facetsClasses, facetsConfig);\n    \n    _registerWithDomStorage(name);\n\n    return ComponentClass;\n}\n\n\nfunction _registerWithDomStorage(className) {\n    DOMStorage.registerDataType(className, Component_domStorageSerializer, Component_domStorageParser);\n}\n\n\nfunction Component_domStorageSerializer(component) {\n    var state = component.getState();\n    return JSON.stringify(state);   \n}\n\n\nfunction Component_domStorageParser(compStr, compClassName) {\n    var state = _.jsonParse(compStr);\n    if (state)\n        return Component.createFromState(state);\n}\n\n\n/**\n * Component class method\n * Creates component from [ComponentInfo](./c_info.js.html) (used by [milo.binder](../binder.js.html) and to copy component)\n * Component of any registered class (see [componentsRegistry](./c_registry.js.html)) with any additional registered facets (see [facetsRegistry](./c_facets/cf_registry.js.html)) can be created using this method.\n *\n * @param {ComponentInfo} info\n * @param {Boolean} throwOnErrors If set to false, then errors will only be logged to console. True by default.\n @ @return {Component}\n */\nfunction Component$$create(info, throwOnErrors) {\n    var ComponentClass = info.ComponentClass;\n\n    if (typeof ComponentClass != 'function') {\n        var message = 'create: component class should be function, \"' + typeof ComponentClass + '\" passed'; \n        if (throwOnErrors === false) {\n            logger.error('Component', message, ';using base Component class instead');\n            ComponentClass = Component;\n        } else\n            throw new Error(message);\n    }\n\n    var aComponent = new ComponentClass(info.scope, info.el, info.name, info);\n\n    if (info.extraFacetsClasses)\n        _.eachKey(info.extraFacetsClasses, function(FacetClass) {\n            if (! aComponent.hasFacet(FacetClass))\n                aComponent.addFacet(FacetClass, undefined, undefined, throwOnErrors);\n        });\n\n    return aComponent;\n}\n\n\n/**\n * Component class method\n * Create a copy of component, including a copy of DOM element. Returns a copy of `component` (of the same class) with new DOM element (not inserted into page).\n * Component is added to the same scope as the original component.\n *\n * @param {Component} component an instance of Component class or subclass\n * @param {Boolean} deepCopy optional `true` to make deep copy of DOM element, otherwise only element without children is copied\n * @return {Component}\n */\nfunction Component$$copy(component, deepCopy) {\n    check(component, Component);\n    check(deepCopy, Match.Optional(Boolean));\n\n    if (deepCopy && !component.container) \n        throw new Error('Cannot deep copy component without container facet');\n\n    // copy DOM element, using Dom facet if it is available\n    var newEl = component.dom \n                    ? component.dom.copy(deepCopy)\n                    : component.el.cloneNode(deepCopy);\n\n    var ComponentClass = component.constructor;\n\n    // create component of the same class on the element\n    var aComponent = ComponentClass.createOnElement(newEl, undefined, component.scope, component.extraFacets);\n    var state = component._getState(deepCopy || false);\n    aComponent.setState(state);\n    _.deferMethod(aComponent, 'broadcast', 'stateready');\n    return aComponent;\n}\n\n\n/**\n * Component class method\n * Creates an instance of component atached to element. All subclasses of component inherit this method.\n * Returns the component of the class this method is used with (thecontext of the method call).\n *\n * @param {Element} el optional element to attach component to. If element is not passed, it will be created\n * @param {String} innerHTML optional inner html to insert in element before binding.\n * @param {Scope} rootScope optional scope to put component in. If not passed, component will be attached to the scope that contains the element. If such scope does not exist, new scope will be created.\n * @param {Array<String>} extraFacets list of extra facet to add to component\n * @return {Subclass<Component>}\n */\nfunction Component$$createOnElement(el, innerHTML, rootScope, extraFacets) {\n    check(innerHTML, Match.Optional(String));\n    check(rootScope, Match.Optional(Scope));\n    check(extraFacets, Match.Optional([String]));\n\n    // \"this\" refers to the class of component here, as this is a class method\n    if (el && innerHTML) el.innerHTML = innerHTML;\n    el = el || _createComponentElement.call(this, innerHTML);\n    rootScope = rootScope || _findOrCreateComponentRootScope(el);\n    var aComponent = _addAttributeAndBindComponent.call(this, el, rootScope, extraFacets);\n    aComponent.broadcast('stateready');\n    return aComponent;\n}\n\nfunction _createComponentElement(innerHTML) {\n    // \"this\" refers to the class of component here, as this is a class method\n    var Dom = facetsRegistry.get('Dom')\n        , domFacetConfig = this.getFacetConfig('dom')\n        , templateFacetConfig = this.getFacetConfig('template')\n        , template = templateFacetConfig && templateFacetConfig.template;\n\n    var elConfig = {\n        domConfig: domFacetConfig,\n        template: template,\n        content: innerHTML\n    };\n\n    return Dom.createElement(elConfig);\n}\n\nfunction _findOrCreateComponentRootScope(el) {\n    var parent = Component.getContainingComponent(el, false, 'Container');\n    return parent ? parent.container.scope : new Scope(el);\n}\n\nfunction _addAttributeAndBindComponent(el, rootScope, extraFacets) {\n    // add bind attribute to element\n    var attr = new BindAttribute(el);\n    // \"this\" refers to the class of component here, as this is a class method\n    attr.compClass = this.name;\n    attr.compFacets = extraFacets;\n    attr.decorate();\n\n    // should be required here to resolve circular dependency\n    var miloBinder = require('../binder');\n    miloBinder(el, rootScope);\n\n    return rootScope[attr.compName];\n}\n\n/**\n * Component class method\n * Creates component from component state, that includes information about its class, extra facets, facets data and all scope children.\n * This is used to save/load, copy/paste and drag/drop component\n *\n * @param {Object} state state from which component will be created\n * @param {Scope} rootScope scope to which component will be added\n * @param {Boolean} newUniqueName optional `true` to create component with the name different from the original one. `False` by default.\n * @param {Boolean} throwOnErrors If set to false, then errors will only be logged to console. True by default.\n * @return {Component} component\n */\nfunction Component$$createFromState(state, rootScope, newUniqueName, throwOnErrors) {\n    check(state, Match.ObjectIncluding({\n        compName: Match.Optional(String),\n        compClass: Match.Optional(String),\n        extraFacets: Match.Optional([String]),\n        facetsStates: Match.Optional(Object),\n        outerHTML: String\n    }));\n\n    var miloBinder = require('../binder');\n\n    // create wrapper element optionally renaming component\n    var wrapEl = _createComponentWrapElement(state, newUniqueName);\n\n    // instantiate all components from HTML\n    var scope = miloBinder(wrapEl, undefined, undefined, throwOnErrors);\n\n    // as there should only be one component, call to _any will return it\n    var component = scope._any();\n\n    // set component's scope\n    if (rootScope) {\n        component.scope = rootScope;\n        rootScope._add(component);\n    }\n\n    // restore component state\n    component.setState(state);\n    _.deferMethod(component, 'broadcast', 'stateready');\n\n    return component;   \n}\n\n\n// used by Component$$createFromState\nfunction _createComponentWrapElement(state, newUniqueName) {\n    var wrapEl = document.createElement('div');\n    wrapEl.innerHTML = state.outerHTML;\n\n    var children = domUtils.children(wrapEl);\n    if (children.length != 1)\n        throw new Error('cannot create component: incorrect HTML, elements number: ' + children.length + ' (should be 1)');\n    var compEl = children[0];\n    var attr = new BindAttribute(compEl);\n    attr.compName = newUniqueName ? miloComponentName() : state.compName;\n    attr.compClass = state.compClass;\n    attr.compFacets = state.extraFacets;\n    attr.decorate();\n\n    return wrapEl;\n}\n\n/**\n * Creates a component from a DataTransfer object (if possible)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer\n * @param {DataTransfer} dataTransfer Data transfer\n */\nfunction Component$$createFromDataTransfer(dataTransfer) {\n    var dataType = _.find(dataTransfer.types, function (type) {\n        return COMPONENT_DATA_TYPE_REGEX.test(type);\n    });\n    if (!dataType) return;\n\n    var state = _.jsonParse(dataTransfer.getData(dataType));\n    if (!state) return;\n\n    return Component.createFromState(state, undefined, true);\n}\n\n\n/**\n * Component instance method.\n * Initializes component. Automatically called by inherited constructor of FacetedObject.\n * Subclasses should call inherited init methods:\n * ```\n * Component.prototype.init.apply(this, arguments)\n * ```\n *\n * @param {Scope} scope scope to which component will belong. It is usually a top level scope object returned by `milo.binder` or `scope` property of Container facet.\n * @param {Element} element DOM element that component is attached to\n * @param {String} name component name, should be unique in the scope of component\n * @param {ComponentInfo} componentInfo instance of ComponentInfo class that can be used to create a copy of component\n *  TODO try removing it\n */\nfunction Component$init(scope, element, name, componentInfo) {\n    // create DOM element if it wasn't passed to Constructor\n    this.el = element || this.createElement();\n\n    // store reference to component on DOM element\n    if (this.el) {\n        // check that element does not have a component already atached\n        var elComp = this.el[config.componentRef];\n        if (elComp)\n            logger.warn('component ' + name + ' attached to element that already has component ' + elComp.name);\n\n        this.el[config.componentRef] = this;\n    }\n\n    _.defineProperties(this, {\n        componentInfo: componentInfo,\n        extraFacets: []\n    }, _.ENUM);\n\n    this.name = name;\n    this.scope = scope;\n\n    // create component messenger\n    var messenger = new Messenger(this);\n    _.defineProperty(this, MESSENGER_PROPERTY, messenger);\n\n    // check all facets dependencies (required facets)\n    this.allFacets('check');\n\n    // start all facets\n    this.allFacets('start');\n\n    // call start method if it's defined in subclass\n    if (this.start) this.start();\n}\n\n\n/**\n * This is a stub to avoid confusion whether the method of superclass should be called in subclasses\n * The start method of subclass instance is called once all the facets are created, initialized and started (see above)\n */\nfunction Component$start() {}\n\n\n/**\n * Component instance method.\n * Initializes the element which this component is bound to\n *\n * This method is called when a component is instantiated outside the DOM and\n * will generate a new element for the component.\n * \n * @return {Element}\n */\nfunction Component$createElement() {\n    if (typeof document == 'undefined')\n        return;\n\n    this.el = this.dom\n                ? this.dom.createElement()\n                : document.createElement('DIV');\n\n    return this.el;\n}\n\n\n/**\n * Component instance method\n * Returns true if component has facet\n *\n * @param {Function|String} facetNameOrClass\n * @return {Boolean}\n */\nfunction Component$hasFacet(facetNameOrClass) {\n    var facetName = _.firstLowerCase(typeof facetNameOrClass == 'function'\n                                        ? facetNameOrClass.name\n                                        : facetNameOrClass);\n\n    var facet = this[facetName];\n    if (! facet instanceof ComponentFacet)\n        logger.warn('expected facet', facetName, 'but this property name is used for something else');\n\n    return !! facet;\n}\n\n\n/**\n * Component instance method.\n * Adds facet with given name or class to the instance of Component (or its subclass).\n * \n * @param {String|Subclass<Component>} facetNameOrClass name of facet class or the class itself. If name is passed, the class will be retireved from facetsRegistry\n * @param {Object} facetConfig optional facet configuration\n * @param {String} facetName optional facet name. Allows to add facet under a name different from the class name supplied.\n * @param {Boolean} throwOnErrors If set to false, then errors will only be logged to console. True by default.\n */\nfunction Component$addFacet(facetNameOrClass, facetConfig, facetName, throwOnErrors) {\n    check(facetNameOrClass, Match.OneOf(String, Match.Subclass(ComponentFacet)));\n    check(facetConfig, Match.Optional(Object));\n    check(facetName, Match.Optional(String));\n\n    var FacetClass;\n    // if only name passed, retrieve facet class from registry\n    if (typeof facetNameOrClass == 'string') {\n        var facetClassName = _.firstUpperCase(facetNameOrClass);\n        FacetClass = facetsRegistry.get(facetClassName);\n    } else \n        FacetClass = facetNameOrClass;\n\n    if (!facetName)\n        facetName = _.firstLowerCase(FacetClass.name);\n\n    this.extraFacets.push(facetName);\n\n    // add facet using method of FacetedObject\n    var newFacet = FacetedObject.prototype.addFacet.call(this, FacetClass, facetConfig, facetName, throwOnErrors);\n\n    // check depenedencies and start facet\n    if (newFacet.check) newFacet.check();\n    if (newFacet.start) newFacet.start();\n}\n\n\n/**\n * Component instance method.\n * Envoke given method with optional parameters on all facets.\n * Returns the map of values returned by all facets. If the facet doesn't have the method it is simply not called and the value in the map will be undefined.\n *\n * @param {String} method method name to envoke on the facet\n * @return {Object}\n */\nfunction Component$allFacets(method) { // ,... arguments\n    var args = _.slice(arguments, 1);\n\n    return _.mapKeys(this.facets, function(facet, fctName) {\n        if (facet && typeof facet[method] == 'function')\n            return facet[method].apply(facet, args);\n    });\n}\n\n\n/**\n * Component instance method.\n * \n * @param {String} [name] optional new name of component, \n * @param {Boolean} [renameInScope] optional false to not rename ComponentInfo object in its scope, true by default\n */\nfunction Component$rename(name, renameInScope) {\n    name = name || miloComponentName();\n    this.componentInfo.rename(name, false);\n    Scope.rename(this, name, renameInScope);\n}\n\n\n/**\n * Component instance method.\n * Removes component from its scope.\n *\n * @param {Boolean} preserveScopeProperty true not to delete scope property of component\n * @param {Boolean} quiet optional true to suppress the warning message if the component is not in scope\n */\nfunction Component$remove(preserveScopeProperty, quiet) {\n    if (this.scope) {\n        this.scope._remove(this.name, quiet);\n        if (! preserveScopeProperty)\n            delete this.scope;\n    }\n}\n\n\n/**\n * Component instance method.\n * Inserts the component into the DOM and attempts to adjust the scope tree accordingly.\n * @param {HTMLElement} parentEl    The element into which the component should be inserted.\n * @param {HTMLElement} referenceEl (optional) The reference element it should be inserted before.\n */\nfunction Component$insertInto(parentEl, referenceEl) {\n    parentEl.insertBefore(this.el, referenceEl);\n    this.setScopeParentFromDOM();\n}\n\n\n/**\n * Component instance method\n * Retrieves all component state, including information about its class, extra facets, facets data and all scope children.\n * This information is used to save/load, copy/paste and drag/drop component \n * Returns component state\n *\n * @this {Component} component which state will be saved\n * @return {Object}\n */\nfunction Component$getState() {\n    this.broadcast('getstatestarted', { rootComponent: this }, undefined, true);\n    var state = this._getState(true);\n    state.outerHTML = this.el.outerHTML;\n    _.deferMethod(this, 'broadcast', 'getstatecompleted', { rootComponent: this }, undefined, true);\n    return state;\n}\n\n\n/**\n * Component instance method\n * Retrieves all component state, including information about its class, extra facets, facets data and all scope children.\n * This information is used to save/load, copy/paste and drag/drop component \n * If component has [Transfer](./c_facets/Transfer.js.html) facet on it, this method retrieves state from this facet\n * Returns component state\n *\n * @this {Component} component which state will be saved\n * @param {Object} options can be used by subclasses. \n * @return {Object}\n */\nfunction Component$getTransferState(options) {\n    return this.transfer\n            ? this.transfer.getState(options)\n            : this.getState(options);\n}\n\n\n/**\n * Component instance method\n * Returns the state of component\n * Used by class method `Component.getState` and by [Container](./c_facets/Container.js.html) facet.\n *\n * @private\n * @param {Boolean} deepState false to get shallow state from all facets (true by default)\n * @return {Object}\n */\nfunction Component$_getState(deepState){\n\n    var facetsStates = this.allFacets('getState', deepState === false ? false : true);\n    facetsStates = _.filterKeys(facetsStates, function(fctState) {\n        return !! fctState;\n    });\n\n    return {\n        compName: this.name,\n        compClass: this.constructor.name,\n        extraFacets: this.extraFacets,\n        facetsStates: facetsStates\n    };\n}\n\n\n/**\n * Component instance method\n * Sets the state of component.\n * Used by class method `Component.createFromState` and by [Container](./c_facets/Container.js.html) facet.\n *\n * @private\n * @param {Object} state state to set the component\n */\nfunction Component$setState(state) {\n    if (state.facetsStates)\n        _.eachKey(state.facetsStates, function(fctState, fctName) {\n            var facet = this[fctName];\n            if (facet && typeof facet.setState == 'function')\n                facet.setState(fctState);\n        }, this);\n}\n\n\n/**\n * Component instance method.\n * Returns the scope parent of a component.\n * If `conditionOrFacet` parameter is not specified, an immediate parent will be returned, otherwise the closest ancestor with a specified facet or passing condition test.\n *\n * @param {Function|String} conditionOrFacet optional condition that component should pass (or facet name it should contain)\n * @return {Component|undefined}\n */\nfunction Component$getScopeParent(conditionOrFacet) {\n    return _callGetScopeParent.call(this, _getScopeParent, conditionOrFacet);\n}\n\nfunction _callGetScopeParent(_getScopeParentFunc, conditionOrFacet) {\n    check(conditionOrFacet, Match.Optional(Match.OneOf(Function, String)));\n    var conditionFunc = componentUtils._makeComponentConditionFunc(conditionOrFacet);\n    return _getScopeParentFunc.call(this, conditionFunc);   \n}\n\nfunction _getScopeParent(conditionFunc) {\n    var parent;\n    try { parent = this.scope._hostObject.owner; } catch(e) {}\n\n    // Where there is no parent, this function will return undefined\n    // The parent component is checked recursively\n    if (parent) {\n        if (! conditionFunc || conditionFunc(parent) )\n            return parent;\n        else\n            return _getScopeParent.call(parent, conditionFunc);\n    }\n}\n\n\n/**\n * Component instance method\n * Returns scope parent with a given class, with same class if not specified\n *\n * @param {Function} [ComponentClass] component class that the parent should have, same class by default\n * @return {Component}\n */\nfunction Component$getScopeParentWithClass(ComponentClass) {\n    ComponentClass = ComponentClass || this.constructor;\n    return _getScopeParent.call(this, function(comp) {\n        return comp instanceof ComponentClass;\n    });\n}\n\n\n/**\n * Component instance method.\n * Returns the topmost scope parent of a component.\n * If `conditionOrFacet` parameter is not specified, the topmost scope parent will be returned, otherwise the topmost ancestor with a specified facet or passing condition test.\n *\n * @param {Function|String} conditionOrFacet optional condition that component should pass (or facet name it should contain)\n * @return {Component|undefined}\n */\nfunction Component$getTopScopeParent(conditionOrFacet) {\n    return _callGetScopeParent.call(this, _getTopScopeParent, conditionOrFacet);\n}\n\nfunction _getTopScopeParent(conditionFunc) {\n    var topParent\n        , parent = this;\n    do {\n        parent = _getScopeParent.call(parent, conditionFunc);\n        if (parent)\n            topParent = parent;\n    } while (parent);\n\n    return topParent;\n}\n\n\n/**\n * Component instance method\n * Returns scope parent with a given class, with same class if not specified\n *\n * @param {Function} [ComponentClass] component class that the parent should have, same class by default\n * @return {Component}\n */\nfunction Component$getTopScopeParentWithClass(ComponentClass) {\n    ComponentClass = ComponentClass || this.constructor;\n    return _getTopScopeParent.call(this, function(comp) {\n        return comp instanceof ComponentClass;\n    });\n}\n\n\n/**\n * Component instance method\n * Finds scope parent of component using DOM tree (unlike getScopeParent that simply goes up the scope tree).\n * While getScopeParent is faster it may fail if scope chain is not setup yet (e.g., when component has been just inserted).\n * The scope property of component will be changed to point to scope object of container facet of that parent.\n * Returned scope parent of the component will be undefined (as well as component's scope property) if no parent in the DOM tree has container facet.\n * TODO Method will not bind DOM children correctly if component has no container facet.\n *\n * @return {Component}\n */\nfunction Component$setScopeParentFromDOM() {\n    var parentEl = this.el.parentNode;\n\n    var parent, foundParent;\n    while (parentEl && ! foundParent) {\n        parent = Component.getComponent(parentEl);\n        foundParent = parent && parent.container;\n        parentEl = parentEl.parentNode;\n    }\n\n    this.remove(); // remove component from its current scope (if it is defined)\n    if (foundParent) {\n        this.rename(undefined, false);\n        parent.container.scope._add(this);\n        return parent;\n    }        \n}\n\n\n/**\n * Walks component tree, calling provided callback on each component\n *\n * @param callback\n * @param thisArg\n */\nfunction Component$walkScopeTree(callback, thisArg) {\n    callback.call(thisArg, this);\n    if (!this.container) return;\n    this.container.scope._each(function(component) {\n        component.walkScopeTree(callback, thisArg);\n    });\n}\n\n\nfunction Component$treePathOf(component) {\n    return domUtils.treePathOf(this.el, component.el);\n}\n\n\nfunction Component$getComponentAtTreePath(treePath, nearest) {\n    var node = domUtils.getNodeAtTreePath(this.el, treePath, nearest);\n    return Component.getComponent(node);\n}\n\n\nfunction Component$insertAtTreePath(treePath, component, nearest) {\n    var wasInserted = domUtils.insertAtTreePath(this.el, treePath, component.el);\n    if (wasInserted) component.setScopeParentFromDOM();\n    return wasInserted;\n}\n\n\n/**\n * Broadcast message to component and to all its scope children\n *\n * @param {String|RegExp} msg message to be sent\n * @param {Any} [data] optional message data\n * @param {Function} [callback] optional callback\n * @param {Boolean} [synchronously] if it should use postMessageSync\n */\nfunction Component$broadcast(msg, data, callback, synchronously) {\n    var postMethod = synchronously ? 'postMessageSync' : 'postMessage';\n    this.walkScopeTree(function(component) {\n        component[postMethod](msg, data, callback);\n    });\n}\n\n\n/**\n * Destroy component: removes component from DOM, removes it from scope, deletes all references to DOM nodes and unsubscribes from all messages both component and all facets\n */\nfunction Component$destroy(opts) {\n    if (typeof opts == 'boolean') opts = { quiet: opts };\n    else if (!opts) opts = {};\n\n    if (this._destroyed) {\n        if (!opts.quiet) logger.warn('Component destroy: component is already destroyed');\n        return;\n    }\n    this.remove(false, opts.quiet);\n    this.allFacets('destroy', opts);\n    this[MESSENGER_PROPERTY].destroy();\n    if (this.el) {\n        domUtils.detachComponent(this.el);\n        domUtils.removeElement(this.el);\n        delete this.el;\n    }\n    this.componentInfo.destroy();\n    this._destroyed = true;\n}\n\n\n/**\n * Returns true if component was destroyed\n *\n * @return {Boolean}\n */\nfunction Component$isDestroyed() {\n    return !!this._destroyed;\n}\n",
    "'use strict';\n\n/**\n * `milo.Component.Facet`\n *\n * The class fot the facet of component. When a component is created, it\n * creates all its facets.\n *\n * See Facets section on information about available facets and on\n * how to create new facets classes.\n *\n * - Component - basic compponent class\n * - ComponentFacet - basic\n */\n\nvar Facet = require('../abstract/facet')\n    , miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , componentUtils = require('./c_utils')\n    , _ = miloCore.proto;\n\nvar ComponentFacet = _.createSubclass(Facet, 'ComponentFacet');\n\nmodule.exports = ComponentFacet;\n\n\n/**\n * postDomParent\n *\n * If facet has DOM parent facet (see `domParent` method), posts the message to this facet.\n *\n * @param {String} messageType\n * @param {Object} messageData\n */\nvar postDomParent = _.partial(_postParent, domParent);\n\n/**\n * postScopeParent\n *\n * If facet has scope parent facet (see `scopeParent` method), posts the message to this facet.\n *\n * @param {String} messageType\n * @param {Object} messageData\n */\nvar postScopeParent = _.partial(_postParent, scopeParent);\n\n\n_.extendProto(ComponentFacet, {\n    init: ComponentFacet$init,\n    start: ComponentFacet$start,\n    check: ComponentFacet$check,\n    destroy: ComponentFacet$destroy,\n    onConfigMessages: ComponentFacet$onConfigMessages,\n    domParent: domParent,\n    postDomParent: postDomParent,\n    scopeParent: scopeParent,\n    postScopeParent: postScopeParent,\n    getMessageSource: getMessageSource,\n    dispatchSourceMessage: dispatchSourceMessage,\n    _createMessenger: _createMessenger,\n    _setMessageSource: _setMessageSource,\n    _createMessageSource: _createMessageSource,\n    _createMessageSourceWithAPI: _createMessageSourceWithAPI\n});\n\n_.extend(ComponentFacet, {\n    requiresFacet: requiresFacet\n});\n\n\n/**\n * Expose Messenger methods on Facet prototype\n */\nvar MESSENGER_PROPERTY = '_messenger';\nMessenger.useWith(ComponentFacet, MESSENGER_PROPERTY, Messenger.defaultMethods);\n\n\n// initComponentFacet\nfunction ComponentFacet$init() {\n    this._createMessenger();\n}\n\n\n// some subclasses (e.g. ModelFacet) overrride this method and do not create their own messenger\nfunction _createMessenger(){\n    _.defineProperty(this, MESSENGER_PROPERTY, new Messenger(this));\n}\n\n\n// startComponentFacet\nfunction ComponentFacet$start() {\n    if (this.config.messages)\n        this.onConfigMessages(this.config.messages);\n}\n\n\nfunction ComponentFacet$onConfigMessages(messageSubscribers) {\n    var notYetRegisteredMap = _.mapKeys(messageSubscribers, function(subscriber, messages) {\n        var subscriberType = typeof subscriber;\n        if (subscriberType == 'function')\n            return this.on(messages, subscriber);\n\n        if (subscriberType == 'object') {\n            var contextType = typeof subscriber.context;\n            if (contextType == 'object')\n                return this.on(messages, subscriber);\n\n            if (contextType == 'string') {\n                if (subscriber.context == this.name || subscriber.context == 'facet')\n                    subscriber = {\n                        subscriber: subscriber.subscriber,\n                        context: this\n                    };\n                else if (subscriber.context == 'owner')\n                    subscriber = {\n                        subscriber: subscriber.subscriber,\n                        context: this.owner\n                    };\n                else\n                    throw new Error('unknown subscriber context in configuration: ' + subscriber.context);\n\n                return this.on(messages, subscriber);\n            }\n\n            throw new Error('unknown subscriber context type in configuration: ' + contextType);\n        }\n\n        throw new Error('unknown subscriber type in configuration: ' + subscriberType);\n    }, this);\n\n    return notYetRegisteredMap;\n}\n\n\n// checkDependencies and config\nfunction ComponentFacet$check() {\n    if (this.require) {\n        this.require.forEach(function(reqFacet) {\n            if (! this.owner.hasFacet(reqFacet))\n                this.owner.addFacet(reqFacet);\n        }, this);\n    }\n\n    if (this.configSchema) {\n        try {\n            milo.util.check(this.config, this.configSchema);\n        } catch(e) {\n            throw 'Error validating config schema for \"' + this.name +'\" facet: ' + e;\n        }\n    }\n}\n\n\n// destroys facet\nfunction ComponentFacet$destroy() {\n    if (this[MESSENGER_PROPERTY]) this[MESSENGER_PROPERTY].destroy();\n    this._destroyed = true;\n}\n\n\n/**\n * domParent\n *\n * @return {ComponentFacet} reference to the facet of the same class of the closest parent DOM element, that has a component with the same facet class attached to it. If such element doesn't exist method will return undefined.\n */\nfunction domParent() {\n    var parentComponent = componentUtils.getContainingComponent(this.owner.el, false, this.name);\n    return parentComponent && parentComponent[this.name];\n}\n\n\n/**\n * scopeParent\n *\n * @return {ComponentFacet} reference to the facet of the same class as `this` facet of the closest scope parent (i.e., the component that has the scope of the current component in its container facet).\n */\nfunction scopeParent() {\n    var parentComponent = this.owner.getScopeParent(this.name);\n    return parentComponent && parentComponent[this.name];\n}\n\n\nfunction _postParent(getParentMethod, messageType, messageData) {\n    var parentFacet = getParentMethod.call(this);\n    if (parentFacet)\n        parentFacet.postMessage(messageType, messageData);\n}\n\n\nfunction _setMessageSource(messageSource) {\n    this[MESSENGER_PROPERTY]._setMessageSource(messageSource);\n}\n\n\nfunction getMessageSource() {\n    return this[MESSENGER_PROPERTY].getMessageSource();\n}\n\n\nfunction dispatchSourceMessage(message, data) {\n    return this.getMessageSource().dispatchMessage(message, data);\n}\n\n\nfunction _createMessageSource(MessageSourceClass, options) {\n    var messageSource = new MessageSourceClass(this, undefined, undefined, this.owner, options);\n    this._setMessageSource(messageSource);\n\n    _.defineProperty(this, '_messageSource', messageSource);\n}\n\n\nfunction _createMessageSourceWithAPI(MessageSourceClass, messengerAPIOrClass, options) {\n    var messageSource = new MessageSourceClass(this, undefined, messengerAPIOrClass, this.owner, options);\n    this._setMessageSource(messageSource);\n\n    _.defineProperty(this, '_messageSource', messageSource);\n}\n\n\nfunction requiresFacet(facetName) {\n    // 'this' refers to the Facet Class\n    var facetRequire = this.prototype.require;\n\n    return facetRequire && (facetRequire.indexOf(_.firstUpperCase(facetName)) >= 0\n                        || facetRequire.indexOf(_.firstLowerCase(facetName)) >= 0);\n}\n",
    "'use strict';\n\n\nvar ComponentFacet = require('../c_facet')\n    , miloBinder = require('../../binder')\n    , Scope = require('../scope')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger\n    , facetsRegistry = require('./cf_registry')\n    , domUtils = require('../../util/dom');\n\n\n/**\n * `milo.registry.facets.get('Container')`\n * A special component facet that makes component create its own inner scope.\n * When [milo.binder](../../binder.js.html) binds DOM tree and creates components, if components are inside component WITH Container facet, they are put on the `scope` of it (component.container.scope - see [Scope](../scope.js.html)), otherwise they are put on the same scope even though they may be deeper in DOM tree.\n * It allows creating namespaces avoiding components names conflicts, at the same time creating more shallow components tree than the DOM tree.\n * To create components for elements inside the current component use:\n * ```\n * component.container.binder();\n * ```\n * See [milo.binder](../../binder.js.html)\n */\nvar Container = _.createSubclass(ComponentFacet, 'Container');\n\n\n/**\n * ####Container facet instance methods####\n *\n * - [binder](#Container$binder) - create components from DOM inside the current one\n */\n_.extendProto(Container, {\n    start: Container$start,\n    path: Container$path,\n    getState: Container$getState,\n    setState: Container$setState,\n    binder: Container$binder,\n    destroy: Container$destroy,\n    unwrap: Container$unwrap,\n\n    append: Container$append,\n    insertBefore: Container$insertBefore,\n    remove: Container$remove\n});\n\nfacetsRegistry.add(Container);\n\nmodule.exports = Container;\n\n\n/**\n * Container instance method.\n * Scans DOM, creates components and adds to scope children of component element.\n */\nfunction Container$binder() {\n    return miloBinder(this.owner.el, this.scope, false);\n}\n\n\n/**\n * Container instance method.\n * Setup empty scope object on start\n */\nfunction Container$start() {\n    ComponentFacet.prototype.start.apply(this, arguments);\n    this.scope = new Scope(this.owner.el, this);\n}\n\n\nvar allowedNamePattern = /^[A-Za-z][A-Za-z0-9\\_\\$]*$/;\n/**\n * Container instance method.\n * Safely traverses component scope\n * Returns component in scope for a given path\n * If path is invalid the method will throw, if there is no component at a given path or some of the components along the path does not have Container facet the method will return undefined, \n * \n * @param {String} path path of child component in scope, each name should be prefixed with '.', e.g.: '.child.subchild'\n * @return {Component}\n */\nfunction Container$path(path) {\n    path = path.split('.');\n    var len = path.length;\n    if (path[0] || len < 2) throwInvalidPath();\n    var comp = this.owner;\n    for (var i = 1; i < len; i++) {\n        var name = path[i];\n        if (!allowedNamePattern.test(name)) throwInvalidPath();\n        if (!comp.container) return;\n        comp = comp.container.scope[name];\n        if (!comp) return;\n    }\n    return comp;\n\n    function throwInvalidPath() {\n        throw new Error('path ' + path + ' is invalid');\n    }\n}\n\n\n/**\n * Container instance method\n * Called by `Component.prototype.getState` to get facet's state\n * Returns the state of components in the scope\n *\n * @param {Boolean} deepCopy true by default\n * @return {Object}\n */\nfunction Container$getState(deepCopy) {\n    var state = { scope: {} };\n    if (deepCopy !== false)\n        this.scope._each(function(component, compName) {\n            state.scope[compName] = component._getState();\n        });\n    return state;\n}\n\n\n/**\n * Container instance method\n * Called by `Component.prototype.setState` to set facet's state\n * Sets the state of components in the scope\n *\n * @param {Object} data data to set on facet's model\n */\nfunction Container$setState(state) {\n    _.eachKey(state.scope, function(compData, compName) {\n        var component = this.scope[compName];\n        if (component)\n            component.setState(compData);\n        else\n            logger.warn('component \"' + compName + '\" does not exist on scope');\n    }, this);\n}\n\nfunction Container$destroy(opts) {\n    this.scope._each(function(component) {\n        if (opts.async) _.deferMethod(component, 'destroy', opts);\n        else component.destroy(opts);\n    });\n    this.scope._detachElement();\n    ComponentFacet.prototype.destroy.apply(this, arguments);\n}\n\n\n/**\n * Container instance method\n * Moves all of the contents of the owner into the parent scope\n * \n * @param {Boolean} renameChildren pass false to not rename scope children (default is true)\n * @param {Boolean} destroy If not false, the component will be destroyed at the end (default is true).\n */\nfunction Container$unwrap(renameChildren, destroy) {\n    domUtils.unwrapElement(this.owner.el);\n    if (this.scope)\n        this.scope._each(function (child) {\n            child.remove();\n            if (renameChildren !== false) child.rename(undefined, false);\n            if (this.owner.scope) this.owner.scope._add(child);\n        }, this);\n    if (destroy !== false) this.owner.destroy();\n}\n\n\n/**\n * Container instance method\n * Append component to DOM and to scope\n * @param {Component} comp component that will be appended\n */\nfunction Container$append(comp) {\n    this.scope._add(comp);\n    this.owner.el.appendChild(comp.el);\n}\n\n\n/**\n * Container instance method\n * Insert component to DOM and to scope before another component\n * @param {Component} comp component that will be inserted\n * @param {Component} sibling component before which component will be appended\n */\nfunction Container$insertBefore(comp, sibling) {\n    this.scope._add(comp);\n    this.el.insertBefore(comp.el, sibling && sibling.el);\n}\n\nfunction Container$remove(comp) {\n    this.scope._remove(comp);\n    this.owner.el.removeChild(comp.el);\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match\n    , modelUtils = miloCore.Model._utils\n    , createFacetClass = require('../../util/create_facet_class');\n\n/**\n * Css Facet facilitates the binding of model values to the css classes being applied to the element owned by a milo\n * component.\n *\n * Facet configuration looks like:\n *\n * ```\n * css: {\n *     classes: {\n *        '.someModelProp': 'some-css-class', // Apply css class if the value of '.someModelProp' is truthy\n *        '.someOtherModelProp': {\n *            'value-1': 'some-css-class', // Apply if the value of '.someOtherModelProp' == 'value-1'\n *            'value-2: 'some-other-css-class' // etc\n *        },\n *        '.anotherModelProp': function getCssClass(modelValue) { return ... } // Apply result of function\n *        '.oneMoreModelProp': 'my-$-class' // Template value of '.oneMoreModelProp' (By replacing $ character)\n *     }\n * }\n * ```\n *\n * To bind a data source to the facet, use milo binder:\n *\n * ```\n * milo.binder(someDataSource, '->>', myComponent.css);\n * ```\n *\n * Or else, set data directly on the facet like so:\n *\n * ```\n * component.css.set({\n *     '.someModelProp': 'milo',\n *     '.someOtherModelProp': 'is-cool'\n * });\n */\nvar CssFacet = module.exports = createFacetClass({\n    className: 'Css',\n    methods: {\n        start: CssFacet$start,\n        set: CssFacet$set,\n        del: CssFacet$del,\n        path: CssFacet$path,\n        update: CssFacet$update\n    }\n});\n\n// Config data type to update function\nvar updateHandlers = {\n    string: updateSimple,\n    object: updateByObject,\n    function: updateByFunction\n};\n\nfunction CssFacet$start() {\n    CssFacet.super.start.apply(this, arguments);\n    var getClassList = this.config.getClassList\n\n    this._classList = (getClassList && getClassList.call(this)) || this.owner.el.classList;\n    modelUtils.path.wrapMessengerMethods.call(this);\n\n    this.onSync('changedata', modelUtils.changeDataHandler); // Listen for changes to data source\n    this.activeModelPaths = {}; // Key-Value object: Css classes (key) set by what model paths (value)\n}\n\nfunction CssFacet$set(data) {\n    check(data, Match.OneOf(Object, null, undefined));\n\n    if(data) {\n        var self = this;\n\n        _.eachKey(data, function (value, prop) {\n            var modelPath = prop.charAt(0) !== '.' ? '.' + prop : prop;\n\n            self.update(modelPath, value);\n        });\n    } else {\n        this.del();\n    }\n}\n\nfunction CssFacet$del() {\n    var classList = this._classList;\n    \n    _.eachKey(this.activeModelPaths, function(modelPaths, cssClass) {\n        modelPaths.clear();\n\n        classList.remove(cssClass);\n    });\n}\n\nfunction CssFacet$path(modelPath) {\n    if (!modelPath) return this; // No model path (or '') means the root object\n\n    // Otherwise the modelPath has to exist in the facet configuration\n    return this.config.classes && this.config.classes[modelPath] ? new Path(this, modelPath) : null;\n}\n\nfunction CssFacet$update(modelPath, value) {\n    var cssConfig = this.config.classes[modelPath];\n\n    if (cssConfig) {\n        var handler = updateHandlers[typeof cssConfig];\n\n        handler.call(this, modelPath, cssConfig, value);\n\n        this.postMessageSync('changed', {\n            modelPath: modelPath,\n            modelValue: value\n        });\n    }\n}\n\nfunction updateSimple(modelPath, cssClass, data) {\n    var classList = this._classList;\n    // Remove any css class set via this model path\n    _.eachKey(this.activeModelPaths, function(modelPaths, cssClass) {\n        if (modelPaths.has(modelPath)) {\n            modelPaths.delete(modelPath);\n\n            if (modelPaths.size === 0) // Only remove the class if no other model path is applying it\n                classList.remove(cssClass);\n        }\n    });\n\n    // Apply new css class (cssClass / data can be null if this is a remove only operation)\n    if (cssClass && data) {\n        cssClass = data ? cssClass.replace(/\\$/g, data) : cssClass; // Process any template characters ($) in class name\n\n        var modelPaths = this.activeModelPaths[cssClass] || (this.activeModelPaths[cssClass] = new Set());\n\n        modelPaths.add(modelPath);\n        classList.add(cssClass);\n    }\n}\n\nfunction updateByObject(modelPath, cssClasses, value) {\n    // Apply new css class\n    var cssClass = cssClasses[value];\n\n    updateSimple.call(this, modelPath, cssClass, value);\n}\n\nfunction updateByFunction(modelPath, getCssClassFn, data) {\n    var cssClass = getCssClassFn.call(this, data);\n\n    updateSimple.call(this, modelPath, cssClass, true);\n}\n\n// Path class\n\nfunction Path(cssFacet, modelPath) {\n    this.cssFacet = cssFacet;\n    this.modelPath = modelPath;\n}\n\nPath.prototype.set = function(value) {\n    this.cssFacet.update(this.modelPath, value);\n};\n\nPath.prototype.del = function() {\n    this.set(null);\n};\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , Mixin = miloCore.classes.Mixin\n    , ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n\n    , Messenger = miloCore.Messenger\n    , DOMEventsSource = require('../msg_src/dom_events')\n    , DataMsgAPI = require('../msg_api/data')\n    , getElementDataAccess = require('../msg_api/de_data')\n    , Model = miloCore.Model\n    , pathUtils = Model._utils.path\n    , modelUtils = Model._utils.model\n    , changeDataHandler = Model._utils.changeDataHandler\n    , getTransactionFlag = changeDataHandler.getTransactionFlag\n    , setTransactionFlag = changeDataHandler.setTransactionFlag\n    , postTransactionFinished = changeDataHandler.postTransactionFinished\n\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger;\n\n\n/**\n * `milo.registry.facets.get('Data')`\n * Facet to give access to DOM data\n */\nvar Data = _.createSubclass(ComponentFacet, 'Data');\n\n\n/**\n * Data facet instance methods\n *\n * - [start](#Data$start) - start Data facet\n * - [get](#Data$get) - get DOM data from DOM tree\n * - [set](#Data$set) - set DOM data to DOM tree\n * - [path](#Data$path) - get reference to Data facet by path\n */\n_.extendProto(Data, {\n    start: Data$start,\n    getState: Data$getState,\n    setState: Data$setState,\n\n    get: Data$get,\n    set: Data$set,\n    del: Data$del,\n    splice: Data$splice,\n    len: Data$len,\n    path: Data$path,\n    getPath: Data$getPath,\n    getKey: Data$getKey,\n\n    _get: Data$_get,\n    _set: Data$_set,\n    _del: Data$_del,\n    _splice: Data$_splice,\n    _len: Data$_len,\n\n    _setScalarValue: Data$_setScalarValue,\n    _getScalarValue: Data$_getScalarValue,\n    _bubbleUpDataChange: Data$_bubbleUpDataChange,\n    _queueDataChange: Data$_queueDataChange,\n    _postDataChanges: Data$_postDataChanges,\n    _prepareMessageSource: _prepareMessageSource\n});\n\nfacetsRegistry.add(Data);\n\nmodule.exports = Data;\n\n\n/**\n * ModelPath methods added to Data prototype\n */\n['push', 'pop', 'unshift', 'shift'].forEach(function(methodName) {\n    var method = Model.Path.prototype[methodName];\n    _.defineProperty(Data.prototype, methodName, method);\n});\n\n\n\n// these methods will be wrapped to support \"*\" pattern subscriptions\nvar proxyDataSourceMethods = {\n        // value: 'value',\n        trigger: 'trigger'\n    };\n\n\n/**\n * Data facet instance method\n * Starts Data facet\n * Called by component after component is initialized.\n */\nfunction Data$start() {\n    // change messenger methods to work with \"*\" subscriptions (like Model class)\n    pathUtils.wrapMessengerMethods.call(this);\n\n    ComponentFacet.prototype.start.apply(this, arguments);\n\n    // get/set methods to set data of element\n    this.elData = getElementDataAccess(this.owner.el);\n\n    this._dataChangesQueue = [];\n\n    this._prepareMessageSource();\n\n    // store facet data path\n    this._path = '.' + this.owner.name;\n\n    // current value\n    this._value = this.get();\n\n    // prepare internal and external messengers\n    // this._prepareMessengers();\n\n    // subscribe to DOM event and accessors' messages\n    this.onSync('', onOwnDataChange);\n\n    // message to mark the end of batch on the current level\n    this.onSync('datachangesfinished', onDataChangesFinished);\n\n    // changes in scope children with Data facet\n    this.onSync('childdata', onChildData);\n\n    // to enable reactive connections\n    this.onSync('changedata', changeDataHandler);\n}\n\n\n/**\n * Data facet instance method\n * Create and connect internal and external messengers of Data facet.\n * External messenger's methods are proxied on the Data facet and they allows \"*\" subscriptions.\n */\n// function _prepareMessengers() {\n    // Data facet will post all its changes on internal messenger\n    // var internalMessenger = new Messenger(this);\n\n    // message source to connect internal messenger to external\n    // var internalMessengerSource = new MessengerMessageSource(this, undefined, new ModelMsgAPI, internalMessenger);\n\n    // external messenger to which all model users will subscribe,\n    // that will allow \"*\" subscriptions and support \"changedata\" message api.\n    // var externalMessenger = new Messenger(this, Messenger.defaultMethods, internalMessengerSource);\n\n//     _.defineProperties(this, {\n//         _messenger: externalMessenger,\n//         _internalMessenger: internalMessenger\n//     });\n// }\n\n\n/**\n * Data facet instance method\n * Initializes DOMEventsSource and connects it to Data facet messenger\n *\n * @private\n */\nfunction _prepareMessageSource() {\n    var dataAPI = new DataMsgAPI(this.owner)\n        , dataEventsSource = new DOMEventsSource(this, proxyDataSourceMethods, dataAPI, this.owner);\n    this._setMessageSource(dataEventsSource);\n\n    _.defineProperty(this, '_dataEventsSource', dataEventsSource);\n\n    // make value method of DataMsgAPI available on Data facet\n    // this is a private method, get() should be used to get data.\n    Mixin.prototype._createProxyMethod.call(dataAPI, 'value', 'value', this);\n}\n\n\n/**\n * Subscriber to data change event\n *\n * @private\n * @param {String} msgType in this instance will be ''\n * @param {Object} data data change information\n */\nfunction onOwnDataChange(msgType, data) {\n    this._bubbleUpDataChange(data);\n    this._queueDataChange(data);\n    if (data.path === '') {\n        var inTransaction = getTransactionFlag(data);\n        this.postMessage('datachangesfinished', { transaction: inTransaction });\n    }\n}\n\n\n/**\n * Data facet instance method\n * Sends data `message` to DOM parent\n *\n * @private\n * @param {Object} msgData data change message\n */\nfunction Data$_bubbleUpDataChange(msgData) {\n    var parentData = this.scopeParent();\n\n    if (parentData) {\n        var parentMsg = _.clone(msgData);\n        parentMsg.path = (this._path || ('.' + this.owner.name))  + parentMsg.path;\n        parentData.postMessage('childdata', parentMsg || msgData);\n    }\n}\n\n\n/**\n * Data facet instance method\n * Queues data messages to be dispatched to connector\n *\n * @private\n * @param {Object} change data change description\n */\nfunction Data$_queueDataChange(change) {\n    this._dataChangesQueue.push(change);\n}\n\n\n/**\n * Subscriber to datachangesfinished event.\n * Calls the method to post changes batch and bubbles up the message\n *\n * @param  {String} msg\n * @param  {Object} [data]\n */\nfunction onDataChangesFinished(msg, data) {\n    this._postDataChanges(data.inTransaction);\n    var parentData = this.scopeParent();\n    if (parentData) parentData.postMessage('datachangesfinished', data);\n}\n\n\n/**\n * Dispatches all changes collected in the batch\n * Used for data propagation - connector subscribes to this message\n *\n * @private\n */\nfunction Data$_postDataChanges(inTransaction) {\n    var queue = this._dataChangesQueue.reverse();\n    this.postMessageSync('datachanges', {\n        changes: queue,\n        transaction: inTransaction\n    });\n    this._dataChangesQueue = []; // it can't be .length = 0, as the actual array may still be used\n}\n\n\n/**\n * Subscriber to data change event in child Data facet\n *\n * @private\n * @param {String} msgType\n * @param {Obejct} data data change information\n */\nfunction onChildData(msgType, data) {\n    this.postMessage(data.path, data);\n    this._bubbleUpDataChange(data);\n    this._queueDataChange(data);\n}\n\n\n/**\n * Data facet instance method\n * Sets data in DOM hierarchy recursively.\n * Returns the object with the data actually set (can be different, if components matching some properties are missing).\n *\n * @param {Object|String|Number} value value to be set. If the value if scalar, it will be set on component's element, if the value is object - on DOM tree inside component\n * @return {Object|String|Number}\n */\nfunction Data$set(value) {\n    var inTransaction = getTransactionFlag(Data$set);\n\n    try {\n        return executeHook.call(this, 'set', arguments);\n    } catch (e) {\n        if (e != noHook) throw e;\n    }\n\n    setTransactionFlag(this._set, inTransaction);\n\n    var oldValue = this._value\n        , newValue = this._set(value);\n\n    // this message triggers onOwnDataChange, as well as actuall DOM change\n    // so the parent gets notified\n    var msg = { path: '', type: 'changed',\n                newValue: newValue, oldValue: oldValue };\n    setTransactionFlag(msg, inTransaction);\n    this.postMessage('', msg);\n\n    return newValue;\n}\n\n\nfunction Data$_set(value) {\n    var inTransaction = getTransactionFlag(Data$_set);\n\n    var valueSet;\n    if (value !== null && typeof value == 'object') {\n        if (Array.isArray(value)) {\n            valueSet = [];\n\n            var listFacet = this.owner.list;\n            if (listFacet){\n                var listLength = listFacet.count()\n                    , newItemsCount = value.length - listLength;\n                if (newItemsCount >= 3) {\n                    listFacet._addItems(newItemsCount);\n                    listFacet._updateDataPaths(listLength, listFacet.count());\n                }\n\n                value.forEach(function(childValue, index) {\n                    setChildData.call(this, valueSet, childValue, index, '[$$]');\n                }, this);\n\n                var listCount = listFacet.count()\n                    , removeCount = listCount - value.length;\n\n                while (removeCount-- > 0)\n                    listFacet._removeItem(value.length);\n            } else\n                logger.warn('Data: setting array data without List facet');\n        } else {\n            valueSet = {};\n            _.eachKey(value, function(childValue, key) {\n                setChildData.call(this, valueSet, childValue, key, '.$$');\n            }, this);\n        }\n    } else\n        valueSet = this._setScalarValue(value);\n\n    this._value = valueSet;\n\n    return valueSet;\n\n\n    function setChildData(valueSet, childValue, key, pathSyntax) {\n        var childPath = pathSyntax.replace('$$', key);\n        var childDataFacet = this.path(childPath, typeof childValue != 'undefined');\n        if (childDataFacet) {\n            setTransactionFlag(childDataFacet.set, inTransaction);\n            valueSet[key] = childDataFacet.set(childValue);\n        }\n    }\n}\n\n\n/**\n * Data facet instance method\n * Deletes component from view and scope, only in case it has Item facet on it\n */\nfunction Data$del() {\n    var inTransaction = getTransactionFlag(Data$del);\n\n    try {\n        var result = executeHook.call(this, 'del');\n        postTransactionFinished.call(this, inTransaction);\n        return result;\n    } catch (e) {\n        if (e != noHook) throw e;\n    }\n\n    var oldValue = this._value;\n\n    setTransactionFlag(this._del, inTransaction);\n    this._del();\n\n    // this message triggers onOwnDataChange, as well as actuall DOM change\n    // so the parent gets notified\n    var msg = { path: '', type: 'deleted', oldValue: oldValue };\n    setTransactionFlag(msg, inTransaction);\n    this.postMessage('', msg);\n}\n\n\nfunction Data$_del() {\n    var inTransaction = getTransactionFlag(Data$_del);\n    setTransactionFlag(this._set, inTransaction);\n    this._set();\n}\n\n\n/**\n * Data facet instance method\n * Sets scalar value to DOM element\n *\n * @private\n * @param {String|Number} value value to set to DOM element\n */\nfunction Data$_setScalarValue(value) {\n    return this.elData.set(this.owner.el, value);\n}\n\n\n/**\n * Data facet instance method\n * Get structured data from DOM hierarchy recursively\n * Returns DOM data\n *\n * @param {Boolean} deepGet true by default\n * @return {Object}\n */\nfunction Data$get(deepGet) {\n    try {\n        return executeHook.call(this, 'get', arguments);\n    } catch (e) {\n        if (e != noHook) throw e;\n    }\n\n    return this._get(deepGet);\n}\n\nfunction Data$_get(deepGet) {\n    if (deepGet === false) // a hack to enable getting shallow state\n        return;\n\n    var comp = this.owner\n        , scopeData;\n\n    if (comp.list) {\n        scopeData = [];\n        comp.list.each(function(listItem, index) {\n            scopeData[index] = listItem.data.get();\n        });\n\n        if (comp.container)\n            comp.container.scope._each(function(scopeItem, name) {\n                if (! comp.list.contains(scopeItem) && scopeItem.data)\n                    scopeData[name] = scopeItem.data.get();\n            });\n    } else if (comp.container) {\n        scopeData = {};\n        comp.container.scope._each(function(scopeItem, name) {\n            if (scopeItem.data)\n                scopeData[name] = scopeItem.data.get();\n        });\n    } else\n        scopeData = this._getScalarValue();\n\n    this._value = scopeData;\n\n    return scopeData;\n}\n\n\n/**\n * Data facet instance method\n * Gets scalar data from DOM element\n *\n * @private\n */\nfunction Data$_getScalarValue() {\n    return this.elData.get(this.owner.el);\n}\n\n\n/**\n * Data facet instance method\n * Splices List items. Requires List facet to be present on component. Works in the same way as array splice.\n * Returns data retrieved from removed items\n *\n * @param {Integer} spliceIndex index to delete/insert at\n * @param {Integer} spliceHowMany number of items to delete\n * @param {List} arguments optional items to insert\n * @return {Array}\n */\nfunction Data$splice(spliceIndex, spliceHowMany) { //, ... arguments\n    var inTransaction = getTransactionFlag(Data$splice);\n    var result;\n\n    try {\n        result = executeHook.call(this, 'splice', arguments);\n        postTransactionFinished.call(this, inTransaction);\n        return result;\n    } catch (e) {\n        if (e != noHook) throw e;\n    }\n\n    setTransactionFlag(this._splice, inTransaction);\n    result = this._splice.apply(this, arguments);\n\n    if (!result) return;\n\n    var msg = { path: '', type: 'splice',\n                index: result.spliceIndex,\n                removed: result.removed,\n                addedCount: result.addedCount,\n                newValue: this._value };\n    setTransactionFlag(msg, inTransaction);\n    this.postMessage('', msg);\n\n    return result.removed;\n}\n\n\nvar noHook = {};\nfunction executeHook(methodName, args) {\n    var hook = this.config[methodName];\n    switch (typeof hook) {\n        case 'function':\n            return hook.apply(this.owner, args);\n\n        case 'string':\n            return this.owner[hook].apply(this.owner, args);\n\n        default:\n            throw noHook;\n    }\n}\n\n\nfunction Data$_splice(spliceIndex, spliceHowMany) { //, ... arguments\n    var inTransaction = getTransactionFlag(Data$_splice);\n\n    var listFacet = this.owner.list;\n    if (! listFacet)\n        return logger.warn('Data: cannot use splice method without List facet');\n\n    var removed = [];\n\n    var listLength = listFacet.count();\n    arguments[0] = spliceIndex =\n        modelUtils.normalizeSpliceIndex(spliceIndex, listLength);\n\n    if (spliceHowMany > 0 && listLength > 0) {\n        for (var i = spliceIndex; i < spliceIndex + spliceHowMany; i++) {\n            var item = listFacet.item(spliceIndex);\n            if (item) {\n                var itemData = item.data.get();\n                listFacet._removeItem(spliceIndex);\n            } else\n                logger.warn('Data: no item for index', i);\n\n            removed.push(itemData);\n        }\n\n        listFacet._updateDataPaths(spliceIndex, listFacet.count());\n    }\n\n    var added = [];\n\n    var argsLen = arguments.length\n        , addItems = argsLen > 2\n        , addedCount = argsLen - 2;\n    if (addItems) {\n        listFacet._addItems(addedCount, spliceIndex);\n        for (var i = 2, j = spliceIndex; i < argsLen; i++, j++) {\n            item = listFacet.item(j);\n            if (item) {\n                setTransactionFlag(item.data.set, inTransaction);\n                itemData = item.data.set(arguments[i]);\n            } else\n                logger.warn('Data: no item for index', j);\n\n            added.push(itemData);\n        }\n\n        // change paths of items that were added and items after them\n        listFacet._updateDataPaths(spliceIndex, listFacet.count());\n    }\n\n    // if (Array.isArray(this._value)) {\n    //     _.prependArray(added, [spliceIndex, spliceHowMany]);\n    //     Array.prototype.splice.apply(this._value, added);\n    // } else\n        this._value = this.get();\n\n    return {\n        spliceIndex: spliceIndex,\n        removed: removed,\n        addedCount: addItems ? addedCount : 0\n    };\n}\n\n\nfunction Data$len() {\n    try {\n        return executeHook.call(this, 'len');\n    } catch (e) {\n        if (e != noHook) throw e;\n    }\n    \n    return this._len();\n}\n\n\nfunction Data$_len() {\n    if (this.owner.list) return this.owner.list.count();\n    else logger.error('Data: len called without list facet');\n}\n\n\n/**\n * Data facet instance method\n * Returns data facet of a child component (by scopes) corresponding to the path\n * @param {String} accessPath data access path\n */\nfunction Data$path(accessPath, createItem) {\n    // createItem = true; // this hack seems to be no longer needed...\n\n    if (! accessPath)\n        return this;\n\n    var parsedPath = pathUtils.parseAccessPath(accessPath);\n    var currentComponent = this.owner;\n\n    for (var i = 0, len = parsedPath.length; i < len; i++) {\n        var pathNode = parsedPath[i]\n            , nodeKey = pathUtils.getPathNodeKey(pathNode);\n        if (pathNode.syntax == 'array' && currentComponent.list) {\n            var itemComponent = currentComponent.list.item(nodeKey);\n            if (! itemComponent && createItem !== false) {\n                itemComponent = currentComponent.list._addItem(nodeKey);\n                itemComponent.data._path = pathNode.property;\n            }\n            currentComponent = itemComponent;\n        } else if (currentComponent.container)\n            currentComponent = currentComponent.container.scope[nodeKey];\n\n        var currentDataFacet = currentComponent && currentComponent.data;\n        if (! currentDataFacet)\n            break;\n    }\n\n    return currentDataFacet;\n}\n\n\n/**\n * Data facet instance method\n * Returns path to access this data facet from parent (using path method)\n *\n * @return {String}\n */\nfunction Data$getPath() {\n    return this._path;\n}\n\n\n/**\n * Data facet instance method\n * Returns key to access the value related to this data facet on the value related to parent data facet.\n * If component has List facet, returns index\n *\n * @return {String|Integer}\n */\nfunction Data$getKey() {\n    var path = this._path;\n    return path[0] == '['\n            ? +path.slice(1, -1) // remove \"[\" and \"]\"\n            : path.slice(1); // remove leading \".\"\n}\n\n\n/**\n * Data facet instance method\n * Called by `Component.prototype.getState` to get facet's state\n * Returns DOM data\n *\n * @param {Boolean} deepState, true by default\n * @return {Object}\n */\nfunction Data$getState(deepState) {\n    return { state: this.get(deepState) };\n}\n\n\n/**\n * Data facet instance method\n * Called by `Component.prototype.setState` to set facet's state\n * Simply sets model data\n *\n * @param {Object} state data to set on facet's model\n */\nfunction Data$setState(state) {\n    return this.set(state.state);\n}\n",
    "'use strict';\n\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry') \n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match\n    , doT = miloCore.util.doT\n    , binder = require('../../binder')\n    , BindAttribute = require('../../attributes/a_bind')\n    , domUtils = require('../../util/dom')\n    , config = require('../../config');\n\n\n/**\n * `milo.registry.facets.get('Dom')`\n * Facet with component related dom utils\n */\nvar Dom = _.createSubclass(ComponentFacet, 'Dom');\n\n_.extend(Dom, {\n    createElement: Dom$$createElement\n});\n\n\n/**\n * Facet class method\n * Creates an element from a passed configuation object\n * \n * @param {Object} config with the properties `domConfig`, `content`, `template`\n * @return {Element} an html element \n */\nfunction Dom$$createElement(config) {\n    var domConfig = config.domConfig || {}\n        , tagName = domConfig.tagName || 'div'\n        , newEl = document.createElement(tagName)\n        , content = config.content\n        , template = config.template;\n\n    // TODO it will be called again when/if component is instantiated\n    // Should be someproperty on element to indicate it's been called?\n    _applyConfigToElement(newEl, domConfig);\n\n    if (typeof content == 'string') {\n        if (template)\n            newEl.innerHTML = doT.template(template)({content: content});\n        else\n            newEl.innerHTML = content;\n    }\n    return newEl;\n}\n\n\nfunction _applyConfigToElement(el, config) {\n    var cssClasses = config && config.cls\n        , configAttributes = config && config.attributes;\n\n    if (configAttributes)\n        _.eachKey(configAttributes, function(attrValue, attrName) {\n            el.setAttribute(attrName, attrValue);\n        });\n\n    if (cssClasses)\n        _attachCssClasses(el, 'add', cssClasses);\n}\n\n\n_.extendProto(Dom, {\n    start: start,\n\n    show: show,\n    hide: hide,\n    toggle: toggle,\n    detach: detach,\n    remove: remove,\n    append: append,\n    prepend: prepend,\n    appendChildren: appendChildren,\n    prependChildren: prependChildren,\n    insertAfter: insertAfter,\n    insertBefore: insertBefore,\n    appendToScopeParent: appendToScopeParent,\n    children: Dom$children,\n    setStyle: setStyle,\n    setStyles: setStyles,\n    copy: copy,\n    createElement: createElement,\n\n    addCssClasses: _.partial(_manageCssClasses, 'add'),\n    removeCssClasses: _.partial(_manageCssClasses, 'remove'),\n    toggleCssClasses: _.partial(_manageCssClasses, 'toggle'),\n\n    find: find,\n    hasTextBeforeSelection: hasTextBeforeSelection,\n    hasTextAfterSelection: hasTextAfterSelection,\n});\n\nfacetsRegistry.add(Dom);\n\nmodule.exports = Dom;\n\n\n// start Dom facet\nfunction start() {\n    var el = this.owner.el;\n    _applyConfigToElement(el, this.config);\n    var currentStyle = window.getComputedStyle(el);\n    this._visible = currentStyle && currentStyle.display != 'none';\n}\n\n// show HTML element of component\nfunction show() {\n    this.toggle(true);\n}\n\n// hide HTML element of component\nfunction hide() {\n    this.toggle(false);\n}\n\n// show/hide\nfunction toggle(doShow) {\n    doShow = typeof doShow == 'undefined'\n                ? ! this._visible\n                : !! doShow;\n\n    this._visible = doShow;\n    var el = this.owner.el;\n\n    el.style.display = doShow ? 'block' : 'none';\n\n    return doShow;\n}\n\n\nfunction _manageCssClasses(methodName, cssClasses, enforce) {\n    _attachCssClasses(this.owner.el, methodName, cssClasses, enforce);\n}\n\n\nfunction _attachCssClasses(el, methodName, cssClasses, enforce) {\n    var classList = el.classList\n        , doToggle = methodName == 'toggle';\n\n    if (Array.isArray(cssClasses))\n        cssClasses.forEach(callMethod);\n    else if (typeof cssClasses == 'string')\n        callMethod(cssClasses);\n    else\n        throw new Error('unknown type of CSS classes parameter');\n\n    function callMethod(cssCls) {\n        if (doToggle) {\n            // Only pass 'enforce' if a value has been provided (The 'toggle' function of the classList will treat undefined === false resulting in only allowing classes to be removed)\n            if (enforce === undefined) classList[methodName](cssCls) \n            else classList[methodName](cssCls, enforce);\n        } else\n            classList[methodName](cssCls);\n    }\n}\n\n\nfunction detach() {\n    if (this.owner.el)  \n        domUtils.detachComponent(this.owner.el);\n}\n\n\nfunction setStyle(property, value) {\n    if (!this.owner.el) {\n        throw new Error(\"Cannot call setStyle on owner with no element: \" + this.owner.constructor.name);\n    }\n    this.owner.el.style[property] = value;\n}\n\nfunction setStyles(properties) {\n    for (var property in properties)\n        this.owner.el.style[property] = properties[property];\n}\n\n\n// create a copy of DOM element using facet config if set\nfunction copy(isDeep) {\n    return this.owner.el && this.owner.el.cloneNode(isDeep);\n}\n\n\nfunction createElement() {\n    var newEl = Dom.createElement(this.config);\n    return newEl;\n}\n\n\n// remove HTML element of component\nfunction remove() {\n    domUtils.removeElement(this.owner.el);\n}\n\n// append inside HTML element of component\nfunction append(el) {\n    this.owner.el.appendChild(el);\n}\n\n// prepend inside HTML element of component\nfunction prepend(el) {\n    var thisEl = this.owner.el\n        , firstChild = thisEl.firstChild;\n    if (firstChild)\n        thisEl.insertBefore(el, firstChild);\n    else\n        thisEl.appendChild(el);\n}\n\n// appends children of element inside this component's element\nfunction appendChildren(el) {\n    while(el.childNodes.length)\n        this.append(el.childNodes[0]);\n}\n\n// prepends children of element inside this component's element\nfunction prependChildren(el) {\n    while(el.childNodes.length)\n        this.prepend(el.childNodes[el.childNodes.length - 1]);\n}\n\nfunction insertAfter(el) {\n    var thisEl = this.owner.el\n        , parent = thisEl.parentNode;    \n    parent.insertBefore(el, thisEl.nextSibling);\n}\n\nfunction insertBefore(el) {\n    var thisEl = this.owner.el\n        , parent = thisEl.parentNode;\n    parent.insertBefore(el, thisEl);\n}\n\n\n// appends component's element to scope parent. If it was alredy in DOM it will be moved\nfunction appendToScopeParent() {\n    var parent = this.owner.getScopeParent();\n    if (parent) parent.el.appendChild(this.owner.el);\n}\n\n\n/**\n * Dom facet instance method\n * Returns the list of child elements of the component element\n *\n * @return {Array<Element>}\n */\nfunction Dom$children() {\n    return domUtils.children(this.owner.el);\n}\n\n\nvar findDirections = {\n    'up': 'previousNode',\n    'down': 'nextNode'\n};\n\n// Finds component passing optional iterator's test\n// in the same scope as the current component (this)\n// by traversing DOM tree upwards (direction = \"up\")\n// or downwards (direction = \"down\")\nfunction find(direction, iterator) {\n    if (! findDirections.hasOwnProperty(direction))\n        throw new Error('incorrect find direction: ' + direction);\n\n    var el = this.owner.el\n        , scope = this.owner.scope\n        , treeWalker = document.createTreeWalker(scope._rootEl, NodeFilter.SHOW_ELEMENT);\n\n    treeWalker.currentNode = el;\n    var nextNode = treeWalker[findDirections[direction]]()\n        , componentsNames = Object.keys(scope)\n        , found = false;\n\n    while (nextNode) {\n        var attr = new BindAttribute(nextNode);\n        if (attr.node) {\n            attr.parse().validate();\n            if (scope.hasOwnProperty(attr.compName)) {\n                var component = scope[attr.compName];\n                if (! iterator || iterator(component)) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n        treeWalker.currentNode = nextNode;\n        nextNode = treeWalker[findDirections[direction]]();\n    }\n\n    if (found) return component;\n}\n\n\n// returns true if the element has text before selection\nfunction hasTextBeforeSelection() {\n    var selection = window.getSelection();\n    if (! selection.isCollapsed) return true;\n    \n    var text = selection.focusNode && selection.focusNode.textContent;\n    var startPos = text && text.charAt(0) == ' ' ? 1 : 0;\n    if (selection.anchorOffset != startPos) return true;\n\n    // walk up the DOM tree to check if there are text nodes before cursor\n    var treeWalker = document.createTreeWalker(this.owner.el, NodeFilter.SHOW_TEXT);\n    treeWalker.currentNode = selection.anchorNode;\n    var prevNode = treeWalker.previousNode();\n\n    var isText = prevNode ? prevNode.nodeValue.trim() !== '' : false;\n\n    return isText;\n}\n\n\nfunction hasTextAfterSelection() {\n    var selection = window.getSelection();\n    if (! selection.isCollapsed) return true;\n\n    var text = selection.focusNode && selection.focusNode.textContent;\n    var startPos = text && text.charAt(text.length-1) == ' ' ? selection.anchorNode.length-1 : selection.anchorNode.length;\n    if (selection.anchorOffset < startPos) return true;\n\n    // walk up the DOM tree to check if there are text nodes after cursor\n    var treeWalker = document.createTreeWalker(this.owner.el, NodeFilter.SHOW_TEXT);\n    treeWalker.currentNode = selection.anchorNode;\n    var nextNode = treeWalker.nextNode();\n    \n    //To capture when treewalker gives us an empty text node (unknown reason)\n    var isText = nextNode ? !nextNode.nodeValue.trim() == '' : false;\n\n    return isText;\n}\n",
    "'use strict';\n\n// <a name=\"components-facets-drag\"></a>\n// ###drag facet\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , DOMEventsSource = require('../msg_src/dom_events')\n    , Component = require('../c_class')\n    , DragDrop = require('../../util/dragdrop')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger;\n\n\n/**\n * `milo.registry.facets.get('Drag')`\n * Facet for components that can be dragged\n * Drag facet supports the following configuration parameters:\n *\n *  - meta: object with properties\n *      - params: object of key-value pairs that will be passed in metadata data type (can also be function or method name that returns this object). See config.dragDrop.dataTypes.componentMetaTemplate\n *      - data: data that will be stored in the above meta data type (or function)\n *  - allowedEffects: string (or function) as specified here: https://developer.mozilla.org/en-US/docs/DragDrop/Drag_Operations#dragstart\n *  - dragImage:\n *      - url: path to image to display when dragging, instead of the owner element\n *      - x: x offset for the image\n *      - y: y offset for the image\n *  - dragCls: CSS class to apply to the component being dragged\n *  - dataTypes: map of additional data types the component will supply to data transfer object, key is data type, value is a function that returns it, component will be passed as the context to this function\n *\n * If function is specified in any parameter it will be called with the component as the context\n */\nvar Drag = _.createSubclass(ComponentFacet, 'Drag');\n\n_.extendProto(Drag, {\n    init: Drag$init,\n    start: Drag$start,\n    setHandle: Drag$setHandle\n});\n\nfacetsRegistry.add(Drag);\n\nmodule.exports = Drag;\n\n\nfunction Drag$init() {\n    ComponentFacet.prototype.init.apply(this, arguments);\n\n    this._createMessageSourceWithAPI(DOMEventsSource);\n    this._dragData = {};\n\n    var dataTypeInfo = this.config._dataTypeInfo || '';\n    this._dataTypeInfo = typeof dataTypeInfo == 'function'\n                            ? dataTypeInfo\n                            : function() { return dataTypeInfo; };\n}\n\n\n/**\n * Drag facet instance method\n * Sets the drag handle element of component. This element has to be dragged for the component to be dragged.\n *\n * @param {Element} handleEl\n */\nfunction Drag$setHandle(handleEl) {\n    if (! this.owner.el.contains(handleEl))\n        return logger.warn('drag handle should be inside element to be dragged');\n    this._dragHandle = handleEl;\n}\n\n\nfunction Drag$start() {\n    ComponentFacet.prototype.start.apply(this, arguments);\n    _addDragAttribute.call(this);\n    _createDragImage.call(this);\n    _toggleDragCls.call(this, false);\n\n    this.onMessages({\n        'mousedown': onMouseDown,\n        'mouseenter mouseleave mousemove': onMouseMovement,\n        'dragstart': onDragStart,\n        'drag': onDragging,\n        'dragend': onDragEnd\n    });\n\n    this.owner.onMessages({\n        'getstatestarted': _removeDragAttribute,\n        'getstatecompleted': _addDragAttribute\n    });\n}\n\n\n/**\n * Adds draggable attribute to component's element\n *\n * @private\n */\nfunction _addDragAttribute() {\n    if (this.el) this.el.setAttribute('draggable', true);\n}\n\n\nfunction _removeDragAttribute() {\n    if (this.el) this.el.removeAttribute('draggable');\n}\n\n\nfunction _createDragImage() {\n    var dragImage = this.config.dragImage;\n    if (dragImage) {\n        this._dragElement = new Image();\n        this._dragElement.src = dragImage.url;\n    }\n}\n\n\nfunction onMouseDown(eventType, event) {\n    this.__mouseDownTarget = event.target;\n    if (targetInDragHandle.call(this)) {\n        window.getSelection().empty();\n        event.stopPropagation();\n    }\n}\n\n\nfunction onMouseMovement(eventType, event) {\n    var shouldBeDraggable = targetInDragHandle.call(this);\n    this.owner.el.setAttribute('draggable', shouldBeDraggable);\n    if (document.body.getAttribute('data-dragEnableEvent') != 'false')\n        event.stopPropagation();\n}\n\n\nfunction onDragStart(eventType, event) {\n    event.stopPropagation();\n\n    if (this.config.off || ! targetInDragHandle.call(this)) {\n        event.preventDefault();\n        return;\n    }\n\n    var dragImage = this.config.dragImage;\n    if (dragImage)\n        event.dataTransfer.setDragImage(this._dragElement, dragImage.x || 0, dragImage.y || 0);\n\n    var owner = this.owner;\n    var dt = new DragDrop(event);\n\n    this._dragData = dt.setComponentState(owner);\n    setMeta.call(this);\n    setAdditionalDataTypes.call(this);\n    _setAllowedEffects.call(this, dt);\n\n    _toggleDragCls.call(this, true);\n\n    DragDrop.service.postMessageSync('dragdropstarted', {\n        eventType: 'dragstart',\n        dragDrop: dt,\n        dragFacet: this\n    });\n\n    function setMeta() {\n        var params = getMetaData.call(this, 'params')\n            , data = getMetaData.call(this, 'data');\n\n        this._dragMetaDataType = dt.setComponentMeta(owner, params, data);\n        this._dragMetaData = data;\n    }\n\n    function getMetaData(property) {\n        try { var func = this.config.meta[property]; } catch(e) {}\n        if (typeof func == 'string') func = owner[func];\n        return _.result(func, owner);\n    }\n\n    function setAdditionalDataTypes() {\n        if (this.config.dataTypes) {\n            this._dataTypesData = _.mapKeys(this.config.dataTypes, function (getDataFunc, dataType) {\n                var data = getDataFunc.call(this.owner, dataType);\n                if (typeof data == 'object') data = JSON.stringify(data);\n                if (data) dt.setData(dataType, data);\n                return data;\n            }, this);\n        }\n    }\n}\n\n\nfunction onDragging(eventType, event) {\n    if (_dragIsDisabled.call(this, event)) return;\n\n    var dt = new DragDrop(event);\n    dt.setComponentState(this.owner, this._dragData);\n    dt.setData(this._dragMetaDataType, this._dragMetaData);\n    if (this._dataTypesData) {\n        _.eachKey(this._dataTypesData, function(data, dataType) {\n            if (data) dt.setData(dataType, data);\n        });\n    }\n\n    _setAllowedEffects.call(this, dt);\n}\n\n\nfunction onDragEnd(eventType, event) {\n    if (_dragIsDisabled.call(this, event)) return;\n    event.stopPropagation();\n\n    _toggleDragCls.call(this, false);\n\n    var dt = new DragDrop(event);\n    DragDrop.service.postMessageSync('completedragdrop', {\n        eventType: 'dragend',\n        dragDrop: dt,\n        dragFacet: this\n    });\n}\n\n\nfunction _toggleDragCls(showHide) {\n    if (this.config.dragCls)\n        this.owner.el.classList.toggle(this.config.dragCls, showHide);\n}\n\n\nfunction _setAllowedEffects(DragDrop) {\n    var effects = _.result(this.config.allowedEffects, this.owner);\n    DragDrop.setAllowedEffects(effects);\n}\n\n\nfunction targetInDragHandle() {\n    return ! this._dragHandle || this._dragHandle.contains(this.__mouseDownTarget);\n}\n\n\nfunction _dragIsDisabled(event) {\n    if (this.config.off) {\n        event.preventDefault();\n        return true;\n    }\n    return false;\n}\n",
    "'use strict';\n\n// <a name=\"components-facets-drop\"></a>\n// ###drop facet\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , DOMEventsSource = require('../msg_src/dom_events')\n    , DropMsgAPI = require('../msg_api/drop')\n    , DragDrop = require('../../util/dragdrop')\n    , _ = require('milo-core').proto;\n\n/**\n * `milo.registry.facets.get('Drop')`\n * Facet for components that can accept drops\n * Drop facet supports the following configuration parameters:\n *\n *  - allow - an object that will define allowed data types during drag (`dragenter` and `dragover` events) with these properties:\n *      - components: `true` by default (all components will be accepted)\n *                        OR string with allowed component class\n *                        OR list of allowed components classes (strings)\n *                        OR map with allowed classes in keys and `true`/test functions in values\n *                        OR test function that will be passed object defined below\n *                        OR `false` to NOT accept components\n *      - dataTypes:  `false` by default (no other data types will be accepted)\n *                        OR string with allowed data type\n *                        OR list of additional data types that a drop target would accept\n *                        OR test function that will be passed DragDrop object\n *                        OR `true` to accept all data types\n *      - checkParent: `false` by default\n *                        OR `true` will call parent component drop allow to check if parent component will accept the component\n *      If test functions are used, they should return boolean. Each test function can also set drop effect as defined here:\n *      https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer#dropEffect.28.29\n *      Setting drop effect that is not allowed by dragged object will prevent drop.\n *      Test functions for components will be passed the owner of Drop facet as context, the object with the following possible properties as the first parameter:\n *          compClass - name of component class as stored in registry\n *          compName - name of component (all lowercase)\n *          params - parameters as encoded in dataType, passed to `milo.util.dragDrop.setComponentMeta` by Drag facet\n *          metaDataType - data type of the data that has compClass, compName and params encoded\n *\n *      ... and DragDrop instance as the second parameter\n *\n *      Test function for other data types will be passed the owner of Drop facet as context and DragDrop instance as the first parameter\n *\n * ####Events####\n *\n * In addition to configuring allowed components and data types, components classes should subscribe to events.\n * At the very least, they should subscribe to `drop` event.\n *\n * Drop facet emits dragin/dragout messages that are emitted whenever actual component element is entered or left\n * (which is different from dragenter and dragleave messages that are emitted whenever any child element is entered or left, as long as event bubbles up)\n * If child component has drop facet attached, dragout will be emitted on the current component when the child is entered.\n *\n * You can see the demonstration of when messages are emitted [here](http://jsbin.com/buqov/6)\n * \n */\nvar Drop = _.createSubclass(ComponentFacet, 'Drop');\n\n\n_.extendProto(Drop, {\n    init: Drop$init,\n    start: Drop$start\n    // _reattach: _reattachEventsOnElementChange\n});\n\nfacetsRegistry.add(Drop);\n\nmodule.exports = Drop;\n\n\nfunction Drop$init() {\n    ComponentFacet.prototype.init.apply(this, arguments);\n    this._createMessageSourceWithAPI(DOMEventsSource, new DropMsgAPI);\n}\n\n\nfunction Drop$start() {\n    ComponentFacet.prototype.start.apply(this, arguments);\n    this.owner.el.classList.add('cc-module-relative');\n    this.onMessages({\n        'dragenter dragover': onDragging,\n        'drop': onDrop,\n        'dragenter dragover dragleave drop dragin dragout': postToService\n    });\n}\n\n\nfunction onDragging(eventType, event) {\n    var dt = new DragDrop(event);\n\n    event.stopPropagation();\n    event.preventDefault();\n\n    if (! _handleDropDependency.call(this, dt))\n        dt.setDropEffect('none');\n}\n\n\nfunction onDrop(eventType, event) {\n    event.stopPropagation();\n    var dt = new DragDrop(event);\n    DragDrop.service.postMessageSync('dragdropcompleted', {\n        eventType: 'drop',\n        dragDrop: dt,\n        dropFacet: this,\n        component: this.owner\n    });\n}\n\n\nfunction postToService(eventType, event) {\n    DragDrop.service.postMessageSync(eventType, {\n        event: event,\n        dropFacet: this,\n        component: this.owner\n    });\n}\n\n\nvar _handleDropDependency = _.throttle(_handleDropDependencyNothrottle, 50);\nfunction _handleDropDependencyNothrottle(dt, originalDropComponent) {\n    var allow = this.config.allow\n        , parentAllowed = true;\n\n    originalDropComponent = originalDropComponent || this.owner;\n\n    if (allow && allow.checkParent) {\n        var parent = this.owner.getScopeParent('Drop');\n        if (parent)\n            parentAllowed = _handleDropDependencyNothrottle.call(parent.drop, dt, originalDropComponent);\n    }\n\n    return parentAllowed && _isDropAllowed.call(this, dt, originalDropComponent);\n}\n\n\n/**\n * Checks if drop is allowed based on facet configuration (see above)\n * \n * @param {DragDrop} dt\n * @return {Boolean}\n */\nfunction _isDropAllowed(dt, originalDropComponent) {\n    var allow = this.config.allow;\n\n    if (dt.isComponent()) {\n        var allowComps = allow && allow.components\n            , meta = dt.getComponentMeta();\n\n        switch (typeof allowComps) {\n            case 'undefined':\n                return true;\n            case 'boolean':\n                return allowComps;\n            // component class\n            case 'string':\n                return meta && meta.compClass == allowComps;\n            // test function\n            case 'function':\n                return allowComps.call(this.owner, meta, dt, originalDropComponent);\n            case 'object':\n                if (Array.isArray(allowComps))\n                    // list of allowed classes\n                    return allowComps.indexOf(meta && meta.compClass) >= 0;\n                else {\n                    // map of class: boolean|test function\n                    var test = allowComps[meta && meta.compClass];\n                    return !! _.result(test, this.owner, meta, dt);\n                }\n                break;\n            default:\n                throw new Error('Incorrect allowed components in config');\n        }\n    } else {\n        var dataTypes = allow && allow.dataTypes;\n        switch (typeof dataTypes) {\n            case 'undefined':\n                return false;\n            case 'string':\n                return dt.types.indexOf(dataTypes) >= 0;\n        }\n    }\n\n    // TODO test for other data types\n}\n",
    "'use strict';\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , DOMEventsSource = require('../msg_src/dom_events')\n    , _ = miloCore.proto;\n\n\n/**\n * `milo.registry.facets.get('Events')`\n * Component facet that manages subscriptions to DOM events using [Messenger](../../messenger/index.js.html) with [DOMEventsSource](../msg_src/dom_events.js.html).\n * All public methods of Messenger and `trigger` method of [DOMEventsSource](../msg_src/dom_events.js.html) are proxied directly to this facet.\n * For example, to subscribe to `click` event use:\n * ```\n * component.frame.on('click', function() {\n *     // ...\n * });\n * ```\n * See [Messenger](../../messenger/index.js.html)\n */\nvar Events = _.createSubclass(ComponentFacet, 'Events');\n\n\n/**\n * ####Events facet instance methods####\n *\n * - [init](#Events$init) - called by constructor automatically\n */\n_.extendProto(Events, {\n    init: Events$init\n    // _reattach: _reattachEventsOnElementChange\n});\n\nfacetsRegistry.add(Events);\n\nmodule.exports = Events;\n\n\n/**\n * Expose DOMEventsSource trigger method on Events prototype\n */\nvar MSG_SOURCE_KEY = '_domEventsSource';\nDOMEventsSource.useWith(Events, MSG_SOURCE_KEY, ['trigger']);\n\n\n/**\n * Events facet instance method\n * Initialzes facet, connects DOMEventsSource to facet's messenger\n */\nfunction Events$init() {\n    ComponentFacet.prototype.init.apply(this, arguments);\n\n    var domEventsSource = new DOMEventsSource(this, undefined, undefined, this.owner);\n    this._setMessageSource(domEventsSource);\n    _.defineProperty(this, MSG_SOURCE_KEY, domEventsSource);\n}\n",
    "'use strict';\n\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , FrameMessageSource = require('../msg_src/frame')\n    , domEventsConstructors = require('../../services/de_constrs')\n    , _ = miloCore.proto;\n\n\n/**\n * `milo.registry.facets.get('Frame')`\n * Component facet that simplifies sending window messages to iframe and subscribing to messages on inner window of iframe.\n * All public methods of Messenger and `trigger` method of [FrameMessageSource](../msg_src/frame.js.html) are proxied directly to this facet.\n * For example, to send custom message to iframe window use:\n * ```\n * iframeComponent.frame.trigger('mymessage', myData);\n * ```\n * To subscribe to this messages inside frame use (with milo - see [milo.mail](../../mail/index.js.html)):\n * ```\n * milo.mail.on('message:mymessage', function(msgType, msgData) {\n *     // data is inside of window message data\n *     // msgType == 'message:mymessage'\n *     var myData = msgData.data;\n *     // ... app logic here\n * });\n * ```\n * or without milo:\n * ```\n * window.attachEventListener('message', function(message) {\n *     var msgType = message.type; // e.g., 'mymessage'\n *     var myData = message.data;\n *     // ... message routing and code here\n * });\n * ```\n * Milo does routing based on sent message type automatically.\n * See [Messenger](../../messenger/index.js.html) and [milo.mail](../../mail/index.js.html).\n */\n var Frame = _.createSubclass(ComponentFacet, 'Frame');\n\n\n/**\n * Calls passed function when frame DOM becomes ready. If already ready calls immediately\n */\nvar Frame$whenReady = _makeWhenReadyFunc(Frame$isReady, 'domready');\n\n/**\n * Calls passed function when frame milo becomes ready. If already ready calls immediately\n */\nvar Frame$whenMiloReady = _makeWhenReadyFunc(Frame$isMiloReady, 'message:miloready');\n\n\n/**\n * ####Events facet instance methods####\n *\n * - [init](#Frame$init) - called by constructor automatically\n */\n_.extendProto(Frame, {\n    init: Frame$init,\n    start: Frame$start,\n    destroy: Frame$destroy,\n    getWindow: Frame$getWindow,\n    isReady: Frame$isReady,\n    whenReady: Frame$whenReady,\n    isMiloReady: Frame$isMiloReady,\n    whenMiloReady: Frame$whenMiloReady,\n    milo: Frame$milo\n    // _reattach: _reattachEventsOnElementChange\n});\n\n\nfacetsRegistry.add(Frame);\n\nmodule.exports = Frame;\n\n\n/**\n * Expose FrameMessageSource trigger method on Events prototype\n */\nvar MSG_SOURCE_KEY = '_messageSource';\nFrameMessageSource.useWith(Frame, MSG_SOURCE_KEY, ['trigger']);\n\n\n/**\n * Frame facet instance method\n * Initialzes facet, connects FrameMessageSource to facet's messenger\n */\nfunction Frame$init() {\n    ComponentFacet.prototype.init.apply(this, arguments);\n    \n    var messageSource = new FrameMessageSource(this, undefined, undefined, this.owner);\n    this._setMessageSource(messageSource);\n\n    _.defineProperty(this, MSG_SOURCE_KEY, messageSource);\n}\n\n\n/**\n * Frame facet instance method\n * Emits frameloaded event when ready.\n */\nfunction Frame$start() {\n    ComponentFacet.prototype.start.apply(this, arguments);\n    var self = this;\n    milo(postDomReady);\n\n    function postDomReady(event) {\n        self.postMessage('domready', event);\n    }\n}\n\n\nfunction Frame$destroy() {\n    ComponentFacet.prototype.destroy.apply(this, arguments);\n}\n\n\n/**\n * Frame facet instance method\n * Retrieves the internal window of the frame \n *\n * @param {Window}\n */\nfunction Frame$getWindow() {\n    return this.owner.el.contentWindow;\n}\n\n\n/**\n * Frame facet instance method\n * Returns document.readyState if frame doument state is 'interactive' or 'complete', false otherwise\n *\n * @return {String|Boolean}\n */\nfunction Frame$isReady() {\n    var readyState = this.getWindow().document.readyState;\n    return  readyState != 'loading' ? readyState : false;\n}\n\n\n/**\n * Frame facet instance method\n * Returns true if milo is loaded and has finished initializing inside the frame\n *\n * @return {Boolean}\n */\nfunction Frame$isMiloReady() {\n    var frameMilo = this.getWindow().milo;\n    return this.isReady() && frameMilo && frameMilo.milo_version;\n}\n\n\n/**\n * Gives access to milo in the frame (assuming it is loaded there)\n * Calls function when both milo and DOM are ready if function is passed.\n * Returns the reference to milo inside the frame if the window is already available.\n * \n * @param {Function} func function to be called when milo and DOM are ready in the frame\n * @return {Function} reference to milo in the frame \n */\nfunction Frame$milo(func) {\n    if (typeof func == 'function') {\n        var self = this;\n        this.whenMiloReady(function() {\n            self.getWindow().milo(func);\n        });\n    }\n    var win = this.getWindow();\n    return win && win.milo;\n}\n\n\nfunction _makeWhenReadyFunc(isReadyFunc, event) {\n    return function Frame_whenReadyFunc(func) { // , arguments\n        var self = this\n            , args = _.slice(arguments, 1);\n        if (isReadyFunc.call(this))\n            callFunc();\n        else\n            this.on(event, callFunc);\n\n        function callFunc() {\n            func.apply(self, args);\n        }\n    };\n}\n",
    "'use strict';\n\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , miloCore = require('milo-core')\n    , Model = miloCore.Model\n    , _ = miloCore.proto\n    , miloMail = require('../../services/mail');\n\n\nvar ItemFacet = _.createSubclass(ComponentFacet, 'Item');\n\n_.extendProto(ItemFacet, {\n    getState: ItemFacet$getState,\n    setState: ItemFacet$setState,\n    getIndex: ItemFacet$getIndex,\n    setIndex: ItemFacet$setIndex,\n    removeItem: ItemFacet$removeItem,\n    extractItem: ItemFacet$extractItem,\n    isSample: ItemFacet$isSample,\n    require: ['Container', 'Dom', 'Data']\n});\n\nfacetsRegistry.add(ItemFacet);\n\nmodule.exports = ItemFacet;\n\n\nfunction ItemFacet$getState() {\n    return { state: {\n        index: this.getIndex()\n    }};\n}\n\n\nfunction ItemFacet$setState(state) {\n    this.setIndex(state.state.index);\n}\n\n\n/**\n * Facet instance method\n * Returns the index of the owner component in it's parent list component\n * @return {Integer} The index\n */\nfunction ItemFacet$getIndex() {\n    return this.index;\n}\n\n\n/**\n * Facet instance method\n * Sets the index of this component\n * @param {Integer} index The index to be set\n */\nfunction ItemFacet$setIndex(index) {\n    this.index = index;\n}\n\n\n/**\n * ItemFacet instance method\n * Removes component from the list, component gets destroyed\n */\nfunction ItemFacet$removeItem() {\n    // this.list and this.index are set by the list when the item is added\n    this.list.removeItem(this.index);\n}\n\n\n/**\n * ItemFacet instance method\n * Removes component from the list, component is NOT destroyed\n */\nfunction ItemFacet$extractItem() {\n    this.list.extractItem(this.index);\n}\n\n\n/**\n* Returns true if the component is a sample for the containing list, false if not\n* @return {Boolean}\n*/\nfunction ItemFacet$isSample() {\n   return this.list.itemSample == this.owner;\n}\n",
    "'use strict';\n\nvar ComponentFacet = require('../c_facet')\n    , Component = require('../c_class')\n    , facetsRegistry = require('./cf_registry')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , miloMail = require('../../services/mail')\n    , miloBinder = require('../../binder')\n    , logger = miloCore.util.logger\n    , doT = miloCore.util.doT\n    , check = miloCore.util.check\n    , Match = check.Match\n    , domUtils = require('../../util/dom')\n    , componentName = require('../../util/component_name')\n    , miloConfig = require('../../config');\n\n\nvar LIST_SAMPLE_CSS_CLASS = 'ml-list-item-sample';\n\n/**\n * `milo.registry.facets.get('List')`\n * Facet enabling list functionality\n */\nvar List = _.createSubclass(ComponentFacet, 'List');\n\n_.extendProto(List, {\n    init: List$init,\n    start: List$start,\n    destroy: List$destroy,\n\n    require: ['Container', 'Dom', 'Data'],\n    _itemPreviousComponent: _itemPreviousComponent,\n\n    item: List$item,\n    count: List$count,\n    contains: List$contains,\n    addItem: List$addItem,\n    addItems: List$addItems,\n    replaceItem: List$replaceItem,\n    moveItem: List$moveItem,\n    removeItem: List$removeItem,\n    extractItem: List$extractItem,\n    each: List$each,\n    map: List$map,\n    _setItem: List$_setItem,\n    _removeItem: List$_removeItem,\n    _addItem: List$_addItem,\n    _addItems: List$_addItems,\n    _createCacheTemplate: List$_createCacheTemplate,\n    _updateDataPaths: List$_updateDataPaths\n});\n\nfacetsRegistry.add(List);\n\nmodule.exports = List;\n\n\n/**\n * Facet instance method\n * Initialized List facet instance and sets up item properties.\n */\nfunction List$init() {\n    ComponentFacet.prototype.init.apply(this, arguments);\n    var self = this;\n\n    _.defineProperties(this, {\n        _listItems: [],\n        _listItemsHash: {}\n    });\n    _.defineProperty(this, 'itemSample', null, _.WRIT);\n}\n\n\n/**\n * Facet instance method\n * Starts the List facet instance, finds child with Item facet.\n */\nfunction List$start() {\n    // Fired by __binder__ when all children of component are bound\n    this.owner.on('childrenbound', onChildrenBound);\n}\n\n\nfunction onChildrenBound() {\n    // get items already in the list\n    var children = this.dom.children()\n        , items = this.list._listItems\n        , itemsHash = this.list._listItemsHash;\n\n    if (children) children.forEach(function(childEl) {\n        var comp = Component.getComponent(childEl);\n        if (comp && comp.item) {\n            items.push(comp);\n            itemsHash[comp.name] = comp;\n            comp.item.list = this.list;\n        }\n    }, this);\n\n    if (items.length) {\n        var foundItem = items[0];\n        items.splice(0, 1);\n        delete itemsHash[foundItem.name];\n        items.forEach(function(item, index) {\n            item.item.setIndex(index);\n        });\n    }\n\n    // Component must have one child with an Item facet\n    if (! foundItem) throw new Error('No child component has Item facet');\n\n    this.list.itemSample = foundItem;\n\n    // After keeping a reference to the item sample, it must be hidden and removed from scope.  The item sample will\n    // remain in the DOM and as such is marked with a CSS class allowing other code to ignore this element if required.\n    foundItem.dom.hide();\n    foundItem.remove(true);\n    foundItem.dom.addCssClasses(LIST_SAMPLE_CSS_CLASS);\n\n    // remove references to components from sample item\n    foundItem.walkScopeTree(function(comp) {\n        delete comp.el[miloConfig.componentRef];\n    });\n\n    this.list._createCacheTemplate();\n}\n\n\nfunction List$_createCacheTemplate() {\n    if (!this.itemSample) return false;\n\n    var itemSample = this.itemSample;\n\n    // create item template to insert many items at once\n    var itemElCopy = itemSample.el.cloneNode(true);\n    itemElCopy.classList.remove(LIST_SAMPLE_CSS_CLASS);\n\n    var attr = itemSample.componentInfo.attr;\n    var attrCopy = _.clone(attr);\n    attr.compName = '{{= it.componentName() }}';\n    attr.el = itemElCopy;\n    attr.decorate();\n\n    var itemsTemplateStr =\n          '{{ var i = it.count; while(i--) { }}'\n        + itemElCopy.outerHTML\n        + '{{ } }}';\n\n    this.itemsTemplate = doT.compile(itemsTemplateStr);\n}\n\n\n/**\n * Facet instance method\n * Retrieve a particular child item by index\n * @param {Integer} index The index of the child item to get.\n * @return {Component} The component found\n */\nfunction List$item(index) {\n    return this._listItems[index];\n}\n\n\n/**\n * Facet instance method\n * Gets the total number of child items\n * @return {Integer} The total\n */\nfunction List$count() {\n    return this._listItems.length;\n}\n\n\nfunction List$_setItem(index, component) {\n    this._listItems.splice(index, 0, component);\n    this._listItemsHash[component.name] = component;\n    component.item.list = this;\n    component.item.setIndex(+index);\n}\n\n\n/**\n * Facet instance method\n * Returns true if a particular child item exists in the list\n * @param {Component} component The component to look for.\n * @return {Boolean}\n */\nfunction List$contains(component) {\n    return this._listItemsHash[component.name] == component;\n}\n\n\n/**\n * Facet instance method\n * Adds a new child component at a particular index and returns the new component.\n * This method uses data facet, so notification will be emitted on data facet.\n * @param {Integer} index The index to add at\n * @return {Component} The newly created component\n */\nfunction List$addItem(index, itemData) {\n    index = isNaN(+index) ? this.count() : +index;\n    this.owner.data.splice(index, 0, itemData || {});\n    return this.item(index);\n}\n\n\n/**\n * Facet instance method\n * Adds a new child component at a particular index and returns the new component\n * @param {Integer} index The index to add at\n * @return {Component} The newly created component\n */\nfunction List$_addItem(index) {\n    if (this.item(index))\n        throw Error('attempt to create item with ID of existing item');\n\n    // Copy component\n    var component = Component.copy(this.itemSample, true);\n    var prevComponent = this._itemPreviousComponent(index);\n\n    if (!prevComponent.el.parentNode)\n        return logger.warn('list item sample was removed from DOM, probably caused by wrong data. Reset list data with array');\n\n    // Add it to the DOM\n    prevComponent.dom.insertAfter(component.el);\n\n    // Add to list items\n    this._setItem(index, component);\n\n    // Show the list item component\n    component.el.style.display = '';\n    component.el.classList.remove(LIST_SAMPLE_CSS_CLASS);\n\n    _updateItemsIndexes.call(this, index + 1);\n\n    return component;\n}\n\n\nfunction _updateItemsIndexes(fromIndex, toIndex) {\n    fromIndex = fromIndex || 0;\n    toIndex = toIndex || this.count();\n    for (var i = fromIndex; i < toIndex; i++) {\n        var component = this._listItems[i];\n        if (component)\n            component.item.setIndex(i);\n        else\n            logger.warn('List: no item at position', i);\n    }\n}\n\n\nfunction List$addItems(count, index) { // ,... items data\n    var itemsData = _.slice(arguments, 2);\n    if (itemsData.length < count)\n        itemsData.concat(_.repeat(count - itemsData.length, {}));\n    var spliceArgs = [index, 0].concat(itemsData);\n    var dataFacet = this.owner.data;\n    dataFacet.splice.apply(dataFacet, spliceArgs);\n}\n\n\n/**\n * List facet instance method\n * Adds a given number of items using template rendering rather than adding elements one by one\n *\n * @param {Integer} count number of items to add\n * @param {Integer} [index] optional index of item after which to add\n */\nfunction List$_addItems(count, index) {\n    check(count, Match.Integer);\n    if (count < 0)\n        throw new Error('can\\'t add negative number of items');\n\n    if (count === 0) return;\n\n    var itemsHTML = this.itemsTemplate({\n        componentName: componentName,\n        count: count\n    });\n\n    var wrapEl = document.createElement(this.owner.el.tagName);\n    wrapEl.innerHTML = itemsHTML;\n\n    miloBinder(wrapEl, this.owner.container.scope);\n    var children = domUtils.children(wrapEl);\n\n    if (count != children.length)\n        logger.error('number of items added is different from requested');\n\n    if (children && children.length) {\n        var listLength = this.count();\n        var spliceIndex = index < 0\n                            ? 0\n                            : typeof index == 'undefined' || index > listLength\n                                ? listLength\n                                : index;\n\n        var prevComponent = spliceIndex === 0\n                                ? this.itemSample\n                                : this._listItems[spliceIndex - 1];\n\n        var frag = document.createDocumentFragment()\n            , newComponents = [];\n\n        children.forEach(function(el, i) {\n            var component = Component.getComponent(el);\n            if (! component)\n                return logger.error('List: element in new items is not a component');\n            newComponents.push(component);\n            this._setItem(spliceIndex++, component);\n            frag.appendChild(el);\n            el.style.display = '';\n        }, this);\n\n        _updateItemsIndexes.call(this, spliceIndex);\n\n        if (!prevComponent.el.parentNode)\n            return logger.warn('list item sample was removed from DOM, probably caused by wrong data. Reset list data with array');\n\n        // Add it to the DOM\n        prevComponent.dom.insertAfter(frag);\n\n        _.deferMethod(newComponents, 'forEach', function(comp) {\n            comp.broadcast('stateready');\n        });\n    }\n}\n\n\n/**\n * List facet instance method\n * @param {Integer} index The index of the item to remove\n * @return {Array[Object]} The spliced data\n */\nfunction List$removeItem(index) {\n    return this.owner.data.splice(index, 1);\n}\n\n\n/**\n * List facet instance method\n * @param {Integer} index The index of the item to extract\n * @return {Component} The extracted item\n */\nfunction List$extractItem(index) {\n    var itemComp = this._removeItem(index, false);\n    this._updateDataPaths(index, this.count());\n    return itemComp;\n}\n\n\n/**\n * List facet instance method\n * Removes item, returns the removed item that is destroyed by default.\n *\n * @param  {Number} index item index\n * @param  {Boolean} doDestroyItem optional false to prevent item destruction, true by default\n * @return {Component}\n */\nfunction List$_removeItem(index, doDestroyItem) {\n    var comp = this.item(index);\n\n    if (! comp)\n        return logger.warn('attempt to remove list item with id that does not exist');\n\n    this._listItems[index] = undefined;\n    delete this._listItemsHash[comp.name];\n    if (doDestroyItem !== false) comp.destroy();\n    else {\n        comp.remove();\n        comp.dom.remove();\n    }\n\n    this._listItems.splice(index, 1);\n    _updateItemsIndexes.call(this, index);\n\n    return comp;\n}\n\n\nfunction List$replaceItem(index, newItem){\n    var oldItem = this.item(index);\n    oldItem.dom.insertAfter(newItem.el);\n    this._removeItem(index);\n    this._setItem(index, newItem);\n}\n\n\nfunction List$moveItem(fromIndex, toIndex) {\n    var componentToMove = this.extractItem(fromIndex);\n    var toComponent = this.item(toIndex);\n\n    componentToMove.insertInto(this.owner.el, toComponent.el);\n\n    this._setItem(toIndex, componentToMove);\n    _updateItemsIndexes.call(this, 0);\n}\n\n\n// Returns the previous item component given an index\nfunction _itemPreviousComponent(index) {\n    while (index >= 0 && ! this._listItems[index])\n        index--;\n\n    return index >= 0\n                ? this._listItems[index]\n                : this.itemSample;\n}\n\n\n// toIndex is not included\n// no range checking is made\nfunction List$_updateDataPaths(fromIndex, toIndex) {\n    for (var i = fromIndex; i < toIndex; i++) {\n        var item = this.item(i);\n        if (item)\n            item.data._path = '[' + i + ']';\n        else\n            logger.warn('Data: no item for index', i);\n    }\n}\n\n\n/**\n * Facet instance method\n * Similar to forEach method of Array, iterates each of the child items.\n * @param {Function} callback An iterator function to be called on each child item.\n * @param {Any} [thisArg]  Context to set `this`.\n */\nfunction List$each(callback, thisArg) {\n    this._listItems.forEach(function(item, index) {\n        if (item) callback.apply(this, arguments); // passes item, index to callback\n        else logger.warn('List$each: item', index, 'is undefined');\n    }, thisArg || this);\n}\n\n\nfunction List$map(callback, thisArg) {\n    return this._listItems.map(function(item, index) {\n        if (item) return callback.apply(this, arguments); // passes item, index to callback\n        else logger.warn('List$map: item', index, 'is undefined');\n    }, thisArg || this);\n}\n\n\n/**\n * Facet instance method\n * Destroys the list\n */\nfunction List$destroy() {\n    if (this.itemSample) this.itemSample.destroy(true);\n    ComponentFacet.prototype.destroy.apply(this, arguments);\n}\n",
    "'use strict';\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , miloCore = require('milo-core')\n    , Model = miloCore.Model\n    , Mixin = miloCore.classes.Mixin\n    , _ = miloCore.proto;\n\n\n// generic drag handler, should be overridden\nvar ModelFacet = _.createSubclass(ComponentFacet, 'Model');\n\n_.extendProto(ModelFacet, {\n    init: ModelFacet$init,\n    getState: ModelFacet$getState,\n    setState: ModelFacet$setState,\n    _createMessenger: ModelFacet$_createMessenger,\n    destroy: ModelFacet$destroy\n});\n\nfacetsRegistry.add(ModelFacet);\n\nmodule.exports = ModelFacet;\n\n\n/**\n * Expose Model class methods on ModelFacet\n */\nModel.useWith(ModelFacet, 'm');\n\n\nfunction ModelFacet$init() {\n    this.m = new Model(this.config.data, this);\n    ComponentFacet.prototype.init.apply(this, arguments);\n    // this.m.proxyMethods(this); // Creates model's methods directly on facet\n}\n\n\n/**\n * ModelFacet instance method\n * Called by `Component.prototype.getState` to get facet's state\n * Simply returns model data\n *\n * @return {Object}\n */\nfunction ModelFacet$getState() {\n    var modelValue = this.m.get();\n    if (typeof modelValue == 'object')\n        modelValue = _.deepClone(modelValue);\n    return { state: modelValue };\n}\n\n\n/**\n * ModelFacet instance method\n * Called by `Component.prototype.setState` to set facet's state\n * Simply sets model data\n *\n * @param {Object} state data to set on facet's model\n */\nfunction ModelFacet$setState(state) {\n    return this.m.set(state.state);\n}\n\n\nfunction ModelFacet$_createMessenger() { // Called by inherited init\n    this._messenger = this.m._messenger;\n}\n\n\nfunction ModelFacet$destroy() {\n    this.m.destroy();\n    ComponentFacet.prototype.destroy.apply(this, arguments);\n}\n",
    "'use strict';\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , miloCore = require('milo-core')\n    , Model = miloCore.Model\n    , _ = miloCore.proto;\n\n\n// generic drag handler, should be overridden\nvar Options = _.createSubclass(ComponentFacet, 'Options');\n\n_.extendProto(Options, {\n    init: Options$init,\n    destroy: Options$destroy,\n    _createMessenger: Options$_createMessenger\n});\n\nfacetsRegistry.add(Options);\n\nmodule.exports = Options;\n\n\nfunction Options$init() {\n    this.m = new Model(this.config.options, this);\n    ComponentFacet.prototype.init.apply(this, arguments);\n    this.m.proxyMethods(this); // Creates model's methods directly on facet\n}\n\n\nfunction Options$_createMessenger() { // Called by inherited init\n    this._messenger = this.m._messenger;\n}\n\n\nfunction Options$destroy() {\n    this.m.destroy();\n    ComponentFacet.prototype.destroy.apply(this, arguments);\n}\n",
    "'use strict';\n\n// <a name=\"components-facets-template\"></a>\n// ###template facet\n\n// simplifies rendering of component element from template.\n//   Any templating enging can be used that supports template compilation\n//   (or you can mock this compilation easily by creating closure storing\n//   template string in case your engine doesn't support compilation).\n//   By default milo uses [doT](), the most versatile, conscise and at the\n//   same time the fastest templating engine.\n//   If you use milo in browser, it is the part of milo bundle and available\n//   as global variable `doT`.\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , logger = miloCore.util.logger\n    , Match = check.Match\n    , binder = require('../../binder')\n    , config = require('../../config');\n\n\n// data model connection facet\nvar Template = _.createSubclass(ComponentFacet, 'Template');\n\n_.extendProto(Template, {\n    init: Template$init,\n    start: Template$start,\n    set: Template$set,\n    getCompiled: Template$getCompiled,\n    render: Template$render,\n    binder: Template$binder\n\n    // _reattach: _reattachEventsOnElementChange\n});\n\nfacetsRegistry.add(Template);\n\nmodule.exports = Template;\n\n\nfunction Template$init() {\n    ComponentFacet.prototype.init.apply(this, arguments);\n\n    // templates are interpolated with default (doT) or configured engine (this.config.compile)\n    // unless this.config.interpolate is false\n    var compile = this.config.interpolate === false\n                    ? undefined\n                    : this.config.compile || config.template.compile;\n\n    this.set(this.config.template || '', compile, this.config.compileOptions);\n}\n\n\nfunction Template$start() {\n    ComponentFacet.prototype.start.apply(this, arguments);\n    if (this.config.autoRender) {\n        this.render();\n        if (this.config.autoBinder)\n            this.binder();\n    }\n}\n\n\nfunction Template$getCompiled() {\n    return this._template;\n}\n\n\nfunction Template$set(templateStr, compile, compileOptions) {\n    check(templateStr, Match.OneOf(String, Function));\n    check(compile, Match.Optional(Function));\n\n    if (typeof templateStr == 'function')\n        this._template = templateStr;\n    else {\n        this._templateStr = templateStr;\n        if (compile)\n            this._compile = compile;\n        else\n            compile = this._compile;\n\n        if (compile)\n            this._template = compile(templateStr, compileOptions);\n    }\n\n    return this;\n}\n\n\nfunction Template$render(data) { // we need data only if use templating engine\n    this.owner.el.innerHTML = this._template\n                                ? this._template(data)\n                                : this._templateStr;\n\n    return this;\n}\n\n\nfunction Template$binder() {\n    if (this.owner.container)\n        return this.owner.container.binder();\n    else\n        logger.error('TemplateFacet: Binder called without container facet.');\n}\n",
    "'use strict';\n\nvar ComponentFacet = require('../c_facet')\n    , facetsRegistry = require('./cf_registry');\n\n\n/**\n * Transfer facet is designed for components to be able to represent other components\n * If a [Component](../c_class.js.html) has Transfer facet, when `Component.getState` is called for this componet it returns previously saved data, possibly from another component.\n * For example, a list of documents can use this facet so that each item in the list can store actual document component on it.\n */\nvar Transfer = _.createSubclass(ComponentFacet, 'Transfer');\n\n_.extendProto(Transfer, {\n    init: Transfer$init,\n    getState: Transfer$getState,\n    setState: Transfer$setState,\n    setActiveState: Transfer$setActiveState,\n    setStateWithKey: Transfer$setStateWithKey,\n    getStateWithKey: Transfer$getStateWithKey,\n    getComponentMeta: Transfer$getComponentMeta\n});\n\nfacetsRegistry.add(Transfer);\n\nmodule.exports = Transfer;\n\n\nfunction Transfer$init() {\n    ComponentFacet.prototype.init.apply(this, arguments);\n    this._activeState = '';\n    this._defaultKey = '';\n    this._state = {};\n}\n\n\n/**\n * Transfer facet instance method\n * Returns transfer state for component. Can be obtained from another component by using `Component.getState`\n *\n * @return {Object}\n */\nfunction Transfer$getState() {\n    return this._state[this._activeState] || this._state[this._defaultKey];\n}\n\n\n/**\n * Transfer facet instance method\n * Sets transfer state for component. Can be obtained from another component by using `Component.getState`\n *\n * @param {Object} state\n */\nfunction Transfer$setState(state) {\n    this._state[''] = state;\n    this.setActiveState('');\n}\n\n/**\n * Transfer facet instance method\n * Sets the active state (used by getState)\n * @param {String} key state key\n */\nfunction Transfer$setActiveState(key) {\n    this._activeState = key;\n}\n\n/**\n * Transfer facet instance method\n * Sets transfer state for component without default key. Can be obtained from another component by using `Component.getState`\n * When the active state is set to the expected key\n * @param {String} key state key\n * @param {Object} state state object\n * @param {Boolean} [isDefaultKey] (Optional)\n */\nfunction Transfer$setStateWithKey(key, state, isDefaultKey) {\n    if (!key) throw new Error('Transfer$setStateWithKey: no key');\n\n    if (isDefaultKey)\n        this._defaultKey = key;\n    else\n        this._defaultKey = this._defaultKey || key;\n\n    this._state[key] = state;\n    this.setActiveState(key);\n}\n\n\nfunction Transfer$getStateWithKey(key) {\n    return typeof key == 'string' && this._state[key];\n}\n\n\nfunction Transfer$getComponentMeta() {\n    var state = this.getState();\n    return {\n        compName: state && state.compName,\n        compClass: state && state.compClass\n    };\n}\n",
    "'use strict';\n\nvar ClassRegistry = require('../../abstract/registry')\n    , ComponentFacet = require('../c_facet');\n\n\n/**\n * `milo.registry.facets`\n * Component facets registry. An instance of [ClassRegistry](../../abstract/registry.js.html) class that is used by milo to register and find facets.\n */\n var facetsRegistry = new ClassRegistry(ComponentFacet);\n\n\n// Adds common ancestor to all facets of components to the registry.\nfacetsRegistry.add(ComponentFacet);\n\nmodule.exports = facetsRegistry;\n",
    "'use strict';\n\nvar componentsRegistry = require('./c_registry')\n    , facetsRegistry = require('./c_facets/cf_registry')\n    , componentName = require('../util/component_name')\n    , Scope = require('./scope')\n    , miloCore = require('milo-core')\n    , logger = miloCore.util.logger\n    , _ = miloCore.proto;\n\n\nmodule.exports = ComponentInfo;\n\n\n/**\n * Simple class to hold information allowing to create/copy component using [`Component.create`](./c_class.js.html#create) and [`Component.copy`](./c_class.js.html#copy).\n *\n * @constructor\n * @param {Scope} scope scope object the component belogs to, usually either top level scope that will be returned by [milo.binder](../binder.js.html) or `scope` property of [Container](./c_facets/Container.js.html) facet of containing component\n * @param {Element} el DOM element the component is attached to\n * @param {BindAttribute} attr BindAttribute instance that the component was created with\n * @param {Boolean} throwOnErrors If set to false, then errors will only be logged to console. True by default.\n * @return {ComponentInfo}\n */\nfunction ComponentInfo(scope, el, attr, throwOnErrors) {\n    attr.parse().validate();\n\n    this.scope = scope;\n    this.el = el;\n    this.attr = attr;\n    this.name = attr.compName;\n    this.ComponentClass = getComponentClass(attr, throwOnErrors);\n    this.extraFacetsClasses = getComponentExtraFacets(this.ComponentClass, attr, throwOnErrors);\n\n    if (this.ComponentClass\n            && hasContainerFacet(this.ComponentClass, this.extraFacetsClasses)) {\n        this.container = {};\n    }\n}\n\n\n/**\n * ####ComponentInfo instance methods####\n * \n * - [destroy](#ComponentInfo$destroy)\n * - [rename](#ComponentInfo$rename)\n */\n_.extendProto(ComponentInfo, {\n    destroy: ComponentInfo$destroy,\n    rename: ComponentInfo$rename\n});\n\n\n/**\n * ComponentInfo instance method\n * Destroys ComponentInfo by removing the references to DOM element\n */\nfunction ComponentInfo$destroy() {\n    delete this.el;\n    this.attr.destroy();\n}\n\n\n/**\n * ComponentInfo instance method\n * Renames ComponentInfo object\n *\n * @param {String} [name] optional new component name, generated from timestamp by default\n * @param {Boolean} [renameInScope] optional false to not rename ComponentInfo object in its scope, true by default\n */\nfunction ComponentInfo$rename(name, renameInScope) {\n    name = name || componentName();\n    Scope.rename(this, name, renameInScope);\n    this.attr.compName = name;\n    this.attr.decorate();\n}\n\n\nfunction getComponentClass(attr, throwOnErrors) {\n    var ComponentClass = componentsRegistry.get(attr.compClass);\n    if (! ComponentClass)\n        reportBinderError(throwOnErrors, 'class ' + attr.compClass + ' is not registered');\n    return ComponentClass;\n}\n\n\nfunction getComponentExtraFacets(ComponentClass, attr, throwOnErrors) {\n    var facets = attr.compFacets\n        , extraFacetsClasses = {};\n\n    if (Array.isArray(facets))\n        facets.forEach(function(fctName) {\n            fctName = _.firstUpperCase(fctName);\n            if (ComponentClass.hasFacet(fctName))\n                reportBinderError(throwOnErrors, 'class ' + ComponentClass.name\n                                      + ' already has facet ' + fctName);\n            if (extraFacetsClasses[fctName])\n                reportBinderError(throwOnErrors, 'component ' + attr.compName\n                                      + ' already has facet ' + fctName);\n            var FacetClass = facetsRegistry.get(fctName);\n            extraFacetsClasses[fctName] = FacetClass;\n        });\n\n    return extraFacetsClasses;\n}\n\n\nfunction reportBinderError(throwOnErrors, message) {\n    if (throwOnErrors === false)\n        logger.error('ComponentInfo binder error:', message);\n    else\n        throw new Error(message);\n}\n\n\nfunction hasContainerFacet(ComponentClass, extraFacetsClasses) {\n    return (ComponentClass.hasFacet('container')\n        || 'Container' in extraFacetsClasses\n        || _.someKey(extraFacetsClasses, facetRequiresContainer)\n        || classHasFacetThatRequiresContainer());\n\n    function classHasFacetThatRequiresContainer() {\n        return (ComponentClass.prototype.facetsClasses\n            && _.someKey(ComponentClass.prototype.facetsClasses, facetRequiresContainer));\n    }\n\n    function facetRequiresContainer(FacetClass) {\n        return FacetClass.requiresFacet('container');\n    }\n}\n",
    "'use strict';\n\nvar ClassRegistry = require('../abstract/registry')\n    , Component = require('./c_class');\n\n/**\n * `milo.registry.components`\n * An instance of [ClassRegistry](../abstract/registry.js.html) class that is used by milo to register and find components.\n */\nvar componentsRegistry = new ClassRegistry(Component);\n\n// add common ancestor to all components to the registry.\ncomponentsRegistry.add(Component);\n\nmodule.exports = componentsRegistry;\n",
    "'use strict';\n\nvar config = require('../config')\n    , miloCore = require('milo-core')\n    , check = miloCore.util.check\n    , Match = check.Match\n    , _ = miloCore.proto;\n\n\nvar componentUtils = module.exports = {\n    isComponent: isComponent,\n    getComponent: getComponent,\n    getContainingComponent: getContainingComponent,\n    _makeComponentConditionFunc: _makeComponentConditionFunc\n};\n\n\n/**\n * isComponent\n *\n * Checks if element has a component attached to it by\n * checking the presence of property difined in milo.config\n *\n * @param {Element} el DOM element\n * @return {Boolean} true, if it has milo component attached to it\n */\nfunction isComponent(el) {\n    return el.hasOwnProperty(config.componentRef);\n}\n\n\n/**\n * getComponent\n *\n * @param {Element} el DOM element\n * @return {Component} component attached to element\n */\nfunction getComponent(el) {\n    return el && el[config.componentRef];\n}\n\n\n/**\n * Returns the closest component which contains the specified element,\n * optionally, only component that passes `condition` test or contains specified facet\n *\n * Unless `returnCurrent` parameter is false, the function will return\n * the current component of the element (true by default).\n *\n * @param {Node} node DOM Element or text Node\n * @param {Boolean} returnCurrent optional boolean value indicating whether the component of the element can be returned. True by default, should be false to return only ancestors.\n * @param {Function|String} conditionOrFacet optional condition that component should pass (or facet name it should contain)\n * @return {Component} \n */\nfunction getContainingComponent(node, returnCurrent, conditionOrFacet) {\n    // check(node, Node); - can't check tiype here as it is most likely coming from another frame\n    check(returnCurrent, Match.Optional(Boolean));\n    check(conditionOrFacet, Match.Optional(Match.OneOf(Function, String)));\n\n    var conditionFunc = _makeComponentConditionFunc(conditionOrFacet);\n\n    return _getContainingComponent(node, returnCurrent, conditionFunc);\n}\n\n\nfunction _makeComponentConditionFunc(conditionOrFacet) {\n    if (typeof conditionOrFacet == 'function')\n        return conditionOrFacet;\n    else if (typeof conditionOrFacet == 'string') {\n        var facetName = _.firstLowerCase(conditionOrFacet);\n        return function (comp) {\n           return comp.hasFacet(facetName);\n        };\n    }\n}\n\n\nfunction _getContainingComponent(el, returnCurrent, conditionFunc) {\n    // Where the current element is a component it should be returned\n    // if returnCurrent is true or undefined\n    if (returnCurrent !== false) {\n        var comp = getComponent(el);\n        if (comp && (! conditionFunc || conditionFunc(comp)))\n            return comp;\n    }\n\n    // Where there is no parent element, this function will return undefined\n    // The parent element is checked recursively\n    if (el.parentNode)\n        return _getContainingComponent(el.parentNode, true, conditionFunc);\n}\n",
    "'use strict';\n\nvar Component = require('../c_class')\n    , componentsRegistry = require('../c_registry');\n\n\nvar View = Component.createComponentClass('View', ['container']);\n\ncomponentsRegistry.add(View);\n\nmodule.exports = View;\n",
    "'use strict';\n\n\nvar getElementDataAccess = require('./de_data')\n    , miloCore = require('milo-core')\n    , MessengerAPI = miloCore.classes.MessengerAPI\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\n\n// class to handle subscribtions to changes in DOM for UI (maybe also content editable) elements\n\n/**\n * A class\n */\nvar DataMsgAPI = _.createSubclass(MessengerAPI, 'DataMsgAPI', true);\n\n\n_.extendProto(DataMsgAPI, {\n    // implementing MessageSource interface\n    init: DataMsgAPI$init,\n    translateToSourceMessage: translateToSourceMessage,\n    filterSourceMessage: filterSourceMessage,\n    createInternalData: createInternalData,\n\n    // class specific methods\n    value: DataMsgAPI$value\n});\n\nmodule.exports = DataMsgAPI;\n\n\nfunction DataMsgAPI$init(component) {\n    MessengerAPI.prototype.init.apply(this, arguments);\n\n    this.component = component;\n    this.elData = getElementDataAccess(component.el);\n}\n\n\n// getDomElementDataValue\nfunction DataMsgAPI$value() { // value method\n    var componentGetter = this.component.data.config.get;\n    var newValue = typeof componentGetter == 'function'\n                    ? componentGetter.call(this.component)\n                    : this.elData.get(this.component.el);\n\n    this.component.data._value = newValue;\n\n    return newValue;\n}\n\n\n// TODO: this function should return relevant DOM event dependent on element tag\n// Can also implement beforedatachanged event to allow preventing the change\n// translateToDomEvent\nfunction translateToSourceMessage(message) {\n    var componentEvent = this.component.data.config.event;\n    var event = componentEvent || this.elData.event(this.component.el);\n\n    if (message === '' && event)\n        return event;  // this.tagEvent;\n}\n\n\n// filterDataMessage\nfunction filterSourceMessage(sourceMessage, message, data) {\n    return data.newValue != data.oldValue;\n}\n\n\nfunction createInternalData(sourceMessage, message, data) {\n    var oldValue = this.component.data._value\n        , newValue = this.value();\n\n    var internalData = { \n        path: '',\n        type: 'changed',\n        oldValue: oldValue,\n        newValue: newValue\n    };\n    return internalData;\n}\n",
    "'use strict';\n\n\nvar _ = require('milo-core').proto;\n\n\n/**\n * Returns data access methods and events for given DOM element.\n * Used by [Data](../c_facets/Data.js.html) facet and by [DataMsgAPI](./data.js.html)\n *\n * @param {Element} el\n * @return {Object}\n */\nvar getElementDataAccess = function(el) {\n    var tagName = el.tagName.toLowerCase()\n        , elData = domElementsDataAccess[tagName];\n    return elData || domElementsDataAccess.byDefault;\n};\n\nmodule.exports = getElementDataAccess;\n\n\n/**\n * Data access methods and events for DOM elements.\n */\nvar domElementsDataAccess = {\n    byDefault: {\n        property: 'innerHTML',\n    },\n    'div': {\n        property: 'innerHTML', // hack, should be innerHTML? to make work with Editable facet\n        // event: 'input'\n    },\n    'span': {\n        property: 'innerHTML',\n        event: 'input'\n    },\n    'p': {\n        property: 'innerHTML',\n        event: 'input'\n    },\n    'input': {\n        property: inputDataProperty,\n        event: inputChangeEvent\n    },\n    'textarea': {\n        property: 'value',\n        event: 'input'\n    },\n    'select': {\n        property: 'value',\n        event: 'change'\n    },\n    'img': {\n        property: 'src'\n    },\n    'caption': {\n        property: 'innerHTML',\n        event: 'input'\n    },\n    'thead': {\n        property: 'innerHTML',\n        event: 'input'\n    },\n    'tbody': {\n        property: 'innerHTML',\n        event: 'input'\n    },\n    'tfoot': {\n        property: 'innerHTML',\n        event: 'input'\n    }\n};\n\n\n// convert strings to functions and create getset methods\n_.eachKey(domElementsDataAccess, function(tagInfo) {\n    var property = tagInfo.property\n        , event = tagInfo.event;\n    if (typeof property != 'function')\n        tagInfo.property = function() { return property; };\n    var propFunc = tagInfo.property;\n    if (typeof event != 'function')\n        tagInfo.event = function() { return event; };\n    if (! tagInfo.get)\n        tagInfo.get = function(el) { return el[propFunc(el)]; };\n    if (! tagInfo.set)\n        tagInfo.set = function(el, value) {\n            return (el[propFunc(el)] = typeof value == 'undefined' ? '' : value);\n        };\n});\n\n\n/**\n * Types of input elements\n */\nvar inputElementTypes = {\n    byDefault: {\n        property: 'value',\n        event: 'input'\n    },\n    'checkbox': {\n        property: 'checked',\n        event: 'change'\n    },\n    'radio': {\n        property: 'checked',\n        event: 'change'\n    },\n    'text': {\n        property: 'value',\n        event: 'input'\n    }\n};\n\n\n/**\n * Return property of input element to get/set its data\n *\n * @param {Element} el\n * @return {String}\n */\nfunction inputDataProperty(el) {\n    var inputType = inputElementTypes[el.type];\n    return inputType\n            ? inputType.property\n            : inputElementTypes.byDefault.property;\n}\n\n\n/**\n * Returns DOM event type to listen to to react to input element change\n *\n * @param {Element} el\n * @return {String}\n */\nfunction inputChangeEvent(el) {\n    var inputType = inputElementTypes[el.type];\n    return inputType\n            ? inputType.event\n            : inputElementTypes.byDefault.event;\n}\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , MessengerAPI = miloCore.classes.MessengerAPI\n    , _ = miloCore.proto;\n\n\nvar DropMsgAPI = _.createSubclass(MessengerAPI, 'DropMsgAPI', true);\n\n\n_.extendProto(DropMsgAPI, {\n    // implementing MessageSource interface\n    translateToSourceMessage: translateToSourceMessage,\n    filterSourceMessage: filterSourceMessage,\n});\n\n\nmodule.exports = DropMsgAPI;\n\n\nvar dropEventsMap = {\n    'dragin': 'dragenter',\n    'dragout': 'dragleave'\n};\n\n\nfunction translateToSourceMessage(message) {\n    return dropEventsMap.hasOwnProperty(message)\n            ? dropEventsMap[message]\n            : message;\n}\n\nfunction resetFilterVars() {\n    delete this._currentTarget;\n    delete this._inside;\n}\n\nfunction filterSourceMessage(sourceMessage, message, data) { // data is DOM event object\n    var ok = true;\n\n    if (sourceMessage == 'dragenter' && message == 'dragin') {\n        this._currentTarget = data.target;\n        ok = !this._inside;\n        this._inside = true;\n    } else if (sourceMessage == 'dragleave' && message == 'dragout') {\n        ok = this._currentTarget == data.target;\n        if (ok) resetFilterVars.call(this);\n    } else if (sourceMessage == 'drop') resetFilterVars.call(this);\n\n    return ok;\n}\n",
    "'use strict';\n\n\nvar DOMEmitterSource = require('../../services/dom_source')\n    , miloCore = require('milo-core')\n    , MessageSource = miloCore.classes.MessageSource\n    , Component = require('../c_class')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\nvar DOMEventsSource = _.createSubclass(DOMEmitterSource, 'DOMEventsSource', true);\n\n\n_.extendProto(DOMEventsSource, {\n    init: init,\n    destroy: DOMEventsSource$destroy,\n    emitter: emitter\n});\n\nmodule.exports = DOMEventsSource;\n\n\nvar useCapturePattern = /__capture$/\n    , useCapturePostfix = '__capture';\n\n\n// init DOM event source\nfunction init(hostObject, proxyMethods, messengerAPIOrClass, component) {\n    check(component, Component);\n    this.component = component;\n    MessageSource.prototype.init.apply(this, arguments);\n}\n\n\nfunction DOMEventsSource$destroy() {\n    MessageSource.prototype.destroy.apply(this, arguments);\n    delete this.component;\n}\n\n\n// get DOM element of component\nfunction emitter() {\n    return this.component.el;\n}\n",
    "'use strict';\n\n// ###component iframe source\n\nvar Component = require('../c_class')\n    , miloCore = require('milo-core')\n    , MessageSource = miloCore.classes.MessageSource\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , logger = miloCore.util.logger\n    , Match = check.Match;\n\nvar FrameMessageSource = _.createSubclass(MessageSource, 'FrameMessageSource', true);\n\n\n_.extendProto(FrameMessageSource, {\n    // implementing MessageSource interface\n    init: init,\n    addSourceSubscriber: addSourceSubscriber,\n    removeSourceSubscriber: removeSourceSubscriber,\n    trigger: trigger,\n\n    //class specific methods\n    frameWindow: frameWindow,\n    handleEvent: handleEvent  // event dispatcher - as defined by Event DOM API\n});\n\nmodule.exports = FrameMessageSource;\n\n\nfunction init(hostObject, proxyMethods, messengerAPIOrClass, component) {\n    check(component, Component);\n    this.component = component;\n\n    if (component.el.tagName.toLowerCase() != 'iframe')\n        throw new Error('component for FrameMessageSource can only be attached to iframe element');\n\n    MessageSource.prototype.init.apply(this, arguments);\n}\n\n\nfunction frameWindow() {\n    return this.component.el.contentWindow;\n}\n\n\n// addIFrameMessageListener\nfunction addSourceSubscriber(sourceMessage) {\n    var win = this.frameWindow();\n    if (win) win.addEventListener('message', this, false);\n    else logger.warn('FrameMessageSource: frame window is undefined');\n}\n\n\n// removeIFrameMessageListener\nfunction removeSourceSubscriber(sourceMessage) {\n    var win = this.frameWindow();\n    if (win) win.removeEventListener('message', this, false);\n    else logger.warn('FrameMessageSource: frame window is undefined');\n}\n\n\nfunction trigger(msgType, data) {\n    data = data || {};\n    data.type = msgType;\n\n    this.frameWindow().postMessage(data, '*');\n}\n\n\n// TODO maybe refactor to FrameMsgAPI?\nfunction handleEvent(event) {\n    this.dispatchMessage(event.data.type, event);\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , componentName = require('../util/component_name')\n    , check = miloCore.util.check\n    , Match = check.Match\n    , logger = miloCore.util.logger;\n\n\n/**\n * Scope class.\n * @param {Element} rootEl the root element of this scope\n * @param {Object} hostObject the host \n * @return {Scope}\n */\nfunction Scope(rootEl, hostObject) {\n    _.defineProperties(this, {\n        _rootEl: rootEl,\n        _hostObject: hostObject\n    }, _.WRIT); // writable\n}\n\n_.extendProto(Scope, {\n    _add: Scope$_add,\n    _safeAdd: Scope$_safeAdd,\n    _copy: Scope$_copy,\n    _each: Scope$_each,\n    _move: Scope$_move,\n    _merge: Scope$_merge,\n    _length: Scope$_length,\n    _any: Scope$_any,\n    _remove: Scope$_remove,\n    _clean: Scope$_clean,\n    _detachElement: Scope$_detachElement,\n    _has: Scope$_has,\n    _filter: Scope$_filter\n});\n\n\n_.extend(Scope, {\n    rename: Scope$$rename\n});\n\n\nmodule.exports = Scope;\n\n\nvar allowedNamePattern = /^[A-Za-z][A-Za-z0-9\\_\\$]*$/;\n\n\n/**\n * Scope instance method.\n * Adds object to the scope, throwing if name is not unique\n * @param {Component|ComponentInfo} object component or component info to add to the scope\n * @param {String} name the name of the component to add\n */\nfunction Scope$_add(object, name) {\n    if (typeof name == 'string')\n        object.name = name;\n    else\n        name = object.name;\n    \n    if (this.hasOwnProperty(name))\n        throw new Error('duplicate object name: ' + name);\n\n    checkName(name);\n    __add.call(this, object, name);\n}\n\n\n/**\n * Scope instance method\n * Adds object to scope renaming it if name is not unique\n * @param {Component|ComponentInfo} object component or component info to add to the scope\n * @param {String} name the name of the component to add\n */\nfunction Scope$_safeAdd(object, name) {\n    if (typeof name == 'string')\n        object.name = name;\n    else\n        name = object.name;\n\n    var shouldRename = this.hasOwnProperty(name);\n    if (shouldRename)\n        logger.error('Scope: duplicate object name: ' + name);\n    else {\n        shouldRename = ! allowedNamePattern.test(name);\n        if (shouldRename)\n            logger.error('Scope: name should start from letter, this name is not allowed: ' + name);\n    }\n\n    if (shouldRename) {\n        name = componentName();\n        object.name = name;\n    }\n\n    __add.call(this, object, name);\n}\n\n\nfunction __add(object, name) {\n    this[name] = object;\n    object.scope = this;\n\n    if (typeof object.postMessage === 'function')\n        object.postMessage('addedtoscope'); \n}\n\n\n/**\n * Instance method.\n * copies all objects from one scope to another,\n * throwing if some object is not unique\n * @param {Scope} aScope the scope to copy\n */\nfunction Scope$_copy(aScope) {\n    check(aScope, Scope);\n\n    aScope._each(Scope$_add, this);\n}\n\n\n/**\n * Instance method.\n * Moves a component from this scope to another scope.\n * @param {Component} component the component to be moved\n * @param {Scope} otherScope the scope to copy the component to\n */\nfunction Scope$_move(component, otherScope) {\n    otherScope._add(component);\n    this._remove(component.name);\n    component.scope = otherScope;\n}\n\n\n/**\n * Instance method.\n * Merges one scope into this scope\n * @param {Scope} scope the scope to absorb\n */\nfunction Scope$_merge(scope) {\n    scope._each(function (comp) {\n        this._add(comp, comp.name);\n        scope._remove(comp.name);\n    }, this);\n}\n\n\n/**\n * Instance method.\n * Enumerates each component in the scope\n * @param {Function} callback the function to execute for each component\n * @param {Object} thisArg the context\n */\nfunction Scope$_each(callback, thisArg) {\n    _.eachKey(this, callback, thisArg || this, true); // enumerates enumerable properties only\n}\n\n\n/**\n * Instance method.\n * Returns a filtered list of components based on a callback\n * @param {Function} callback the function to execute for each component\n * @param {Object} thisArg the context\n * @return {Array}\n */\nfunction Scope$_filter(callback, thisArg) {\n    return _.filterKeys(this, callback, thisArg || this, true);\n}\n\n\n/**\n * Checks the validity of a name.\n * @param {Function} callback the function to execute for each component\n */\nfunction checkName(name) {\n    if (! allowedNamePattern.test(name))\n        throw new Error('name should start from letter, this name is not allowed: ' + name);\n}\n\n\n/**\n * Instance method.\n * Returns the number of objects in the scope\n * @return {Number}\n */\nfunction Scope$_length() {\n    return Object.keys(this).length;\n}\n\n\n/**\n * Instance method.\n * Returns a component from the scope. It may look like it returns the first component\n * but in reality given that scopes are hashes, there is no such thing.\n * @return {Component}\n */\nfunction Scope$_any() {\n    var key = Object.keys(this)[0];\n    return key && this[key];\n}\n\n\n/**\n * Instance method.\n * Removes a component from the scope by it's name.\n * @param {String} name the name of the component to remove\n * @param {Boolean} quiet optional true to suppress the warning message if the component is not in scope\n */\nfunction Scope$_remove(name, quiet) {\n    if (! (name in this)) {\n        if (!quiet) logger.warn('removing object that is not in scope');\n        return;\n    }\n\n    var object = this[name];\n\n    delete this[name];\n\n    if (typeof object.postMessage === 'function')\n        object.postMessage('removedfromscope');\n}\n\n\n/**\n * Instance method.\n * Removes all components from the scope.\n */\nfunction Scope$_clean() {\n    this._each(function(object, name) {\n        delete this[name].scope;\n        delete this[name];\n    }, this);\n}\n\nfunction Scope$_detachElement() {\n    this._rootEl = null;\n}\n\n\n/**\n * Checks if scope has object by object name\n * @param {Object} object\n * @return {Boolean}\n */\nfunction Scope$_has(object) {\n    return this.hasOwnProperty(object.name);\n}\n\n\n/**\n * Change object name, renaming it in scope unless renameInScope is false\n * @param {Object} obj\n * @param {String} name new name\n * @param {Boolean} renameInScope true by default\n */\nfunction Scope$$rename(obj, name, renameInScope) {\n    if (obj.scope && renameInScope !== false) {\n        obj.scope._remove(obj.name);\n        obj.scope._add(obj, name);\n    } else\n        obj.name = name;\n}\n",
    "'use strict';\n\n\n// <a name=\"config\"></a>\n// milo.config\n// -----------\n\n// It is the function that allows to change milo configurations and also\n// access them on config's properties.\n\n// ```javascript\n// milo.config({\n//     attrs: {\n//         bind: 'ml-bind',\n//         load: 'ml-load'\n//     }\n// });\n// ```\n\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , doT = miloCore.util.doT;\n\n\nvar config = module.exports = miloCore.config;\n\n\nconfig({\n    attrs: {\n        bind: 'ml-bind',\n        load: 'ml-load'\n    },\n    componentRef: '___milo_component',\n    componentPrefix: 'milo_',\n    template: {\n        compile: doT.compile\n    },\n    domStorage: {\n        typeSuffix: ':___milo_data_type',\n        prefixSeparator: '/',\n        root: '',\n        messageKey: '___milo_message/',\n        messageTimestamp: '___milo_timestamp',\n        quotaExceeded: {\n            throwError: true,\n            message: false\n        }\n    },\n    dragDrop: {\n        dataTypes: {\n            component: 'x-application/milo/component',\n            componentMetaTemplate: 'x-application/milo/component-meta/%class/%name/%params',\n            componentMetaRegex: /^x\\-application\\/milo\\/component\\-meta\\/([a-z0-9]+)\\/([a-z0-9]+)\\/([a-z0-9]*)$/,\n        }\n    },\n    request: {\n        jsonpTimeout: 60000,\n        jsonpCallbackPrefix: '___milo_callback_',\n        optionsKey: '___milo_options',\n        completedKey: '___milo_completed',\n        defaults: {\n            timeout: 60000\n        }\n    },\n    websocket: {\n        rpc: {\n            timeout: 15000,\n            responsePrefix: 'response_'\n        }\n    },\n    deprecationWarning: 'once'\n});\n",
    "'use strict';\n\n\nvar miloMail = require('./services/mail')\n    , request = require('./util/request')\n    , miloCore = require('milo-core')\n    , logger = miloCore.util.logger\n    , _ = miloCore.proto\n    , utilDom = require('./util/dom')\n    , config = require('./config')\n    , LoadAttribute = require('./attributes/a_load');\n\n\nmodule.exports = loader;\n\n/**\n * `milo.loader`\n * \n * Recursively scans the document tree inside `rootEl` (document.body by default) looking for __ml-load__ @attribute.\n * One level load is executed. No additional loader get called on inside __ml-load__ attributes. \n *\n * Possible usages:\n * - milo.loader([myRootEl,][myRemoveAttribute,]myCallback)\n * \n * @param  {Element}  rootEl          Root element inside which DOM will be scanned (document.body by default).\n * @param  {Boolean}  removeAttribute If set to true, then the __ml-load__ attribute will be removed once loader has been executed (False by default).\n * @param  {Function} callback        Callback to call after all elements get loaded (Required).\n */\nfunction loader(rootEl, removeAttribute, callback) {\n    milo(function() {\n        _loader(rootEl, removeAttribute, callback);\n    });\n}\n\n\nfunction _loader(rootEl, removeAttribute, callback) {\n    if (typeof rootEl == 'function') {\n        callback = rootEl;\n        rootEl = undefined;\n        removeAttribute = false;\n    }\n\n    if (typeof removeAttribute == 'function') {\n        callback = removeAttribute;\n        removeAttribute = false;\n    }\n\n    rootEl = rootEl || document.body;\n\n    miloMail.postMessage('loader', { state: 'started' });\n    _loadViewsInElement(rootEl, removeAttribute, function(views) {\n        miloMail.postMessage('loader', { \n            state: 'finished',\n            views: views\n        });\n        callback(views);\n    });\n}\n\n\nfunction _loadViewsInElement(rootEl, removeAttribute, callback) {\n    var loadElements = rootEl.getAttribute(config.attrs.load)\n                        ? [rootEl]\n                        : rootEl.querySelectorAll('[' + config.attrs.load + ']');\n\n    var views = {}\n        , totalCount = loadElements.length\n        , loadedCount = 0;\n\n    _.forEach(loadElements, function (el) {\n        loadView(el, removeAttribute, function(err) {\n            views[el.id] = err || el;\n            loadedCount++;\n            if (loadedCount == totalCount)\n                callback(views);\n        });\n    });\n}\n\n\nfunction loadView(el, removeAttribute, callback) {\n    if (utilDom.children(el).length)\n        throw new Error('can\\'t load html into element that is not empty');\n\n    var attr = new LoadAttribute(el);\n\n    attr.parse().validate();\n\n    request.get(attr.loadUrl, function(err, html) {\n        if (err) {\n            err.message = err.message || 'can\\'t load file ' + attr.loadUrl;\n            // logger.error(err.message);\n            callback(err);\n            return;\n        }\n\n        el.innerHTML = html;\n        if (removeAttribute) LoadAttribute.remove(el);\n        callback(null);\n    });\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto;\n\n\n// register included facets\nrequire('./use_facets');\n\nrequire('./components/classes/View');\n\n\n/**\n * `milo`\n *\n * A minimalist browser framework that binds DOM elements to JS components and components to models.\n *\n * `milo` is available as global object in the browser.\n * At the moment it is not possiible to require it with browserify to have it bundled with the app because of the way [brfs](https://github.com/substack/brfs) browserify plugin is implemented.\n * It is possible though to require `milo` with node to use universal parts of the framework (abstract classes, Messenger, Model, etc.):\n * ```\n * var milo = require('milojs');\n * ```\n * \n * `milo` itself is a function that in the browser can be used to delay execution until DOM is ready.\n */\nfunction milo(func) {\n    milo.util.domReady(func);\n}\n\n\n/**\n * ####Milo packages####\n *\n * - [loader](./loader.js.html) - loading subviews into page\n * - [binder](./binder.js.html) - components instantiation and binding of DOM elements to them\n * - [minder](./minder.js.html) - data reactivity, one or two way, shallow or deep, as you like it\n * - [mail](./mail/index.js.html) - applicaiton level messenger, also connects to messages from other windows dispatched with `window.postMessage`.\n * - [config](./config.js.html) - milo configuration\n * - [util](./util/index.js.html) - logger, request, dom, check, error, etc.\n * - [classes](./classes.js.html) - abstract and base classes\n * - [attributes](./attributes/index.js.html) - classes that wrap DOM elements attributes recognized by milo\n * - [ComponentFacet](./components/c_facet.js.html) - base class of Component facet\n * - [Component](./components/c_class.js.html) - base Component class\n * - [Messenger](./messenger/index.js.html) - generic Messenger used in most other milo classes, can be mixed into app classes too.\n * - [Model](./model/index.js.html) - Model class that emits messages on changes to any depth without timer based watching\n * - [registry](./registry.js.html) - registries of fasets and components classes\n */\n_.extend(milo, {\n    Messenger: miloCore.Messenger,\n    Model: miloCore.Model,\n    minder: miloCore.minder,\n    loader: require('./loader'),\n    binder: require('./binder'),\n    mail: require('./services/mail'),\n    window: require('./services/window'),\n    config: require('./config'),\n    util: require('./util'),\n    classes: require('./classes'),\n    attributes: require('./attributes'),\n    ComponentFacet: require('./components/c_facet'),\n    Component: require('./components/c_class'),\n    Command: require('./command'),\n    registry: require('./registry'),\n    milo_version: '0.2.6',\n    createComponentClass: require('./util/create_component_class'),\n    createFacetClass: require('./util/create_facet_class'),\n    destroy: destroy\n});\n\n\n// export for node/browserify\nif (typeof module == 'object' && module.exports)    \n    module.exports = milo;\n\n// global milo for browser\nif (typeof window == 'object') {\n    window.milo = milo;\n    milo.mail.trigger('miloready');\n}\n\n\nfunction destroy() {\n    miloCore.destroy();\n    milo.mail.destroy();\n    milo.window.destroy();\n    milo.util.destroy();\n}\n",
    "'use strict';\n\n/**\n * Registries of facets and of components\n *\n * - [facets](./components/c_facets/cf_registry.js.html)\n * - [components](./components/c_registry.js.html)\n */\nvar registry = module.exports = {\n    facets: require('./components/c_facets/cf_registry'),\n    components: require('./components/c_registry'),\n    commands: require('./command/cmd_registry')\n};\n",
    "'use strict';\n\n// <a name=\"components-dom-constructors\"></a>\n// ###dom events constructors\n\n\nvar _ = require('milo-core').proto;\n\n\n// https://developer.mozilla.org/en-US/docs/Web/Reference/Events\n\nvar eventTypes = {\n    ClipboardEvent: ['copy', 'cut', 'paste', 'beforecopy', 'beforecut', 'beforepaste'],\n    Event: ['input', 'readystatechange'],\n    FocusEvent: ['focus', 'blur', 'focusin', 'focusout'],\n    KeyboardEvent: ['keydown', 'keypress',  'keyup'],\n    MouseEvent: ['click', 'contextmenu', 'dblclick', 'mousedown', 'mouseup',\n                 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover',\n                 'show' /* context menu */],\n    TouchEvent: ['touchstart', 'touchend', 'touchmove', 'touchenter', 'touchleave', 'touchcancel'],\n};\n\n\n// mock window and event constructors for testing\nif (typeof window != 'undefined')\n    var global = window;\nelse {\n    global = {};\n    _.eachKey(eventTypes, function(eTypes, eventConstructorName) {\n        var eventConstructor = _.makeFunction(eventConstructorName, 'type', 'properties',\n            'this.type = type; _.extend(this, properties);');\n        global[eventConstructorName] = eventConstructor;\n    });\n}\n\n\nvar domEventsConstructors = {};\n\n_.eachKey(eventTypes, function(eTypes, eventConstructorName) {\n    eTypes.forEach(function(type) {\n        if (Object.hasOwnProperty(domEventsConstructors, type))\n            throw new Error('duplicate event type ' + type);\n\n        domEventsConstructors[type] = global[eventConstructorName];\n    });\n});\n\n\nmodule.exports = domEventsConstructors;\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , MessageSource = miloCore.classes.MessageSource\n    , Component = require('../components/c_class')\n    , domEventsConstructors = require('./de_constrs') // TODO merge with DOMEventSource ??\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\nvar DOMEmitterSource = _.createSubclass(MessageSource, 'DOMEmitterSource', true);\n\n\n_.extendProto(DOMEmitterSource, {\n    // implementing MessageSource interface\n    init: init,\n    destroy: DOMEmitterSource$destroy,\n    addSourceSubscriber: _.partial(sourceSubscriberMethod, 'addEventListener'),\n    removeSourceSubscriber: _.partial(sourceSubscriberMethod, 'removeEventListener'),\n    postMessage: DOMEmitterSource$postMessage,\n    trigger: trigger,\n\n    // class specific methods\n    emitter: emitter,\n    handleEvent: handleEvent,  // event dispatcher - as defined by Event DOM API\n});\n\nmodule.exports = DOMEmitterSource;\n\n\nvar useCapturePattern = /__capture$/\n    , useCapturePostfix = '__capture';\n\n\n// init DOM event source\nfunction init(hostObject, proxyMethods, messengerAPIOrClass, eventEmitter) {\n    this.eventEmitter = eventEmitter;\n    MessageSource.prototype.init.apply(this, arguments);\n}\n\n\nfunction DOMEmitterSource$destroy() {\n    MessageSource.prototype.destroy.apply(this, arguments);\n    delete this.eventEmitter;\n}\n\n\n// get DOM element of component\nfunction emitter() {\n    return this.eventEmitter;\n}\n\n\nfunction sourceSubscriberMethod(method, eventType) {\n    if (! (eventType && typeof eventType == 'string')) return;\n    var capture = useCapturePattern.test(eventType);\n    if (capture) eventType = eventType.replace(useCapturePattern, '');\n    this.emitter()[method](eventType, this, capture);\n}\n\n\n// event dispatcher - as defined by Event DOM API\nfunction handleEvent(event) {\n    var isCapturePhase;\n    if (typeof window != 'undefined')\n        isCapturePhase = event.eventPhase == window.Event.CAPTURING_PHASE;\n\n    var msg = event.type + (isCapturePhase ? useCapturePostfix : '');\n\n    this.dispatchMessage(msg, event);\n}\n\n\nfunction DOMEmitterSource$postMessage(message, data) {\n    this.messenger.postMessageSync(message, data);\n}\n\n\nfunction trigger(eventType, properties) {\n    check(eventType, String);\n    check(properties, Match.Optional(Object));\n\n    eventType = eventType.replace(useCapturePattern, '');\n    var EventConstructor = domEventsConstructors[eventType];\n\n    if (typeof EventConstructor != 'function')\n        throw new Error('unsupported event type');\n\n    // check if it is correct\n    if (typeof properties != 'undefined')\n        properties.type = eventType;\n\n    var domEvent = new EventConstructor(eventType, properties);\n    var notCancelled = this.emitter().dispatchEvent(domEvent);\n    return notCancelled;\n}\n",
    "'use strict';\n\n/**\n * `milo.mail`\n * It is an application level messenger that is an instance of Messenger class.\n *\n * At the moment, in addition to application messages that you define, you can subscribe to __domready__ message that is guaranteed to fire once,\n * even if DOM was ready at the time of the subscription.\n *\n * Messaging between frames is available via milo.mail. See [Frame facet](../components/c_facets/Frame.js.html).\n *\n * See [Messenger](../messenger/index.js.html).\n * \n**/\n\n\nvar miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , MailMsgAPI = require('./mail_api')\n    , MailMessageSource = require('./mail_source')\n    , _ = miloCore.proto;\n\n\nvar miloMail = new Messenger;\n\nvar mailMsgSource = new MailMessageSource(miloMail, { trigger: 'trigger' }, new MailMsgAPI);\n\nmiloMail._setMessageSource(mailMsgSource);\n\n\nmodule.exports = miloMail;\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , MessengerAPI = miloCore.classes.MessengerAPI\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\n\nvar MailMsgAPI = _.createSubclass(MessengerAPI, 'MailMsgAPI', true);\n\n\n_.extendProto(MailMsgAPI, {\n    translateToSourceMessage: translateToSourceMessage,\n    filterSourceMessage: filterSourceMessage\n});\n\nmodule.exports = MailMsgAPI;\n\n\n// TODO: this function should return relevant DOM event dependent on element tag\n// Can also implement beforedatachanged event to allow preventing the change\n// translateToDomEvent\nvar windowMessageRegExp = /^message\\:/\n    , windowMessagePrefix = 'message:';\n\nfunction translateToSourceMessage(message) {\n    if (message == 'domready')\n        return 'readystatechange';\n    else if (windowMessageRegExp.test(message))\n        return 'message';\n}\n\n\n// filterDataMessage\nfunction filterSourceMessage(sourceMessage, msgType, msgData) {\n    if (sourceMessage == 'readystatechange') {\n        //return document.readyState == 'interactive';\n        //  return false;\n        // _.defineProperty(this, '_domReadyFired', true, _.WRIT);\n        return true;\n    } else if (sourceMessage == 'message')\n        return windowMessagePrefix + msgData.data.type == msgType;\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , MessageSource = miloCore.classes.MessageSource\n    , domEventsConstructors = require('../de_constrs')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\n\nvar MailMessageSource = _.createSubclass(MessageSource, 'MailMessageSource', true);\n\n\n_.extendProto(MailMessageSource, {\n    // implementing MessageSource interface\n    addSourceSubscriber: addSourceSubscriber,\n    removeSourceSubscriber: removeSourceSubscriber,\n    trigger: trigger,\n\n    // class specific methods\n    _windowSubscriberMethod: _windowSubscriberMethod,\n    handleEvent: handleEvent,  // event dispatcher - as defined by Event DOM API\n});\n\n\nmodule.exports = MailMessageSource;\n\n\nfunction addSourceSubscriber(sourceMessage) {\n    if (isReadyStateChange(sourceMessage)) {\n        if (document.readyState == 'loading')\n            document.addEventListener('readystatechange', this, false);\n        else {\n            var EventConstructor = domEventsConstructors.readystatechange;\n            var domEvent = new EventConstructor('readystatechange', { target: document });\n            this.dispatchMessage('readystatechange', domEvent);\n        }\n    } else\n        this._windowSubscriberMethod('addEventListener', sourceMessage);\n}\n\n\nfunction removeSourceSubscriber(sourceMessage) {\n    if (isReadyStateChange(sourceMessage))\n        document.removeEventListener('readystatechange', this, false);\n    else \n        this._windowSubscriberMethod('removeEventListener', sourceMessage);\n}\n\n\nfunction isReadyStateChange(sourceMessage) {\n    return sourceMessage == 'readystatechange' && typeof document == 'object';\n}\n\nfunction isWindowMessage(sourceMessage) {\n    return sourceMessage == 'message' && typeof window == 'object';\n}\n\nfunction _windowSubscriberMethod(method, sourceMessage) {\n    if (isWindowMessage(sourceMessage))\n        window[method]('message', this, false);\n}\n\n\n// event dispatcher - as defined by Event DOM API\nfunction handleEvent(event) {\n    this.dispatchMessage(event.type, event);\n}\n\n\nfunction trigger(msgType, data) {\n    data = data || {};\n    data.type = 'message:' + msgType;\n    \n    if (typeof window == 'object')\n        window.postMessage(data, '*');\n}\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , DOMEmitterSource = require('./dom_source')\n    , _ = miloCore.proto;\n\n\nvar windowService = new Messenger;\nvar domEmitterSource = new DOMEmitterSource(windowService, { trigger: 'trigger' }, undefined, window);\nwindowService._setMessageSource(domEmitterSource);\n\n\nmodule.exports = windowService;\n\n\n_.extend(windowService, {\n    isTop: windowService_isTop\n});\n\n\nfunction windowService_isTop() {\n    return window.top == window.self || window.__karma__;\n}\n",
    "'use strict';\n\nrequire('./components/c_facets/Css');\nrequire('./components/c_facets/Dom');\nrequire('./components/c_facets/Data');\nrequire('./components/c_facets/Frame');\nrequire('./components/c_facets/Events');\nrequire('./components/c_facets/Options');\nrequire('./components/c_facets/Template');\nrequire('./components/c_facets/Container');\nrequire('./components/c_facets/ModelFacet');\nrequire('./components/c_facets/Drag');\nrequire('./components/c_facets/Drop');\nrequire('./components/c_facets/List');\nrequire('./components/c_facets/Item');\nrequire('./components/c_facets/Transfer');\n",
    "'use strict';\n\nvar uniqueId = require('./unique_id')\n    , config = require('../config')\n    , prefix = config.componentPrefix;\n\n\nmodule.exports = componentName;\n\n\nfunction componentName() {\n    return prefix + uniqueId();\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match\n    , componentRegistry = require('../components/c_registry');\n\n\nmodule.exports = createComponentClass;\n\n/**\n * Utility function which creates and registers new milo component.  The component created will have\n * a reference to the super class used in its creation (Accessible using <ComponentClass>.super).\n *\n * @param {string} config.className - The name of the new component\n * @param {string} ['Component'] config.superClassName - The name of an existing component to be used as the new component's super class\n * @param {object=} config.facets - Facet configuration (Hash of facet name {string} to config {object})\n * @param {object=} config.methods - Methods of the new component (Hash of function name {string} to function {function})\n * @param {object=} config.staticMethods - Static methods of the new component (Hash of function name {string} to function {function})\n */\nfunction createComponentClass(config) {\n    check(config, {\n        superClassName: Match.Optional(String),\n        className: String,\n        facets: Match.Optional(Object),\n        methods: Match.Optional(Match.ObjectHash(Function)),\n        staticMethods: Match.Optional(Match.ObjectHash(Function)),\n    });\n    var SuperClass = componentRegistry.get(config.superClassName || 'Component');\n    var ComponentClass = SuperClass.createComponentClass(config.className, config.facets);\n\n    if (config.methods) _.extendProto(ComponentClass, config.methods);\n\n    if (config.staticMethods) {\n        if (config.staticMethods.super !== undefined) throw '\\'super\\' is a reserved keyword';\n        _.extend(ComponentClass, config.staticMethods);\n    }\n\n    ComponentClass.super = SuperClass.prototype;\n    componentRegistry.add(ComponentClass);\n    return ComponentClass;\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match\n    , FacetBaseClass = require('../components/c_facet')\n    , facetRegistry = require('../components/c_facets/cf_registry');\n\nmodule.exports = createFacetClass;\n\nfunction createFacetClass(config) {\n    check(config, {\n        className: String,\n        superClassName: Match.Optional(String),\n        require: Match.Optional(Array),\n        methods: Match.Optional(Match.ObjectHash(Function)),\n        configSchema: Match.Optional(Object)\n    });\n\n    var SuperClass = config.superClassName ? facetRegistry.get(config.superClassName) : FacetBaseClass;\n    var FacetClass = _.createSubclass(SuperClass, config.className);\n\n    if (config.methods) _.extendProto(FacetClass, config.methods);\n    if (config.require) _.extendProto(FacetClass, { require: config.require });\n    if (config.configSchema) _.extendProto(FacetClass, { configSchema: config.configSchema });\n\n    FacetClass.super = SuperClass.prototype;\n    facetRegistry.add(FacetClass);\n    return FacetClass;\n}",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger\n    , config = require('../config');\n\n\nmodule.exports = function deprecate(fn, message) {\n    var warned;\n    switch (typeof fn) {\n        case 'object':\n            return _.mapKeys(fn, function(f) { return deprecate(f, message); });\n        case 'function':\n            for (var prop in fn)\n                deprecated[prop] = deprecate(fn[prop], message);\n            return deprecated;\n        default:\n            return fn;\n    }\n\n\n    function deprecated() {\n        if (config.deprecationWarning\n            && (!warned || config.deprecationWarning == 'always')) {\n            logger.error(message || 'Function ' + fn.name + ' is DEPRECATED');\n            warned = true;\n        }\n        return fn.apply(this, arguments);\n    }\n};\n",
    "'use strict';\n\n\nvar config = require('../config')\n    , miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger;\n\nvar domUtils = {\n    children: children,\n    filterNodeListByType: filterNodeListByType,\n    containingElement: containingElement,\n    selectElementContents: selectElementContents,\n    selectElementText: selectElementText,\n    getElementOffset: getElementOffset,\n    setCaretPosition: setCaretPosition,\n    getSelectionDirection: getSelectionDirection,\n    setSelection: setSelection,\n    clearSelection: clearSelection,\n    removeElement: removeElement,\n    unwrapElement: unwrapElement,\n    wrapInElement: wrapInElement,\n    detachComponent: detachComponent,\n    firstTextNode: firstTextNode,\n    lastTextNode: lastTextNode,\n    trimNodeRight: trimNodeRight,\n    trimNodeLeft: trimNodeLeft,\n    stripHtml: stripHtml,\n    htmlEntities: htmlEntities,\n    walkTree: walkTree,\n    createTreeWalker: createTreeWalker,\n\n    treePathOf: treePathOf,\n    getNodeAtTreePath: getNodeAtTreePath,\n    insertAtTreePath: insertAtTreePath,\n    isTreePathBefore: isTreePathBefore,\n\n    getNodeWindow: getNodeWindow,\n\n    getComponentsFromRange: getComponentsFromRange,\n    deleteRangeWithComponents: deleteRangeWithComponents,\n    forEachNodesInRange: forEachNodesInRange,\n    areRangesEqual: areRangesEqual,\n\n    xpathSelector: xpathSelector,\n    xpathSelectorAll: xpathSelectorAll,\n\n    addDebugPoint: addDebugPoint\n};\n\nmodule.exports = domUtils;\n\n\n/**\n * Returns the list of element children of DOM element\n *\n * @param {Element} el element to return the children of (only DOM elements)\n * @return {Array<Element>}\n */\n function children(el) {\n    return filterNodeListByType(el.childNodes, Node.ELEMENT_NODE);\n }\n\n\n/**\n * Filters the list of nodes by type\n *\n * @param {NodeList} nodeList the list of nodes, for example childNodes property of DOM element\n * @param {Integer} nodeType an integer constant [defined by DOM API](https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType), e.g. `Node.ELEMENT_NODE` or `Node.TEXT_NODE`\n * @return {Array<Node>}\n */\nfunction filterNodeListByType(nodeList, nodeType) {\n    return _.filter(nodeList, function (node) {\n        return node.nodeType == nodeType;\n    });\n}\n\n\n/**\n * Find nearest parent element for node.\n * If node is an element, it will be returned.\n *\n * @param {Node} node\n * @return {Element|null}\n */\nfunction containingElement(node) {\n    while (node) {\n        if (node.nodeType == Node.ELEMENT_NODE)\n            return node;\n        node = node.parentNode;\n    }\n    return null;\n}\n\n\n/**\n * Selects inner contents of DOM element\n *\n * @param {Element} el DOM element\n */\nfunction selectElementContents(el) {\n    var doc = el.ownerDocument;\n    if (! doc) return logger.error('selectElementContents: element has no document');\n    var range = doc.createRange();\n    range.selectNodeContents(el);\n    var win = getNodeWindow(el)\n        , sel = win.getSelection();\n    sel.removeAllRanges();\n    sel.addRange(range);\n}\n\n\n/**\n * Selects text inside element\n * @param {Element} el\n */\nfunction selectElementText(el) {\n    var fromNode = firstTextNode(el)\n        , toNode = lastTextNode(el);\n\n    if (fromNode && toNode)\n        setSelection(fromNode, 0, toNode, toNode.textContent.length);\n}\n\n\n/**\n * Sets the caret position to the position in the node\n *\n * @param {Node} node DOM node\n * @param {Number} pos caret position\n */\nfunction setCaretPosition(node, pos) {\n    var doc = node.ownerDocument;\n    if (! doc) return logger.error('setCaretPosition: element has no document');\n    var range = doc.createRange();\n    range.setStart(node, pos);\n    var win = getNodeWindow(node)\n        , sel = win.getSelection();\n    sel.removeAllRanges();\n    sel.addRange(range);\n}\n\n/**\n * get the direction of a selection\n *\n * 1 forward, -1 backward, 0 no direction, undefined one of the node is detached or in a different frame\n *\n * @param {sel} a selection object\n * @return {Integer} can be -1, 0, 1 or undefined\n */\nfunction getSelectionDirection(sel){\n    return _getDirection(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n}\n\nfunction _getDirection(fromNode, startOffset, toNode, endOffset){\n    var docPosition = fromNode.compareDocumentPosition(toNode);\n    if (docPosition & Node.DOCUMENT_POSITION_FOLLOWING){\n        return 1;\n    }\n    else if (docPosition & Node.DOCUMENT_POSITION_PRECEDING){\n        return -1;\n    }\n    else if (fromNode == toNode){\n        if (startOffset < endOffset){\n            return 1;\n        }\n        else if (startOffset > endOffset){\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n\n/**\n * Selects a range in a document\n *\n * @param {Node} fromNode DOM node to start selection in\n * @param {Number} startOffset\n * @param {Node} toNode DOM node to end selection in\n * @param {Number} endOffset\n */\nfunction setSelection(fromNode, startOffset, toNode, endOffset) {\n    var doc = fromNode.ownerDocument;\n    if (! doc) return logger('setCaretPosition: element has no document');\n    var backward = _getDirection(fromNode, startOffset, toNode, endOffset) == -1;\n    var range = doc.createRange();\n    var container, originalContentEditable;\n    // does not work in non contentEditable items\n\n    var win = getNodeWindow(fromNode)\n        , sel = win.getSelection();\n\n\n    if (backward){\n        range.setStart(toNode, endOffset);\n        range.setEnd(fromNode, startOffset);\n        range.collapse(false);\n    }\n    else {\n        range.setStart(fromNode, startOffset);\n        range.setEnd(toNode, endOffset);\n    }\n\n    container = range.commonAncestorContainer == Node.ELEMENT_NODE ?\n        range.commonAncestorContainer :\n        range.commonAncestorContainer.parentElement;\n\n    if (!container.isContentEditable){\n        originalContentEditable = container.contentEditable; // false or inherit\n        container.contentEditable = \"true\";\n    }\n\n    sel.removeAllRanges();\n    sel.addRange(range);\n\n    if (backward){\n        sel.extend(toNode, endOffset);\n    }\n\n    if (originalContentEditable){\n        // restoring contentEditable\n        container.contentEditable = originalContentEditable;\n    }\n}\n\n/**\n * Clears selection in a given window\n * @param {Window} win\n */\nfunction clearSelection(win) {\n    win = win || window;\n    var sel = win.getSelection();\n    sel.removeAllRanges();\n}\n\n\n/**\n * Calculates an element's total top and left offset from the document edge.\n *\n * @param {Element} el the element for which position needs to be returned\n * @param {includeBorder} if is to include the border width\n * @return {Object} vector object with properties topOffset and leftOffset\n */\nfunction getElementOffset(el, includeBorder) {\n    var yPos, xPos;\n\n    yPos = el.offsetTop;\n    xPos = el.offsetLeft;\n    el = el.offsetParent;\n\n    while (el) {\n        yPos += el.offsetTop + getBorder(el, 'Height', includeBorder);\n        xPos += el.offsetLeft + getBorder(el, 'Width', includeBorder);\n        el = el.offsetParent;\n    }\n\n    return { topOffset: yPos, leftOffset: xPos };\n}\n\n\nfunction getBorder(el, type, includeBorder) {\n    if (includeBorder) {\n        var side = (type == 'Height') ? 'top' : 'left',\n            styles = window.getComputedStyle(el),\n            sideValue = parseInt(styles.getPropertyValue('border-' + side + '-width'), 10);\n\n        if (sideValue) return sideValue;\n    }\n    return 0;\n}\n\n\n/**\n * Removes element from the document\n *\n * @param {Element} el the element to be removed\n */\nfunction removeElement(el) {\n    var parent = el.parentNode;\n    if (parent){\n        parent.removeChild(el);\n        parent.normalize();\n    }\n}\n\n\n/**\n * Returns the first child text node of an element\n *\n * @param {Element|Node} node the node to be searched, if the node is text node we return the node.\n * @return {TextNode}\n */\nfunction firstTextNode(node) {\n    if (node.nodeType == Node.TEXT_NODE) return node;\n    var treeWalker = createTreeWalker(node, NodeFilter.SHOW_TEXT);\n    return treeWalker.firstChild();\n}\n\n\n/**\n * Returns the last child text node of an element\n *\n * @param {Element|Node} node the node to be searched, if the node is text node we return the node.\n * @return {TextNode}\n */\nfunction lastTextNode(node) {\n    if (node.nodeType == Node.TEXT_NODE) return node;\n    var treeWalker = createTreeWalker(node, NodeFilter.SHOW_TEXT);\n    return treeWalker.lastChild();\n}\n\n\n/**\n * Removes element from the document putting its children in its place\n *\n * @param {Element} el the element to be \"unwrapped\"\n */\nfunction unwrapElement(el) {\n    var parent = el.parentNode;\n\n    if (parent) {\n        var frag = document.createDocumentFragment();\n        // must be copied to avoid iterating a mutating list of childNodes\n        var children = _.slice(el.childNodes);\n        children.forEach(frag.appendChild, frag);\n        parent.replaceChild(frag, el);\n        parent.normalize();\n    }\n}\n\n\n/**\n * Wraps an element in another element\n *\n * @param  {Element} wrapIntoEl\n * @param  {Element} el\n */\nfunction wrapInElement(wrapIntoEl, el) {\n    var parent = el.parentNode;\n\n    if (parent) {\n        parent.insertBefore(wrapIntoEl, el);\n        wrapIntoEl.appendChild(el);\n    }\n}\n\n\n/**\n * Trims a text node of trailing spaces, and returns true if a trim was performed.\n *\n * @param  {TextNode} node\n * @return {Boolean}\n */\nfunction trimNodeRight(node) {\n    return _trimNode(node, 'trimRight');\n}\n\n\n/**\n * Trims a text node of leading spaces, and returns true if a trim was performed.\n *\n * @param  {TextNode} node\n * @return {Boolean}\n */\nfunction trimNodeLeft(node) {\n    return _trimNode(node, 'trimLeft');\n}\n\n\nfunction _trimNode(node, methodName) {\n    var len = node.length;\n    node.textContent = node.textContent[methodName]();\n    return len !== node.length;\n}\n\n\n/**\n * Removes the reference to component from element\n *\n * @param  {Element} el\n */\nfunction detachComponent(el) {\n    delete el[config.componentRef];\n}\n\n\n/**\n * Retrieves the content of a html string\n * @param  {String} str Any string\n * @return {String} returns the string cleaned of any html content.\n */\nfunction stripHtml(str) {\n    var div = document.createElement('DIV');\n    div.innerHTML = str;\n    return div.textContent || '';\n}\n\n\n/**\n * Convenience wrapper for native TreeWalker that automatically walks the tree and calls an iterator function.\n * This will not iterate the root element.\n * @param  {HTMLElement} root The containing root element to be walked. Will not be iterated.\n * @param  {NodeFiler} filter A NodeFilter constant, see https://developer.mozilla.org/en/docs/Web/API/TreeWalker\n * @param  {Function} iterator A function to be called on each node. Returning 'false' will break.\n * @param  {Object} context An optional context to passed, defaults to root.\n */\nfunction walkTree(root, filter, iterator, context) {\n    var tw = document.createTreeWalker(root, filter);\n    while(tw.nextNode()) {\n        var result = iterator.call(context || root, tw.currentNode);\n        if (result === false) break;\n    }\n}\n\n\n/**\n * Returns array of child indexes of element path inside root element in DOM tree using breadth first tree traversal.\n * Returns undefined if the element is not inside root element, 0 if the root element itself is passed.\n *\n * @param  {Element} rootEl element to search\n * @param  {Element} el element to find the index of\n * @return {Array<Number>}\n */\nfunction treePathOf(rootEl, el) {\n    if (! (rootEl && rootEl.contains(el))) return;\n\n    var treePath = []\n        , node = rootEl;\n\n    while (node != el) {\n        var nodeIndex = _.findIndex(node.childNodes, containsEl);\n        treePath.push(nodeIndex);\n        node = node.childNodes[nodeIndex];\n    }\n\n    return treePath;\n\n    function containsEl(child) {\n        return child.contains(el);\n    }\n}\n\n\n/**\n * Returns element at given tree path\n *\n * @param {Element} rootEl\n * @param {Array<Number>} treePath\n * @param {Boolean} nearest return nearest possible node if exact node does not exist\n * @return {Node}\n */\nfunction getNodeAtTreePath(rootEl, treePath, nearest) {\n    if (!treePath) return;\n\n    var len = treePath.length;\n    if (len === 0) return rootEl;\n\n    var node = rootEl;\n\n    for (var i = 0; i < len; i++) {\n        var children = node.childNodes;\n        if (! children) {\n            if (! nearest) node = undefined;\n            break;\n        }\n        var childIndex = treePath[i]\n            , child = children[childIndex];\n        if (! child) {\n            node = nearest\n                    ? children[children.length - 1]\n                    : undefined;\n            break;\n        }\n        node = child;\n    }\n\n    return node;\n}\n\n\n/**\n * Inserts an element inside root at a given path in tree (that has the same meaning as the index returned by `treePathOf` function). If element is already in the root's tree, it will be removed first and then moved to the passed treeIndex\n * Insertion at index 0 is not possible and will return undefined as it would mean replacing the root element.\n *\n * @param {Element} rootEl element into which to insert\n * @param {Number} treeIndex index in DOM tree inside root element (see treePathOf)\n * @param {Element} el element to be inserted\n * @return {Boolean} true if was successfully inserted\n */\nfunction insertAtTreePath(rootEl, treePath, el, nearest) {\n    var toNormalize = el.nodeType == Node.TEXT_NODE;\n    if (rootEl.contains(el))\n        removeElement(el); // can't use removeChild as rootEl here is not an immediate parent\n\n    if (treePath.length === 0) return;\n\n    var parent = getNodeAtTreePath(rootEl, treePath.slice(0, -1), nearest)\n        , children = parent.childNodes;\n\n    if (! children) {\n        if (nearest) {\n            parent = parent.parentNode;\n            children = parent.childNodes;\n        } else return;\n    }\n\n    var childIndex = treePath[treePath.length - 1]\n        , child = children[childIndex];\n\n    if (child) {\n        parent.insertBefore(el, child);\n        if (toNormalize) parent.normalize();\n        return true;\n    } else if (children.length === 0 && (childIndex === 0 || nearest)) {\n        parent.appendChild(el);\n        if (toNormalize) parent.normalize();\n        return true;\n    } else {\n        child = children[childIndex - 1];\n        if (child || nearest) {\n            parent.appendChild(el);\n            if (toNormalize) parent.normalize();\n            return true;\n        }\n    }\n}\n\n\n/**\n * Returns `true` if the first tree path points to a node which is before the other in the document order.\n * @param  {Array}  path1   A treepath array\n * @param  {Array}  path2   A treepath array\n * @return {Boolean}\n */\nfunction isTreePathBefore(path1, path2) {\n    var i = 0\n        , isBefore;\n    if (!Array.isArray(path1) && Array.isArray(path2))\n        return logger.error('isTreePathBefore: One or both paths are not valid treepath arrays.');\n\n    for (i; i < path1.length; i++) {\n        if (path1[i] < path2[i]) {\n            isBefore = true;\n            break;\n        } else if (path1[i] > path2[i]) {\n            isBefore = false;\n            break;\n        }\n    }\n\n    if (typeof isBefore == 'undefined')\n        if (path1.length < path2.length)\n            logger.warn('isTreePathBefore: One node is inside another');\n\n    return isBefore || false;\n}\n\n\n/**\n * Converts non latin characters to HTML entity codes.\n * @param  {String} str the string to convert\n * @return {String}     the string with html entities\n */\nfunction htmlEntities(str) {\n    return str.replace(/[\\u00A0-\\u99999<>\\&]/gim, function(i) {\n        return '&#'+i.charCodeAt(0)+';';\n    });\n}\n\n\nfunction createTreeWalker(el, whatToShow) {\n    whatToShow = whatToShow || (NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT);\n    return document.createTreeWalker(el, whatToShow);\n}\n\n\n/**\n * Returns the reference to the window the node is in\n *\n * @param {Node} node\n * @return {Window}\n */\nfunction getNodeWindow(node) {\n    var doc = node.ownerDocument;\n    return doc && (doc.defaultView || doc.parentWindow);\n}\n\n\n\n/**\n * do something for each nodes contained in a range\n *\n * @param {range} a range\n * @param {cb} a function taking a node as argument\n\n */\nfunction forEachNodesInRange(range, cb){\n    var rangeContainer = range.commonAncestorContainer\n        , doc = rangeContainer.ownerDocument;\n\n    function isNodeInsideRange(node){\n        var nodeRange = document.createRange();\n        var isInside = false;\n        nodeRange.selectNode(node);\n\n        if (nodeRange.compareBoundaryPoints(window.Range.START_TO_START, range) != -1\n            && nodeRange.compareBoundaryPoints(window.Range.END_TO_END, range) != 1){\n            isInside = true;\n        }\n        return isInside;\n    }\n\n    var treeWalker = doc.createTreeWalker(rangeContainer,\n            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n\n    var currentNode;\n    while (currentNode = treeWalker.nextNode()){ // should be assignment\n        if (isNodeInsideRange(currentNode)){\n            cb(currentNode);\n        }\n    }\n}\n\n/**\n * get all components contained in a range\n *\n * @param {range} a DOM range.\n */\nfunction getComponentsFromRange(range) {\n    var win = getNodeWindow(range.startContainer)\n        , Component = win.milo.Component;\n\n    var components = [];\n    forEachNodesInRange(range, function (node){\n        if (node.nodeType != Node.TEXT_NODE) {\n            var comp = Component.getComponent(node);\n            if (comp)\n                components.push(comp);\n        }\n    });\n\n    return components;\n}\n\n/**\n * delete a range\n *\n * @param {range} delete a DOM range and all the components inside\n */\nfunction deleteRangeWithComponents(range) {\n    var components = getComponentsFromRange(range);\n\n    components.forEach(function(comp) {\n        comp.destroy(true);\n    });\n\n    range.deleteContents();\n}\n\n/**\n * check if two ranges are equivalent\n *\n * @param {range} range1\n * @param {range} range2\n * @return {Boolean} are the two ranges equivalent\n */\nfunction areRangesEqual(range1, range2){\n    return range1.compareBoundaryPoints(window.Range.START_TO_START, range2) === 0 && range1.compareBoundaryPoints(window.Range.END_TO_END, range2) === 0;\n}\n\n\n/**\n * Return the first node that matches xpath expression\n * @param  {String} xpath xpath expression, e.g. '//a[contains(text(), \"Click here\")]' or '/html/body//h1'\n * @param  {Node} context optional context node to search inside, document by default\n * @return {Node}\n */\nfunction xpathSelector(xpath, context) {\n    if (!document.evaluate) return logger.error('document.evaluate is not supported');\n    context = context || document;\n    var result = document.evaluate(xpath, context, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);\n    return result && result.singleNodeValue;\n}\n\n\n/**\n * Return array of nodes that match xpath expression\n * @param  {String} xpath xpath expression, e.g. '//a[contains(text(), \"Click here\")]' or '/html/body//h1'\n * @param  {Node} context optional context node to search inside, document by default\n * @return {Array<Node>}\n */\nfunction xpathSelectorAll(xpath, context) {\n    if (!document.evaluate) return logger.error('document.evaluate is not supported');\n    context = context || document;\n    var result = document.evaluate(xpath, context, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);\n    var nodes = [], i = 0, node;\n    while (node = result.snapshotItem(i)) nodes[i++] = node;\n    return nodes;\n}\n\n\n/**\n * Adds a single pixel div to the body at a given x and y position. Useful for debugging position specific code.\n * @param {Number} x\n * @param {Number} y\n */\nfunction addDebugPoint(x, y) {\n    var dbEl = document.createElement('div');\n    dbEl.setAttribute('style', 'width: 1px; height: 1px; position:fixed; left:'+x+'px; top:'+y+'px; background-color:red; z-index: 100');\n    setTimeout(function() {document.body.appendChild(dbEl);}, 200);\n}\n",
    "'use strict';\n\n\nvar _ = require('milo-core').proto;\n\n\nmodule.exports = DOMListeners;\n\n\nfunction DOMListeners() {\n    this.listeners = [];\n}\n\n\n_.extendProto(DOMListeners, {\n    add: DOMListeners$add,\n    remove: DOMListeners$remove,\n    removeAll: DOMListeners$removeAll\n});\n\n\nfunction DOMListeners$add(target, eventType, handler) {\n    this.listeners.push({\n        target: target,\n        eventType: eventType,\n        handler: handler\n    });\n    target.addEventListener(eventType, handler);\n}\n\n\nfunction DOMListeners$remove(target, eventType, handler) {\n    var listener = {\n        target: target,\n        eventType: eventType,\n        handler: handler\n    };\n    var idx = _.findIndex(this.listeners, _.partial(_.isEqual, listener));\n\n    if (idx > -1) {\n        this.listeners.splice(idx, 1);\n        _removeListener(listener);\n    }\n}\n\n\nfunction DOMListeners$removeAll() {\n    this.listeners.forEach(_removeListener);\n    this.listeners = [];\n}\n\n\nfunction _removeListener(l) {\n    l.target.removeEventListener(l.eventType, l.handler);\n}\n",
    "'use strict';\n\n\nvar _ = require('milo-core').proto;\n\n\nmodule.exports = domReady;\n\n\nvar domReadyFuncs = []\n    , domReadySubscribed = false;\n\n\nfunction domReady(func) { // , arguments\n    var self = this\n        , args = _.slice(arguments, 1);\n    if (isReady.call(this))\n        callFunc();\n    else {\n        if (!domReadySubscribed) {\n            document.addEventListener('readystatechange', onDomReady);\n            domReadySubscribed = true;\n        }\n        domReadyFuncs.push(callFunc); // closure is added, so every time different function will be called\n    }\n\n    function callFunc() {\n        func.apply(self, args);\n    }\n}\n\n\nfunction onDomReady() {\n    document.removeEventListener('readystatechange', onDomReady);\n    domReadyFuncs.forEach(function(func) { func(); });\n}\n\n\n_.extend(domReady, {\n    isReady: isReady\n});\n\n\nfunction isReady() {\n    var readyState = document.readyState;\n    return readyState == 'loading' ? false : readyState;\n}\n",
    "'use strict';\n\nvar Component = require('../components/c_class')\n    , miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , dragDropConfig = require('../config').dragDrop\n    , componentMetaRegex = dragDropConfig.dataTypes.componentMetaRegex\n    , _ = miloCore.proto\n    , base32 = require('base32');\n\n\nmodule.exports = DragDrop;\n\n\n/**\n * Wrapper for event.dataTransfer of drag-drop HTML API\n *\n * @constructor\n * @param {event} DOM event\n * @return {DragDrop}\n */\nfunction DragDrop(event) {\n    this.event = event;\n    this.dataTransfer = event.dataTransfer;\n    this.types = event.dataTransfer.types;\n}\n\n/**\n * Usage:\n * var testDT = new DragDrop(event);\n * testDT.setComponentMeta(newComponent, {test: 'test', test2: 'test2'});\n * testDT.getComponentMeta();\n */\n\n_.extend(DragDrop, {\n    componentDataType: DragDrop$$componentDataType,\n    getDropPositionY: DragDrop$$getDropPositionY\n});\n\n_.extendProto(DragDrop, {\n    isComponent: DragDrop$isComponent,\n    getComponentState: DragDrop$getComponentState,\n    setComponentState: DragDrop$setComponentState,\n    getComponentMeta: DragDrop$getComponentMeta,\n    setComponentMeta: DragDrop$setComponentMeta,\n    getAllowedEffects: DragDrop$getAllowedEffects,\n    setAllowedEffects: DragDrop$setAllowedEffects,\n    getDropEffect: DragDrop$getDropEffect,\n    setDropEffect: DragDrop$setDropEffect,\n    isEffectAllowed: DragDrop$isEffectAllowed,\n    getData: DragDrop$getData,\n    setData: DragDrop$setData,\n    clearData: DragDrop$clearData\n});\n\n\nfunction DragDrop$$componentDataType() {\n    return dragDropConfig.dataTypes.component;\n}\n\nfunction DragDrop$$getDropPositionY(event, el) {\n    var dP = getDropPosition(event, el);\n    var isBelow = dP.clientY > dP.targetTop + dP.targetHeight / 2;\n    return isBelow ? 'below' : 'above';\n}\n\nfunction getDropPosition(event, el) {\n    try {\n        var clientRect = el.getBoundingClientRect();\n        var targetWidth = clientRect.width;\n        var targetHeight = clientRect.height;\n        var targetTop = clientRect.top;\n        var targetLeft = clientRect.left;\n    } catch(e){}\n    return {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        targetWidth: targetWidth,\n        targetHeight: targetHeight,\n        targetTop: targetTop,\n        targetLeft: targetLeft\n    };\n}\n\n\nfunction DragDrop$isComponent() {\n    return _.indexOf(this.types, DragDrop.componentDataType()) >= 0;\n}\n\n\nfunction DragDrop$getComponentState() {\n    var dataType = DragDrop.componentDataType()\n        , stateStr = this.dataTransfer.getData(dataType)\n        , state = _.jsonParse(stateStr);\n\n    return state;\n}\n\n\nfunction DragDrop$setComponentState(component, stateStr){\n    if (! stateStr) {\n        var state = component.getTransferState({ requestedBy: 'drag' });\n        stateStr = JSON.stringify(state);\n    }\n    var dataType = DragDrop.componentDataType();\n\n    stateStr && this.dataTransfer.setData(dataType, stateStr);\n    this.dataTransfer.setData('text/html', component.el.outerHTML);\n    return stateStr;\n}\n\n\nfunction DragDrop$setComponentMeta(component, params, data) {\n    var meta = _componentMeta(component);\n\n    var paramsStr = JSON.stringify(params || {});\n    var dataType = dragDropConfig.dataTypes.componentMetaTemplate\n                    .replace('%class', _encode(meta.compClass || ''))\n                    .replace('%name', _encode(meta.compName || ''))\n                    .replace('%params', _encode(paramsStr || ''));\n\n    if (data && typeof data == 'object') data = JSON.stringify(data);\n\n    this.dataTransfer.setData(dataType, data || '');\n\n    return dataType;\n}\n\n\nfunction _encode(str) {\n    return base32.encode(str).toLowerCase();\n}\n\n\nfunction _componentMeta(component) {\n    return component.transfer\n            ? component.transfer.getComponentMeta()\n            : {\n                compClass: component.constructor.name,\n                compName: component.name\n            };\n}\n\n\nfunction DragDrop$getComponentMeta() {\n    var match;\n    var metaDataType = _.find(this.types, function (dType) {\n        match = dType.match(componentMetaRegex);\n        return !!match;\n    });\n    if (!metaDataType) return;\n\n    for (var i=1; i<4; i++)\n        match[i] = base32.decode(match[i]);\n\n    return {\n        compClass: match[1],\n        compName: match[2],\n        params: JSON.parse(match[3]),\n        metaDataType: metaDataType,\n        metaData: _.jsonParse(this.dataTransfer.getData(metaDataType)) || this.dataTransfer.getData(metaDataType)\n    };\n}\n\n\n// as defined here: https://developer.mozilla.org/en-US/docs/DragDrop/Drag_Operations#dragstart\nfunction DragDrop$getAllowedEffects() {\n    return this.dataTransfer.effectAllowed;\n}\n\n\nfunction DragDrop$setAllowedEffects(effects) {\n    this.dataTransfer.effectAllowed = effects;\n}\n\n\nfunction DragDrop$getDropEffect() {\n    return this.dataTransfer.dropEffect;\n}\n\n\nfunction DragDrop$setDropEffect(effect) {\n    this.dataTransfer.dropEffect = effect;\n}\n\n\nfunction DragDrop$isEffectAllowed(effect) {\n    var allowedEffects = this.getAllowedEffects()\n        , isCopy = effect == 'copy'\n        , isMove = effect == 'move'\n        , isLink = effect == 'link'\n        , isAllowed = isCopy || isLink || isMove;\n\n    switch (allowedEffects) {\n        case 'copy':\n        case 'move':\n        case 'link':\n            return allowedEffects == effect;\n        case 'copyLink':\n            return isCopy || isLink;\n        case 'copyMove':\n            return isCopy || isMove;\n        case 'linkMove':\n            return isLink || isMove;\n        case 'all':\n        case 'uninitialized':\n            return isAllowed;\n        case 'none':\n            return false;\n    }\n}\n\n\nfunction DragDrop$getData(dataType) {\n    return this.dataTransfer.getData(dataType);\n}\n\n\nfunction DragDrop$setData(dataType, dataStr) {\n    this.dataTransfer.setData(dataType, dataStr);\n}\n\n\nfunction DragDrop$clearData(dataType) {\n    this.dataTransfer.clearData(dataType);\n}\n\n\n/**\n * Drag drop service compensating for the lack of communication from drop target to drag source in DOM API\n */\nvar dragDropService = new Messenger;\n\nvar _currentDragDrop, _currentDragFacet;\n\n_.extend(DragDrop, {\n    service: dragDropService,\n    destroy: DragDrop_destroy\n});\n\n\ndragDropService.onMessages({\n    // data is DragDropDataTransfer instance\n    // fired by Drag facet on \"dragstart\" event\n    'dragdropstarted': onDragDropStarted,\n    // data is object with at least dropEffect property\n    // fired by Drop facet on \"drop\" event\n    'dragdropcompleted': onDragDropCompleted,\n    // fired by Drag facet on \"dragend\" event to complete drag\n    // if drop happended in another window or if it was cancelled\n    'completedragdrop': onCompleteDragDrop\n});\n\n\n_.extend(dragDropService, {\n    getCurrentDragDrop: getCurrentDragDrop,\n    getCurrentDragSource: getCurrentDragSource\n});\n\n\nfunction onDragDropStarted(msg, data) {\n    _currentDragDrop = data.dragDrop;\n    _currentDragFacet = data.dragFacet;\n}\n\n\nfunction onDragDropCompleted(msg, data) {\n    _currentDragFacet && _currentDragFacet.postMessageSync('dragdropcompleted', data);\n    _currentDragDrop = undefined;\n    _currentDragFacet = undefined;\n}\n\n\nfunction onCompleteDragDrop(msg, data) {\n    if (_currentDragDrop)\n        dragDropService.postMessageSync('dragdropcompleted', data);\n}\n\n\nfunction getCurrentDragDrop() {\n    return _currentDragDrop;\n}\n\n\nfunction getCurrentDragSource() {\n    return _currentDragFacet && _currentDragFacet.owner;\n}\n\n\nfunction DragDrop_destroy() {\n    dragDropService.offAll();\n}\n",
    "// <a name=\"utils-error\"></a>\n// milo.utils.error\n// -----------\n\n'use strict';\n\nvar _ = require('milo-core').proto;\n\n\n// module exports error classes for all names defined in this array\nvar errorClassNames = ['AbstractClass', 'Mixin', 'Messenger', 'Component',\n                       'Attribute', 'Binder', 'Loader', 'MailMessageSource', 'Facet',\n                       'Scope', 'Model', 'DomFacet', 'EditableFacet',\n                       'List', 'Connector', 'Registry', 'FrameMessageSource',\n                       'Drop', 'Angular', 'StorageMessageSource'];\n\nvar error = {\n    toBeImplemented: error$toBeImplemented,\n    createClass: error$createClass\n};\n\nerrorClassNames.forEach(function(name) {\n    error[name] = error$createClass(name + 'Error');\n});\n\nmodule.exports = error;\n\n\nfunction error$createClass(errorClassName) {\n    var ErrorClass = _.makeFunction(errorClassName, 'message',\n            'this.name = \"' + errorClassName + '\"; \\\n            this.message = message || \"There was an  error\";');\n    _.makeSubclass(ErrorClass, Error);\n\n    return ErrorClass;\n}\n\n\nfunction error$toBeImplemented() {\n    throw new error.AbstractClass('calling the method of an absctract class');\n}\n",
    "'use strict';\n\n\nvar Component = require('../components/c_class')\n    , BindAttribute = require('../attributes/a_bind')\n    , binder = require('../binder')\n    , domUtils = require('./dom')\n    , miloCore = require('milo-core')\n    , logger = miloCore.util.logger\n    , check = miloCore.util.check\n    , _ = miloCore.proto;\n\n\nvar createRangePaths = _createNodesAndPathsFunc(domUtils.treePathOf);\nvar createRangeNodes = _createNodesAndPathsFunc(domUtils.getNodeAtTreePath);\n\n\nvar fragmentUtils = module.exports = {\n    getState: fragment_getState,\n    getStateAsync: fragment_getStateAsync,\n\n    expandRangeToSiblings: expandRangeToSiblings,\n    getRangeSiblings: getRangeSiblings,\n    createRangeFromSiblings: createRangeFromSiblings,\n    createRangeFromNodes: createRangeFromSiblings, // alias\n    createRangePaths: createRangePaths,\n    createRangeNodes: createRangeNodes\n};\n\n\n/**\n * Creates an object with the state of wrapped range with components, including partially selected. The range will be cloned and wrapped in component with container facet before getting its state.\n * This function will log error and return undefined if range has no common ancestor that has component with container facet\n * \n * @param {Range} range DOM Range instance\n * @param {Boolean} renameChildren optional parameter, `true` to rename fragment child components\n * @param {String} wrapperClassName optional parameter to wrap in a custom component class\n * @return {Object}\n */\nfunction fragment_getState(range, renameChildren, wrapperClassName) {\n    var rangeContainer = _getRangeContainer(range);\n    if (! rangeContainer) {\n        logger.error('fragment.getState: range has no common container');\n        return;\n    }\n\n    var frag = range.cloneContents()\n        , wrapper = _wrapFragmentInContainer(frag, wrapperClassName);\n\n    _transferStates(rangeContainer, wrapper);\n    if (renameChildren) _renameChildren(wrapper);\n    var wrapperState = wrapper.getState();\n    _.deferMethod(wrapper, 'destroy');\n    return wrapperState;\n}\n\n\n/**\n * Creates an object with the state of wrapped range with components, including partially selected. The range will be cloned and wrapped in component with container facet before getting its state.\n * This function will return result and any error via callback.\n * \n * @param {Range} range DOM Range instance\n * @param {Boolean} renameChildren optional parameter, `true` to rename fragment child components\n * @param {Function} callback always the last parameter, optional parameters can be dropped; result is passed via callback with any error as first parameter\n */\nfunction fragment_getStateAsync(range, renameChildren, callback) {\n    try {\n        var rangeContainer = _getRangeContainer(range);\n        if (! rangeContainer) {\n            callback(new Error('fragment.getState: range has no common container'));\n            return; // do NOT connect return to previous callback, getState should return undefined\n        }\n\n        if (typeof renameChildren == 'function') {\n            callback = renameChildren;\n            renameChildren = false;\n        }\n\n        var frag = range.cloneContents()\n            , wrapper = _wrapFragmentInContainer(frag);\n\n        _transferStates(rangeContainer, wrapper);\n        _.defer(function() {\n            wrapper.broadcast('stateready');\n            _.defer(function() {\n                if (renameChildren) _renameChildren(wrapper);\n                var wrapperState = wrapper.getState();\n                wrapper.destroy();\n                callback(null, wrapperState);\n            });\n        });\n    } catch (err) {\n        callback(err);\n    }\n}\n\n\nfunction _wrapFragmentInContainer(frag, wrapperClassName) {\n    var wrapEl = document.createElement('div')\n        , attr = new BindAttribute(wrapEl);\n\n    _.extend(attr, {\n        compClass: wrapperClassName || 'Component',\n        compFacets: wrapperClassName ? [] : ['container'],\n        compName: 'wrapper'\n    });\n\n    attr.decorate();\n\n    wrapEl.appendChild(frag);\n    var scope = binder(wrapEl);\n    return scope.wrapper;\n}\n\n\nfunction _getRangeContainer(range) {\n    var el = domUtils.containingElement(range.commonAncestorContainer);\n    return Component.getContainingComponent(el, true, 'container');\n}\n\n\nfunction _transferStates(fromComp, toComp) {\n    var fromScope = fromComp.container.scope;\n    toComp.container.scope._each(function(toChildComp, name) {\n        var fromChildComp = fromScope[name];\n        if (! fromChildComp) return logger.error('fragment.getState: conponent', name, 'not found in range');\n        var state = fromChildComp._getState(true);\n        toChildComp.setState(state);\n    });\n}\n\n\nfunction _renameChildren(comp) {\n    comp.container.scope._each(function(child) {\n        child.rename();\n    });\n}\n\n\nfunction expandRangeToSiblings(range) {\n    var siblings = getRangeSiblings(range);\n    range = createRangeFromSiblings(siblings);\n    return range;\n}\n\n\nfunction createRangeFromSiblings(nodes) {\n    var range = document.createRange();\n    if (nodes.siblings) {\n        range.setStartBefore(nodes.start);\n        range.setEndAfter(nodes.end);\n    } else\n        range.selectNode(nodes.start);\n    return range;\n}\n\n\nfunction getRangeSiblings(range) {\n    var containerNode = range.commonAncestorContainer\n        , startNode = range.startContainer\n        , endNode = range.endContainer;\n\n    if (startNode == endNode) {\n        if (startNode != containerNode) logger.error('deleteSelectionCommand logical error: start==end, but container is different');\n        return { siblings: false, start: startNode };\n    }\n\n    if (startNode == containerNode || endNode == containerNode)\n        return { siblings: false, start: containerNode };\n\n    var startSibling = _findContainingChild(containerNode, startNode);\n    var endSibling = _findContainingChild(containerNode, endNode);\n\n    if (startSibling && endSibling) {\n        if (startSibling == endSibling) {\n            logger.error('deleteSelectionCommand logical error: same siblings');\n            return { siblings: false, start: startSibling };\n        } else\n            return { siblings: true, start: startSibling, end: endSibling };\n    }\n}\n\n\nfunction _findContainingChild(containerNode, selNode) {\n    return _.find(containerNode.childNodes, function(node) {\n        return node.contains(selNode);\n    });\n}\n\n\nfunction _createNodesAndPathsFunc(func) {\n    return function(rootEl, fromObj) {\n        var toObj = {\n            siblings: fromObj.siblings,\n            start: func(rootEl, fromObj.start)\n        };\n        if (toObj.siblings)\n            toObj.end = func(rootEl, fromObj.end);\n        return toObj;\n    };\n}\n\n\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , deprecate = require('./deprecate');\n\n/**\n * `milo.util`\n */\nvar util = {\n    logger: miloCore.util.logger,\n    request: require('./request'),\n    websocket: require('./websocket'),\n    check: miloCore.util.check,\n    error: deprecate(require('./error'), 'milo.util.error is DEPRECATED and will be REMOVED soon!'),\n    count: deprecate(require('./unique_id'), 'milo.util.count is DEPRECATED! Use milo.util.uniqueId instead'),\n    uniqueId: require('./unique_id'),\n    componentName: require('./component_name'),\n    dom: require('./dom'),\n    domListeners: require('./dom_listeners'),\n    selection: require('./selection'),\n    fragment: require('./fragment'),\n    jsonParse: deprecate(require('./json_parse'), 'milo.util.jsonParse is DEPRECATED! Use _.jsonParse instead'),\n    storage: require('./storage'),\n    domReady: require('./domready'),\n    dragDrop: require('./dragdrop'),\n    deprecate: deprecate,\n    doT: miloCore.util.doT,\n    destroy: util_destroy\n};\n\nmodule.exports = util;\n\n\nfunction util_destroy() {\n    util.request.destroy();\n    util.dragDrop.destroy();\n}\n",
    "'use strict';\n\n\nmodule.exports = jsonParse;\n\n\n/**\n * `milo.util.jsonParse`\n * Safe JSON.parse, returns undefined if JSON.parse throws an exception\n *\n * @param {String} str - JSON string representation of object\n * @return {Object|undefined}\n */\nfunction jsonParse(str) {\n    try {\n        return JSON.parse(str);\n    } catch (e) {}\n}\n",
    "'use strict';\n\n// milo.utils.request\n// -----------\n\n// Convenience functions wrapping XMLHTTPRequest functionality.\n\n// ```\n// var request = milo.utils.request\n//     , opts: { method: 'GET' };\n\n// request(url, opts, function(err, data) {\n//     logger.debug(data);\n// });\n\n// request.get(url, function(err, data) {\n//     logger.debug(data);\n// });\n// ```\n\n// Only generic request and get, json, post convenience methods are currently implemented.\n\n\nvar miloCore = require('milo-core')\n    , _ = miloCore.proto\n    , uniqueId = require('./unique_id')\n    , config = require('../config')\n    , logger = miloCore.util.logger\n    , Messenger = miloCore.Messenger;\n\nmodule.exports = request;\n\n\nvar _pendingRequests = [];\n\nvar promiseThen = createPromiseOverride('then');\nvar promiseCatch = createPromiseOverride('catch');\n\n/**\n * Creates a function which is used to override standard promise behaviour and allow promise instances\n * created to maintain a reference to the request object no matter if .then() or .catch() is called.\n */\nfunction createPromiseOverride(functionName) {\n    return function() {\n        var promise = Promise.prototype[functionName].apply(this, arguments);\n        keepRequestObject(promise, this._request);\n        return promise;\n    };\n}\n\n\nfunction request(url, opts, callback) {\n    opts.url = url;\n    opts.contentType = opts.contentType || 'application/json;charset=UTF-8';\n\n    if (_messenger) request.postMessageSync('request', { options: opts });\n\n    var req = new XMLHttpRequest();\n    req.open(opts.method, opts.url, true);\n    req.setRequestHeader('Content-Type', opts.contentType);\n    setRequestHeaders(req, opts.headers);\n\n    req.timeout = opts.timeout || config.request.defaults.timeout;\n    req.onloadend = req.ontimeout = req.onabort = onReady;\n\n    var xPromise = _createXPromise(req);\n\n    req.send(JSON.stringify(opts.data));\n    req[config.request.optionsKey] = opts;\n\n    if (opts.trackCompletion !== false) _pendingRequests.push(req);\n\n    return xPromise.promise;\n\n    function onReady(e) {\n        _onReady(req, callback, xPromise, e.type);\n    }\n}\n\n\nfunction _createXPromise(request) {\n    var resolvePromise, rejectPromise;\n    var promise = new Promise(function(resolve, reject) {\n        resolvePromise = resolve;\n        rejectPromise = reject;\n    });\n\n    keepRequestObject(promise, request);\n    promise.catch(_.noop); // Sometimes errors are handled within callbacks, so uncaught promise error message should be suppressed.\n\n    return {\n        promise: promise,\n        resolve: resolvePromise,\n        reject: rejectPromise\n    };\n}\n\n// Ensures that the promise (and any promises created when calling .then/.catch) has a reference to the original request object\nfunction keepRequestObject(promise, request) {\n    promise._request = request;\n    promise.then = promiseThen;\n    promise.catch = promiseCatch;\n\n    return promise;\n}\n\n\nfunction setRequestHeaders(req, headers) {\n    if (headers)\n        _.eachKey(headers, function(value, key) {\n            req.setRequestHeader(key, value);\n        });\n}\n\nfunction _onReady(req, callback, xPromise, eventType) {\n    if (req.readyState != 4) return;\n    if (req[config.request.completedKey]) return;\n\n    _.spliceItem(_pendingRequests, req);\n\n    var error;\n    try {\n        if ( req.status >= 200 && req.status < 400 ) {\n            try {\n                postMessage('success');\n                callback && callback(null, req.responseText, req);\n            } catch(e) { error = e; }\n            xPromise.resolve(req.responseText);\n        }\n        else {\n            var errorReason = req.status || eventType;\n            try {\n                postMessage('error');\n                postMessage('error' + errorReason);\n                callback && callback(errorReason, req.responseText, req);\n            } catch(e) { error = e; }\n            xPromise.reject({ reason: errorReason, response: req.responseText });\n        }\n    } catch(e) {\n        error = error || e;\n    } finally {\n        req[config.request.completedKey] = true;\n    }\n\n    // not removing subscription creates memory leak, deleting property would not remove subscription\n    req.onloadend = req.ontimeout = req.onabort = undefined;\n\n    if (!_pendingRequests.length)\n        postMessage('requestscompleted');\n\n    if (error) {\n        var errObj = new Error('Exception: ' + error);\n        logger.error(error.stack);\n        throw errObj;\n    }\n\n    function postMessage(msg) {\n        if (_messenger) request.postMessage(msg,\n            { status: status, response: req.responseText });\n    }\n}\n\n\n_.extend(request, {\n    get: request$get,\n    post: request$post,\n    json: request$json,\n    jsonp: request$jsonp,\n    file: request$file,\n    useMessenger: request$useMessenger,\n    destroy: request$destroy,\n    whenRequestsCompleted: whenRequestsCompleted\n});\n\n\nvar _messenger;\n\n\nfunction request$useMessenger() {\n    _messenger = new Messenger(request, ['on', 'once', 'onSync', 'off', 'onMessages', 'offMessages', 'postMessage', 'postMessageSync']);\n}\n\n\nfunction request$get(url, callback) {\n    return request(url, { method: 'GET' }, callback);\n}\n\n\nfunction request$post(url, data, callback) {\n    return request(url, { method: 'POST', data: data }, callback);\n}\n\n\nfunction request$json(url, callback) {\n    var promise = request(url, { method: 'GET' });\n\n    var jsonPromise = promise.then(JSON.parse);\n\n    if (callback)\n        jsonPromise\n        .then(function(data) {\n            callback(null, data);\n        }, function(errData) {\n            callback(errData.reason, errData.response);\n        });\n\n    return jsonPromise;\n}\n\n\nvar jsonpOptions = { method: 'GET', jsonp: true };\nfunction request$jsonp(url, callback) {\n    var script = document.createElement('script'),\n        xPromise = _createXPromise(script),\n        head = window.document.head,\n        uniqueCallback = config.request.jsonpCallbackPrefix + uniqueId();\n\n    var opts = _.extend({ url: url }, jsonpOptions);\n    if (_messenger) request.postMessageSync('request', { options: opts });\n\n    if (! _.isEqual(_.omitKeys(opts, 'url'), jsonpOptions))\n        logger.warn('Ignored not allowed request options change in JSONP request - only URL can be changed');\n\n    var timeout = setTimeout(function() {\n        var err = new Error('No JSONP response or no callback in response');\n        _onResult(err);\n    }, config.request.jsonpTimeout);\n\n    window[uniqueCallback] = _.partial(_onResult, null);\n\n    _pendingRequests.push(window[uniqueCallback]);\n\n    script.type = 'text/javascript';\n    script.src = opts.url + (opts.url.indexOf('?') == -1 ? '?' : '&') + 'callback=' + uniqueCallback;\n\n    head.appendChild(script);\n\n    return xPromise.promise;\n\n\n    function _onResult(err, result) {\n        _.spliceItem(_pendingRequests, window[uniqueCallback]);\n        var error;\n        try {\n            postMessage(err ? 'error' : 'success', err, result);\n            if (err) {\n                logger.error('No JSONP response or timeout');\n                postMessage('errorjsonptimeout', err);\n            }\n            callback && callback(err, result);\n        }\n        catch(e) { error = e; }\n        if (err) xPromise.reject(err);\n        else xPromise.resolve(result);\n\n        cleanUp();\n        if (!_pendingRequests.length)\n            postMessage('requestscompleted');\n\n        if (error) throw error;\n    }\n\n\n    function cleanUp() {\n        clearTimeout(timeout);\n        head.removeChild(script);\n        delete window[uniqueCallback];\n    }\n\n\n    function postMessage(msg, status, result) {\n        if (_messenger) request.postMessage(msg,\n            { status: status, response: result });\n    }\n}\n\n\nfunction request$file(opts, fileData, callback, progress) {\n    if (typeof opts == 'string')\n        opts = { method: 'POST', url: opts };\n\n    opts.method = opts.method || 'POST';\n    opts.file = true;\n\n    if (_messenger) request.postMessageSync('request', { options: opts });\n\n    var req = new XMLHttpRequest();\n    if (progress) req.upload.onprogress = progress;\n\n    req.open(opts.method, opts.url, true);\n    setRequestHeaders(req, opts.headers);\n\n    req.timeout = opts.timeout || config.request.defaults.timeout;\n    req.onloadend = req.ontimeout = req.onabort = onReady;\n\n    var xPromise = _createXPromise(req);\n\n    if (opts.binary)\n        req.send(fileData);\n    else {\n        var formData = new FormData();\n        formData.append('file', fileData);\n        req.send(formData);\n    }\n\n    req[config.request.optionsKey] = opts;\n\n    if (opts.trackCompletion !== false) _pendingRequests.push(req);\n\n    return xPromise.promise;\n\n    function onReady(e) {\n        if (progress) req.upload.onprogress = undefined;\n        _onReady(req, callback, xPromise, e.type);\n    }\n}\n\n\nfunction request$destroy() {\n    if (_messenger) _messenger.destroy();\n    request._destroyed = true;\n}\n\n\nfunction whenRequestsCompleted(callback, timeout) {\n    callback = _.once(callback);\n    if (timeout)\n        _.delay(callback, timeout, 'timeout');\n\n    if (_pendingRequests.length)\n        _messenger.once('requestscompleted', callback);\n    else\n        _.defer(callback);\n}\n",
    "'use strict';\n\n\nvar domUtils = require('../dom')\n    , containingElement = domUtils.containingElement\n    , setCaretPosition = domUtils.setCaretPosition\n    , getComponentsFromRange = domUtils.getComponentsFromRange\n    , deleteRangeWithComponents = domUtils.deleteRangeWithComponents\n    , miloCore = require('milo-core')\n    , logger = miloCore.util.logger\n    , Component = require('../../components/c_class')\n    , _ = miloCore.proto;\n\nmodule.exports = TextSelection;\n\n\n/**\n * Text selection class.\n * Serves as a helper to manage current selection\n * The object cannot be reused, if the selection changes some of its properties may contain information related to previous selection\n *\n * @param {Window} win window in which text selection is processed\n */\nfunction TextSelection(win) {\n    if (! this instanceof TextSelection)\n        return new TextSelection(win);\n    this.window = win || window;\n    this.init();\n}\n\n\n/**\n * TextSelection instance method\n * Returns selection start element\n *\n * @return {Element|null}\n */\nvar TextSelection$startElement = \n    _.partial(_getElement, '_startElement', 'startContainer');\n\n\n/**\n * TextSelection instance method\n * Returns selection end element\n *\n * @return {Element|null}\n */\nvar TextSelection$endElement = \n    _.partial(_getElement, '_endElement', 'endContainer');\n\n\n/**\n * TextSelection instance method\n * Returns selection end element\n *\n * @return {Element|null}\n */\nvar TextSelection$containingElement = \n    _.partial(_getElement, '_containingElement', 'commonAncestorContainer');\n\n\n/**\n * TextSelection instance method\n * Returns selection start Component\n *\n * @return {Component}\n */\nvar TextSelection$startComponent = \n    _.partial(_getComponent, '_startComponent', 'startElement');\n\n\n/**\n * TextSelection instance method\n * Returns selection end Component\n *\n * @return {Component}\n */\nvar TextSelection$endComponent = \n    _.partial(_getComponent, '_endComponent', 'endElement');\n\n\n/**\n * TextSelection instance method\n * Returns selection end Component\n *\n * @return {Component}\n */\nvar TextSelection$containingComponent = \n    _.partial(_getComponent, '_containingComponent', 'containingElement');\n\n\n_.extendProto(TextSelection, {\n    init: TextSelection$init,\n    text: TextSelection$text,\n    textNodes: TextSelection$textNodes,\n    clear: TextSelection$clear,\n\n    startElement: TextSelection$startElement,\n    endElement: TextSelection$endElement,\n    containingElement: TextSelection$containingElement,\n\n    startComponent: TextSelection$startComponent,\n    endComponent: TextSelection$endComponent,\n    containingComponent: TextSelection$containingComponent,\n\n    containedComponents: TextSelection$containedComponents,\n    eachContainedComponent: TextSelection$eachContainedComponent,\n    del: TextSelection$del,\n    _getPostDeleteSelectionPoint: _getPostDeleteSelectionPoint,\n    _selectAfterDelete: _selectAfterDelete,\n\n    getRange: TextSelection$getRange,\n    getState: TextSelection$getState,\n    getNormalizedRange: TextSelection$$getNormalizedRange,\n    getDirection: TextSelection$$getDirection\n});\n\n\n_.extend(TextSelection, {\n    createFromRange: TextSelection$$createFromRange,\n    createFromState: TextSelection$$createFromState,\n    createStateObject: TextSelection$$createStateObject\n});\n\n\n/**\n * TextSelection instance method\n * Initializes TextSelection from the current selection\n */\nfunction TextSelection$init() {\n    this.selection = this.window.getSelection();\n    if (this.selection.rangeCount)\n        this.range = this.selection.getRangeAt(0);\n    this.isCollapsed = this.selection.isCollapsed;\n}\n\n\n/**\n * TextSelection instance method\n * Retrieves and returns selection text\n *\n * @return {String}\n */\nfunction TextSelection$text() {\n    if (! this.range) return undefined;\n\n    if (! this._text)\n        this._text = this.range.toString();\n\n    return this._text;\n}\n\n\n/**\n * TextSelection instance method\n * Retrieves and returns selection text nodes\n *\n * @return {Array<Node>}\n */\nfunction TextSelection$textNodes() {\n    if (! this.range) return undefined;\n\n    if (! this._textNodes)\n        this._textNodes = _getTextNodes.call(this);\n    return this._textNodes;\n}\n\n\nfunction TextSelection$clear() {\n    this.selection.removeAllRanges();\n}\n\n\n/**\n * Retrieves text and text nodes from selection saving them on properties of object\n *\n * @private\n * @param {TextSelection} this\n */\nfunction _getTextNodes() {\n    // list of selected text nodes\n    var textNodes = [];\n\n    if (this.isCollapsed)\n        return textNodes;\n\n    // create TreeWalker to traverse the tree to select all text nodes\n    var selStart = this.range.startContainer\n        , selEnd = this.range.endContainer\n        , rangeContainer = this.range.commonAncestorContainer;\n\n    var treeWalker = this.window.document.createTreeWalker(rangeContainer, NodeFilter.SHOW_TEXT);\n    var node = treeWalker.currentNode = selStart;\n\n    // traverse DOM tree to collect all selected text nodes\n    while (node && (! inEnd || selEnd.contains(node))) {\n        textNodes.push(node);\n        var inEnd = inEnd || selEnd.contains(node);\n        node = treeWalker.nextNode();\n    }\n    return textNodes;\n}\n\n\n/**\n * Retrieves and returns start/end element from selection saving them on properties of object\n *\n * @private\n * @param {TextSelection} this\n * @return {Element|null}\n */\nfunction _getElement(thisPropName, rangePropName) {\n    if (! this.range) return undefined;\n\n    if (typeof this[thisPropName] == 'undefined')\n        this[thisPropName] = containingElement(this.range[rangePropName]);\n    return this[thisPropName];\n}\n\n\n/**\n * Retrieves and returns start/end component from selection saving them on properties of object\n *\n * @private\n * @param {TextSelection} this\n * @return {Component}\n */\nfunction _getComponent(thisPropName, elMethodName) {\n    if (! this.range) return undefined;\n\n    if (typeof this[thisPropName] == 'undefined')\n        this[thisPropName] = Component.getContainingComponent(this[elMethodName]());\n    return this[thisPropName];\n}\n\n\nfunction TextSelection$containedComponents() {\n    if (this._containedComponents)\n        return this._containedComponents;\n\n    var components = this._containedComponents = [];\n\n    if (this.isCollapsed || ! this.range) return components;\n\n    return getComponentsFromRange(this.range);\n}\n\n\nfunction TextSelection$eachContainedComponent(callback, thisArg) {\n    if (this.isCollapsed || ! this.range) return;\n\n    var components = this.containedComponents();\n\n    components.forEach(callback, thisArg);\n}\n\n\n/**\n * TextSelection instance method\n * Deletes the current selection and all components in it\n * \n * @param {Boolean} selectEndContainer set to true if the end container should be selected after deletion\n */\nfunction TextSelection$del(selectEndContainer) {\n    if (this.isCollapsed || ! this.range) return;\n\n    var selPoint = this._getPostDeleteSelectionPoint(selectEndContainer);\n\n    deleteRangeWithComponents(this.range);\n\n    this._selectAfterDelete(selPoint);\n    selPoint.node.parentNode.normalize();\n}\n\n\nfunction _getPostDeleteSelectionPoint(selectEndContainer) {\n    var selNode = this.range.startContainer;\n    var selOffset = this.range.startOffset;\n    if (selectEndContainer && this.range.startContainer != this.range.endContainer) {\n        selNode = this.range.endContainer;\n        selOffset = 0;\n    }\n    return { node: selNode, offset: selOffset };\n}\n\n\nfunction _selectAfterDelete(selPoint) {\n    var selNode = selPoint.node\n        , selOffset = selPoint.offset;\n\n    if (!selNode) return;\n    if (selNode.nodeType == Node.TEXT_NODE)\n        selNode.textContent = selNode.textContent.trimRight();\n    if (!selNode.nodeValue)\n        selNode.nodeValue = '\\u00A0'; //non-breaking space, \\u200B for zero width space;\n\n    var position = selOffset > selNode.length ? selNode.length : selOffset;\n    setCaretPosition(selNode, position);\n}\n\n\n/**\n * Returns selection range\n *\n * @return {Range}\n */\nfunction TextSelection$getRange() {\n    return this.range;\n}\n\n\n/**\n * Stores selection window, nodes and offsets in object\n */\nfunction TextSelection$getState(rootEl) {\n    var r = this.range;\n    var doc = rootEl.ownerDocument\n        , win = doc.defaultView || doc.parentWindow;\n    if (!r) return { window: win };\n    return TextSelection.createStateObject(rootEl, r.startContainer, r.startOffset, r.endContainer, r.endOffset);\n}\n\n\nfunction TextSelection$$createStateObject(rootEl, startContainer, startOffset, endContainer, endOffset) {\n    endContainer = endContainer || startContainer;\n    endOffset = endOffset || startOffset;\n    var doc = rootEl.ownerDocument\n        , win = doc.defaultView || doc.parentWindow;\n    return {\n        window: win,\n        rootEl: rootEl,\n        start: _getSelectionPointState(rootEl, startContainer, startOffset),\n        end: _getSelectionPointState(rootEl, endContainer, endOffset)\n    };\n}\n\n\nfunction _getSelectionPointState(rootEl, node, offset) {\n    var treePath = domUtils.treePathOf(rootEl, node);\n    if (! treePath) logger.error('Selection point is outside of root element');\n    return {\n        treePath: treePath,\n        offset: offset\n    };\n}\n\n\n/**\n * Restores actual selection to the stored range\n */\nfunction TextSelection$$createFromState(state) {\n    var domUtils = state.window.milo.util.dom;\n\n    if (state.rootEl && state.start && state.end) {\n        var startNode = _selectionNodeFromState(state.rootEl, state.start)\n            , endNode = _selectionNodeFromState(state.rootEl, state.end);\n\n        try {\n            domUtils.setSelection(startNode, state.start.offset, endNode, state.end.offset);\n            return new TextSelection(state.window);\n        } catch(e) {\n            logger.error('Text selection: can\\'t create selection', e, e.message);\n        }\n    } else {\n        domUtils.clearSelection(state.window);\n        return new TextSelection(state.window);\n    }\n}\n\n\nfunction _selectionNodeFromState(rootEl, pointState) {\n    var node = domUtils.getNodeAtTreePath(rootEl, pointState.treePath);\n    if (! node) logger.error('TextSelection createFromState: no node at treePath');\n    return node;\n}\n\n\n/**\n * Creates selection from passed range\n * \n * @param {Range} range\n * @param {Boolean} backward\n *\n * @return {TextSelection}\n */\nfunction TextSelection$$createFromRange(range, backward) {\n    var win = range.startContainer.ownerDocument.defaultView\n        , sel = win.getSelection()\n        , endRange;\n\n    sel.removeAllRanges();\n\n    if (backward){\n        endRange = range.cloneRange();\n        endRange.collapse(false);\n\n        sel.addRange(endRange);\n        sel.extend(range.startContainer, range.startOffset);\n    }\n    else {\n        sel.addRange(range);\n    }\n\n    return new TextSelection(win);\n}\n\n/**\n * Returns a normalized copy of the range\n * If you triple click an item, the end of the range is positioned at the beginning of the NEXT node.\n * this function returns a range with the end positioned at the end of the last textnode contained \n * inside a component with the \"editable\" facet\n * \n * @return {range}\n */\nfunction TextSelection$$getNormalizedRange(){\n    var doc = this.range.commonAncestorContainer.ownerDocument\n        , tw, previousNode\n        , newRange = this.range.cloneRange();\n\n    if (newRange.endContainer.nodeType !== Node.TEXT_NODE) {\n        tw = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT);\n        tw.currentNode = newRange.endContainer;\n        previousNode = tw.previousNode();\n        newRange.setEnd(previousNode, previousNode.length);\n    }\n\n    return newRange;\n}\n\n/**\n * get the direction of a selection\n *\n * 1 forward, -1 backward, 0 no direction, undefined one of the node is detached or in a different frame\n *\n * @return {Integer} can be -1, 0, 1 or undefined\n */\nfunction TextSelection$$getDirection(){\n    return domUtils.getSelectionDirection(this.selection);    \n}\n\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , Messenger = miloCore.Messenger\n    , StorageMessageSource = require('./msg_src')\n    , config = require('../../config')\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\nrequire('./model');\n\nmodule.exports = DOMStorage;\n\n\n// shared keys stored by all instances, include key prefixes\nvar _storedKeys = {\n    true: {}, // session storage\n    false: {} // local storage\n};\n\n\n/**\n * DOMStorage class to simplify storage and retrieval of multiple items with types preservation to DOM storage (localStorage and sessionStorage).\n * Types will be stored in the key created from value keys with appended `milo.config.domStorage.typeSuffix`\n *\n * @param {String} keyPrefix prefix that will be added to all keys followed by `milo.config.domStorage.prefixSeparator` (\"/\" by default).\n * @param {Boolean} sessionOnly true to use sessionStorage. localStorage will be used by default.\n * @param {Window} win window to work in\n */\nfunction DOMStorage(keyPrefix, sessionOnly, win) {\n    if (typeof window == 'undefined') return;\n    win = win || window;\n\n    keyPrefix = config.domStorage.root +\n                (keyPrefix\n                    ? keyPrefix + config.domStorage.prefixSeparator\n                    : '');\n\n    _.defineProperties(this, {\n        keyPrefix: keyPrefix,\n        sessionOnly: !! sessionOnly,\n        window: win,\n        _storage: sessionOnly ? win.sessionStorage : win.localStorage,\n        _typeSuffix: config.domStorage.typeSuffix,\n        _keys: {}\n    }, _.WRIT);\n}\n\n\n_.extendProto(DOMStorage, {\n    get: DOMStorage$get,\n    set: DOMStorage$set,\n    remove: DOMStorage$remove,\n    hasItem: DOMStorage$hasItem,\n    getItem: DOMStorage$getItem,\n    setItem: DOMStorage$setItem,\n    removeItem: DOMStorage$removeItem,\n    _storageKey: DOMStorage$_storageKey,\n    _domStorageKey: DOMStorage$_domStorageKey,\n    getAllKeys: DOMStorage$getAllKeys,\n    getAllItems: DOMStorage$getAllItems,\n    createMessenger: DOMStorage$createMessenger,\n    destroy: DOMStorage$destroy\n});\n\n\n/**\n * Expose Mesenger and MessageSource methods on DOMStorage\n */\nMessenger.useWith(DOMStorage, '_messenger', Messenger.defaultMethods);\nStorageMessageSource.useWith(DOMStorage, '_messageSource', ['trigger']);\n\n\nvar _sessionStorage = new DOMStorage('', true)\n    , _localStorage = new DOMStorage('', false);\n\nvar _domStorage = {\n        true: _sessionStorage,\n        false: _localStorage\n    };\n\n_.extend(DOMStorage, {\n    registerDataType: DOMStorage$$registerDataType,\n    local: _localStorage,\n    session: _sessionStorage,\n    storage: _domStorage,\n    _storedKeys: _storedKeys // exposed for testing\n});\n\n\n/**\n * Sets data to DOM storage. `this.keyPrefix` is prepended to keys.\n *\n * @param {Object} data single object can be passed in which case keys will be used as keys in local storage.\n * @param {List} arguments alternatively just the list of arguments can be passed where arguments can be sequentially used as keys and values.\n */\nfunction DOMStorage$set(data) { // or arguments\n    if (typeof data == 'object')\n        _.eachKey(data, function(value, key) {\n            this.setItem(key, value);\n        }, this);\n    else {\n        var argsLen = arguments.length;\n        if (argsLen % 2)\n            throw new Error('DOMStorage: set should have even number of arguments or object');\n\n        for (var i = 0; i < argsLen; i++) {\n            var key = arguments[i]\n                , value = arguments[++i];\n\n            this.setItem(key, value);\n        }\n    }\n}\n\n\n/**\n * Gets data from DOM storage. `this.keyPrefix` is prepended to passed keys, but returned object will have keys without root keys.\n *\n * @param {List} arguments keys can be passed as strings or arrays of strings\n * @returns {Object}\n */\nfunction DOMStorage$get() { // , ... arguments\n    var data = {};\n    _.deepForEach(arguments, function(key) {\n        data[key] = this.getItem(key);\n    }, this);\n    return data;\n}\n\n\n/**\n * Removes keys from DOM storage. `this.keyPrefix` is prepended to passed keys.\n *\n * @param {List} arguments keys can be passed as strings or arrays of strings\n */\nfunction DOMStorage$remove() { //, ... arguments\n    _.deepForEach(arguments, function(key) {\n        this.removeItem(key);\n    }, this);\n}\n\n\n/**\n * Check for presence of single item in DOM storage. `this.keyPrefix` is prepended to passed key.\n *\n * @param {String} key\n * @return {Boolean}\n */\nfunction DOMStorage$hasItem(key) {\n    var pKey = this._storageKey(key);\n    return this._storage.getItem(pKey) != null;\n}\n\n\n/**\n * Gets single item from DOM storage prepending `this.keyPrefix` to passed key.\n * Reads type of the originally stored value from `key + this._typeSuffix` and converts data to the original type.\n *\n * @param {String} key\n * @return {Any}\n */\nfunction DOMStorage$getItem(key) {\n    var pKey = this._storageKey(key);\n    var dataType = _getKeyDataType.call(this, pKey);\n    var valueStr = this._storage.getItem(pKey);\n    var value = _parseData(valueStr, dataType);\n    return value;\n}\n\n\n/**\n * Sets single item to DOM storage prepending `this.keyPrefix` to passed key.\n * Stores type of the stored value to `key + this._typeSuffix`.\n *\n * @param {String} key\n * @return {Any}\n */\nfunction DOMStorage$setItem(key, value) {\n    var pKey = this._storageKey(key);\n    var dataType = _setKeyDataType.call(this, pKey, value);\n    var valueStr = _serializeData(value, dataType);\n    try {\n        this._storage.setItem(pKey, valueStr);\n    } catch(e) {\n        if (e.name == 'QuotaExceededError') {\n            var cfg = config.domStorage.quotaExceeded;\n            if (cfg.message)\n                milo.mail.postMessage('quotaexceedederror', value);\n            if (cfg.throwError)\n                throw e;\n        } else\n            throw e;\n    }\n    this._keys[key] = true;\n    _domStorage[this.sessionOnly]._keys[pKey] = true;\n}\n\n\n/**\n * Removes single item from DOM storage prepending `this.keyPrefix` to passed key.\n * Type of the stored value (in `key + this._typeSuffix` key) is also removed.\n *\n * @param {String} key\n * @return {Any}\n */\nfunction DOMStorage$removeItem(key) {\n    var pKey = this._storageKey(key);\n    this._storage.removeItem(pKey);\n    _removeKeyDataType.call(this, pKey);\n    delete this._keys[key];\n    delete _domStorage[this.sessionOnly]._keys[pKey];\n}\n\n\n/**\n * Returns the array of all keys stored by this instance of DOMStorage\n *\n * @return {Array}\n */\nfunction DOMStorage$getAllKeys() {\n    var storedKeys = Object.keys(this._keys);\n    var keysInStorage = storedKeys.filter(function(key) {\n        if (this.hasItem(key)) return true;\n        else delete this._keys[key];\n    }, this);\n    return keysInStorage;\n}\n\n\n/**\n * Returns the map with all keys and values (deserialized) stored using this instance of DOMStorage\n *\n * @return {Object}\n */\nfunction DOMStorage$getAllItems() {\n    return this.get(this.getAllKeys());\n}\n\n\n/**\n * Returns prefixed key for DOM storage for given unprefixed key.\n *\n * @param {String} key\n * @return {String}\n */\nfunction DOMStorage$_storageKey(key) {\n    return this.keyPrefix + key;\n}\n\n\n/**\n * Returns unprefixed key to be used with this instance of DOMStorage fir given actual key in storage\n * If key has different prefix from the keyPrefix returns undefined\n *\n * @param {String} storageKey actual key in local/session storage\n * @return {String}\n */\nfunction DOMStorage$_domStorageKey(storageKey) {\n    if (storageKey.indexOf(this._typeSuffix) >= 0) return;\n    return _.unPrefix(storageKey, this.keyPrefix);\n}\n\n\n/**\n * Gets originally stored data type for given (prefixed) `key`.\n *\n * @param  {String} pKey prefixed key of stored value\n * @return {String}\n */\nfunction _getKeyDataType(pKey) {\n    pKey = _dataTypeKey.call(this, pKey);\n    return this._storage.getItem(pKey);\n}\n\n\n/**\n * Stores data type for given (prefixed) `key` and `value`.\n * Returns data type for `value`.\n *\n * @param {String} pKey prefixed key of stored value\n * @param {Any} value\n * @return {String}\n */\nfunction _setKeyDataType(pKey, value) {\n    var dataType = _getValueType(value);\n    pKey = _dataTypeKey.call(this, pKey);\n    this._storage.setItem(pKey, dataType);\n    return dataType;\n}\n\n\n/**\n * Removes stored data type for given (prefixed) `key`.\n *\n * @param  {String} pKey prefixed key of stored value\n */\nfunction _removeKeyDataType(pKey) {\n    pKey = _dataTypeKey.call(this, pKey);\n    this._storage.removeItem(pKey);\n}\n\n\n/**\n * Returns the key to store data type for given (prefixed) `key`.\n *\n * @param  {String} pKey prefixed key of stored value\n * @return {String}\n */\nfunction _dataTypeKey(pKey) {\n    return pKey + this._typeSuffix;\n}\n\n\n/**\n * Returns type of value as string. Class name returned for objects ('null' for null).\n * @param  {Any} value\n * @return {String}\n */\nfunction _getValueType(value) {\n    var valueType = typeof value\n        , className = value && value.constructor.name\n        , dataType = valuesDataTypes[className];\n    return dataType || (\n            valueType != 'object'\n                ? valueType\n                : value == null\n                    ? 'null'\n                    : value.constructor.name);\n}\nvar valuesDataTypes = {\n    // can be registered with `registerDataType`\n};\n\n\n/**\n * Serializes value to be stored in DOM storage.\n *\n * @param  {Any} value value to be serialized\n * @param  {String} valueType optional data type to define serializer, _getValueType is used if not passed.\n * @return {String}\n */\nfunction _serializeData(value, valueType) {\n    valueType = valueType || _getValueType(value);\n    var serializer = dataSerializers[valueType];\n    return serializer\n            ? serializer(value, valueType)\n            : value && value.toString == Object.prototype.toString\n                ? JSON.stringify(value)\n                : '' + value;\n}\nvar dataSerializers = {\n    'Array': JSON.stringify\n};\n\n\n/**\n * Parses string retrieved from DOM storage.\n *\n * @param  {String} valueStr\n * @param  {String} valueType data type that defines parser. Original sring will be returned if parser is not defined.\n * @return {Any}\n */\nfunction _parseData(valueStr, valueType) {\n    var parser = dataParsers[valueType];\n    return parser\n            ? parser(valueStr, valueType)\n            : valueStr;\n}\nvar dataParsers = {\n    Object: _.jsonParse,\n    Array: _.jsonParse,\n    Date: function(valStr) { return new Date(valStr); },\n    boolean: function(valStr) { return valStr == 'true'; },\n    number: Number,\n    function: _.toFunction,\n    RegExp: _.toRegExp\n};\n\n\n/**\n * Registers data type to be saved in DOM storage. Class name can be used or result of `typeof` operator for non-objects to override default conversions.\n *\n * @param {String} valueType class (constructor) name or the string returned by typeof.\n * @param {Function} serializer optional serializer for this type\n * @param {Function} parser optional parser for this type\n * @param {String} [storeAsDataType] optional name of stored data type if different from valueType\n */\nfunction DOMStorage$$registerDataType(valueType, serializer, parser, storeAsDataType) {\n    if (serializer) dataSerializers[valueType] = serializer;\n    if (parser) dataParsers[valueType] = parser;\n    valuesDataTypes[valueType] = storeAsDataType || valueType;\n}\n\n\nfunction DOMStorage$createMessenger() {\n    var storageMessageSource = new StorageMessageSource(this);\n    var messenger = new Messenger(this, undefined, storageMessageSource);\n    _.defineProperties(this, {\n        _messenger: messenger,\n        _messageSource: storageMessageSource\n    }, _.WRIT);\n}\n\n\nfunction DOMStorage$destroy() {\n    this._storage = undefined;\n    this.window = undefined;\n    if (this._messenger) this._messenger.destroy();\n    this._destroyed = true;\n}\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , Model = miloCore.Model\n    , _ = miloCore.proto;\n\nModel.registerWithDOMStorage = Model$$registerWithDOMStorage;\n\n\nfunction Model$$registerWithDOMStorage() {\n    var DOMStorage = require('./index');\n    DOMStorage.registerDataType('Model', Model_domStorageSerializer, Model_domStorageParser);\n    DOMStorage.registerDataType('ModelPath', Model_domStorageSerializer, Model_domStorageParser, 'Model');\n}\n\n\nfunction Model_domStorageSerializer(value) {\n    var data = value.get();\n    return JSON.stringify(data);\n}\n\n\nfunction Model_domStorageParser(valueStr) {\n    var data = _.jsonParse(valueStr);\n    return new Model(data);\n}\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , MessageSource = miloCore.classes.MessageSource\n    , _ = miloCore.proto\n    , config = require('../../config')\n    , uniqueId = require('../../util/unique_id');\n\nvar StorageMessageSource = _.createSubclass(MessageSource, 'StorageMessageSource', true);\n\n\n_.extendProto(StorageMessageSource, {\n    // implementing MessageSource interface\n    init: init,\n    addSourceSubscriber: StorageMessageSource$addSourceSubscriber,\n    removeSourceSubscriber: StorageMessageSource$removeSourceSubscriber,\n    postMessage: StorageMessageSource$postMessage,\n    trigger: StorageMessageSource$trigger,\n\n    //class specific methods\n    handleEvent: handleEvent  // event dispatcher - as defined by Event DOM API\n});\n\nmodule.exports = StorageMessageSource;\n\n\nfunction init(hostObject, proxyMethods, messengerAPIOrClass) {\n    if (hostObject.constructor.name != 'DOMStorage')\n        throw new Error('hostObject should be an instance of DOMStorage');\n    this.storage = hostObject;\n    this.messageKey = config.domStorage.messageKey;\n    this.window = hostObject.window;\n    MessageSource.prototype.init.apply(this, arguments);\n}\n\n\nfunction StorageMessageSource$addSourceSubscriber(sourceMessage) {\n    this.window.addEventListener('storage', this, false);\n}\n\n\nfunction StorageMessageSource$removeSourceSubscriber(sourceMessage) {\n    this.window.removeEventListener('storage', this, false);\n}\n\n\nfunction StorageMessageSource$postMessage(message, data) {\n    this.messenger.postMessageSync(message, data);\n}\n\n\nfunction StorageMessageSource$trigger(msgType, data) {\n    var key = this.messageKey + msgType;\n    data = data || {};\n    data[config.domStorage.messageTimestamp] = uniqueId();\n    _.deferMethod(this.storage, 'setItem', key, data);\n}\n\n\nfunction handleEvent(event) {\n    if (event.storageArea != this.storage._storage) return;\n    var key = this.storage._domStorageKey(event.key); if (! key) return;\n    var msgType = _.unPrefix(key, this.messageKey); if (! msgType) return;\n    var data = this.storage.getItem(key); if (! data) return;\n    this.dispatchMessage(msgType, data);\n}\n",
    "'use strict';\n\nvar timestamp = Date.now()\n    , count = ''\n    , uniqueID = '' + timestamp;\n\nfunction uniqueCount() {\n    var newTimestamp = Date.now();\n    uniqueID = '' + newTimestamp;\n    if (timestamp == newTimestamp) {\n        count = count === '' ? 0 : count + 1;\n        uniqueID += '_' + count;\n    } else {\n        timestamp = newTimestamp;\n        count = '';\n    }\n\n    return uniqueID;\n}\n\nuniqueCount.get = function() {\n    return uniqueID;\n};\n\nmodule.exports = uniqueCount;\n",
    "'use strict';\n\n/**\n * `milo.util.websocket` \n**/\n\n\nvar Messenger = require('milo-core').Messenger\n    , WSMessageSource = require('./msg_src')\n    , WSMsgAPI = require('./msg_api');\n\n\nfunction websocket() {\n    var wsMessenger = new Messenger;\n    var wsMsgSource = new WSMessageSource(wsMessenger, { send: 'trigger', connect: 'connect' }, new WSMsgAPI);\n    wsMessenger._setMessageSource(wsMsgSource);\n    return wsMessenger;\n}\n\n\nmodule.exports = websocket;\n",
    "'use strict';\n\nvar miloCore = require('milo-core')\n    , MessengerAPI = miloCore.classes.MessengerAPI\n    , _ = miloCore.proto\n    , check = miloCore.util.check\n    , Match = check.Match;\n\n\nvar WSMsgAPI = _.createSubclass(MessengerAPI, 'WSMsgAPI', true);\n\n\n_.extendProto(WSMsgAPI, {\n    translateToSourceMessage: translateToSourceMessage,\n    filterSourceMessage: filterSourceMessage,\n    createInternalData: createInternalData\n});\n\nmodule.exports = WSMsgAPI;\n\n\nvar SOCKET_MESSAGES = ['open', 'close', 'error', 'message'];\n\nfunction translateToSourceMessage(message) {\n    return SOCKET_MESSAGES.indexOf(message) >= 0\n            ? message\n            : 'message';\n}\n\n\nfunction filterSourceMessage(sourceMessage, message, msgData) {\n    if (SOCKET_MESSAGES.indexOf(message) >= 0) return true; // internal message is one of external messages\n    if (sourceMessage == 'message') {\n        var msgType = msgData && msgData.type;\n        return msgType == message; // type equals internal message\n    }\n}\n\n\nfunction createInternalData(sourceMessage, message, event) {\n    var internalData = sourceMessage == 'message'\n                        ? _.jsonParse(event.data) || event.data\n                        : event;\n    return internalData;\n}\n",
    "'use strict';\n\n\nvar miloCore = require('milo-core')\n    , MessageSource = miloCore.classes.MessageSource\n    , _ = miloCore.proto\n    , logger = miloCore.util.logger\n    , uniqueId = require('../../util/unique_id')\n    , config = require('../../config')\n    , check = miloCore.util.check\n    , Match = check.Match;\n\n\nvar WSMessageSource = _.createSubclass(MessageSource, 'WSMessageSource', true);\n\n\n_.extendProto(WSMessageSource, {\n    // implementing MessageSource interface\n    addSourceSubscriber: addSourceSubscriber,\n    removeSourceSubscriber: removeSourceSubscriber,\n    \n    // class specific methods\n    handleEvent: WSMessageSource$handleEvent,\n    connect: WSMessageSource$connect,\n    trigger: WSMessageSource$trigger\n});\n\n\nmodule.exports = WSMessageSource;\n\n\nfunction WSMessageSource$connect(options) {\n    this._options = options = options || {};\n\n    var host = options.host || window.location.host.replace(/:.*/, '')\n        , port = options.port || '8080';\n\n    var self = this;\n\n    if (this._ws) {\n        // TODO should unsubscribe differently\n        this._ws.onopen = this.ws.onmessage = this.ws.onclose = this.ws.onerror = undefined;\n        this._ws.close();\n    }\n\n    this._ws = new WebSocket('ws://' + host + ':' + port);\n\n    // TODO reconnect\n}\n\n\n\nfunction addSourceSubscriber (sourceMessage) {\n    _wsSubscriberMethod.call(this, 'addEventListener', sourceMessage);\n}\n\n\nfunction removeSourceSubscriber (sourceMessage) {\n    _wsSubscriberMethod.call(this, 'removeEventListener', sourceMessage);\n}\n\n\nfunction _wsSubscriberMethod (method, sourceMessage) {    \n    if (!this._ws) return logger.error('websocket is not created');\n    this._ws[method](sourceMessage, this);\n}\n\n\n// event dispatcher - as defined by Event DOM API\nfunction WSMessageSource$handleEvent (event) {\n    this.dispatchMessage(event.type, event);\n}\n\n\nfunction WSMessageSource$trigger (msg, data, callback) {\n    if (!this._ws) return logger.error('websocket is not created');\n\n    data = data || {};\n    data.type = msg;\n\n    var self = this;\n    \n    if (callback) {\n        data.callbackCorrId = uniqueId();\n        var interval = _.delay(onTimeout, config.websocket.rpc.timeout);\n        toggleRpcSubscription('once', data.callbackCorrId);\n    }    \n\n    this._ws.send(JSON.stringify(data));\n\n\n    function onTimeout() {\n        toggleRpcSubscription('off', data.callbackCorrId);\n        callback(new Error('websocket rpc: timeout'));\n    }\n\n    function onResponse(msg, msgData) {\n        clearInterval(interval);\n        if (typeof msgData == 'object') {\n            var err = msgData.error ? new Error(msgData.error) : null;\n            callback(err, msgData.data);\n        } else\n            callback(new Error('websocket rpc: invalid response data'), msgData);\n    }\n\n    function toggleRpcSubscription(onOff, corrId) {\n        self.messenger[onOff](config.websocket.rpc.responsePrefix + corrId, onResponse);\n    }\n}\n",
    ";(function(){\n\n// This would be the place to edit if you want a different\n// Base32 implementation\n\nvar alphabet = '0123456789abcdefghjkmnpqrtuvwxyz'\nvar alias = { o:0, i:1, l:1, s:5 }\n\n/**\n * Build a lookup table and memoize it\n *\n * Return an object that maps a character to its\n * byte value.\n */\n\nvar lookup = function() {\n    var table = {}\n    // Invert 'alphabet'\n    for (var i = 0; i < alphabet.length; i++) {\n        table[alphabet[i]] = i\n    }\n    // Splice in 'alias'\n    for (var key in alias) {\n        if (!alias.hasOwnProperty(key)) continue\n        table[key] = table['' + alias[key]]\n    }\n    lookup = function() { return table }\n    return table\n}\n\n/**\n * A streaming encoder\n *\n *     var encoder = new base32.Encoder()\n *     var output1 = encoder.update(input1)\n *     var output2 = encoder.update(input2)\n *     var lastoutput = encode.update(lastinput, true)\n */\n\nfunction Encoder() {\n    var skip = 0 // how many bits we will skip from the first byte\n    var bits = 0 // 5 high bits, carry from one byte to the next\n\n    this.output = ''\n\n    // Read one byte of input\n    // Should not really be used except by \"update\"\n    this.readByte = function(byte) {\n        // coerce the byte to an int\n        if (typeof byte == 'string') byte = byte.charCodeAt(0)\n\n        if (skip < 0) { // we have a carry from the previous byte\n            bits |= (byte >> (-skip))\n        } else { // no carry\n            bits = (byte << skip) & 248\n        }\n\n        if (skip > 3) {\n            // not enough data to produce a character, get us another one\n            skip -= 8\n            return 1\n        }\n\n        if (skip < 4) {\n            // produce a character\n            this.output += alphabet[bits >> 3]\n            skip += 5\n        }\n\n        return 0\n    }\n\n    // Flush any remaining bits left in the stream\n    this.finish = function(check) {\n        var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '')\n        this.output = ''\n        return output\n    }\n}\n\n/**\n * Process additional input\n *\n * input: string of bytes to convert\n * flush: boolean, should we flush any trailing bits left\n *        in the stream\n * returns: a string of characters representing 'input' in base32\n */\n\nEncoder.prototype.update = function(input, flush) {\n    for (var i = 0; i < input.length; ) {\n        i += this.readByte(input[i])\n    }\n    // consume all output\n    var output = this.output\n    this.output = ''\n    if (flush) {\n      output += this.finish()\n    }\n    return output\n}\n\n// Functions analogously to Encoder\n\nfunction Decoder() {\n    var skip = 0 // how many bits we have from the previous character\n    var byte = 0 // current byte we're producing\n\n    this.output = ''\n\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    this.readChar = function(char) {\n        if (typeof char != 'string'){\n            if (typeof char == 'number') {\n                char = String.fromCharCode(char)\n            }\n        }\n        char = char.toLowerCase()\n        var val = lookup()[char]\n        if (typeof val == 'undefined') {\n            // character does not exist in our lookup table\n            return // skip silently. An alternative would be:\n            // throw Error('Could not find character \"' + char + '\" in lookup table.')\n        }\n        val <<= 3 // move to the high bits\n        byte |= val >>> skip\n        skip += 5\n        if (skip >= 8) {\n            // we have enough to preduce output\n            this.output += String.fromCharCode(byte)\n            skip -= 8\n            if (skip > 0) byte = (val << (5 - skip)) & 255\n            else byte = 0\n        }\n\n    }\n\n    this.finish = function(check) {\n        var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '')\n        this.output = ''\n        return output\n    }\n}\n\nDecoder.prototype.update = function(input, flush) {\n    for (var i = 0; i < input.length; i++) {\n        this.readChar(input[i])\n    }\n    var output = this.output\n    this.output = ''\n    if (flush) {\n      output += this.finish()\n    }\n    return output\n}\n\n/** Convenience functions\n *\n * These are the ones to use if you just have a string and\n * want to convert it without dealing with streams and whatnot.\n */\n\n// String of data goes in, Base32-encoded string comes out.\nfunction encode(input) {\n  var encoder = new Encoder()\n  var output = encoder.update(input, true)\n  return output\n}\n\n// Base32-encoded string goes in, decoded data comes out.\nfunction decode(input) {\n    var decoder = new Decoder()\n    var output = decoder.update(input, true)\n    return output\n}\n\nvar base32 = {\n    Decoder: Decoder,\n    Encoder: Encoder,\n    encode: encode,\n    decode: decode\n}\n\nif (typeof window !== 'undefined') {\n  // we're in a browser - OMG!\n  window.base32 = base32\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  // nodejs/browserify\n  module.exports = base32\n}\n})();\n",
    "\n// not implemented\n// The reason for having an empty file and not throwing is to allow\n// untraditional implementation of this module.\n",
    "'use strict';\n\nvar _ = require('mol-proto')\n    , check = require('../util/check')\n    , Match = check.Match\n    , config = require('../config');\n\n\nmodule.exports = Mixin;\n\n/**\n * `milo.classes.Mixin` - an abstract Mixin class.\n * Can be subclassed using:\n * ```\n * var MyMixin = _.createSubclass(milo.classes.Mixin, 'MyMixin');\n * ```\n *\n * Mixin pattern is also used, but Mixin in milo is implemented as a separate object that is stored on the property of the host object and can create proxy methods on the host object if required.\n * Classes [Messenger](../messenger/index.js.html) and [MessageSource](../messenger/m_source.js.html) are subclasses of Mixin abstract class. `this` in proxy methods refers to Mixin instance, the reference to the host object is `this._hostObject`.\n *\n * @param {Object} hostObject Optional object where a Mixin instance will be stored on. It is used to proxy methods and also to find the reference when it is needed for host object implementation.\n * @param {Object} proxyMethods Optional map of proxy method names as keys and Mixin methods names as values, so proxied methods can be renamed to avoid name-space conflicts if two different Mixin instances with the same method names are put on the object\n * @param {List} arguments all constructor arguments will be passed to init method of Mixin subclass together with hostObject and proxyMethods\n * @return {Mixin}\n */\nfunction Mixin(hostObject, proxyMethods) { // , other args - passed to init method\n    check(hostObject, Match.Optional(Match.OneOf(Object, Function)));\n\n    // store hostObject\n    _.defineProperty(this, '_hostObject', hostObject);\n\n    // proxy methods to hostObject\n    if (proxyMethods)\n        this._createProxyMethods(proxyMethods);\n\n    // calling init if it is defined in the class\n    if (this.init)\n        this.init.apply(this, arguments);\n}\n\n\n/**\n * ####Mixin instance methods####\n * These methods are called by constructor, they are not to be called from subclasses.\n *\n * - [_createProxyMethod](#_createProxyMethod)\n * - [_createProxyMethods](#_createProxyMethods)\n */\n_.extendProto(Mixin, {\n    _createProxyMethod: _createProxyMethod,  // deprecated, should not be used\n    _createProxyMethods: _createProxyMethods  // deprecated, should not be used\n});\n\n\n/**\n * ####Mixin class methods####\n * These method should be called in host class declaration.\n *\n * - [useWith](#Mixin$$useWith)\n */\n_.extend(Mixin, {\n    useWith: Mixin$$useWith\n});\n\n\n/**\n * Creates a proxied method of Mixin subclass on host object.\n *\n * @param {String} mixinMethodName name of method in Mixin subclass\n * @param {String} proxyMethodName name of created proxy method on host object\n * @param {Object} hostObject Optional reference to the host object; if not specified the host object passed to constructor wil be used. It allows to use the same instance of Mixin on two host objects.\n */\nfunction _createProxyMethod(proxyMethodName, mixinMethodName, hostObject) {\n    hostObject = hostObject || this._hostObject;\n\n    // Mixin class does not allow shadowing methods that exist on the host object\n    if (hostObject[proxyMethodName])\n        throw new Error('method ' + proxyMethodName +\n                        ' already defined in host object');\n\n    var method = this[mixinMethodName]\n    check(method, Function);\n\n    // Bind proxied Mixin's method to Mixin instance\n    var boundMethod = method.bind(this);\n\n    _.defineProperty(hostObject, proxyMethodName, boundMethod, _.WRIT);\n}\n\n\n/**\n * Creates proxied methods of Mixin subclass on host object.\n *\n * @param {Hash[String]|Array[String]} proxyMethods map of names of methods, key - proxy method name, value - mixin method name. Can be array.\n * @param {Object} hostObject an optional reference to the host object; if not specified the host object passed to constructor wil be used. It allows to use the same instance of Mixin on two host objects.\n */\nfunction _createProxyMethods(proxyMethods, hostObject) {\n    check(proxyMethods, Match.Optional(Match.OneOf([String], Match.ObjectHash(String))));\n\n    // creating and binding proxy methods on the host object\n    if (Array.isArray(proxyMethods))\n        proxyMethods.forEach(function(methodName) {\n            // method called this way to allow using _createProxyMethods with objects\n            // that are not inheriting from Mixin\n            _createProxyMethod.call(this, methodName, methodName, hostObject);\n        }, this);\n    else\n        _.eachKey(proxyMethods, function(mixinMethodName, proxyMethodName) {\n            // method called this way to allow using _createProxyMethods with objects\n            // that are not inheriting from Mixin\n            _createProxyMethod.call(this, proxyMethodName, mixinMethodName, hostObject);\n        }, this);\n}\n\n\n/**\n * Sets mixin instance property name on the host class\n * Can be called only once\n *\n * @private\n * @param {Function} this Mixin subclass (not instance)\n * @param {Function} hostClass\n * @param {String} instanceKey\n */\nfunction Mixin_setInstanceKey(hostClass, method, instanceKey) {\n    check(hostClass, Function);\n    check(instanceKey, Match.IdentifierString);\n\n    var prop = config.mixin.instancePropertiesMap\n        , instanceKeys = hostClass[prop] = hostClass[prop] || {};\n\n    if (instanceKeys[method.name])\n        throw new Error('Mixin: instance property for method with name '\n            + method.name + ' is already set');\n\n    instanceKeys[method.name] = instanceKey;\n}\n\n\n/**\n * Adds method of Mixin subclass to host class prototype.\n *\n * @private\n * @param {Function} this Mixin subclass (not instance)\n * @param {String} mixinMethodName name of method in Mixin subclass\n * @param {String} hostMethodName (optional) name of created proxy method on host object, same if not specified\n * @param {Object} hostObject object class, must be specified as the last parameter (2nd or 3rd)\n */\nfunction Mixin_addMethod(hostClass, instanceKey, mixinMethodName, hostMethodName) {\n    var method = this.prototype[mixinMethodName];\n    check(method, Function);\n\n    var wrappedMethod = _wrapMixinMethod.call(this, method);\n\n    _.defineProperty(hostClass.prototype, hostMethodName, wrappedMethod, _.WRIT);\n\n    Mixin_setInstanceKey(hostClass, method, instanceKey)\n}\n\n\n/**\n * Returns method that will be exposed on the host class prototype\n *\n * @private\n * @param {Function} this Mixin subclass (not instance)\n * @return {Function}\n */\nfunction _wrapMixinMethod(method) {\n    return function() { // ,... arguments\n        var mixinInstance = _getMixinInstance.call(this, method.name);\n        return method.apply(mixinInstance, arguments);\n    }\n}\n\n\n/**\n * Returns the reference to the instance of mixin subclass.\n * This method is used when methods are exposed on the host class prototype (using addMehtods) rather than on host instance.\n * Subclasses should not use this methods - whenever subclass method is exposed on the prototype it will be wrapped to set correct context for the subclass method.\n *\n * @private\n * @return {Object}\n */\nfunction _getMixinInstance(methodName) {\n    if (this instanceof Mixin) return this;\n    var instanceKeys = this.constructor[config.mixin.instancePropertiesMap]\n        , mixinProp = instanceKeys[methodName]\n        , mixin = this[mixinProp];\n    if (!mixin) throw new Error('Mixin ' + mixinProp + ' does not exist');\n    return mixin;\n}\n\n\n/**\n * Adds methods of Mixin subclass to host class prototype.\n *\n * @param {Function} this Mixin subclass (not instance)\n * @param {Object} hostClass host object class; must be specified.\n * @param {String} instanceKey the name of the property the host class instance will store mixin instance on\n * @param {Hash[String]|Array[String]} mixinMethods map of names of methods, key - host method name, value - mixin method name. Can be array.\n */\nfunction Mixin$$useWith(hostClass, instanceKey, mixinMethods) {\n    check(mixinMethods, Match.Optional(Match.OneOf([String], Match.ObjectHash(String))));\n\n    if (Array.isArray(mixinMethods))\n        mixinMethods.forEach(function(methodName) {\n            Mixin_addMethod.call(this, hostClass, instanceKey, methodName, methodName);\n        }, this);\n    else\n        _.eachKey(mixinMethods, function(mixinMethodName, hostMethodName) {\n            Mixin_addMethod.call(this, hostClass, instanceKey, mixinMethodName, hostMethodName);\n        }, this);\n}\n",
    "'use strict';\n\n// <a name=\"classes\"></a>\n// milo.classes\n// -----------\n\n// This module contains foundation classes\n\nvar classes = {\n    Mixin: require('./abstract/mixin'),\n    MessageSource: require('./messenger/m_source'),\n    MessengerMessageSource: require('./messenger/msngr_source'),\n    MessengerAPI: require('./messenger/m_api'),\n    MessengerRegexpAPI: require('./messenger/m_api_rx')\n};\n\nmodule.exports = classes;\n",
    "'use strict';\n\n\nvar _ = require('mol-proto');\n\n\nmodule.exports = config;\n\nfunction config(options) {\n    _.deepExtend(config, options);\n}\n\nconfig({\n    mixin: {\n        instancePropertiesMap: '___mixin_instances'\n    },\n    check: false,\n    debug: false\n});\n",
    "'use strict';\n\nvar Mixin = require('../abstract/mixin')\n    , MessageSource = require('./m_source')\n    , _ = require('mol-proto')\n    , check = require('../util/check')\n    , Match = check.Match;\n\n\n// in browser code can be replaced with milo.util.zeroTimeout using useSetTimeout method\nvar _setTimeout = setTimeout;\n\n\n/**\n * `milo.Messenger`\n * A generic Messenger class that is used for all kinds of messaging in milo. It is subclassed from [Mixin](../abstract/mixin.js.html) and it proxies its methods to the host object for convenience.\n * All facets and components have messenger attached to them. Messenger class interoperates with [MessageSource](./m_source.js.html) class that connects the messenger to some external source of messages (e.g., DOM events) and [MessengerAPI](./m_api.js.html) class that allows to define higher level messages than messages that exist on the source.\n * Messenger class is used internally in milo and can be used together with any objects/classes in the application.\n * milo also defines a global messenger [milo.mail](../mail/index.js.html) that dispatches `domready` event and can be used for any application wide messaging.\n * To initialize your app after DOM is ready use:\n * ```\n * milo.mail.on('domready', function() {\n *     // application starts\n * });\n * ```\n * or the following shorter form of the same:\n * ```\n * milo(function() {\n *     // application starts\n * });\n * ```\n */\nvar Messenger = _.createSubclass(Mixin, 'Messenger');\n\nvar messagesSplitRegExp = Messenger.messagesSplitRegExp = /\\s*(?:\\,|\\s)\\s*/;\n\n\n/**\n * ####Messenger instance methods####\n *\n * - [init](#init)\n * - [on](#Messenger$on) (alias - onMessage, deprecated)\n * - [off](#Messenger$off) (alias - offMessage, deprecated)\n * - [onMessages](#onMessages)\n * - [offMessages](#offMessages)\n * - [once](#once)\n * - [onceSync](#onceSync)\n * - [postMessage](#postMessage)\n * - [getSubscribers](#getSubscribers)\n *\n * \"Private\" methods\n *\n * - [_chooseSubscribersHash](#_chooseSubscribersHash)\n * - [_registerSubscriber](#_registerSubscriber)\n * - [_removeSubscriber](#_removeSubscriber)\n * - [_removeAllSubscribers](#_removeAllSubscribers)\n * - [_callPatternSubscribers](#_callPatternSubscribers)\n * - [_callSubscribers](#_callSubscribers)\n * - [_setMessageSource](#_setMessageSource)\n * - [getMessageSource](#getMessageSource)\n */\n_.extendProto(Messenger, {\n    init: init, // called by Mixin (superclass)\n    destroy: Messenger$destroy,\n    on: Messenger$on,\n    once: Messenger$once,\n    onceSync: Messenger$onceSync,\n    onSync: Messenger$onSync,\n    onAsync: Messenger$onAsync,\n    onMessage: Messenger$on, // deprecated\n    off: Messenger$off,\n    offMessage: Messenger$off, // deprecated\n    onMessages: onMessages,\n    offMessages: offMessages,\n    offAll: Messenger$offAll,\n    postMessage: postMessage,\n    postMessageSync: postMessageSync,\n    getSubscribers: getSubscribers,\n    getMessageSource: getMessageSource,\n    _chooseSubscribersHash: _chooseSubscribersHash,\n    _registerSubscriber: _registerSubscriber,\n    _removeSubscriber: _removeSubscriber,\n    _removeAllSubscribers: _removeAllSubscribers,\n    _callPatternSubscribers: _callPatternSubscribers,\n    _callSubscribers: _callSubscribers,\n    _callSubscriber: _callSubscriber,\n    _setMessageSource: _setMessageSource\n});\n\n\n/**\n * A default map of proxy methods used by ComponentFacet and Component classes to pass to Messenger when it is instantiated.\n * This map is for convenience only, it is NOT used internally by Messenger, a host class should pass it for methods to be proxied this way.\n */\nMessenger.defaultMethods = {\n    on: 'on',\n    onSync: 'onSync',\n    once: 'once',\n    onceSync: 'onceSync',\n    off: 'off',\n    onMessages: 'onMessages',\n    offMessages: 'offMessages',\n    postMessage: 'postMessage',\n    postMessageSync: 'postMessageSync',\n    getSubscribers: 'getSubscribers'\n};\n\n\n/**\n * Messenger class (static) methods\n * - [useSetTimeout](#useSetTimeout)\n */\nMessenger.useSetTimeout = useSetTimeout;\n\n\nmodule.exports = Messenger;\n\n\nMessenger.subscriptions = [];\n\n\n/**\n * Messenger instance method\n * Initializes Messenger. Method is called by Mixin class constructor.\n * See [on](#Messenger$on) method, [Messenger](#Messenger) class above and [MessageSource](./m_source.js.html) class.\n *\n * @param {Object} hostObject Optional object that stores the messenger on one of its properties. It is used to proxy methods of messenger and also as a context for subscribers when they are called by the Messenger. See `on` method.\n * @param {Object} proxyMethods Optional map of method names; key - proxy method name, value - messenger's method name.\n * @param {MessageSource} messageSource Optional messageSource linked to the messenger. If messageSource is supplied, the reference to the messenger will stored on its 'messenger' property\n */\nfunction init(hostObject, proxyMethods, messageSource) {\n    // hostObject and proxyMethods are used in Mixin and checked there\n    if (messageSource)\n        this._setMessageSource(messageSource);\n\n    _initializeSubscribers.call(this);\n}\n\n\nfunction _initializeSubscribers() {\n    _.defineProperties(this, {\n        _messageSubscribers: {},\n        _patternMessageSubscribers: {},\n    }, _.CONF);\n}\n\n\n/**\n * Destroys messenger. Maybe needs to unsubscribe all subscribers\n */\nfunction Messenger$destroy() {\n    this.offAll();\n    var messageSource = this.getMessageSource();\n    if (messageSource)\n        messageSource.destroy();\n}\n\n\n/**\n * Messenger instance method.\n * Registers a subscriber function for a certain message(s).\n * This method returns `true` if the subscription was successful. It can be unsuccessful if the passed subscriber has already been subscribed to this message type - double subscription never happens and it is safe to subscribe again - no error or warning is thrown or logged.\n * Subscriber is passed two parameters: `message` (string) and `data` (object). Data object is supplied when message is dispatched, Messenger itself adds nothing to it. For example, [events facet](../components/c_facets/Events.js.html) sends actual DOM event when it posts message.\n * Usage:\n * ```\n * // subscribes onMouseUpDown to two DOM events on component via events facet.\n * myComp.events.on('mousedown mouseup', onMouseUpDown);\n * function onMouseUpDown(eventType, event) {\n *     // ...\n * }\n *\n * myComp.data.on(/.+/, function(msg, data) {\n *     logger.debug(msg, data);\n * }); // subscribes anonymous function to all non-empty messages on data facet\n * // it will not be possible to unsubscribe anonymous subscriber separately,\n * // but myComp.data.off(/.+/) will unsubscribe it\n * ```\n * If messenger has [MessageSource](./m_source.js.html) attached to it, MessageSource will be notified when the first subscriber for a given message is added, so it can subscribe to the source.\n * [Components](../components/c_class.js.html) and [facets](../components/c_facet.js.html) change this method name to `on` when they proxy it.\n * See [postMessage](#postMessage).\n *\n * @param {String|Array[String]|RegExp} messages Message types that should envoke the subscriber.\n *  If string is passed, it can be a sigle message or multiple message types separated by whitespace with optional commas.\n *  If an array of strings is passed, each string is a message type to subscribe for.\n *  If a RegExp is passed, the subscriber will be envoked when the message dispatched on the messenger matches the pattern (or IS the RegExp with identical pattern).\n *  Pattern subscriber does NOT cause any subscription to MessageSource, it only captures messages that are already subscribed to with precise message types.\n * @param {Function|Object} subscriber Message subscriber - a function that will be called when the message is dispatched on the messenger (usually via proxied postMessage method of host object).\n *  If hostObject was supplied to Messenger constructor, hostObject will be the context (the value of this) for the subscriber envocation.\n *  Subscriber can also be an object with properties `subscriber` (function) and `context` (\"this\" value when subscriber is called)\n * @return {Boolean}\n */\nfunction Messenger$on(messages, subscriber) {\n    return _Messenger_onWithOptions.call(this, messages, subscriber);\n}\n\n\nfunction Messenger$once(messages, subscriber) {\n    return _Messenger_onWithOptions.call(this, messages, subscriber, { dispatchTimes: 1 });\n}\n\nfunction Messenger$onceSync(messages, subscriber) {\n    return _Messenger_onWithOptions.call(this, messages, subscriber, { dispatchTimes: 1, sync: true });\n}\n\n\nfunction Messenger$onSync(messages, subscriber) {\n    return _Messenger_onWithOptions.call(this, messages, subscriber, { sync: true });\n}\n\n\nfunction Messenger$onAsync(messages, subscriber) {\n    return _Messenger_onWithOptions.call(this, messages, subscriber, { sync: false });\n}\n\n\nfunction _Messenger_onWithOptions(messages, subscriber, options) {\n    check(messages, Match.OneOf(String, [String], RegExp));\n    check(subscriber, Match.OneOf(Function, {\n        subscriber: Function,\n        context: Match.Any,\n        options: Match.Optional(Object),\n    }));\n\n    if (typeof subscriber == 'function') {\n        subscriber = {\n            subscriber: subscriber,\n            context: this._hostObject,\n        };\n    }\n\n    if (options) {\n        subscriber.options = subscriber.options || {};\n        _.extend(subscriber.options, options);\n    }\n\n    return _Messenger_on.call(this, messages, subscriber);\n}\n\n\nfunction _Messenger_on(messages, subscriber) {\n    _.defineProperty(subscriber, '__messages', messages);\n    return _eachMessage.call(this, '_registerSubscriber', messages, subscriber);\n}\n\n\nfunction _eachMessage(methodName, messages, subscriber) {\n    if (typeof messages == 'string')\n        messages = messages.split(messagesSplitRegExp);\n\n    var subscribersHash = this._chooseSubscribersHash(messages);\n\n    if (messages instanceof RegExp)\n        return this[methodName](subscribersHash, messages, subscriber);\n\n    else {\n        var changed = false;\n\n        messages.forEach(function(message) {\n            var subscriptionChanged = this[methodName](subscribersHash, message, subscriber);\n            changed = changed || subscriptionChanged;\n        }, this);\n\n        return changed;\n    }\n}\n\n\n/**\n * \"Private\" Messenger instance method\n * It is called by [on](#Messenger$on) to register subscriber for one message type.\n * Returns `true` if this subscriber is not yet registered for this type of message.\n * If messenger has [MessageSource](./m_source.js.html) attached to it, MessageSource will be notified when the first subscriber for a given message is added.\n *\n * @private\n * @param {Object} subscribersHash The map of subscribers determined by [on](#Messenger$on) based on Message type, can be `this._patternMessageSubscribers` or `this._messageSubscribers`\n * @param {String} message Message type\n * @param {Function|Object} subscriber Subscriber function to be added or object with properties `subscriber` (function) and `context` (value of \"this\" when subscriber is called)\n * @return {Boolean}\n */\nfunction _registerSubscriber(subscribersHash, message, subscriber) {\n    if (! (subscribersHash[message] && subscribersHash[message].length)) {\n        subscribersHash[message] = [];\n        if (message instanceof RegExp)\n            subscribersHash[message].pattern = message;\n        if (this._messageSource)\n            this._messageSource.onSubscriberAdded(message);\n        var noSubscribers = true;\n    }\n\n    var msgSubscribers = subscribersHash[message];\n    var notYetRegistered = noSubscribers || _indexOfSubscriber.call(this, msgSubscribers, subscriber) == -1;\n\n    if (notYetRegistered)\n        msgSubscribers.push(subscriber);\n\n    return notYetRegistered;\n}\n\n\n/**\n * Finds subscriber index in the list\n *\n * @param {Array[Function|Object]} list list of subscribers\n * @param {Function|Object} subscriber subscriber function or object with properties `subscriber` (function) and `context` (\"this\" object)\n */\nfunction _indexOfSubscriber(list, subscriber) {\n    var self = this;\n    return _.findIndex(list, function(subscr){\n        return subscriber.subscriber == subscr.subscriber\n                && subscriber.context == subscr.context\n    });\n}\n\n\n/**\n * Messenger instance method.\n * Subscribes to multiple messages passed as map together with subscribers.\n * Usage:\n * ```\n * myComp.events.onMessages({\n *     'mousedown': onMouseDown,\n *     'mouseup': onMouseUp\n * });\n * function onMouseDown(eventType, event) {}\n * function onMouseUp(eventType, event) {}\n * ```\n * Returns map with the same keys (message types) and boolean values indicating whether particular subscriber was added.\n * It is NOT possible to add pattern subscriber using this method, as although you can use RegExp as the key, JavaScript will automatically convert it to string.\n *\n * @param {Object[Function]} messageSubscribers Map of message subscribers to be added\n * @return {Object[Boolean]}\n */\nfunction onMessages(messageSubscribers) {\n    check(messageSubscribers, Match.ObjectHash(Match.OneOf(Function, { subscriber: Function, context: Match.Any })));\n\n    var notYetRegisteredMap = _.mapKeys(messageSubscribers, function(subscriber, messages) {\n        return this.on(messages, subscriber);\n    }, this);\n\n    return notYetRegisteredMap;\n}\n\n\n/**\n * Messenger instance method.\n * Removes a subscriber for message(s). Removes all subscribers for the message if subscriber isn't passed.\n * This method returns `true` if the subscriber was registered. No error or warning is thrown or logged if you remove subscriber that was not registered.\n * [Components](../components/c_class.js.html) and [facets](../components/c_facet.js.html) change this method name to `off` when they proxy it.\n * Usage:\n * ```\n * // unsubscribes onMouseUpDown from two DOM events.\n * myComp.events.off('mousedown mouseup', onMouseUpDown);\n * ```\n * If messenger has [MessageSource](./m_source.js.html) attached to it, MessageSource will be notified when the last subscriber for a given message is removed and there is no more subscribers for this message.\n *\n * @param {String|Array[String]|RegExp} messages Message types that a subscriber should be removed for.\n *  If string is passed, it can be a sigle message or multiple message types separated by whitespace with optional commas.\n *  If an array of strings is passed, each string is a message type to remove a subscriber for.\n *  If a RegExp is passed, the pattern subscriber will be removed.\n *  RegExp subscriber does NOT cause any subscription to MessageSource, it only captures messages that are already subscribed to with precise message types.\n * @param {Function} subscriber Message subscriber - Optional function that will be removed from the list of subscribers for the message(s). If subscriber is not supplied, all subscribers will be removed from this message(s).\n * @return {Boolean}\n */\nfunction Messenger$off(messages, subscriber) {\n    check(messages, Match.OneOf(String, [String], RegExp));\n    check(subscriber, Match.Optional(Match.OneOf(Function, {\n        subscriber: Function,\n        context: Match.Any,\n        options: Match.Optional(Object),\n        // __messages: Match.Optional(Match.OneOf(String, [String], RegExp))\n    })));\n\n    return _Messenger_off.call(this, messages, subscriber);\n}\n\n\nfunction _Messenger_off(messages, subscriber) {\n    return _eachMessage.call(this, '_removeSubscriber', messages, subscriber);\n}\n\n\n/**\n * \"Private\" Messenger instance method\n * It is called by [off](#Messenger$off) to remove subscriber for one message type.\n * Returns `true` if this subscriber was registered for this type of message.\n * If messenger has [MessageSource](./m_source.js.html) attached to it, MessageSource will be notified when the last subscriber for a given message is removed and there is no more subscribers for this message.\n *\n * @private\n * @param {Object} subscribersHash The map of subscribers determined by [off](#Messenger$off) based on message type, can be `this._patternMessageSubscribers` or `this._messageSubscribers`\n * @param {String} message Message type\n * @param {Function} subscriber Subscriber function to be removed\n * @return {Boolean}\n */\nfunction _removeSubscriber(subscribersHash, message, subscriber) {\n    var msgSubscribers = subscribersHash[message];\n    if (! msgSubscribers || ! msgSubscribers.length)\n        return false; // nothing removed\n\n    if (subscriber) {\n        if (typeof subscriber == 'function')\n            subscriber = { subscriber: subscriber, context: this._hostObject };\n\n        var subscriberIndex = _indexOfSubscriber.call(this, msgSubscribers, subscriber);\n        if (subscriberIndex == -1)\n            return false; // nothing removed\n        msgSubscribers.splice(subscriberIndex, 1);\n        if (! msgSubscribers.length)\n            this._removeAllSubscribers(subscribersHash, message);\n\n    } else\n        this._removeAllSubscribers(subscribersHash, message);\n\n    return true; // subscriber(s) removed\n}\n\n\n/**\n * \"Private\" Messenger instance method\n * It is called by [_removeSubscriber](#_removeSubscriber) to remove all subscribers for one message type.\n * If messenger has [MessageSource](./m_source.js.html) attached to it, MessageSource will be notified that all message subscribers were removed so it can unsubscribe from the source.\n *\n * @private\n * @param {Object} subscribersHash The map of subscribers determined by [off](#Messenger$off) based on message type, can be `this._patternMessageSubscribers` or `this._messageSubscribers`\n * @param {String} message Message type\n */\nfunction _removeAllSubscribers(subscribersHash, message) {\n    delete subscribersHash[message];\n    if (this._messageSource && typeof message == 'string')\n        this._messageSource.onSubscriberRemoved(message);\n}\n\n\n/**\n * Messenger instance method.\n * Unsubscribes from multiple messages passed as map together with subscribers.\n * Returns map with the same keys (message types) and boolean values indicating whether particular subscriber was removed.\n * If a subscriber for one of the messages is not supplied, all subscribers for this message will be removed.\n * Usage:\n * ```\n * myComp.events.offMessages({\n *     'mousedown': onMouseDown,\n *     'mouseup': onMouseUp,\n *     'click': undefined // all subscribers to this message will be removed\n * });\n * ```\n * It is NOT possible to remove pattern subscriber(s) using this method, as although you can use RegExp as the key, JavaScript will automatically convert it to string.\n *\n * @param {Object[Function]} messageSubscribers Map of message subscribers to be removed\n * @return {Object[Boolean]}\n */\nfunction offMessages(messageSubscribers) {\n    check(messageSubscribers, Match.ObjectHash(Match.Optional(Match.OneOf(Function, { subscriber: Function, context: Match.Any }))));\n\n    var subscriberRemovedMap = _.mapKeys(messageSubscribers, function(subscriber, messages) {\n        return this.off(messages, subscriber);\n    }, this);\n\n    return subscriberRemovedMap;\n}\n\n\n/**\n * Unsubscribes all subscribers\n */\nfunction Messenger$offAll() {\n    _offAllSubscribers.call(this, this._patternMessageSubscribers);\n    _offAllSubscribers.call(this, this._messageSubscribers);\n}\n\n\nfunction _offAllSubscribers(subscribersHash) {\n    _.eachKey(subscribersHash, function(subscribers, message) {\n        this._removeAllSubscribers(subscribersHash, message);\n    }, this);\n}\n\n\n// TODO - send event to messageSource\n\n\n/**\n * Messenger instance method.\n * Dispatches the message calling all subscribers registered for this message and, if the message is a string, calling all pattern subscribers when message matches the pattern.\n * Each subscriber is passed the same parameters that are passed to theis method.\n * The context of the subscriber envocation is set to the host object (`this._hostObject`) that was passed to the messenger constructor.\n * Subscribers are called in the next tick (\"asynchronously\") apart from those that were subscribed with `onSync` (or that have `options.sync == true`).\n *\n * @param {String|RegExp} message message to be dispatched\n *  If the message is a string, the subscribers registered with exactly this message will be called and also pattern subscribers registered with the pattern that matches the dispatched message.\n *  If the message is RegExp, only the subscribers registered with exactly this pattern will be called.\n * @param {Any} data data that will be passed to the subscriber as the second parameter. Messenger does not modify this data in any way.\n * @param {Function} callback optional callback to pass to subscriber\n * @param {Boolean} _synchronous if true passed, subscribers will be envoked synchronously apart from those that have `options.sync == false`. This parameter should not be used, instead postMessageSync should be used.\n */\nfunction postMessage(message, data, callback, _synchronous) {\n    check(message, Match.OneOf(String, RegExp));\n    check(callback, Match.Optional(Function));\n\n    var subscribersHash = this._chooseSubscribersHash(message);\n    var msgSubscribers = subscribersHash[message];\n\n    this._callSubscribers(message, data, callback, msgSubscribers, _synchronous);\n\n    if (typeof message == 'string')\n        this._callPatternSubscribers(message, data, callback, msgSubscribers, _synchronous);\n}\n\n\n/**\n * Same as postMessage apart from envoking subscribers synchronously, apart from those subscribed with `onAsync` (or with `options.sync == false`).\n *\n * @param {String|RegExp} message\n * @param {Any} data\n * @param {Function} callback\n */\nfunction postMessageSync(message, data, callback) {\n    this.postMessage(message, data, callback, true);\n}\n\n\n/**\n * \"Private\" Messenger instance method\n * Envokes pattern subscribers with the pattern that matches the message.\n * The method is called by [postMessage](#postMessage) - see more information there.\n *\n * @private\n * @param {String} message message to be dispatched. Pattern subscribers registered with the pattern that matches the dispatched message will be called.\n * @param {Any} data data that will be passed to the subscriber as the second parameter. Messenger does not modify this data in any way.\n * @param {Function} callback optional callback to pass to subscriber\n * @param {Array[Function|Object]} calledMsgSubscribers array of subscribers already called, they won't be called again if they are among pattern subscribers.\n */\nfunction _callPatternSubscribers(message, data, callback, calledMsgSubscribers, _synchronous) {\n    _.eachKey(this._patternMessageSubscribers,\n        function(patternSubscribers) {\n            var pattern = patternSubscribers.pattern;\n            if (pattern.test(message)) {\n                if (calledMsgSubscribers) {\n                    var patternSubscribers = patternSubscribers.filter(function(subscriber) {\n                        var index = _indexOfSubscriber.call(this, calledMsgSubscribers, subscriber);\n                        return index == -1;\n                    });\n                }\n                this._callSubscribers(message, data, callback, patternSubscribers, _synchronous);\n            }\n        }\n    , this);\n}\n\n\n/**\n * \"Private\" Messenger instance method\n * Envokes subscribers from the passed list.\n * The method is called by [postMessage](#postMessage) and [_callPatternSubscribers](#_callPatternSubscribers).\n *\n * @private\n * @param {String} message message to be dispatched, passed to subscribers as the first parameter.\n * @param {Any} data data that will be passed to the subscriber as the second parameter. Messenger does not modify this data in any way.\n * @param {Array[Function|Object]} msgSubscribers the array of message subscribers to be called. Each subscriber is called with the host object (see Messenger constructor) as the context.\n * @param {Function} callback optional callback to pass to subscriber\n */\nfunction _callSubscribers(message, data, callback, msgSubscribers, _synchronous) {\n    if (msgSubscribers && msgSubscribers.length) {\n        // cloning is necessary as some of the subscribers\n        // can be unsubscribed during the dispatch\n        // so this array would change in the process\n        msgSubscribers = msgSubscribers.slice();\n\n        msgSubscribers.forEach(function(subscriber) {\n            this._callSubscriber(subscriber, message, data, callback, _synchronous);\n        }, this);\n    }\n}\n\n\nfunction _callSubscriber(subscriber, message, data, callback, _synchronous) {\n    var syncSubscriber = subscriber.options && subscriber.options.sync\n        , synchro = (_synchronous && syncSubscriber !== false)\n                  || syncSubscriber;\n\n    var dispatchTimes = subscriber.options && subscriber.options.dispatchTimes;\n    if (dispatchTimes) {\n        if (dispatchTimes <= 1) {\n            var messages = subscriber.__messages;\n            this.off(messages, subscriber);\n        } else if (dispatchTimes > 1)\n            subscriber.options.dispatchTimes--;\n    }\n\n    if (synchro)\n        subscriber.subscriber.call(subscriber.context, message, data, callback);\n    else\n        _setTimeout(function() { subscriber.subscriber.call(subscriber.context, message, data, callback); }, 0);\n}\n\n\n/**\n * Replace setTimeout with another function (e.g. setImmediate in node or milo.util.zeroTimeout in browser)\n *\n * @param  {Function} setTimeoutFunc function to use to delay execution\n */\nfunction useSetTimeout(setTimeoutFunc) {\n    _setTimeout = setTimeoutFunc;\n}\n\n\n/**\n * Messenger instance method.\n * Returns the array of subscribers that would be called if the message were dispatched.\n * If `includePatternSubscribers === false`, pattern subscribers with matching patters will not be included (by default they are included).\n * If there are no subscribers to the message, `undefined` will be returned, not an empty array, so it is safe to use the result in boolean tests.\n *\n * @param {String|RegExp} message Message to get subscribers for.\n *  If the message is RegExp, only pattern subscribers registered with exactly this pattern will be returned.\n *  If the message is String, subscribers registered with the string messages and pattern subscribers registered with matching pattern will be returned (unless the second parameter is false).\n * @param {Boolean} includePatternSubscribers Optional false to prevent inclusion of patter subscribers, by default they are included.\n * @return {Array|undefined}\n */\nfunction getSubscribers(message, includePatternSubscribers) {\n    check(message, Match.OneOf(String, RegExp));\n\n    var subscribersHash = this._chooseSubscribersHash(message);\n    var msgSubscribers = subscribersHash[message]\n                            ? [].concat(subscribersHash[message])\n                            : [];\n\n    // pattern subscribers are incuded by default\n    if (includePatternSubscribers !== false && typeof message == 'string') {\n        _.eachKey(this._patternMessageSubscribers,\n            function(patternSubscribers) {\n                var pattern = patternSubscribers.pattern;\n                if (patternSubscribers && patternSubscribers.length\n                        && pattern.test(message))\n                    _.appendArray(msgSubscribers, patternSubscribers);\n            }\n        );\n    }\n\n    // return undefined if there are no subscribers\n    return msgSubscribers.length\n                ? msgSubscribers\n                : undefined;\n}\n\n\n/**\n * \"Private\" Messenger instance method\n * Returns the map of subscribers for a given message type.\n *\n * @private\n * @param {String|RegExp} message Message to choose the map of subscribers for\n * @return {Object[Function]}\n */\nfunction _chooseSubscribersHash(message) {\n    return message instanceof RegExp\n                ? this._patternMessageSubscribers\n                : this._messageSubscribers;\n}\n\n\n/**\n * Messenger instance method\n * Sets [MessageSource](./m_source.js.html) for the messenger also setting the reference to the messenger in the MessageSource.\n * MessageSource can be passed to message constructor; this method allows to set it at a later time. For example, the subclasses of [ComponentFacet](../components/c_facet.js.html) use this method to set different MessageSource'es in the messenger that is created by ComponentFacet.\n * Currently the method is implemented in such way that it can be called only once - MessageSource cannot be changed after this method is called.\n *\n * @param {MessageSource} messageSource an instance of MessageSource class to attach to this messenger (and to have this messenger attached to it too)\n */\nfunction _setMessageSource(messageSource) {\n    check(messageSource, MessageSource);\n\n    _.defineProperty(this, '_messageSource', messageSource);\n    messageSource.messenger = this;\n}\n\n\n/**\n * Messenger instance method\n * Returns messenger MessageSource\n *\n * @return {MessageSource}\n */\nfunction getMessageSource() {\n    return this._messageSource\n}\n",
    "'use strict';\n\nvar _ = require('mol-proto');\n\n\nmodule.exports = MessengerAPI;\n\n\n/**\n * `milo.classes.MessengerAPI`\n * Base class, subclasses of which can supplement the functionality of [MessageSource](./m_source.js.html) by implementing three methods:\n *\n * - `translateToSourceMessage` to translate source messages (recieved from external source via `MessageSOurce`) to internal messages (that are dispatched on Messenger), allowing to make internal messages more detailed than source messages. For example, [Data facet](../components/c_facets/Data.js.html) uses [DataMsgAPI](../components/msg_api/data.js.html) to define several internal messages related to the change of state in contenteditable DOM element.\n * - `createInternalData` to modify message data received from source to some more meaningful or more detailed message data that will be dispatched on Messenger. For example, [Data facet](../components/c_facets/Data.js.html) uses [DataMsgAPI](../components/msg_api/data.js.html) (subclass of MessengerAPI) to translate DOM messages to data change messages.\n * - `filterSourceMessage` to enable/disable message dispatch based on some conditions in data.\n *\n * If `MessageSource` constructor is not passed an instance of some subclass of `MessengerAPI`, it automatically creates an instance of MessengerAPI that defines all 3 of those methods in a trivial way. See these methods below for their signatures.\n *\n * @constructor\n * @this {MessengerAPI}\n * @return {MessengerAPI}\n */\nfunction MessengerAPI() {\n    if (this.init)\n        this.init.apply(this, arguments);\n}\n\n\n/**\n * ####MessengerAPI instance methods####\n *\n * - [init](#init) - initializes MessengerAPI\n * - [addInternalMessage](#addInternalMessage) - adds internal message\n * - [removeInternalMessage](#removeInternalMessage) - removes internal message\n * - [getInternalMessages](#getInternalMessages) - returns the list of internal messages for given source message\n *\n * These methods should be redefined by subclass:\n *\n * - [translateToSourceMessage](#translateToSourceMessage) - converts internal message type to source (external) message type\n * - [createInternalData](#createInternalData) - converts source message data received via MessageSource to internal message data\n * - [filterSourceMessage](#filterSourceMessage) - filters source message based on the data of the message and the corresponding internal message that is about to be sent on Messenger\n */\n_.extendProto(MessengerAPI, {\n    init: init,\n    destroy: MessengerAPI$destroy,\n    addInternalMessage: addInternalMessage,\n    removeInternalMessage: removeInternalMessage,\n    getInternalMessages: getInternalMessages,\n\n    // should be redefined by subclass\n    translateToSourceMessage: translateToSourceMessage,\n    createInternalData: createInternalData,\n    filterSourceMessage: filterSourceMessage\n});\n\n\n/**\n * MessengerAPI instance method\n * Called by MessengerAPI constructor. Subclasses that re-implement `init` method should call this method using: `MessengerAPI.prototype.init.apply(this, arguments)`\n */\nfunction init() {\n    _.defineProperty(this, '_internalMessages', {});\n}\n\n\n/**\n * Destroys messenger API\n */\nfunction MessengerAPI$destroy() {\n\n}\n\n\n/**\n * MessengerAPI instance method\n * Translates internal `message` to source message, adds internal `message` to the list, making sure the same `message` wasn't passed before (it would indicate Messenger error).\n * Returns source message if it is used first time (so that `MessageSource` subcribes to this source message) or `undefined`.\n *\n * @param {String} message internal message to be translated and added\n * @return {String|undefined}\n */\nfunction addInternalMessage(message) {\n    var internalMsgs\n        , sourceMessage = this.translateToSourceMessage(message);\n\n    if (typeof sourceMessage == 'undefined') return;\n\n    if (this._internalMessages.hasOwnProperty(sourceMessage)) {\n        internalMsgs = this._internalMessages[sourceMessage];\n        if (internalMsgs.indexOf(message) == -1)\n            internalMsgs.push(message);\n        else\n            require('../util/logger').warn('Duplicate addInternalMessage call for internal message ' + message);\n    } else {\n        internalMsgs = this._internalMessages[sourceMessage] = [];\n        internalMsgs.push(message);\n        return sourceMessage;\n    }\n}\n\n\n/**\n * MessengerAPI instance method\n * Removes internal `message` from the list connected to corresponding source message (`translateToSourceMessage` is used for translation).\n * Returns source message, if the last internal message was removed (so that `MessageSource` can unsubscribe from this source message), or `undefined`.\n *\n * @param {String} message internal message to be translated and removed\n * @return {String|undefined}\n */\nfunction removeInternalMessage(message) {\n    var sourceMessage = this.translateToSourceMessage(message);\n\n    if (typeof sourceMessage == 'undefined') return;\n\n    var internalMsgs = this._internalMessages[sourceMessage];\n\n    if (internalMsgs && internalMsgs.length) {\n        var messageIndex = internalMsgs.indexOf(message);\n        if (messageIndex >= 0) {\n            internalMsgs.splice(messageIndex, 1);\n            if (internalMsgs.length == 0) {\n                delete this._internalMessages[sourceMessage];\n                return sourceMessage;\n            }\n        } else\n            unexpectedNotificationWarning();\n    } else\n        unexpectedNotificationWarning();\n\n\n    function unexpectedNotificationWarning() {\n        require('../util/logger').warn('notification received: un-subscribe from internal message ' + message\n                     + ' without previous subscription notification');\n    }\n}\n\n\n/**\n * MessengerAPI instance method\n * Returns the array of internal messages that were translated to given `sourceMessage`.\n * This method is used by `MessageSource` to dispatch source message on the `Mesenger`.\n *\n * @param {String} sourceMessage source message\n * @return {Array[String]}\n */\nfunction getInternalMessages(sourceMessage) {\n    return this._internalMessages[sourceMessage];\n}\n\n\n/**\n * MessengerAPI instance method\n * Subclasses should re-implement this method to define the rule for translation of internal `message` to source message. This class simply returns the same `message`.\n *\n * @param {String} message internal message to be translated\n * @return {String}\n */\nfunction translateToSourceMessage(message) {\n    return message\n}\n\n\n/**\n * MessengerAPI instance method\n * Subclasses should re-implement this method to define the rule for translation of source message data to internal message data. This class simply returns the same `sourceData`.\n * This method is used in [dispatchMessage](./m_source.js.html#dispatchMessage) method of `MessageSource`.\n *\n * @param {String} sourceMessage source message, can be used in translation rule\n * @param {String} message internal message, can be used in translation rule\n * @param {Object} sourceData data received from source that has to be translated to data that will be sent to internal Messenger subscriber\n * @return {Object}\n */\nfunction createInternalData(sourceMessage, message, sourceData) {\n    return sourceData;\n}\n\n\n/**\n * MessengerAPI instance method\n * Subclasses should re-implement this method to define the dispatch filter for internal messages. This method should return `true` to allow and `false` to prevent internal message dispatch. This class always returns `true`.\n * This method is used in [dispatchMessage](./m_source.js.html#dispatchMessage) method of `MessageSource`.\n *\n * @param {String} sourceMessage source message, can be used in filter rule\n * @param {String} message internal message, can be used in filter rule\n * @param {Object} internalData data translated by `createInternalData` method from source data, can be used in filter rule\n * @return {Boolean}\n */\nfunction filterSourceMessage(sourceMessage, message, internalData) {\n    return true;\n}\n",
    "'use strict';\n\nvar MessengerAPI = require('./m_api')\n    , _ = require('mol-proto');\n\n\n/**\n * A generic subsclass of [MessengerAPI](./m_api.js.html) that supports pattern subscriptions to source.\n * Can be useful if the source is another Messenger.\n */\n var MessengerRegexpAPI = _.createSubclass(MessengerAPI, 'MessengerRegexpAPI');\n\n module.exports = MessengerRegexpAPI;\n\n\n_.extendProto(MessengerRegexpAPI, {\n    init: init,\n    addInternalMessage: addInternalMessage,\n    removeInternalMessage: removeInternalMessage,\n    getInternalMessages: getInternalMessages\n});\n\n\n/**\n * MessengerRegexpAPI instance method\n * Called by MessengerRegexpAPI constructor.\n */\nfunction init() {\n    MessengerAPI.prototype.init.apply(this, arguments);\n    _.defineProperties(this, {\n        _patternInternalMessages: {}\n    });\n    this._catchAllSubscribed = false;\n}\n\n\n/**\n * MessengerRegexpAPI instance method\n * Augments MessengerAPI method by storing regexp\n *\n * @param {String} message internal message to be translated and added\n * @return {String|RegExp|undefined}\n */\nfunction addInternalMessage(message) {\n    var sourceMessage = MessengerAPI.prototype.addInternalMessage.apply(this, arguments);\n    \n    // store regexp itself if sourceMessage is regexp\n    if (sourceMessage && sourceMessage instanceof RegExp) {\n        this._internalMessages[sourceMessage].pattern = sourceMessage;\n        this._patternInternalMessages[sourceMessage] = this._internalMessages[sourceMessage];\n        if (this._catchAllSubscribed) return;\n            this._catchAllSubscribed = true;\n        return /.*/;\n    }\n\n    return sourceMessage;\n}\n\n\n/**\n * MessengerRegexpAPI instance method\n * Augments MessengerAPI method by removing regexp subscirption\n * \n * @param {String} message internal message to be translated and added\n * @return {String|RegExp|undefined}\n */\nfunction removeInternalMessage(message) {\n    var sourceMessage = MessengerAPI.prototype.removeInternalMessage.apply(this, arguments);\n\n    if (sourceMessage && sourceMessage instanceof RegExp) {\n        delete this._patternInternalMessages[sourceMessage];\n        var noPatternInternalMessages = ! Object.keys(this._patternInternalMessages).length;\n        if (noPatternInternalMessages) {\n            this._catchAllSubscribed = false;\n            return /.*/;\n        }\n    }\n\n    return sourceMessage;\n}\n\n\n/**\n * MessengerAPI instance method\n * Augments MessengerAPI method by returning messages subscribed with regexp\n * This method is used by `MessageSource` to dispatch source message on the `Mesenger`.\n *\n * @param {String|RegExp} sourceMessage source message\n * @return {Array[String]}\n */\nfunction getInternalMessages(sourceMessage) {\n    var internalMessages = MessengerAPI.prototype.getInternalMessages.apply(this, arguments);\n\n    // add internal messages for regexp source subscriptions\n    if (typeof sourceMessage == 'string') {\n        internalMessages = internalMessages || [];\n        var internalMessagesHash = _.object(internalMessages, true);\n\n        _.eachKey(this._patternInternalMessages, function(patternMessages) {\n            var sourcePattern = patternMessages.pattern;\n\n            if (sourcePattern.test(sourceMessage))\n                patternMessages.forEach(function(message) {\n                    if (internalMessagesHash[message]) return;\n                    internalMessages.push(message);\n                    internalMessagesHash[message] = true;\n                });\n        });\n    } \n\n    return internalMessages;\n}\n",
    "'use strict';\n\nvar Mixin = require('../abstract/mixin')\n    , MessengerAPI = require('./m_api')\n    , _ = require('mol-proto')\n    , check = require('../util/check')\n    , Match = check.Match;\n\n\n/**\n * `milo.classes.MessageSource`\n * An abstract class (subclass of [Mixin](../abstract/mixin.js.html)) for connecting [Messenger](./index.js.html) to external sources of messages (like DOM events) and defining higher level messages.\n * An instance of MessageSource can either be passed to Messenger constructor or later using `_setMessageSource` method of Messenger. Once set, MessageSource of Messenger cannot be changed.\n */\nvar MessageSource = _.createSubclass(Mixin, 'MessageSource', true);\n\nmodule.exports = MessageSource;\n\n\n/**\n * ####MessageSource instance methods####\n *\n * - [init](#init) - initializes messageSource - called by Mixin superclass\n * - [setMessenger](#setMessenger) - connects Messenger to MessageSource, is called from `init` or `_setMessageSource` methods of [Messenger](./index.js.html).\n * - [onSubscriberAdded](#onSubscriberAdded) - called by Messenger to notify when the first subscriber for an internal message was added, so MessageSource can subscribe to source\n * - [onSubscriberRemoved](#onSubscriberRemoved) - called by Messenger to notify when the last subscriber for an internal message was removed, so MessageSource can unsubscribe from source\n * - [dispatchMessage](#dispatchMessage) - dispatches source message. MessageSource subclass should implement mechanism when on actual source message this method is called.\n *\n * Methods below should be implemented in subclass:\n *\n * - [trigger](#trigger) - triggers messages on the source (an optional method)\n * - [addSourceSubscriber](#addSourceSubscriber) - adds listener/subscriber to external message\n * - [removeSourceSubscriber](#removeSourceSubscriber) - removes listener/subscriber from external message\n */\n_.extendProto(MessageSource, {\n    init: init,\n    destroy: MessageSource$destroy,\n    setMessenger: setMessenger,\n    onSubscriberAdded: onSubscriberAdded,\n    onSubscriberRemoved: onSubscriberRemoved, \n    dispatchMessage: dispatchMessage,\n    postMessage: postMessage,\n    _prepareMessengerAPI: _prepareMessengerAPI,\n\n    // Methods below must be implemented in subclass\n    trigger: toBeImplemented,\n    addSourceSubscriber: toBeImplemented,\n    removeSourceSubscriber: toBeImplemented\n});\n\n\n/**\n * MessageSource instance method.\n * Called by Mixin constructor.\n * MessageSource constructor should be passed the same parameters as this method signature.\n * If an instance of [MessengerAPI](./m_api.js.html) is passed as the third parameter, it extends MessageSource functionality to allow it to define new messages, to filter messages based on their data and to change message data. See [MessengerAPI](./m_api.js.html).\n *\n * @param {Object} hostObject Optional object that stores the MessageSource on one of its properties. It is used to proxy methods of MessageSource.\n * @param {Object[String]} proxyMethods Optional map of method names; key - proxy method name, value - MessageSource's method name.\n * @param {MessengerAPI} messengerAPI Optional instance of MessengerAPI.\n */\nfunction init(hostObject, proxyMethods, messengerAPI) {\n    this._prepareMessengerAPI(messengerAPI);\n}\n\n\n/**\n * Destroys message source\n */\nfunction MessageSource$destroy() {\n    if (this.messengerAPI)\n        this.messengerAPI.destroy();\n}\n\n\n/**\n * MessageSource instance method.\n * Sets reference to Messenger instance.\n *\n * @param {Messenger} messenger reference to Messenger instance linked to this MessageSource\n */\nfunction setMessenger(messenger) {\n    _.defineProperty(this, 'messenger', messenger);\n}\n\n\n/**\n * MessageSource instance method.\n * Prepares [MessengerAPI](./m_api.js.html) passed to constructor by proxying its methods to itself or if MessengerAPI wasn't passed defines two methods to avoid checking their availability every time the message is dispatched.\n *\n * @private\n * @param {MessengerAPI} messengerAPI Optional instance of MessengerAPI\n */\nfunction _prepareMessengerAPI(messengerAPI) {\n    check(messengerAPI, Match.Optional(MessengerAPI));\n\n    if (! messengerAPI)\n        messengerAPI = new MessengerAPI;\n\n    _.defineProperty(this, 'messengerAPI', messengerAPI);\n}\n\n\n/**\n * MessageSource instance method.\n * Subscribes to external source using `addSourceSubscriber` method that should be implemented in subclass.\n * This method is called by [Messenger](./index.js.html) when the first subscriber to the `message` is added.\n * Delegates to supplied or default [MessengerAPI](./m_api.js.html) for translation of `message` to `sourceMessage`. `MessageAPI.prototype.addInternalMessage` will return undefined if this `sourceMessage` was already subscribed to to prevent duplicate subscription.\n *\n * @param {String} message internal Messenger message that has to be subscribed to at the external source of messages.\n */\nfunction onSubscriberAdded(message) {\n    var newSourceMessage = this.messengerAPI.addInternalMessage(message);\n    if (typeof newSourceMessage != 'undefined')\n        this.addSourceSubscriber(newSourceMessage);\n}\n\n\n/**\n * MessageSource instance method.\n * Unsubscribes from external source using `removeSourceSubscriber` method that should be implemented in subclass.\n * This method is called by [Messenger](./index.js.html) when the last subscriber to the `message` is removed.\n * Delegates to supplied or default [MessengerAPI](./m_api.js.html) for translation of `message` to `sourceMessage`. `MessageAPI.prototype.removeInternalMessage` will return undefined if this `sourceMessage` was not yet subscribed to to prevent unsubscription without previous subscription.\n *\n * @param {String} message internal Messenger message that has to be unsubscribed from at the external source of messages.\n */\nfunction onSubscriberRemoved(message) {\n    var removedSourceMessage = this.messengerAPI.removeInternalMessage(message);\n    if (typeof removedSourceMessage != 'undefined')\n        this.removeSourceSubscriber(removedSourceMessage);\n}\n\n\n/**\n * MessageSource instance method.\n * Dispatches sourceMessage to Messenger.\n * Mechanism that calls this method when the source message is received should be implemented by subclass (see [DOMEventsSource](../components/msg_src/dom_events.js.html) for example).\n * Delegates to supplied or default [MessengerAPI](./m_api.js.html) to create internal message data (`createInternalData`) and to filter the message based on its data and/or message (`filterSourceMessage`).\n * Base MessengerAPI class implements these two methods in a trivial way (`createInternalData` simply returns external data, `filterSourceMessage` returns `true`), they are meant to be implemented by subclass.\n *\n * @param {String} sourceMessage source message received from external source\n * @param {Object} sourceData data received from external source\n */\nfunction dispatchMessage(sourceMessage, sourceData) {\n    var api = this.messengerAPI\n        , internalMessages = api.getInternalMessages(sourceMessage);\n\n    if (internalMessages) \n        internalMessages.forEach(function (message) {\n            var internalData = api.createInternalData(sourceMessage, message, sourceData);\n\n            var shouldDispatch = api.filterSourceMessage(sourceMessage, message, internalData);\n            if (shouldDispatch) \n                this.postMessage(message, internalData);      \n            \n        }, this);\n}\n\n\n/**\n * Posts message on the messenger. This method is separated so specific message sources can make message dispatch synchronous by using `postMessageSync`\n * \n * @param  {String} message\n * @param  {Object} data\n */\nfunction postMessage(message, data) {\n    this.messenger.postMessage(message, data);\n}\n\n\nfunction toBeImplemented() {\n    throw new Error('calling the method of an absctract class');\n}\n",
    "'use strict';\n\n\nvar MessageSource = require('./m_source')\n    , _ = require('mol-proto')\n    , check = require('../util/check');\n\n\n/**\n * Subclass of MessageSource that allows to connect Messenger to another Messenger using it as external source.\n */\nvar MessengerMessageSource = _.createSubclass(MessageSource, 'MessengerMessageSource');\n\nmodule.exports = MessengerMessageSource;\n\n\n/**\n * ####MessengerMessageSource instance methods####\n */\n_.extendProto(MessengerMessageSource, {\n    init: init,\n    addSourceSubscriber: addSourceSubscriber,\n    removeSourceSubscriber: removeSourceSubscriber,\n    postMessage: MessengerMessageSource$postMessage\n});\n\n/**\n * Initializes MessengerMessageSource\n * Defines one parameter in addition to [MessageSource](./m_source.js.html) parameters\n *\n * @param {Messenger} sourceMessenger messenger this message source connects to\n */\nfunction init(hostObject, proxyMethods, messengerAPI, sourceMessenger) {\n    MessageSource.prototype.init.apply(this, arguments);\n    this.sourceMessenger = sourceMessenger;\n}\n\n\n/**\n * Subscribes to source message. See [MessageSource](./m_source.js.html) docs.\n *\n * @param {String|Regex} sourceMessage source message to subscribe to\n */\nfunction addSourceSubscriber(sourceMessage) {\n    this.sourceMessenger.onSync(sourceMessage, { context: this, subscriber: this.dispatchMessage });\n}\n\n\n/**\n * Unsubscribes from source message. See [MessageSource](./m_source.js.html) docs.\n *\n * @param {String|Regex} sourceMessage source message to unsubscribe from\n */\nfunction removeSourceSubscriber(sourceMessage) {\n    this.sourceMessenger.off(sourceMessage, { context: this, subscriber: this.dispatchMessage });\n}\n\n\n/**\n * Overrides defalut message source to dispatch messages synchronously\n * \n * @param {String} message\n * @param {Object} data\n */\nfunction MessengerMessageSource$postMessage(message, data) {\n    this.messenger.postMessageSync(message, data);\n}\n",
    "'use strict';\n\nvar _ = require('mol-proto');\n\n\n/**\n * ####Milo packages####\n *\n * - [minder](./minder.js.html) - data reactivity, one or two way, shallow or deep, as you like it\n * - [config](./config.js.html) - milo configuration\n * - [util](./util/index.js.html) - logger, request, dom, check, error, etc.\n * - [classes](./classes.js.html) - abstract and base classes\n * - [Messenger](./messenger/index.js.html) - generic Messenger used in most other milo classes, can be mixed into app classes too.\n * - [Model](./model/index.js.html) - Model class that emits messages on changes to any depth without timer based watching\n */\nvar milo = {\n    minder: require('./minder'),\n    config: require('./config'),\n    util: require('./util'),\n    classes: require('./classes'),\n    Messenger: require('./messenger'),\n    Model: require('./model'),\n    destroy: destroy,\n    proto: _\n};\n\n\n// export for node/browserify\nif (typeof module == 'object' && module.exports)    \n    module.exports = milo;\n\n// global milo for browser\nif (typeof window == 'object')\n    window.milo = milo;\n\n\nfunction destroy() {\n    milo.minder.destroy();\n}\n",
    "'use strict';\n\nvar Connector = require('./model/connector')\n    , Messenger = require('./messenger')\n    , _ = require('mol-proto')\n    , logger = require('./util/logger');\n\n\nmodule.exports = minder;\n\n\n/**\n * This function creates one or many Connector objects that\n * create live reactive connection between objects implementing\n * dataSource interface:\n * Objects should emit messages when any part of their data changes,\n * methods `on` and `off` should be implemented to subscribe/unsubscribe\n * to change notification messages, methods `set` and `get` should be implemented to get/set data\n * on path objects, pointing to particular parts of the object, method `path`\n * should return path object for a given path string (see path utils for path string syntax).\n * Both Model and Data facet are such data sources, they can be linked by Connector object.\n *\n * @param {Object} ds1 the first data source. Instead of the first data source an array can be passed with arrays of Connection objects parameters in each array element.\n * @param {String} mode the connection mode that defines the direction and the depth of connection. Possible values are '->', '<<-', '<<<->>>', etc.\n * @param {Object} ds2 the second data source\n * @param {Object} options not implemented yet\n */\nfunction minder(ds1, mode, ds2, options) {\n    if (Array.isArray(ds1)) {\n        var connDescriptions = ds1;\n        var connectors = connDescriptions.map(function(descr) {\n            return new Connector(descr[0], descr[1], descr[2], descr[3]);\n        });\n        connectors.forEach(_addConnector);\n        return connectors;\n    } else {\n        var cnct = new Connector(ds1, mode, ds2, options);\n        _addConnector(cnct);\n        return cnct;\n    }\n}\n\n\n/**\n * messenger of minder where it emits events related to all connectors\n * @type {Messenger}\n */\nvar _messenger = new Messenger(minder, Messenger.defaultMethods);\n\n\nvar _connectors = []\n    , _receivedMessages = []\n    , _isPropagating = false;\n\n\n_.extend(minder, {\n    getConnectors: minder_getConnectors,\n    getExpandedConnections: minder_getExpandedConnections,\n    isPropagating: minder_isPropagating,\n    whenPropagationCompleted: minder_whenPropagationCompleted,\n    destroyConnector: minder_destroyConnector,\n    destroy: minder_destroy\n});\n\n\nfunction _addConnector(cnct) {\n    cnct.___minder_id = _connectors.push(cnct) - 1;\n    cnct.on(/.*/, onConnectorMessage);\n    minder.postMessage('added', { connector: cnct });\n    minder.postMessage('turnedon', { connector: cnct });\n}\n\n\nfunction onConnectorMessage(msg, data) {\n    var data = data ? _.clone(data) : {};\n    _.extend(data, {\n        id: this.___minder_id,\n        connector: this\n    });\n    minder.postMessage(msg, data);\n    if (! _receivedMessages.length && ! _isPropagating) {\n        _.defer(_idleCheck);\n        _isPropagating = true;\n    }\n\n    _receivedMessages.push({ msg: msg, data: data });\n}\n\n\nfunction _idleCheck() {\n    if (_receivedMessages.length) {\n        _receivedMessages.length = 0;\n        _.defer(_idleCheck);\n        minder.postMessage('propagationticked');\n    } else {\n        _isPropagating = false;\n        minder.postMessage('propagationcompleted');\n    }\n}\n\n\nfunction minder_isPropagating() {\n    return _isPropagating;\n}\n\n\nfunction minder_whenPropagationCompleted(callback) {\n    if (_isPropagating)\n        minder.once('propagationcompleted', executeCallback);\n    else\n        _.defer(executeCallback);\n\n    function executeCallback() {\n        if (_isPropagating)\n            minder.once('propagationcompleted', executeCallback);\n        else\n            callback();\n    }\n}\n\n\nfunction minder_getConnectors(onOff) {\n    if (typeof onOff == 'undefined')\n        return _connectors;\n\n    return _connectors.filter(function(cnct) {\n        return cnct.isOn === onOff;\n    });\n}\n\n\nfunction minder_destroyConnector(cnct) {\n    cnct.destroy();\n    var index = _connectors.indexOf(cnct);\n    if (index >= 0)\n        delete _connectors[index];\n    else\n        logger.warn('minder: connector destroyed that is not registered in minder');\n}\n\n\nfunction minder_getExpandedConnections(onOff, searchStr) {\n    var connectors = minder.getConnectors(onOff);\n    var connections =  connectors.map(function(cnct) {\n        var connection = {\n            leftSource: _getExpandedSource(cnct.ds1),\n            rightSource: _getExpandedSource(cnct.ds2),\n            mode: cnct.mode,\n            isOn: cnct.isOn\n        };\n        \n        if (cnct.options)\n            connection.options = cnct.options;\n\n        return connection;\n    });\n\n    if (searchStr)\n        connections = connections.filter(function(cnctn) {\n            return _sourceMatchesString(cnctn.leftSource, searchStr)\n                    || _sourceMatchesString(cnctn.rightSource, searchStr);\n        });\n\n    return connections;\n}\n\n\nfunction _getExpandedSource(ds) {\n    var source = [];\n    if (typeof ds == 'function') {\n        if (ds._model && ds._accessPath) {\n            source.unshift(ds._accessPath);\n            ds = ds._model;\n        }\n\n        source.unshift(ds);\n        ds = ds._hostObject;\n    }\n\n    if (typeof ds == 'object') {\n        source.unshift(ds);\n\n        if (ds.owner)\n            source.unshift(ds.owner);\n    }\n\n    return source;\n}\n\n\nfunction _sourceMatchesString(source, matchStr) {\n    return source.some(function(srcNode) {\n        var className = srcNode.constructor && srcNode.constructor.name;\n        return _stringMatch(className, matchStr)\n                || _stringMatch(srcNode.name, matchStr)\n                || _stringMatch(srcNode, matchStr);\n    });\n}\n\n\nfunction _stringMatch(str, substr) {\n    return str && typeof str == 'string' && str.indexOf(substr) >= 0;\n}\n\n\nfunction minder_destroy() {\n    _connectors.forEach(function(cnct) {\n        destroyDS(cnct.ds1);\n        destroyDS(cnct.ds2);\n        cnct.destroy();\n    });\n    _messenger.destroy();\n    minder._destroyed = true;\n\n    function destroyDS(ds) {\n        if (ds && !ds._destroyed) ds.destroy();\n    }\n}\n",
    "'use strict';\n\n\nvar logger = require('../util/logger')\n    , config = require('../config')\n    , pathUtils = require('./path_utils')\n    , _ = require('mol-proto');\n\n/**\n * Utility function to process \"changedata\" messages emitted by Connector object.\n */\nmodule.exports = changeDataHandler;\n\n\n_.extend(changeDataHandler, {\n    setTransactionFlag: setTransactionFlag,\n    getTransactionFlag: getTransactionFlag,\n    passTransactionFlag: passTransactionFlag,\n    postTransactionFinished: postTransactionFinished\n});\n\n\n/**\n * Change data uses hidden property on accessor methods to pass flag that the accessor is executed as a part of change transaction.\n * Accessor methods are supposed to store this flag in a local variable and to clear it (because another accessor can be executed in or out of transaction) using `getTransactionFlag`\n *\n * @private\n * @param {Function} func accessor method reference\n * @param {Boolean} flag a flag to be set\n */\nfunction setTransactionFlag(func, flag) {\n    _.defineProperty(func, '__inChangeTransaction', flag, _.CONF | _.WRIT);\n}\n\n\n/**\n * Retrieves and clears transaction flag from accessor method\n *\n * @private\n * @param {Function} func accessor method reference\n * @return {Boolean}\n */\nfunction getTransactionFlag(func) {\n    var inTransaction = func.__inChangeTransaction;\n    delete func.__inChangeTransaction;\n    return inTransaction;\n}\n\n\nfunction passTransactionFlag(fromFunc, toFunc) {\n    var inTransaction = getTransactionFlag(fromFunc);\n    setTransactionFlag(toFunc, inTransaction);\n    return inTransaction;\n}\n\n\n/**\n * Posts message on this to indicate the end of transaction unless `inChangeTransaction` is `true`.\n */\nfunction postTransactionFinished() {\n    this.postMessageSync('datachanges', { transaction: false, changes: [] });\n}\n\n\n/**\n * subscriber to \"changedata\" event emitted by [Connector](./connector.js.html) object to enable reactive connections\n * Used by Data facet, Model and ModelPath. Can be used by any object that implements get/set/del/splice api and sets data deeply to the whole tree.\n * Object should call `changeDataHandler.initialize.call(this)` in its constructor.\n * TODO: optimize messages list to avoid setting duplicate values down the tree\n *\n * @param {String} msg should be \"changedata\" here\n * @param {Object} data batch of data change desciption objects\n * @param {Function} callback callback to call before and after the data is processed\n */\nfunction changeDataHandler(message, data, callback) {\n    processChanges.call(this, data.changes, callback);\n}\n\n\n// map of message types to methods\nvar CHANGE_TYPE_TO_METHOD_MAP = {\n    'added':   'set',\n    'changed': 'set',\n    'deleted': 'del',\n    'removed': 'del'\n};\n\n\n/**\n * Processes queued \"changedata\" messages.\n * Posts \"changestarted\" and \"changecompleted\" messages and calls callback\n *\n * @param {[Function]} callback optional callback that is called with `(null, false)` parameters before change processing starts and `(null, true)` after it's finished.\n */\nfunction processChanges(transaction, callback) {\n    notify.call(this, callback, false);\n    processTransaction.call(this,\n        prepareTransaction(\n            validateTransaction(transaction)));\n    notify.call(this, callback, true);\n}\n\n\nfunction notify(callback, changeFinished) {\n    callback && callback(null, changeFinished);\n    this.postMessage(changeFinished ? 'changecompleted' : 'changestarted');\n}\n\n\n/**\n * Checks that all messages from the transaction come from the same source.\n * Hack: reverses the transaction if it comes from the Data facet\n * Returns the reference to the transaction (for chaining)\n * \n * @param  {Array} transaction transaction of data changes\n * @return {Array} \n */\nfunction validateTransaction(transaction) {\n    var source = transaction[0].source\n        , sameSource = true;\n\n    if (transaction.length > 1) {\n        for (var i = 1, len = transaction.length; i < len; i++)\n            if (transaction[i].source != source) {\n                logger.error('changedata: changes from different sources in the same transaction, sources:', transaction[i].source.name, source.name);\n                sameSource = false;\n                source = transaction[i].source;\n            }\n    }\n\n    return transaction;\n}\n\n\nfunction prepareTransaction(transaction) {\n    var todo = []\n        , pathsToSplice = []\n        , pathsToChange = []\n        , hadSplice\n        , exitLoop = {};\n\n\n    try { transaction.forEach(checkChange); }\n    catch (e) { if (e != exitLoop) throw e; }\n\n    return todo;\n\n\n    function checkChange(data) {\n        (data.type == 'splice' ? checkSplice : checkMethod)(data);\n    }\n\n\n    function checkSplice(data) {\n        var parsedPath = pathUtils.parseAccessPath(data.path);\n        var parentPathChanged = pathsToChange.some(function(parentPath) {\n            if (parsedPath.length < parentPath.length) return;\n            return _pathIsParentOf(parentPath, parsedPath);\n        });\n\n        if (parentPathChanged) return;\n\n        todo.push(data);\n\n        if (! config.debug) throw exitLoop;\n        pathsToSplice.push(parsedPath);\n        hadSplice = true;\n    }\n\n\n    function checkMethod(data) {\n        var parsedPath = pathUtils.parseAccessPath(data.path);\n        var parentPathSpliced = pathsToSplice && pathsToSplice.some(function(parentPath) {\n            if (parsedPath.length <= parentPath.length\n                || parsedPath[parentPath.length].syntax != 'array') return;\n            return _pathIsParentOf(parentPath, parsedPath);\n        });\n\n        if (parentPathSpliced) return;\n        if (hadSplice) logger.error('changedata: child change is executed after splice; probably data source did not emit message with data.type==\"finished\"');\n\n        var parentPathChanged = pathsToChange.some(function(parentPath) {\n            if (parsedPath.length <= parentPath.length) return;\n            return _pathIsParentOf(parentPath, parsedPath);\n        });\n\n        if (parentPathChanged) return;\n\n        pathsToChange.push(parsedPath);\n\n        todo.push(data);\n    }\n\n\n    function _pathIsParentOf(parentPath, childPath) {\n        return parentPath.every(function(pathNode, index) {\n            return pathNode.property == childPath[index].property;\n        });\n    }\n}\n\n\nfunction processTransaction(transaction) {\n    transaction.forEach(processChange, this);\n    postTransactionFinished.call(this, false);\n\n    function processChange(data) {\n        var modelPath = this.path(data.path, data.type != 'removed' && data.type != 'deleted');\n        if (! modelPath) return;\n        (data.type == 'splice' ? executeSplice : executeMethod)(modelPath, data);\n    }\n}\n\n\nfunction executeSplice(modelPath, data) {\n    var index = data.index\n        , howMany = data.removed.length\n        , spliceArgs = [index, howMany];\n\n    spliceArgs = spliceArgs.concat(data.newValue.slice(index, index + data.addedCount));\n    setTransactionFlag(modelPath.splice, true);\n    modelPath.splice.apply(modelPath, spliceArgs);\n}\n\n\nfunction executeMethod(modelPath, data) {\n    var methodName = CHANGE_TYPE_TO_METHOD_MAP[data.type];\n    if (methodName) {\n        setTransactionFlag(modelPath[methodName], true);\n        modelPath[methodName](data.newValue);\n    } else\n        logger.error('unknown data change type');\n}\n",
    "'use strict';\n\nvar Messenger = require('../messenger')\n    , pathUtils = require('./path_utils')\n    , _ = require('mol-proto')\n    , logger = require('../util/logger');\n\n\nmodule.exports = Connector;\n\n\nvar modePattern = /^(\\<*)\\-+(\\>*)$/;\n\n\n/**\n * Connector\n * Class that creates connector object for data connection between\n * two data-sources\n * Data-sources should implement the following API:\n * get() - get value from datasource or its path\n * set(value) - set value to datasource or to its path\n * on(path, subscriber) - subscription to data changes with \"*\" support\n * off(path, subscriber)\n * path(accessPath) - to return the object that gives reference to some part of datasource\n * and complies with that api too.\n *\n * ####Events####\n *\n * - 'turnedon' - connector was turned on\n * - 'turnedoff' - connector was turned off\n * - 'changestarted' - change on connected datasource is started\n * - 'changecompleted' - change on connected datasource is completed\n * - 'destroyed' - connector was destroyed\n * \n * @param {Object} ds1 the first data source.\n * @param {String} mode the connection mode that defines the direction and the depth of connection. Possible values are '->', '<<-', '<<<->>>', etc.\n * @param {Object} ds2 the second data source\n * @param {Object} options not implemented yet\n * @return {Connector} when called with `new`, creates a Connector object.\n */\nfunction Connector(ds1, mode, ds2, options) {\n    setupMode.call(this, mode);\n\n    _.extend(this, {\n        ds1: ds1,\n        ds2: ds2,\n        isOn: false,\n        _changesQueue1: [],\n        _changesQueue2: [],\n        _messenger: new Messenger(this, Messenger.defaultMethods)\n    });\n\n    if (options) {\n        this.options = options;\n\n        var pathTranslation = options.pathTranslation;\n        if (pathTranslation) {\n            pathTranslation = _.clone(pathTranslation);\n            var patternTranslation = getPatternTranslations(pathTranslation);\n            _.extend(this, {\n                pathTranslation1: reverseTranslationRules(pathTranslation),\n                pathTranslation2: pathTranslation,\n                patternTranslation1: reversePatternTranslationRules(patternTranslation),\n                patternTranslation2: patternTranslation\n            });\n        }\n\n        var dataTranslation = options.dataTranslation;\n        if (dataTranslation) {\n            _.extend(this, {\n                dataTranslation1: dataTranslation['<-'],\n                dataTranslation2: dataTranslation['->']\n            });\n        }\n\n        var dataValidation = options.dataValidation;\n        if (dataValidation) {\n            _.extend(this, {\n                dataValidation1: dataValidation['<-'],\n                dataValidation2: dataValidation['->']\n            });\n        }\n    }\n\n    this.turnOn();\n}\n\n\nfunction setupMode(mode){\n    var parsedMode = mode.match(modePattern);\n\n    if (! parsedMode)\n        modeParseError();\n\n    var depth1 = parsedMode[1].length\n        , depth2 = parsedMode[2].length;\n\n    if (depth1 && depth2 && depth1 != depth2)\n        modeParseError();\n\n    if (! depth1 && ! depth2)\n        modeParseError();\n\n    _.extend(this, {\n        mode: mode,\n        depth1: depth1,\n        depth2: depth2,\n    });\n\n    function modeParseError() {\n        throw new Error('invalid Connector mode: ' + mode);\n    }\n}\n\n\n_.extendProto(Connector, {\n    turnOn: Connector$turnOn,\n    turnOff: Connector$turnOff,\n    destroy: Connector$destroy,\n    changeMode: Connector$changeMode,\n    deferChangeMode: Connector$deferChangeMode\n});\n\n/**\n * Function change the mode of the connection\n *\n * @param @param {String} mode the connection mode that defines the direction and the depth of connection. Possible values are '->', '<<-', '<<<->>>', etc.\n * @return {Object[String]}\n */\nfunction Connector$changeMode(mode) {\n    this.turnOff();\n    setupMode.call(this, mode);\n    this.turnOn();\n    return this;\n}\n\n\n/**\n * Function change the mode of the connection\n *\n * @param @param {String} mode the connection mode that defines the direction and the depth of connection. Possible values are '->', '<<-', '<<<->>>', etc.\n * @return {Object[String]}\n */\nfunction Connector$deferChangeMode(mode) {\n    _.deferMethod(this, 'changeMode', mode);\n    return this;\n}\n\n\n/**\n * Function that reverses translation rules for paths of connected odata sources\n *\n * @param {Object[String]} rules map of paths defining the translation rules\n * @return {Object[String]}\n */\nfunction reverseTranslationRules(rules) {\n    var reverseRules = {};\n    _.eachKey(rules, function(path2_value, path1_key) {\n        reverseRules[path2_value] = path1_key;\n    });\n    return reverseRules;\n}\n\n\nfunction getPatternTranslations(pathTranslation) {\n    var patternTranslation = [];\n    _.eachKey(pathTranslation, function(path2_value, path1_key) {\n        var starIndex1 = path1_key.indexOf('*')\n            , starIndex2 = path2_value.indexOf('*');\n        if (starIndex1 >= 0 && starIndex2 >= 0) { // pattern translation\n            if (path1_key.slice(starIndex1) != path2_value.slice(starIndex2))\n                _throwInvalidTranslation(path1_key, path2_value);\n            delete pathTranslation[path1_key];            \n\n            patternTranslation.push({\n                fromPattern: pathUtils.createRegexPath(path1_key),\n                fromStaticPath: _getStaticPath(path1_key, starIndex1),\n                toPattern: pathUtils.createRegexPath(path2_value),\n                toStaticPath: _getStaticPath(path2_value, starIndex2)\n            });\n        } else if (starIndex1 >= 0 || starIndex2 >= 0) // pattern only on one side of translation\n            _throwInvalidTranslation(path1_key, path2_value);\n    });\n\n    return patternTranslation;\n\n\n    function _throwInvalidTranslation(path1, path2) {\n        throw new Error('Invalid pattern translation: ' + path1 + ', ' + path2);\n    }\n\n\n    function _getStaticPath(path, starIndex) {\n        return path.replace(/[\\.\\[]?\\*.*$/, '');\n    }\n}\n\n\nfunction reversePatternTranslationRules(patternTranslation) {\n    return patternTranslation.map(function(pt) {\n        return {\n            fromPattern: pt.toPattern,\n            fromStaticPath: pt.toStaticPath,\n            toPattern: pt.fromPattern,\n            toStaticPath: pt.fromStaticPath\n        };\n    });\n}\n\n\n/**\n * turnOn\n * Method of Connector that enables connection (if it was previously disabled)\n */\nfunction Connector$turnOn() {\n    if (this.isOn)\n        return logger.warn('data sources are already connected');\n\n    var subscriptionPath = this._subscriptionPath =\n        new Array(this.depth1 || this.depth2).join('*');\n\n    var subscriptionPattern = pathUtils.createRegexPath(subscriptionPath);\n\n    var self = this;\n    if (this.depth1)\n        this._link1 = linkDataSource('_link2', this.ds2, this.ds1, this._changesQueue1, this.pathTranslation1, this.patternTranslation1, this.dataTranslation1, this.dataValidation1);\n    if (this.depth2)\n        this._link2 = linkDataSource('_link1', this.ds1, this.ds2, this._changesQueue2, this.pathTranslation2, this.patternTranslation2, this.dataTranslation2, this.dataValidation2);\n\n    this.isOn = true;\n    this.postMessage('turnedon');\n\n\n    function linkDataSource(reverseLink, fromDS, toDS, changesQueue, pathTranslation, patternTranslation, dataTranslation, dataValidation) {\n        fromDS.onSync('datachanges', onData);\n        return onData;\n\n        function onData(message, batch) {\n            var sendData = {\n                changes: [],\n                transaction: batch.transaction\n            }\n\n            batch.changes.forEach(function(change) {\n                var sourcePath = change.path\n                    , targetPath = translatePath(sourcePath);\n\n                if (typeof targetPath == 'undefined') return;\n\n                var change = _.clone(change);\n                _.extend(change, {\n                    source: fromDS,\n                    path: targetPath\n                });\n\n                translateData(sourcePath, change);\n                validateData(sourcePath, change);\n            });\n\n            if (! changesQueue.length)\n                _.defer(postChangeData);\n\n            changesQueue.push(sendData);\n\n\n            function translatePath(sourcePath) {\n                if (pathTranslation) {\n                    var translatedPath = pathTranslation[sourcePath];\n                    if (translatedPath) return translatedPath;\n                    if (!patternTranslation.length) return;\n                    var pt = _.find(patternTranslation, function(pTranslation) {\n                        return pTranslation.fromPattern.test(sourcePath);\n                    });\n                    if (!pt) return;\n                    var translatedPath = sourcePath.replace(pt.fromStaticPath, pt.toStaticPath);\n                } else if (! ((subscriptionPattern instanceof RegExp\n                                 && subscriptionPattern.test(sourcePath))\n                              || subscriptionPattern == sourcePath)) return;\n\n                return translatedPath || sourcePath;\n            }\n\n\n            function translateData(sourcePath, change) {\n                if (dataTranslation) {\n                    var translate = dataTranslation[sourcePath];\n                    if (translate && typeof translate == 'function') {\n                        change.oldValue = translate(change.oldValue);\n                        change.newValue = translate(change.newValue);\n                    }\n                }\n            }\n\n             \n            function validateData(sourcePath, change) {\n                propagateData(change);\n\n                if (dataValidation) {\n                    var validators = dataValidation[sourcePath]\n                        , passedCount = 0\n                        , alreadyFailed = false;\n\n                    if (validators)\n                        validators.forEach(callValidator);   \n                }\n\n\n                function callValidator(validator) {\n                    validator(change.newValue, function(err, response) {\n                        response.path = sourcePath;\n                        if (! alreadyFailed && (err || response.valid) && ++passedCount == validators.length) {\n                            fromDS.postMessage('validated', response);\n                        } else if (! response.valid) {\n                            alreadyFailed = true;\n                            fromDS.postMessage('validated', response);\n                        }\n                    });\n                }\n            }\n\n\n            function propagateData(change) {\n                sendData.changes.push(change);\n            }\n\n\n            function postChangeData() {\n                // prevent endless loop of updates for 2-way connection\n                if (self[reverseLink]) var callback = subscriptionSwitch;\n\n                var transactions = mergeTransactions(changesQueue);\n                changesQueue.length = 0;\n                transactions.forEach(function(transaction) {\n                    // send data change instruction as message\n                    toDS.postMessageSync('changedata', { changes: transaction }, callback);\n                });\n            }\n\n\n            function subscriptionSwitch(err, changeFinished) {\n                if (err) return;\n                var onOff = changeFinished ? 'onSync' : 'off';\n                toDS[onOff]('datachanges', self[reverseLink]);\n\n                var message = changeFinished ? 'changecompleted' : 'changestarted';\n                self.postMessage(message, { source: fromDS, target: toDS });\n            }\n\n\n            function mergeTransactions(batches) {\n                var transactions = []\n                    , currentTransaction;\n\n                batches.forEach(function(batch) {\n                    if (! batch.transaction) currentTransaction = undefined;\n                    if (! batch.changes.length) return;\n\n                    if (batch.transaction) {\n                        if (currentTransaction)\n                            _.appendArray(currentTransaction, batch.changes);\n                        else {\n                            currentTransaction = _.clone(batch.changes);\n                            transactions.push(currentTransaction);\n                        }\n                    } else\n                        transactions.push(batch.changes);\n                });\n\n                return transactions;\n            }\n        }\n    }\n}\n\n\n/**\n * turnOff\n * Method of Connector that disables connection (if it was previously enabled)\n */\nfunction Connector$turnOff() {\n    if (! this.isOn)\n        return logger.warn('data sources are already disconnected');\n\n    var self = this;\n    unlinkDataSource(this.ds1, '_link2', this.pathTranslation2);\n    unlinkDataSource(this.ds2, '_link1', this.pathTranslation1);\n\n    this.isOn = false;\n    this.postMessage('turnedoff');\n\n\n    function unlinkDataSource(fromDS, linkName, pathTranslation) {\n        if (self[linkName]) {\n            fromDS.off('datachanges', self[linkName]);\n            delete self[linkName];\n        }\n    }\n}\n\n\n/**\n * Destroys connector object by turning it off and removing references to connected sources\n */\nfunction Connector$destroy() {\n    this.turnOff();\n    this.postMessage('destroyed');\n    this._messenger.destroy();\n    delete this.ds1;\n    delete this.ds2;\n    this._destroyed = true;\n}\n",
    "'use strict';\n\nvar ModelPath = require('./m_path')\n    , synthesize = require('./synthesize')\n    , pathUtils = require('./path_utils')\n    , modelUtils = require('./model_utils')\n    , changeDataHandler = require('./change_data')\n    , Messenger = require('../messenger')\n    , MessengerMessageSource = require('../messenger/msngr_source')\n    , ModelMsgAPI = require('./m_msg_api')\n    , Mixin = require('../abstract/mixin')\n    , _ = require('mol-proto')\n    , check = require('../util/check')\n    , Match = check.Match\n    , logger = require('../util/logger');\n\n\nmodule.exports = Model;\n\n\n/**\n * `milo.Model`\n * Model class instantiates objects that allow deep data access with __safe getters__ that return undefined (rather than throwing exception) when properties/items of unexisting objects/arrays are requested and __safe setters__ that create object trees when properties/items of unexisting objects/arrays are set and also post messages to allow subscription on changes and enable data reactivity.\n * Reactivity is implememnted via [Connector](./connector.js.html) that can be instantiated either directly or with more convenient interface of [milo.minder](../minder.js.html). At the moment model can be connected to [Data facet](../components/c_facets/Data.js.html) or to another model or [ModelPath](./m_path.js.html).\n * Model constructor returns objects that are functions at the same time; when called they return ModelPath objects that allow get/set access to any point in model data. See [ModelData](#ModelData) below.\n *\n * You can subscribe to model changes with `on` method by passing model access path in place of message, pattern or string with any number of stars to subscribe to a certain depth in model (e.g., `'***'` to subscribe to three levels).\n *\n * @constructor\n * @param {Object|Array} data optional initial array data. If it is planned to connect model to view it is usually better to instantiate an empty Model (`var m = new Model`), connect it to [Component](../components/c_class.js.html)'s [Data facet](../components/c_facets/Data.js.html) (e.g., `milo.minder(m, '<<->>', c.data);`) and then set the model with `m.set(data)` - the view will be automatically updated.\n * @param {Object} hostObject optional object that hosts model on one of its properties. Can be used when model itself is the context of the message subscriber and you need to travers to this object (although it is possible to set any context). Can also be used to proxy model's methods to the host like [Model facet](../components/c_facets/ModelFacet.js.html) is doing.\n * @param {Object} options pass { reactive: false } to use model without messaging when it is not needed - it makes it much faster\n * @return {Model}\n */\nfunction Model(data, hostObject, options) {\n    // `model` will be returned by constructor instead of `this`. `model`\n    // (`modelPath` function) should return a ModelPath object with \"synthesized\" methods\n    // to get/set model properties, to subscribe to property changes, etc.\n    // Additional arguments of modelPath can be used in the path using interpolation - see ModelPath below.\n    var model = function modelPath(accessPath) { // , ... arguments that will be interpolated\n        return Model$path.apply(model, arguments);\n    };\n    model.__proto__ = Model.prototype;\n\n    model._hostObject = hostObject;\n    model._options = options || {};\n\n    if (model._options.reactive !== false) {\n        model._prepareMessengers();\n        // subscribe to \"changedata\" message to enable reactive connections\n        model.onSync('changedata', changeDataHandler);\n    }\n\n    if (data) model._data = data;\n\n    return model;\n}\n\nModel.prototype.__proto__ = Model.__proto__;\n\n\n/**\n * ####Model instance methods####\n *\n * - [path](#path) - returns ModelPath object that allows access to any point in Model\n * - [get](#Model$get) - get model data\n * - set - set model data, synthesized\n * - splice - splice model data (as array or pseudo-array), synthesized\n * - [len](./m_path.js.html#ModelPath$len) - returns length of array (or pseudo-array) in model in safe way, 0 if no length is set\n * - [push](./m_path.js.html#ModelPath$push) - add items to the end of array (or pseudo-array) in model\n * - [pop](./m_path.js.html#ModelPath$pop) - remove item from the end of array (or pseudo-array) in model\n * - [unshift](./m_path.js.html#ModelPath$unshift) - add items to the beginning of array (or pseudo-array) in model\n * - [shift](./m_path.js.html#ModelPath$shift) - remove item from the beginning of array (or pseudo-array) in model\n * - [proxyMessenger](#proxyMessenger) - proxy model's Messenger methods to host object\n * - [proxyMethods](#proxyMethods) - proxy model methods to host object\n */\n_.extendProto(Model, {\n    path: Model$path,\n    get: Model$get,\n    proxyMessenger: proxyMessenger, // deprecated, should not be used\n    proxyMethods: proxyMethods,\n    _prepareMessengers: _prepareMessengers,\n    _getHostObject: _getHostObject,\n    destroy: Model$destroy\n});\n\n// set, del, splice are added to model\n_.extendProto(Model, synthesize.modelMethods);\n\n\n/**\n * - Path: ModelPath class as `milo.Model.Path`\n */\n_.extend(Model, {\n    Path: ModelPath,\n    useWith: Model$$useWith,\n    _utils: {\n        path: pathUtils,\n        model: modelUtils,\n        changeDataHandler: changeDataHandler\n    }\n});\n\n\n/**\n * Expose Messenger methods on Facet prototype\n */\nvar MESSENGER_PROPERTY = '_messenger';\nMessenger.useWith(Model, MESSENGER_PROPERTY, Messenger.defaultMethods);\n\n\n/**\n * ModelPath methods added to Model prototype\n */\n['len', 'push', 'pop', 'unshift', 'shift'].forEach(function(methodName) {\n    var method = ModelPath.prototype[methodName];\n    _.defineProperty(Model.prototype, methodName, method);\n});\n\n\n/**\n * Model instance method.\n * Get model data.\n *\n * @return {Any}\n */\nfunction Model$get() {\n    return this._data;\n}\n\n\n/**\n * Model instance method.\n * Returns ModelPath object that implements the same API as model but allows access to any point inside model as defined by `accessPath`.\n * See [ModelPath](./m_path.js.html) class for more information.\n *\n * @param {String} accessPath string that defines path to access model.\n *  Path string consists of parts to define either property access (`\".name\"` to access property name) or array item access (`\"[1]\"` to access item with index 1).\n *  Access path can contain as many parts as necessary (e.g. `\".list[0].name\"` to access property `name` in the first element of array stored in property `list`.\n * @param {List} arguments additional arguments of this method can be used to create interpolated paths.\n *  E.g. `m.path(\"[$1].$2\", id, prop)` returns ModelPath to access property with name `prop` in array item with index `id`. Although this ModelPath object will work exactly as `m(\"[\" + id + \"].\" + prop)`, the interpolated is much more efficient as ModelPath with interpolation will not synthesize new getters and setters, while ModelPath with computed access path will synthesize new getters and setters for each pair of values of `id` and `prop`.\n * @return {ModelPath}\n */\nfunction Model$path(accessPath) {  // , ... arguments that will be interpolated\n    if (! accessPath) return this;\n\n    // \"null\" is context to pass to ModelPath, first parameter of bind\n    // \"this\" (model) is added in front of all arguments\n    _.splice(arguments, 0, 0, null, this);\n\n    // calling ModelPath constructor with new and the list of arguments: this (model), accessPath, ...\n    return new (Function.prototype.bind.apply(ModelPath, arguments));\n}\n\n\n/**\n * Model instance method.\n * Proxy model's Messenger methods to host object.\n *\n * @param {Object} modelHostObject optional host object. If not passed, hostObject passed to Model constructor will be used.\n */\nfunction proxyMessenger(modelHostObject) {\n    modelHostObject = modelHostObject || this._hostObject;\n    Mixin.prototype._createProxyMethods.call(this[MESSENGER_PROPERTY], Messenger.defaultMethods, modelHostObject);\n}\n\n\nvar modelMethodsToProxy = ['path', 'get', 'set', 'del', 'splice', 'len', 'push', 'pop', 'unshift', 'shift'];\n\n\n/**\n * Expose model methods on\n * See same method in Mixin class for parameters meaning\n *\n * @param {Function} hostClass\n * @param {[type]} instanceKey\n * @param {[type]} mixinMethods optional\n */\nfunction Model$$useWith(hostClass, instanceKey, mixinMethods) {\n    mixinMethods = mixinMethods || modelMethodsToProxy;\n    Mixin.useWith.call(Model, hostClass, instanceKey, mixinMethods);\n}\n\n\n/**\n * Model instance method.\n * Proxy model methods to host object.\n *\n * @param {Object} modelHostObject optional host object. If not passed, hostObject passed to Model constructor will be used.\n */\nfunction proxyMethods(modelHostObject) {\n    modelHostObject = modelHostObject || this._hostObject;\n    Mixin.prototype._createProxyMethods.call(this, modelMethodsToProxy, modelHostObject);\n}\n\n\n/**\n * Model instance method.\n * Create and connect internal and external model's messengers.\n * External messenger's methods are proxied on the model and they allows \"*\" subscriptions.\n */\nfunction _prepareMessengers() {\n    // model will post all its changes on internal messenger\n    var internalMessenger = new Messenger(this, undefined, undefined);\n\n    // message source to connect internal messenger to external\n    var internalMessengerSource = new MessengerMessageSource(this, undefined, new ModelMsgAPI, internalMessenger);\n\n    // external messenger to which all model users will subscribe,\n    // that will allow \"*\" subscriptions and support \"changedata\" message api.\n    var externalMessenger = new Messenger(this, undefined, internalMessengerSource);\n\n    _.defineProperty(this, MESSENGER_PROPERTY, externalMessenger);\n    _.defineProperty(this, '_internalMessenger', internalMessenger);\n}\n\n\nfunction _getHostObject() {\n    return this._hostObject;\n}\n\n\nfunction Model$destroy() {\n    this[MESSENGER_PROPERTY].destroy();\n    this._internalMessenger.destroy();\n    this._destroyed = true;\n}\n",
    "'use strict';\n\nvar MessengerRegexpAPI = require('../messenger/m_api_rx')\n    , pathUtils = require('./path_utils')\n    , _ = require('mol-proto');\n\n\n/**\n * Subclass of MessengerRegexpAPI that is used to translate messages of external messenger of Model to internal messenger of Model.\n */\nvar ModelMsgAPI = _.createSubclass(MessengerRegexpAPI, 'ModelMsgAPI');\n\nmodule.exports = ModelMsgAPI;\n\n\n/**\n * ####ModelMsgAPI instance methods####\n *\n * - [translateToSourceMessage](#translateToSourceMessage) - translates subscription paths with \"*\"s to regex, leaving other strings untouched\n */\n_.extendProto(ModelMsgAPI, {\n    translateToSourceMessage: translateToSourceMessage,\n});\n\n\n/**\n * ModelMsgAPI instance method\n * Translates subscription paths with \"*\"s to regex, leaving other strings untouched.\n *\n * @param {String} accessPath relative access path to be translated\n * @return {RegExp|String}\n */\nfunction translateToSourceMessage(accessPath) {\n    if (accessPath instanceof RegExp) return accessPath;\n\n    return pathUtils.createRegexPath(accessPath);\n}\n",
    "'use strict';\n\nvar synthesize = require('./synthesize')\n    , pathUtils = require('./path_utils')\n    , changeDataHandler = require('./change_data')\n    , Messenger = require('../messenger')\n    , ModelPathMsgAPI = require('./path_msg_api')\n    , MessengerMessageSource = require('../messenger/msngr_source')\n    , _ = require('mol-proto')\n    , check = require('../util/check')\n    , Match = check.Match;\n\n\nmodule.exports = ModelPath;\n\n\n/**\n * `milo.Model.Path`\n * ModelPath object that allows access to any point inside [Model](./index.js.html) as defined by `accessPath`\n *\n * @constructor\n * @param {Model} model Model instance that ModelPath gives access to.\n * @param {String} accessPath string that defines path to access model.\n *  Path string consists of parts to define either property access (`\".name\"` to access property name) or array item access (`\"[1]\"` to access item with index 1).\n *  Access path can contain as many parts as necessary (e.g. `\".list[0].name\"` to access property `name` in the first element of array stored in property `list`.\n * @param {List} arguments additional arguments of this method can be used to create interpolated paths.\n *  E.g. `m.path(\"[$1].$2\", id, prop)` returns ModelPath to access property with name `prop` in array item with index `id`. Although this ModelPath object will work exactly as `m(\"[\" + id + \"].\" + prop)`, the interpolated is much more efficient as ModelPath with interpolation will not synthesize new getters and setters, while ModelPath with computed access path will synthesize new getters and setters for each pair of values of `id` and `prop`.\n * @return {ModelPath}\n */\nfunction ModelPath(model, path) { // ,... - additional arguments for interpolation\n    // check(model, Model);\n    check(path, String);\n\n    // `modelPath` will be returned by constructor instead of `this`. `modelPath`\n    // (`modelPath_path` function) should also return a ModelPath object with \"synthesized\" methods\n    // to get/set model properties, to subscribe to property changes, etc.\n    // Additional arguments of modelPath can be used in the path using interpolation - see ModelPath below.\n    var modelPath = function modelPath_path(accessPath) { // , ... arguments that will be interpolated\n        return ModelPath$path.apply(modelPath, arguments);\n    };\n    modelPath.__proto__ = ModelPath.prototype;\n\n\n    _.defineProperties(modelPath, {\n        _model: model,\n        _path: path,\n        _args: _.slice(arguments, 1), // path will be the first element of this array\n        _options: model._options\n    });\n\n    // parse access path\n    var parsedPath = pathUtils.parseAccessPath(path);\n\n    // compute access path string\n    _.defineProperty(modelPath, '_accessPath', interpolateAccessPath(parsedPath, modelPath._args));\n\n    if (modelPath._options.reactive !== false) {\n        // messenger fails on \"*\" subscriptions\n        modelPath._prepareMessenger();\n        // subscribe to \"changedata\" message to enable reactive connections\n        modelPath.onSync('changedata', changeDataHandler);\n    }\n\n    // compiling getter and setter\n    var methods = synthesize(path, parsedPath);\n\n    // adding methods to model path\n    _.defineProperties(modelPath, methods);\n\n    Object.freeze(modelPath);\n\n    return modelPath;\n}\n\nModelPath.prototype.__proto__ = ModelPath.__proto__;\n\n\n/**\n * Interpolates path elements to compute real path\n *\n * @param {Array} parsedPath parsed path - array of path nodes\n * @param {Array} args path interpolation arguments, args[0] is path itself\n * @return {String}\n */\nfunction interpolateAccessPath(parsedPath, args) {\n    return parsedPath.reduce(function(accessPathStr, currNode, index) {\n        var interpolate = currNode.interpolate;\n        return accessPathStr +\n                (interpolate\n                    ? (currNode.syntax == 'array'\n                        ? '[' + args[interpolate] + ']'\n                        : '.' + args[interpolate])\n                    : currNode.property);\n    }, '');\n}\n\n\n/**\n * ####ModelPath instance methods####\n *\n * - [path](#ModelPath$path) - gives access to path inside ModelPath\n * - get - synthesized\n * - set - synthesized\n * - splice - splice model data (as array or pseudo-array), synthesized\n * - [len](#ModelPath$len) - returns length of array (or pseudo-array) in safe way, 0 if no length is set\n * - [push](#ModelPath$push) - add items to the end of array (or pseudo-array) in ModelPath\n * - [pop](#ModelPath$pop) - remove item from the end of array (or pseudo-array) in ModelPath\n * - [unshift](#ModelPath$unshift) - add items to the beginning of array (or pseudo-array) in ModelPath\n * - [shift](#ModelPath$shift) - remove item from the beginning of array (or pseudo-array) in ModelPath\n */\n_.extendProto(ModelPath, {\n    path: ModelPath$path,\n    len: ModelPath$len,\n    push: ModelPath$push,\n    pop: ModelPath$pop,\n    unshift: ModelPath$unshift,\n    shift: ModelPath$shift,\n    _prepareMessenger: _prepareMessenger,\n    _getDefinition: _getDefinition,\n    destroy: ModelPath$destroy\n});\n\n\n_.extend(ModelPath, {\n    _createFromDefinition: _createFromDefinition\n})\n\n\n/**\n * Expose Messenger methods on Facet prototype\n */\nvar MESSENGER_PROPERTY = '_messenger';\nMessenger.useWith(ModelPath, MESSENGER_PROPERTY, Messenger.defaultMethods);\n\n\n/**\n * ModelPath instance method\n * Gives access to path inside ModelPath. Method works similarly to [path method](#Model$path) of model, using relative paths.\n *\n * @param {String} accessPath string that defines path to access model.\n *  Path string consists of parts to define either property access (`\".name\"` to access property name) or array item access (`\"[1]\"` to access item with index 1).\n *  Access path can contain as many parts as necessary (e.g. `\".list[0].name\"` to access property `name` in the first element of array stored in property `list`.\n * @param {List} arguments additional arguments of this method can be used to create interpolated paths.\n *  E.g. `m.path(\"[$1].$2\", id, prop)` returns ModelPath to access property with name `prop` in array item with index `id`. Although this ModelPath object will work exactly as `m(\"[\" + id + \"].\" + prop)`, the interpolated is much more efficient as ModelPath with interpolation will not synthesize new getters and setters, while ModelPath with computed access path will synthesize new getters and setters for each pair of values of `id` and `prop`.\n * @return {ModelPath}\n */\nfunction ModelPath$path(accessPath) {  // , ... arguments that will be interpolated\n    if (! accessPath) return this;\n\n    var thisPathArgsCount = this._args.length - 1;\n\n    if (thisPathArgsCount > 0) {// this path has interpolated arguments too\n        accessPath = accessPath.replace(/\\$[1-9][0-9]*/g, function(str) {\n            return '$' + (+str.slice(1) + thisPathArgsCount);\n        });\n    }\n\n    var newPath = this._path + accessPath;\n\n    // this._model is added in front of all arguments as the first parameter\n    // of ModelPath constructor\n    var args = [this._model, newPath]\n                .concat(this._args.slice(1)) // remove old path from _args, as it is 1 based\n                .concat(_.slice(arguments, 1)); // add new interpolation arguments\n\n    // calling ModelPath constructor with new and the list of arguments: this (model), accessPath, ...\n    return _.newApply(ModelPath, args);\n}\n\n\n/**\n * ModelPath and Model instance method\n * Returns length property and sets it to 0 if it wasn't set.\n *\n * @return {Any}\n */\nfunction ModelPath$len() {\n    return this.path('.length').get() || 0;\n}\n\n\n/**\n * ModelPath and Model instance method\n * Adds items to the end of array (or pseudo-array). Returns new length.\n *\n * @param {List} arguments list of items that will be added to array (pseudo array)\n * @return {Integer}\n */\nfunction ModelPath$push() { // arguments\n    var length = this.len();\n    var newLength = length + arguments.length;\n\n    _.splice(arguments, 0, 0, length, 0);\n    this.splice.apply(this, arguments);\n\n    return newLength;\n}\n\n\n/**\n * ModelPath and Model instance method\n * Removes item from the end of array (or pseudo-array). Returns this item.\n *\n * @return {Any}\n */\nfunction ModelPath$pop() {\n    return this.splice(this.len() - 1, 1)[0];\n}\n\n\n/**\n * ModelPath and Model instance method\n * Inserts items to the beginning of the array. Returns new length.\n *\n * @param {List} arguments items to be inserted in the beginning of array\n * @return {Integer}\n */\nfunction ModelPath$unshift() { // arguments\n    var length = this.len();\n    length += arguments.length;\n\n    _.splice(arguments, 0, 0, 0, 0);\n    this.splice.apply(this, arguments);\n\n    return length;\n}\n\n\n/**\n * ModelPath and Model instance method\n * Removes the item from the beginning of array (or pseudo-array). Returns this item.\n *\n * @return {Any}\n */\nfunction ModelPath$shift() { // arguments\n    return this.splice(0, 1)[0];\n}\n\n\n/**\n * ModelPath instance method\n * Initializes ModelPath mesenger with Model's messenger as its source ([MessengerMessageSource](../messenger/msngr_source.js.html)) and [ModelPathMsgAPI](./path_msg_api.js.html) as [MessengerAPI](../messenger/m_api.js.html)\n */\nfunction _prepareMessenger() {\n    var mPathAPI = new ModelPathMsgAPI(this._accessPath);\n\n    // create MessengerMessageSource connected to Model's messenger\n    var modelMessageSource = new MessengerMessageSource(this, undefined, mPathAPI, this._model);\n\n    // create messenger with model passed as hostObject (default message dispatch context)\n    // and without proxying methods (we don't want to proxy them to Model)\n    var mPathMessenger = new Messenger(this, undefined, modelMessageSource);\n\n    // store messenger on ModelPath instance\n    _.defineProperty(this, MESSENGER_PROPERTY, mPathMessenger);\n}\n\n\n/**\n * Returns the object allowing to recreate model path\n *\n * @return {Object}\n */\nfunction _getDefinition() {\n    return {\n        model: this._model,\n        path: this._path,\n        args: this._args\n    };\n}\n\n\n/**\n * Class method\n * Creates modelPath object from definition created by _getDefinition\n *\n * @param  {Object} definition\n * @return {ModelPath}\n */\nfunction _createFromDefinition(definition) {\n    check(definition, {\n        model: Function, // Model\n        path: String,\n        args: Array\n    });\n\n    var m = definition.model;\n\n    return m.apply(m, definition.args);\n}\n\n\nfunction ModelPath$destroy() {\n    this[MESSENGER_PROPERTY].destroy();\n}\n",
    "'use strict';\n\n\nvar modelUtils = {\n    normalizeSpliceIndex: normalizeSpliceIndex\n};\n\nmodule.exports = modelUtils;\n\n\nfunction normalizeSpliceIndex(spliceIndex, length) {\n    return spliceIndex > length\n            ? length\n            : spliceIndex >= 0\n                ? spliceIndex\n                : spliceIndex + length > 0\n                    ? spliceIndex + length\n                    : 0;\n}\n",
    "'use strict';\n\nvar MessengerAPI = require('../messenger/m_api')\n    , pathUtils = require('./path_utils')\n    , logger = require('../util/logger')\n    , _ = require('mol-proto');\n\n\n/**\n * Subclass of MessengerAPI that is used to translate messages of Messenger on ModelPath to Messenger on Model.\n */\nvar ModelPathMsgAPI = _.createSubclass(MessengerAPI, 'ModelPathMsgAPI');\n\nmodule.exports = ModelPathMsgAPI;\n\n\n/**\n * ####ModelPathMsgAPI instance methods####\n *\n * - [init](#init) - initializes ModelPathMsgAPI\n * - [translateToSourceMessage](#translateToSourceMessage) - translates relative access paths of ModelPath to full path of Model\n * - [createInternalData](#createInternalData) - changes path in message on model to relative path and adds `fullPath` property to message data\n */\n_.extendProto(ModelPathMsgAPI, {\n    init: init,\n    translateToSourceMessage: translateToSourceMessage,\n    createInternalData: createInternalData,\n});\n\n\n/**\n * ModelPathMsgAPI instance method\n * Called by MessengerAPI constructor.\n *\n * @param {String} rootPath root path of model path\n */\nfunction init(rootPath) {\n    MessengerAPI.prototype.init.apply(this, arguments);\n    this.rootPath = rootPath;\n}\n\n/**\n * ModelPathMsgAPI instance method\n * Translates relative access paths of ModelPath to full path of Model.\n *\n * @param {String} accessPath relative access path to be translated\n * @return {String}\n */\nfunction translateToSourceMessage(message) {\n    // TODO should prepend RegExes\n    // TODO should not prepend changedata too???\n    if (message instanceof RegExp)\n        return message;\n    if (message == 'datachanges')\n        return message;\n    \n    return this.rootPath + message;\n}\n\n\n/**\n * ModelPathMsgAPI instance method\n * Changes path in message on model to relative path and adds `fullPath` property to message data.\n *\n * @param {String} sourceMessage full access path on Model\n * @param {String} message relative access path on ModelPath\n * @param {Object} sourceData data received from Model, will be translated as described to be dispatched to ModelPath\n * @return {Object}\n */\nfunction createInternalData(sourceMessage, message, sourceData) {\n    // TODO return on changedata too???\n    if (message == 'datachanges') {\n        var internalChanges = sourceData.changes\n            .map(truncateChangePath, this)\n            .filter(function(change) { return change; });\n        var internalData = {\n            changes: internalChanges,\n            transaction: sourceData.transaction\n        };\n\n        return internalData\n    }\n\n    var internalData = truncateChangePath.call(this, sourceData);\n    return internalData;\n}\n\n\nfunction truncateChangePath(change) {\n    var fullPath = change.path\n        , path = _.unPrefix(fullPath, this.rootPath);\n\n    if (typeof path == 'string') {\n        var change = _.clone(change);\n        change.fullPath = fullPath;\n        change.path = path;\n        return change;\n    }\n}\n",
    "'use strict';\n\n// <a name=\"model-path\"></a>\n// ### model path utils\n\nvar check = require('../util/check')\n    , Match = check.Match\n    , _ = require('mol-proto');\n\nvar pathUtils = {\n    parseAccessPath: parseAccessPath,\n    createRegexPath: createRegexPath,\n    getPathNodeKey: getPathNodeKey,\n    wrapMessengerMethods: wrapMessengerMethods\n};\n\nmodule.exports = pathUtils;\n\n\nvar propertyPathSyntax = '\\\\.[A-Za-z_-][A-Za-z0-9_-]*'\n    , arrayPathSyntax = '\\\\[[0-9]+\\\\]'\n    , interpolationSyntax = '\\\\$[1-9][0-9]*'\n    , propertyInterpolateSyntax = '\\\\.' + interpolationSyntax\n    , arrayInterpolateSyntax = '\\\\[' + interpolationSyntax + '\\\\]'\n\n    , propertyStarSyntax = '\\\\.\\\\*'\n    , arrayStarSyntax = '\\\\[\\\\*\\\\]'\n    , starSyntax = '\\\\*'\n\n    , pathParseSyntax = [\n                            propertyPathSyntax,\n                            arrayPathSyntax,\n                            propertyInterpolateSyntax,\n                            arrayInterpolateSyntax\n                        ].join('|')\n    , pathParsePattern = new RegExp(pathParseSyntax, 'g')\n\n    , patternPathParseSyntax =  [\n                                    pathParseSyntax,\n                                    propertyStarSyntax,\n                                    arrayStarSyntax,\n                                    starSyntax\n                                ].join('|')\n    , patternPathParsePattern = new RegExp(patternPathParseSyntax, 'g')\n\n    //, targetPathParsePattern = /\\.[A-Za-z][A-Za-z0-9_]*|\\[[0-9]+\\]|\\.\\$[1-9][0-9]*|\\[\\$[1-9][0-9]*\\]|\\$[1-9][0-9]/g\n    , pathNodeTypes = {\n        '.': { syntax: 'object', empty: '{}' },\n        '[': { syntax: 'array', empty: '[]'},\n        '*': { syntax: 'match', empty: '{}'},\n    };\n\nfunction parseAccessPath(path, nodeParsePattern) {\n    nodeParsePattern = nodeParsePattern || pathParsePattern;\n\n    var parsedPath = [];\n\n    if (! path)\n        return parsedPath;\n\n    var unparsed = path.replace(nodeParsePattern, function(nodeStr) {\n        var pathNode = { property: nodeStr };\n        _.extend(pathNode, pathNodeTypes[nodeStr[0]]);\n        if (nodeStr[1] == '$')\n            pathNode.interpolate = getPathNodeKey(pathNode, true);\n\n        parsedPath.push(pathNode);\n        return '';\n    });\n    if (unparsed)\n        throw new Error('incorrect model path: ' + path);\n\n    return parsedPath;\n}\n\n\nvar nodeRegex = {\n    '.*': propertyPathSyntax,\n    '[*]': arrayPathSyntax\n};\nnodeRegex['*'] = nodeRegex['.*'] + '|' + nodeRegex['[*]'];\n\nfunction createRegexPath(path) {\n    check(path, Match.OneOf(String, RegExp));\n\n    if (path instanceof RegExp || path.indexOf('*') == -1)\n        return path;\n\n    var parsedPath = pathUtils.parseAccessPath(path, patternPathParsePattern)\n        , regexStr = '^'\n        // , regexStrEnd = ''\n        , patternsStarted = false;\n\n    parsedPath.forEach(function(pathNode) {\n        var prop = pathNode.property\n            , regex = nodeRegex[prop];\n        \n        if (regex) {\n            // regexStr += '(' + regex;\n            // regexStrEnd += '|)';\n            regexStr += '(' + regex + '|)';\n            // regexStrEnd += '|)';\n            patternsStarted = true;\n        } else {\n            // if (patternsStarted)\n            //  throw new Error('\"*\" path segment cannot be in the middle of the path: ' + path);\n            regexStr += prop.replace(/(\\.|\\[|\\])/g, '\\\\$1'); // add slash in front of symbols that have special meaning in regex\n        }\n    });\n\n    regexStr += /* regexStrEnd + */ '$';\n\n    try {\n        return new RegExp(regexStr);\n    } catch (e) {\n        throw new Error('can\\'t construct regex for path pattern: ' + path);\n    }\n}\n\n\nfunction getPathNodeKey(pathNode, interpolated) {\n    var prop = pathNode.property\n        , startIndex = interpolated ? 2 : 1;\n    return pathNode.syntax == 'array'\n        ? prop.slice(startIndex, prop.length - 1)\n        : prop.slice(startIndex);\n}\n\n\n// TODO allow for multiple messages in a string\nfunction wrapMessengerMethods(methodsNames) {\n    methodsNames = methodsNames || ['on', 'off'];\n    var wrappedMethods = _.mapToObject(methodsNames, function(methodName) {\n        var origMethod = this[methodName];\n        // replacing message subsribe/unsubscribe/etc. to convert \"*\" message patterns to regexps\n        return function(path, subscriber) {\n            var regexPath = createRegexPath(path);\n            origMethod.call(this, regexPath, subscriber);\n        };\n    }, this);\n    _.defineProperties(this, wrappedMethods);\n}\n",
    "'use strict';\n\nvar pathUtils = require('../path_utils')\n    , modelUtils = require('../model_utils')\n    , logger = require('../../util/logger')\n    , fs = require('fs')\n    , doT = require('dot')\n    , _ = require('mol-proto')\n    , changeDataHandler = require('../change_data')\n    , getTransactionFlag = changeDataHandler.getTransactionFlag\n    , postTransactionFinished = changeDataHandler.postTransactionFinished;\n\n\n/**\n * Templates to synthesize model getters and setters\n */\nvar templates = {\n    get: \"'use strict';\\n/* Only use this style of comments, not \\\"//\\\" */\\n\\nmethod = function get() {\\n    var m = {{# def.modelAccessPrefix }};\\n    return m {{~ it.parsedPath :pathNode }}\\n        {{? pathNode.interpolate}}\\n            && (m = m[this._args[ {{= pathNode.interpolate }} ]])\\n        {{??}}\\n            && (m = m{{= pathNode.property }})\\n        {{?}} {{~}};\\n};\\n\",\n    set: \"'use strict';\\n/* Only use this style of comments, not \\\"//\\\" */\\n\\n{{# def.include_defines }}\\n{{# def.include_create_tree }}\\n\\n\\n/**\\n * Template that synthesizes setter for Model and for ModelPath\\n */\\nmethod = function set(value) {\\n    {{# def.initVars:'set' }}\\n\\n    {{# def.createTree:'set' }}\\n\\n    {{\\n        currNode = nextNode;\\n        currProp = currNode && currNode.property;\\n    }}\\n\\n    {{ /* assign value to the last property */ }}\\n    {{? currProp }}\\n        wasDef = {{# def.wasDefined}};\\n        {{# def.changeAccessPath }}\\n\\n        var old = m{{# def.currProp }};\\n\\n        {{ /* clone value to prevent same reference in linked models */ }}\\n        m{{# def.currProp }} = cloneTree(value);\\n    {{?}}\\n\\n    {{ /* add message related to the last property change */ }}\\n    if (this._options.reactive !== false) {\\n        if (! wasDef)\\n            {{# def.addMsg }} accessPath, type: 'added',\\n                newValue: value });\\n        else if (old != value)\\n            {{# def.addMsg }} accessPath, type: 'changed',\\n                oldValue: old, newValue: value });\\n\\n        {{ /* add message related to changes in (sub)properties inside removed and assigned value */ }}\\n        if (! wasDef || old != value)\\n            addTreeChangesMessages(messages, messagesHash,\\n                accessPath, old, value); /* defined in the function that synthesizes ModelPath setter */\\n\\n        {{ /* post all stored messages */ }}\\n        {{# def.postMessages }}\\n    }\\n};\\n\",\n    del: \"'use strict';\\n/* Only use this style of comments, not \\\"//\\\" */\\n\\n{{# def.include_defines }}\\n{{# def.include_traverse_tree }}\\n\\nmethod = function del() {\\n    {{# def.initVars:'del' }}\\n\\n    {{? it.parsedPath.length }}\\n        {{# def.traverseTree }}\\n\\n        {{\\n            var currNode = it.parsedPath[count];\\n            var currProp = currNode.property;       \\n        }}\\n\\n        if (! treeDoesNotExist && m && m.hasOwnProperty && {{# def.wasDefined}}) {\\n            var old = m{{# def.currProp }};\\n            delete m{{# def.currProp }};\\n            {{# def.changeAccessPath }}\\n            var didDelete = true;\\n        }\\n    {{??}}\\n        if (typeof m != 'undefined') {\\n            var old = m;\\n            {{# def.modelAccessPrefix }} = undefined;\\n            var didDelete = true;\\n        }\\n    {{?}}\\n\\n    if (didDelete && this._options.reactive !== false) {\\n        {{# def.addMsg }} accessPath, type: 'deleted', oldValue: old });\\n\\n        addTreeChangesMessages(messages, messagesHash,\\n            accessPath, old, undefined); /* defined in the function that synthesizes ModelPath setter */\\n\\n        {{ /* post all stored messages */ }}\\n        {{# def.postMessages }}\\n    }\\n};\\n\",\n    splice: \"'use strict';\\n/* Only use this style of comments, not \\\"//\\\" */\\n\\n{{# def.include_defines }}\\n{{# def.include_create_tree }}\\n{{# def.include_traverse_tree }}\\n\\nmethod = function splice(spliceIndex, spliceHowMany) { /* ,... - extra arguments to splice into array */\\n    {{# def.initVars:'splice' }}\\n\\n    var argsLen = arguments.length;\\n    var addItems = argsLen > 2;\\n\\n    if (addItems) {\\n        {{ /* only create model tree if items are inserted in array */ }}\\n\\n        {{ /* if model is undefined it will be set to an empty array */ }}  \\n        var value = [];\\n        {{# def.createTree:'splice' }}\\n\\n        {{? nextNode }}\\n            {{\\n                var currNode = nextNode;\\n                var currProp = currNode.property;\\n                var emptyProp = '[]';\\n            }}\\n\\n            {{# def.createTreeStep }}\\n        {{?}}\\n\\n    } else if (spliceHowMany > 0) {\\n        {{ /* if items are not inserted, only traverse model tree if items are deleted from array */ }}\\n        {{? it.parsedPath.length }}\\n            {{# def.traverseTree }}\\n\\n            {{\\n                var currNode = it.parsedPath[count];\\n                var currProp = currNode.property;       \\n            }}\\n\\n            {{ /* extra brace closes 'else' in def.traverseTreeStep */ }}\\n            {{# def.traverseTreeStep }} }\\n        {{?}}\\n    }\\n\\n    {{ /* splice items */ }}\\n    if (addItems || (! treeDoesNotExist && m\\n            && m.length > spliceIndex ) ) {\\n        var oldLength = m.length = m.length || 0;\\n\\n        arguments[0] = spliceIndex = normalizeSpliceIndex(spliceIndex, m.length);\\n\\n        {{ /* clone added arguments to prevent same references in linked models */ }}\\n        if (addItems)\\n            for (var i = 2; i < argsLen; i++)\\n                arguments[i] = cloneTree(arguments[i]);\\n\\n        {{ /* actual splice call */ }}\\n        var removed = Array.prototype.splice.apply(m, arguments);\\n\\n        if (this._options.reactive !== false) {\\n            {{# def.addMsg }} accessPath, type: 'splice',\\n                    index: spliceIndex, removed: removed, addedCount: addItems ? argsLen - 2 : 0,\\n                    newValue: m });\\n\\n            if (removed && removed.length)\\n                removed.forEach(function(item, index) {\\n                    var itemPath = accessPath + '[' + (spliceIndex + index) + ']';\\n                    {{# def.addMsg }} itemPath, type: 'removed', oldValue: item });\\n\\n                    if (valueIsTree(item))\\n                        addMessages(messages, messagesHash, itemPath, item, 'removed', 'oldValue');\\n                });\\n\\n            if (addItems)\\n                for (var i = 2; i < argsLen; i++) {\\n                    var item = arguments[i];\\n                    var itemPath = accessPath + '[' + (spliceIndex + i - 2) + ']';\\n                    {{# def.addMsg }} itemPath, type: 'added', newValue: item });\\n\\n                    if (valueIsTree(item))\\n                        addMessages(messages, messagesHash, itemPath, item, 'added', 'newValue');\\n                }\\n\\n            {{ /* post all stored messages */ }}\\n            {{# def.postMessages }}\\n        }\\n    }\\n\\n    return removed || [];\\n}\\n\"\n};\n\nvar include_defines = \"'use strict';\\n/* Only use this style of comments, not \\\"//\\\" */\\n\\n/**\\n * Inserts initialization code\\n */\\n {{## def.initVars:method:\\n    var m = {{# def.modelAccessPrefix }};\\n    var messages = [], messagesHash = {};\\n    var accessPath = '';\\n    var treeDoesNotExist;\\n    /* hack to prevent sending finished events to allow for propagation of batches without splitting them */\\n    var inChangeTransaction = getTransactionFlag( {{= method }} );\\n #}}\\n\\n/**\\n * Inserts the beginning of function call to add message to list\\n */\\n{{## def.addMsg: addChangeMessage(messages, messagesHash, { path: #}}\\n\\n/**\\n * Inserts current property/index for both normal and interpolated properties/indexes\\n */\\n{{## def.currProp:{{? currNode.interpolate }}[this._args[ {{= currNode.interpolate }} ]]{{??}}{{= currProp }}{{?}} #}}\\n\\n/**\\n * Inserts condition to test whether normal/interpolated property/index exists\\n */\\n{{## def.wasDefined: m.hasOwnProperty(\\n    {{? currNode.interpolate }}\\n        this._args[ {{= currNode.interpolate }} ]\\n    {{??}}\\n        '{{= it.getPathNodeKey(currNode) }}'\\n    {{?}}\\n) #}}\\n\\n\\n/**\\n * Inserts code to update access path for current property\\n * Because of the possibility of interpolated properties, it can't be calculated in template, it can only be calculated during accessor call.\\n */\\n{{## def.changeAccessPath:\\n    accessPath += {{? currNode.interpolate }}\\n        {{? currNode.syntax == 'array' }}\\n            '[' + this._args[ {{= currNode.interpolate }} ] + ']';\\n        {{??}}\\n            '.' + this._args[ {{= currNode.interpolate }} ];\\n        {{?}}\\n    {{??}}\\n        '{{= currProp }}';\\n    {{?}}\\n#}}\\n\\n\\n/**\\n * Inserts code to post stored messages\\n */\\n{{## def.postMessages:\\n    if (messages.length) {\\n        {{# def.modelPostBatchCode }}('datachanges', {\\n            changes: messages,\\n            transaction: inChangeTransaction\\n        });\\n\\n        messages.forEach(function(msg) {\\n            {{# def.modelPostMessageCode }}(msg.path, msg);\\n        }, this);\\n    }\\n#}}\\n\"\n    , include_create_tree = \"'use strict';\\n/* Only use this style of comments, not \\\"//\\\" */\\n\\n/**\\n * Inserts code to create model tree as neccessary for `set` and `splice` accessors and to add messages to send list if the tree changes.\\n */\\n{{## def.createTree:method:\\n    var wasDef = true;\\n    var old = m;\\n\\n    {{ var emptyProp = it.parsedPath[0] && it.parsedPath[0].empty; }}\\n    {{? emptyProp }}\\n        {{ /* create top level model if it was not previously defined */ }}\\n        if (! m) {\\n            m = {{# def.modelAccessPrefix }} = {{= emptyProp }};\\n            wasDef = false;\\n\\n            if (this._options.reactive !== false) {\\n                {{# def.addMsg }} '', type: 'added',\\n                      newValue: m });\\n            }\\n        }\\n    {{??}}\\n        {{? method == 'splice' }}\\n            if (! m) {\\n        {{?}}\\n                m = {{# def.modelAccessPrefix }} = cloneTree(value);\\n                wasDef = typeof old != 'undefined';\\n        {{? method == 'splice' }}\\n            }\\n        {{?}}       \\n    {{?}}\\n\\n\\n    {{ /* create model tree if it doesn't exist */ }}\\n    {{  var modelDataProperty = '';\\n        var nextNode = it.parsedPath[0];\\n        var count = it.parsedPath.length - 1;\\n\\n        for (var i = 0; i < count; i++) {\\n            var currNode = nextNode;\\n            var currProp = currNode.property;\\n            nextNode = it.parsedPath[i + 1];\\n            var emptyProp = nextNode && nextNode.empty;\\n    }}\\n\\n        {{# def.createTreeStep }}\\n\\n    {{  } /* for loop */ }}\\n#}}\\n\\n\\n/**\\n * Inserts code to create one step in the model tree\\n */\\n{{## def.createTreeStep:\\n    {{# def.changeAccessPath }}\\n\\n    if (! {{# def.wasDefined }}) { \\n        {{ /* property does not exist */ }}\\n        m = m{{# def.currProp }} = {{= emptyProp }};\\n\\n        if (this._options.reactive !== false) {\\n            {{# def.addMsg }} accessPath, type: 'added', \\n                  newValue: m });\\n        }\\n\\n    } else if (typeof m{{# def.currProp }} != 'object') {\\n        {{ /* property is not object */ }}\\n        var old = m{{# def.currProp }};\\n        m = m{{# def.currProp }} = {{= emptyProp }};\\n\\n        if (this._options.reactive !== false) {\\n            {{# def.addMsg }} accessPath, type: 'changed', \\n                  oldValue: old, newValue: m });\\n        }\\n\\n    } else {\\n        {{ /* property exists, just traverse down the model tree */ }}\\n        m = m{{# def.currProp }};\\n    }\\n#}}\\n\"\n    , include_traverse_tree = \"'use strict';\\n/* Only use this style of comments, not \\\"//\\\" */\\n\\n/**\\n * Inserts code to traverse model tree for `delete` and `splice` accessors.\\n */\\n{{## def.traverseTree:\\n    {{ \\n        var count = it.parsedPath.length-1;\\n\\n        for (var i = 0; i < count; i++) { \\n            var currNode = it.parsedPath[i];\\n            var currProp = currNode.property;\\n    }}\\n            {{# def.traverseTreeStep }}\\n\\n    {{ } /* for loop */\\n\\n        var i = count;\\n        while (i--) { /* closing braces for else's above */\\n    }}\\n            }\\n    {{ } /* while loop */ }}\\n#}}\\n\\n\\n/**\\n * Inserts code to traverse one step in the model tree\\n */\\n{{## def.traverseTreeStep:\\n    if (! (m && m.hasOwnProperty && {{# def.wasDefined}} ) )\\n        treeDoesNotExist = true;\\n    else {\\n        m = m{{# def.currProp }};\\n        {{# def.changeAccessPath }}\\n    {{ /* brace from else is not closed on purpose - all braces are closed in while loop */ }}\\n#}}\\n\";\n\nvar dotDef = {\n    include_defines: include_defines,\n    include_create_tree: include_create_tree,\n    include_traverse_tree: include_traverse_tree,\n    getPathNodeKey: pathUtils.getPathNodeKey,\n    modelAccessPrefix: 'this._model._data',\n    modelPostMessageCode: 'this._model._internalMessenger.postMessage',\n    modelPostBatchCode: 'this._model.postMessageSync',\n    internalMessenger: 'this._model._internalMessenger'\n};\n\nvar modelDotDef = _(dotDef).clone().extend({\n    modelAccessPrefix: 'this._data',\n    modelPostMessageCode: 'this._internalMessenger.postMessage',\n    modelPostBatchCode: 'this.postMessageSync',\n    internalMessenger: 'this._internalMessenger'\n})._();\n\n\nvar dotSettings = _.clone(doT.templateSettings);\ndotSettings.strip = false;\n\nvar synthesizers = _.mapKeys(templates, function(tmpl) {\n    return doT.template(tmpl, dotSettings, dotDef); \n});\n\n\nvar modelSynthesizers = _.mapToObject(['set', 'del', 'splice'], function(methodName) {\n    return doT.template(templates[methodName], dotSettings, modelDotDef);\n});\n\n\n/**\n * Function that synthesizes accessor methods.\n * Function is memoized so accessors are cached (up to 1000).\n *\n * @param {String} path Model/ModelPath access path\n * @param {Array} parsedPath array of path nodes\n * @return {Object[Function]}\n */\nvar synthesizePathMethods = _.memoize(_synthesizePathMethods, undefined, 1000);\n\nfunction _synthesizePathMethods(path, parsedPath) {\n    var methods = _.mapKeys(synthesizers, function(synthszr) {\n        return _synthesize(synthszr, path, parsedPath);\n    });\n    return methods;\n}\n\n\nvar normalizeSpliceIndex = modelUtils.normalizeSpliceIndex; // used in splice.dot.js\n\n\nfunction _synthesize(synthesizer, path, parsedPath) {\n    var method\n        , methodCode = synthesizer({\n            parsedPath: parsedPath,\n            getPathNodeKey: pathUtils.getPathNodeKey\n        });\n\n    try {\n        eval(methodCode);\n    } catch (e) {\n        throw ModelError('ModelPath method compilation error; path: ' + path + ', code: ' + methodCode);\n    }\n\n    return method;\n\n\n    // functions used by methods `set`, `delete` and `splice` (synthesized by template)\n    function addChangeMessage(messages, messagesHash, msg) {\n        messages.push(msg);\n        messagesHash[msg.path] = msg;\n    }\n\n    function addTreeChangesMessages(messages, messagesHash, rootPath, oldValue, newValue) {\n        var oldIsTree = valueIsTree(oldValue)\n            , newIsTree = valueIsTree(newValue);\n\n        if (newIsTree)\n            addMessages(messages, messagesHash, rootPath, newValue, 'added', 'newValue');\n        \n        if (oldIsTree)\n            addMessages(messages, messagesHash, rootPath, oldValue, 'removed', 'oldValue');\n    }\n\n    function addMessages(messages, messagesHash, rootPath, obj, msgType, valueProp) {\n        _addMessages(rootPath, obj);\n\n\n        function _addMessages(rootPath, obj) {\n            if (Array.isArray(obj)) {\n                var pathSyntax = rootPath + '[$$]';\n                obj.forEach(function(value, index) {\n                    addMessage(value, index, pathSyntax);\n                });\n            } else {\n                var pathSyntax = rootPath + '.$$';\n                _.eachKey(obj, function(value, key) {\n                    addMessage(value, key, pathSyntax);\n                });\n            }\n        }\n\n        function addMessage(value, key, pathSyntax) {\n            var path = pathSyntax.replace('$$', key)\n                , existingMsg = messagesHash[path];\n\n            if (existingMsg) {\n                if (existingMsg.type == msgType)\n                    logger.error('setter error: same message type posted on the same path');\n                else {\n                    existingMsg.type = 'changed';\n                    existingMsg[valueProp] = value;\n                }\n            } else {\n                var msg = { path: path, type: msgType };\n                msg[valueProp] = value;\n                addChangeMessage(messages, messagesHash, msg);\n            }\n\n            if (valueIsTree(value))\n                _addMessages(path, value);\n        }\n    }\n\n    function cloneTree(value) {\n        return valueIsNormalObject(value)\n                ? _.deepClone(value)\n                : value;\n    }\n\n    function protectValue(value) {\n        return ! valueIsNormalObject(value)\n                ? value\n                : Array.isArray(value)\n                    ? value.slice()\n                    : Object.create(value);\n    }\n\n    function valueIsTree(value) {\n        return valueIsNormalObject(value)\n                && Object.keys(value).length;\n    }\n\n    function valueIsNormalObject(value) {\n        return value != null\n                && typeof value == \"object\"\n                && ! (value instanceof Date)\n                && ! (value instanceof RegExp);\n    }\n\n    function addBatchIdsToMessage(msg, batchId, msgId) {\n        _.defineProperties(msg, {\n            __batch_id: batchId,\n            __msg_id: msgId\n        });\n    }\n}\n\n\n/**\n * Exports `synthesize` function with the following:\n *\n * - .modelMethods.set - `set` method for Model\n * - .modelMethods.del - `del` method for Model\n * - .modelMethods.splice - `splice` method for Model\n */\nmodule.exports = synthesizePathMethods;\n\nvar modelMethods = _.mapKeys(modelSynthesizers, function(synthesizer) {\n    return _synthesize(synthesizer, '', []);\n});\n\nsynthesizePathMethods.modelMethods = modelMethods;\n",
    "'use strict';\n\n/**\n * `milo.utils.check`\n *\n * Check is a module for parameters checking extracted from [Meteor](http://docs.meteor.com/) framework.\n *\n * It allows to both document and to check parameter types in your function\n * making code both readable and stable.\n *\n *\n * ### Usage\n *```\n * var check = milo.check\n *     , Match = check.Match;\n *\n * function My(name, obj, cb) {\n *     // if any of checks fail an error will be thrown\n *     check(name, String);\n *     check(obj, Match.ObjectIncluding({ options: Object }));\n *     check(cb, Function);\n *\n *     // ... your code\n * }\n *```\n * See [Meteor docs](http://docs.meteor.com/#match) to see how it works\n *\n *\n * ### Patterns\n *\n * All patterns and functions described in Meteor docs work.\n *\n * Unlike in Meteor, Object pattern matches instance of any class,\n * not only plain object.\n *\n * In addition to patterns described in Meteor docs the following patterns are implemented\n *\n * * Match.__ObjectHash__(_pattern_)\n *\n *   Matches an object where all properties match a given pattern\n *\n * * Match.__Subclass__(_constructor_ [, _matchThisClassToo_])\n *\n *   Matches a class that is a subclass of a given class. If the second parameter\n *   is true, it will also match the class itself.\n *\n *   Without this pattern to check if _MySubclass_ is a subclass of _MyClass_\n *   you would have to use\n *\n *       check(MySubclass, Match.Where(function() {\n *           return MySubclass.prototype instanceof MyClass;\n *       });\n *\n *\n * Things we explicitly do NOT support:\n *    - heterogenous arrays\n**/\n\nvar _ = require('mol-proto')\n    , config = require('../config');\n\nvar check = function (value, pattern) {\n    if (config.check === false)\n        return;\n\n    // Record that check got called, if somebody cared.\n    try {\n        checkSubtree(value, pattern);\n    } catch (err) {\n        if ((err instanceof Match.Error) && err.path)\n            err.message += \" in field \" + err.path;\n        throw err;\n    }\n};\n\nmodule.exports = check;\n\nvar Match = check.Match = {\n    Optional: function (pattern) {\n        return new Optional(pattern);\n    },\n    OneOf: function (/* arguments */) {\n        return new OneOf(arguments);\n    },\n    Any: ['__any__'],\n    Where: function (condition) {\n        return new Where(condition);\n    },\n    ObjectIncluding: function (pattern) {\n        return new ObjectIncluding(pattern);\n    },\n    // Matches only signed 32-bit integers\n    Integer: ['__integer__'],\n\n    // Matches string that is a valid identifier, will not allow javascript reserved words\n    IdentifierString: /^[a-z_$][0-9a-z_$]*$/i,\n\n    // Matches hash (object) with values matching pattern\n    ObjectHash: function(pattern) {\n        return new ObjectHash(pattern);\n    },\n\n    Subclass: function(Superclass, matchSuperclassToo) {\n        return new Subclass(Superclass, matchSuperclassToo);\n    },\n\n    // XXX matchers should know how to describe themselves for errors\n    Error: TypeError,\n\n    // Meteor.makeErrorType(\"Match.Error\", function (msg) {\n        // this.message = \"Match error: \" + msg;\n        // The path of the value that failed to match. Initially empty, this gets\n        // populated by catching and rethrowing the exception as it goes back up the\n        // stack.\n        // E.g.: \"vals[3].entity.created\"\n        // this.path = \"\";\n        // If this gets sent over DDP, don't give full internal details but at least\n        // provide something better than 500 Internal server error.\n    //     this.sanitizedError = new Meteor.Error(400, \"Match failed\");\n    // }),\n\n    // Tests to see if value matches pattern. Unlike check, it merely returns true\n    // or false (unless an error other than Match.Error was thrown).\n    test: function (value, pattern) {\n        try {\n            checkSubtree(value, pattern);\n            return true;\n        } catch (e) {\n            if (e instanceof Match.Error)\n                return false;\n            // Rethrow other errors.\n            throw e;\n        }\n    }\n};\n\nfunction Optional(pattern) {\n    this.pattern = pattern;\n};\n\nfunction OneOf(choices) {\n    if (choices.length == 0)\n        throw new Error(\"Must provide at least one choice to Match.OneOf\");\n    this.choices = choices;\n};\n\nfunction Where(condition) {\n    this.condition = condition;\n};\n\nfunction ObjectIncluding(pattern) {\n    this.pattern = pattern;\n};\n\nfunction ObjectHash(pattern) {\n    this.pattern = pattern;\n};\n\nfunction Subclass(Superclass, matchSuperclassToo) {\n    this.Superclass = Superclass;\n    this.matchSuperclass = matchSuperclassToo;\n};\n\nvar typeofChecks = [\n    [String, \"string\"],\n    [Number, \"number\"],\n    [Boolean, \"boolean\"],\n    [Function, \"function\"],\n    // While we don't allow undefined in JSON, this is good for optional\n    // arguments with OneOf.\n    [undefined, \"undefined\"]\n];\n\nfunction checkSubtree(value, pattern) {\n    // Match anything!\n    if (pattern === Match.Any)\n        return;\n\n    // Basic atomic types.\n    // Do not match boxed objects (e.g. String, Boolean)\n    for (var i = 0; i < typeofChecks.length; ++i) {\n        if (pattern === typeofChecks[i][0]) {\n            if (typeof value === typeofChecks[i][1])\n                return;\n            throw new Match.Error(\"Expected \" + typeofChecks[i][1] + \", got \" +\n                                                        typeof value);\n        }\n    }\n    if (pattern === null) {\n        if (value === null)\n            return;\n        throw new Match.Error(\"Expected null, got \" + JSON.stringify(value));\n    }\n\n    // Match.Integer is special type encoded with array\n    if (pattern === Match.Integer) {\n        // There is no consistent and reliable way to check if variable is a 64-bit\n        // integer. One of the popular solutions is to get reminder of division by 1\n        // but this method fails on really large floats with big precision.\n        // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n        // Bitwise operators work consistantly but always cast variable to 32-bit\n        // signed integer according to JavaScript specs.\n        if (typeof value === 'number' && (value | 0) === value)\n            return\n        throw new Match.Error('Expected Integer, got '\n                                + (value instanceof Object ? JSON.stringify(value) : value));\n    }\n\n    if (pattern === Match.IdentifierString) {\n        if (typeof value === 'string' && Match.IdentifierString.test(value)\n                && _jsKeywords.indexOf(key) == -1)\n            return;\n        throw new Match.Error('Expected identifier string, got '\n                                + (value instanceof Object ? JSON.stringify(value) : value));\n    }\n\n    // \"Object\" is shorthand for Match.ObjectIncluding({});\n    if (pattern === Object)\n        pattern = Match.ObjectIncluding({});\n\n    // Array (checked AFTER Any, which is implemented as an Array).\n    if (pattern instanceof Array) {\n        if (pattern.length !== 1)\n            throw Error(\"Bad pattern: arrays must have one type element\" +\n                                    JSON.stringify(pattern));\n        if (!Array.isArray(value)) {\n            throw new Match.Error(\"Expected array, got \" + JSON.stringify(value));\n        }\n\n        value.forEach(function (valueElement, index) {\n            try {\n                checkSubtree(valueElement, pattern[0]);\n            } catch (err) {\n                if (err instanceof Match.Error) {\n                    err.path = _prependPath(index, err.path);\n                }\n                throw err;\n            }\n        });\n        return;\n    }\n\n    // Arbitrary validation checks. The condition can return false or throw a\n    // Match.Error (ie, it can internally use check()) to fail.\n    if (pattern instanceof Where) {\n        if (pattern.condition(value))\n            return;\n        // XXX this error is terrible\n        throw new Match.Error(\"Failed Match.Where validation\");\n    }\n\n\n    if (pattern instanceof Optional)\n        pattern = Match.OneOf(undefined, pattern.pattern);\n\n    if (pattern instanceof OneOf) {\n        for (var i = 0; i < pattern.choices.length; ++i) {\n            try {\n                checkSubtree(value, pattern.choices[i]);\n                // No error? Yay, return.\n                return;\n            } catch (err) {\n                // Other errors should be thrown. Match errors just mean try another\n                // choice.\n                if (!(err instanceof Match.Error))\n                    throw err;\n            }\n        }\n        // XXX this error is terrible\n        throw new Match.Error(\"Failed Match.OneOf or Match.Optional validation\");\n    }\n\n    // A function that isn't something we special-case is assumed to be a\n    // constructor.\n    if (pattern instanceof Function) {\n        if (value instanceof pattern)\n            return;\n        // XXX what if .name isn't defined\n        throw new Match.Error(\"Expected \" + pattern.constructor.name);\n    }\n\n    var unknownKeysAllowed = false;\n    if (pattern instanceof ObjectIncluding) {\n        unknownKeysAllowed = true;\n        pattern = pattern.pattern;\n    }\n\n    if (pattern instanceof ObjectHash) {\n        var keyPattern = pattern.pattern;\n        var emptyHash = true;\n        for (var key in value) {\n            emptyHash = false;\n            check(value[key], keyPattern);\n        }\n        if (emptyHash)\n            throw new Match.Error(\"Expected \" + pattern.constructor.name);\n        return;\n    }\n\n    if (pattern instanceof Subclass) {\n        var Superclass = pattern.Superclass;\n        if (pattern.matchSuperclass && value == Superclass)\n            return;\n        if (! (value.prototype instanceof Superclass))\n            throw new Match.Error(\"Expected \" + pattern.constructor.name + \" of \" + Superclass.name);\n        return;\n    }\n\n    if (typeof pattern !== \"object\")\n        throw Error(\"Bad pattern: unknown pattern type\");\n\n    // An object, with required and optional keys. Note that this does NOT do\n    // structural matches against objects of special types that happen to match\n    // the pattern: this really needs to be a plain old {Object}!\n    if (typeof value !== 'object')\n        throw new Match.Error(\"Expected object, got \" + typeof value);\n    if (value === null)\n        throw new Match.Error(\"Expected object, got null\");\n\n    var requiredPatterns = {};\n    var optionalPatterns = {};\n\n    _.eachKey(pattern, function(subPattern, key) {\n        if (pattern[key] instanceof Optional)\n            optionalPatterns[key] = pattern[key].pattern;\n        else\n            requiredPatterns[key] = pattern[key];\n    }, this, true);\n\n    _.eachKey(value, function(subValue, key) {\n        var subValue = value[key];\n        try {\n            if (requiredPatterns.hasOwnProperty(key)) {\n                checkSubtree(subValue, requiredPatterns[key]);\n                delete requiredPatterns[key];\n            } else if (optionalPatterns.hasOwnProperty(key)) {\n                checkSubtree(subValue, optionalPatterns[key]);\n            } else {\n                if (!unknownKeysAllowed)\n                    throw new Match.Error(\"Unknown key\");\n            }\n        } catch (err) {\n            if (err instanceof Match.Error)\n                err.path = _prependPath(key, err.path);\n            throw err;\n        }\n    }, this, true);\n\n    _.eachKey(requiredPatterns, function(value, key) {\n        throw new Match.Error(\"Missing key '\" + key + \"'\");\n    }, this, true);\n};\n\n\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",\n    \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",\n    \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",\n    \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",\n    \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",\n    \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",\n    \"instanceof\"];\n\n// Assumes the base of path is already escaped properly\n// returns key + base\nfunction _prependPath(key, base) {\n    if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))\n        key = \"[\" + key + \"]\";\n    else if (!key.match(Match.IdentifierString) || _jsKeywords.indexOf(key) != -1)\n        key = JSON.stringify([key]);\n\n    if (base && base[0] !== \"[\")\n        return key + '.' + base;\n    return key + base;\n};\n",
    "'use strict';\n\n/**\n * `milo.util`\n */\nvar util = {\n    logger: require('./logger'),\n    check: require('./check'),\n    doT: require('dot')\n};\n\nmodule.exports = util;\n",
    "'use strict';\n\n// <a name=\"utils-logger\"></a>\n// milo.utils.logger\n// -----------\n\n// Application logger that has error, warn, info and debug\n// methods, that can be suppressed by setting log level.\n\n// Properties:\n\n// - level\n\n//   - 0 - error\n//   - 1 - warn\n//   - 2 - info\n//   - 3 - debug (default)\n\n// - enabled\n\n//   true by default. Set to false to disable all logging in browser console.\n\n\nvar Logger = require('./logger_class');\n\nvar logger = new Logger({ level: 3 });\n\nmodule.exports = logger;\n",
    "'use strict';\n\n// ### Logger Class\n\n// Properties:\n\n// - level\n\n//   - 0 - error\n//   - 1 - warn\n//   - 2 - info\n//   - 3 - debug (default)\n\n// - enabled\n\n//   true by default. Set to false to disable all logging in browser console.\n\n\nvar _ = require('mol-proto')\n    , Messenger = require('../messenger');\n\n\n/**\n * Log levels.\n */\n\nvar levels = [\n    'error',\n    'warn',\n    'info',\n    'debug'\n];\n\nvar maxLevelLength = Math.max.apply(Math, levels.map(function(level) { return level.length; }));\n\n/**\n * Colors for log levels.\n */\n\nvar colors = [\n    31,\n    33,\n    36,\n    90\n];\n\n/**\n * Pads the nice output to the longest log level.\n */\nfunction pad(str) {\n    if (str.length < maxLevelLength)\n        return str + new Array(maxLevelLength - str.length + 1).join(' ');\n\n    return str;\n};\n\n\nfunction colored(str, color) {\n    return '\\x1B[' + color + 'm' + str + ' -\\x1B[39m';\n}\n\n\nvar DEFAULT_OPTIONS = {\n    level: 3,\n    throwLevel: -1, // never throw\n    enabled: true,\n    logPrefix: ''\n}\n\n\n/**\n * Expose Messenger methods on Logger prototype\n */\nvar MESSENGER_PROPERTY = '_messenger';\nMessenger.useWith(Logger, MESSENGER_PROPERTY, Messenger.defaultMethods);\n\n\n/**\n * Logger (console).\n *\n * @api public\n */\nfunction Logger(opts) {\n    _.extend(this, DEFAULT_OPTIONS);\n    _.extend(this, opts || {});\n    var messenger = new Messenger(this);\n    _.defineProperty(this, MESSENGER_PROPERTY, messenger);\n};\n\n\n/**\n * Log method.\n *\n * @api public\n */\n\nLogger.prototype.log = function (type) {\n    var index = levels.indexOf(type);\n\n    if (! this.enabled || index > this.level)\n        return this;\n\n    var args = _.slice(arguments, 1)\n        , self = this;\n\n    if (index <= this.throwLevel)\n        throw new Error(logString());\n\n    if (index <= this.messageLevel)\n        this.postMessage('log', { level: index, type: type, str: logString() });\n\n    console.log.apply(\n          console\n        , [ this.logPrefixColor\n              ? '   ' + colored(this.logPrefix, this.logPrefixColor)\n              : this.logPrefix,\n            (this.colors\n              ? ' ' + colored(pad(type), colors[index])\n              : type) + ':'\n          ].concat(args)\n    );\n\n    return this;\n\n\n    function logString() {\n        return [self.logPrefix, type + ':'].concat(args).join(' ');\n    }\n};\n\n/**\n * Generate methods.\n */\n\nlevels.forEach(function (name) {\n    Logger.prototype[name] = function () {\n        this.log.apply(this, [name].concat(_.toArray(arguments)));\n    };\n});\n\n\nmodule.exports = Logger;\n",
    "// doT.js\n// 2011-2014, Laura Doktorova, https://github.com/olado/doT\n// Licensed under the MIT license.\n\n(function() {\n\t\"use strict\";\n\n\tvar doT = {\n\t\tversion: \"1.0.3\",\n\t\ttemplateSettings: {\n\t\t\tevaluate:    /\\{\\{([\\s\\S]+?(\\}?)+)\\}\\}/g,\n\t\t\tinterpolate: /\\{\\{=([\\s\\S]+?)\\}\\}/g,\n\t\t\tencode:      /\\{\\{!([\\s\\S]+?)\\}\\}/g,\n\t\t\tuse:         /\\{\\{#([\\s\\S]+?)\\}\\}/g,\n\t\t\tuseParams:   /(^|[^\\w$])def(?:\\.|\\[[\\'\\\"])([\\w$\\.]+)(?:[\\'\\\"]\\])?\\s*\\:\\s*([\\w$\\.]+|\\\"[^\\\"]+\\\"|\\'[^\\']+\\'|\\{[^\\}]+\\})/g,\n\t\t\tdefine:      /\\{\\{##\\s*([\\w\\.$]+)\\s*(\\:|=)([\\s\\S]+?)#\\}\\}/g,\n\t\t\tdefineParams:/^\\s*([\\w$]+):([\\s\\S]+)/,\n\t\t\tconditional: /\\{\\{\\?(\\?)?\\s*([\\s\\S]*?)\\s*\\}\\}/g,\n\t\t\titerate:     /\\{\\{~\\s*(?:\\}\\}|([\\s\\S]+?)\\s*\\:\\s*([\\w$]+)\\s*(?:\\:\\s*([\\w$]+))?\\s*\\}\\})/g,\n\t\t\tvarname:\t\"it\",\n\t\t\tstrip:\t\ttrue,\n\t\t\tappend:\t\ttrue,\n\t\t\tselfcontained: false,\n\t\t\tdoNotSkipEncoded: false\n\t\t},\n\t\ttemplate: undefined, //fn, compile template\n\t\tcompile:  undefined  //fn, for express\n\t}, _globals;\n\n\tdoT.encodeHTMLSource = function(doNotSkipEncoded) {\n\t\tvar encodeHTMLRules = { \"&\": \"&#38;\", \"<\": \"&#60;\", \">\": \"&#62;\", '\"': \"&#34;\", \"'\": \"&#39;\", \"/\": \"&#47;\" },\n\t\t\tmatchHTML = doNotSkipEncoded ? /[&<>\"'\\/]/g : /&(?!#?\\w+;)|<|>|\"|'|\\//g;\n\t\treturn function(code) {\n\t\t\treturn code ? code.toString().replace(matchHTML, function(m) {return encodeHTMLRules[m] || m;}) : \"\";\n\t\t};\n\t};\n\n\t_globals = (function(){ return this || (0,eval)(\"this\"); }());\n\n\tif (typeof module !== \"undefined\" && module.exports) {\n\t\tmodule.exports = doT;\n\t} else if (typeof define === \"function\" && define.amd) {\n\t\tdefine(function(){return doT;});\n\t} else {\n\t\t_globals.doT = doT;\n\t}\n\n\tvar startend = {\n\t\tappend: { start: \"'+(\",      end: \")+'\",      startencode: \"'+encodeHTML(\" },\n\t\tsplit:  { start: \"';out+=(\", end: \");out+='\", startencode: \"';out+=encodeHTML(\" }\n\t}, skip = /$^/;\n\n\tfunction resolveDefs(c, block, def) {\n\t\treturn ((typeof block === \"string\") ? block : block.toString())\n\t\t.replace(c.define || skip, function(m, code, assign, value) {\n\t\t\tif (code.indexOf(\"def.\") === 0) {\n\t\t\t\tcode = code.substring(4);\n\t\t\t}\n\t\t\tif (!(code in def)) {\n\t\t\t\tif (assign === \":\") {\n\t\t\t\t\tif (c.defineParams) value.replace(c.defineParams, function(m, param, v) {\n\t\t\t\t\t\tdef[code] = {arg: param, text: v};\n\t\t\t\t\t});\n\t\t\t\t\tif (!(code in def)) def[code]= value;\n\t\t\t\t} else {\n\t\t\t\t\tnew Function(\"def\", \"def['\"+code+\"']=\" + value)(def);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"\";\n\t\t})\n\t\t.replace(c.use || skip, function(m, code) {\n\t\t\tif (c.useParams) code = code.replace(c.useParams, function(m, s, d, param) {\n\t\t\t\tif (def[d] && def[d].arg && param) {\n\t\t\t\t\tvar rw = (d+\":\"+param).replace(/'|\\\\/g, \"_\");\n\t\t\t\t\tdef.__exp = def.__exp || {};\n\t\t\t\t\tdef.__exp[rw] = def[d].text.replace(new RegExp(\"(^|[^\\\\w$])\" + def[d].arg + \"([^\\\\w$])\", \"g\"), \"$1\" + param + \"$2\");\n\t\t\t\t\treturn s + \"def.__exp['\"+rw+\"']\";\n\t\t\t\t}\n\t\t\t});\n\t\t\tvar v = new Function(\"def\", \"return \" + code)(def);\n\t\t\treturn v ? resolveDefs(c, v, def) : v;\n\t\t});\n\t}\n\n\tfunction unescape(code) {\n\t\treturn code.replace(/\\\\('|\\\\)/g, \"$1\").replace(/[\\r\\t\\n]/g, \" \");\n\t}\n\n\tdoT.template = function(tmpl, c, def) {\n\t\tc = c || doT.templateSettings;\n\t\tvar cse = c.append ? startend.append : startend.split, needhtmlencode, sid = 0, indv,\n\t\t\tstr  = (c.use || c.define) ? resolveDefs(c, tmpl, def || {}) : tmpl;\n\n\t\tstr = (\"var out='\" + (c.strip ? str.replace(/(^|\\r|\\n)\\t* +| +\\t*(\\r|\\n|$)/g,\" \")\n\t\t\t\t\t.replace(/\\r|\\n|\\t|\\/\\*[\\s\\S]*?\\*\\//g,\"\"): str)\n\t\t\t.replace(/'|\\\\/g, \"\\\\$&\")\n\t\t\t.replace(c.interpolate || skip, function(m, code) {\n\t\t\t\treturn cse.start + unescape(code) + cse.end;\n\t\t\t})\n\t\t\t.replace(c.encode || skip, function(m, code) {\n\t\t\t\tneedhtmlencode = true;\n\t\t\t\treturn cse.startencode + unescape(code) + cse.end;\n\t\t\t})\n\t\t\t.replace(c.conditional || skip, function(m, elsecase, code) {\n\t\t\t\treturn elsecase ?\n\t\t\t\t\t(code ? \"';}else if(\" + unescape(code) + \"){out+='\" : \"';}else{out+='\") :\n\t\t\t\t\t(code ? \"';if(\" + unescape(code) + \"){out+='\" : \"';}out+='\");\n\t\t\t})\n\t\t\t.replace(c.iterate || skip, function(m, iterate, vname, iname) {\n\t\t\t\tif (!iterate) return \"';} } out+='\";\n\t\t\t\tsid+=1; indv=iname || \"i\"+sid; iterate=unescape(iterate);\n\t\t\t\treturn \"';var arr\"+sid+\"=\"+iterate+\";if(arr\"+sid+\"){var \"+vname+\",\"+indv+\"=-1,l\"+sid+\"=arr\"+sid+\".length-1;while(\"+indv+\"<l\"+sid+\"){\"\n\t\t\t\t\t+vname+\"=arr\"+sid+\"[\"+indv+\"+=1];out+='\";\n\t\t\t})\n\t\t\t.replace(c.evaluate || skip, function(m, code) {\n\t\t\t\treturn \"';\" + unescape(code) + \"out+='\";\n\t\t\t})\n\t\t\t+ \"';return out;\")\n\t\t\t.replace(/\\n/g, \"\\\\n\").replace(/\\t/g, '\\\\t').replace(/\\r/g, \"\\\\r\")\n\t\t\t.replace(/(\\s|;|\\}|^|\\{)out\\+='';/g, '$1').replace(/\\+''/g, \"\");\n\t\t\t//.replace(/(\\s|;|\\}|^|\\{)out\\+=''\\+/g,'$1out+=');\n\n\t\tif (needhtmlencode) {\n\t\t\tif (!c.selfcontained && _globals && !_globals._encodeHTML) _globals._encodeHTML = doT.encodeHTMLSource(c.doNotSkipEncoded);\n\t\t\tstr = \"var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : (\"\n\t\t\t\t+ doT.encodeHTMLSource.toString() + \"(\" + (c.doNotSkipEncoded || '') + \"));\"\n\t\t\t\t+ str;\n\t\t}\n\t\ttry {\n\t\t\treturn new Function(c.varname, str);\n\t\t} catch (e) {\n\t\t\tif (typeof console !== \"undefined\") console.log(\"Could not create a template function: \" + str);\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\tdoT.compile = function(tmpl, def) {\n\t\treturn doT.template(tmpl, null, def);\n\t};\n}());\n",
    "/* doT + auto-compilation of doT templates\n *\n * 2012, Laura Doktorova, https://github.com/olado/doT\n * Licensed under the MIT license\n *\n * Compiles .def, .dot, .jst files found under the specified path.\n * It ignores sub-directories.\n * Template files can have multiple extensions at the same time.\n * Files with .def extension can be included in other files via {{#def.name}}\n * Files with .dot extension are compiled into functions with the same name and\n * can be accessed as renderer.filename\n * Files with .jst extension are compiled into .js files. Produced .js file can be\n * loaded as a commonJS, AMD module, or just installed into a global variable\n * (default is set to window.render).\n * All inline defines defined in the .jst file are\n * compiled into separate functions and are available via _render.filename.definename\n *\n * Basic usage:\n * var dots = require(\"dot\").process({path: \"./views\"});\n * dots.mytemplate({foo:\"hello world\"});\n *\n * The above snippet will:\n * 1. Compile all templates in views folder (.dot, .def, .jst)\n * 2. Place .js files compiled from .jst templates into the same folder.\n *    These files can be used with require, i.e. require(\"./views/mytemplate\").\n * 3. Return an object with functions compiled from .dot templates as its properties.\n * 4. Render mytemplate template.\n */\n\nvar fs = require(\"fs\"),\n\tdoT = module.exports = require(\"./doT\");\n\ndoT.process = function(options) {\n\t//path, destination, global, rendermodule, templateSettings\n\treturn new InstallDots(options).compileAll();\n};\n\nfunction InstallDots(o) {\n\tthis.__path \t\t= o.path || \"./\";\n\tif (this.__path[this.__path.length-1] !== '/') this.__path += '/';\n\tthis.__destination\t= o.destination || this.__path;\n\tif (this.__destination[this.__destination.length-1] !== '/') this.__destination += '/';\n\tthis.__global\t\t= o.global || \"window.render\";\n\tthis.__rendermodule\t= o.rendermodule || {};\n\tthis.__settings \t= o.templateSettings ? copy(o.templateSettings, copy(doT.templateSettings)) : undefined;\n\tthis.__includes\t\t= {};\n}\n\nInstallDots.prototype.compileToFile = function(path, template, def) {\n\tdef = def || {};\n\tvar modulename = path.substring(path.lastIndexOf(\"/\")+1, path.lastIndexOf(\".\"))\n\t\t, defs = copy(this.__includes, copy(def))\n\t\t, settings = this.__settings || doT.templateSettings\n\t\t, compileoptions = copy(settings)\n\t\t, defaultcompiled = doT.template(template, settings, defs)\n\t\t, exports = []\n\t\t, compiled = \"\"\n\t\t, fn;\n\n\tfor (var property in defs) {\n\t\tif (defs[property] !== def[property] && defs[property] !== this.__includes[property]) {\n\t\t\tfn = undefined;\n\t\t\tif (typeof defs[property] === 'string') {\n\t\t\t\tfn = doT.template(defs[property], settings, defs);\n\t\t\t} else if (typeof defs[property] === 'function') {\n\t\t\t\tfn = defs[property];\n\t\t\t} else if (defs[property].arg) {\n\t\t\t\tcompileoptions.varname = defs[property].arg;\n\t\t\t\tfn = doT.template(defs[property].text, compileoptions, defs);\n\t\t\t}\n\t\t\tif (fn) {\n\t\t\t\tcompiled += fn.toString().replace('anonymous', property);\n\t\t\t\texports.push(property);\n\t\t\t}\n\t\t}\n\t}\n\tcompiled += defaultcompiled.toString().replace('anonymous', modulename);\n\tfs.writeFileSync(path, \"(function(){\" + compiled\n\t\t+ \"var itself=\" + modulename + \", _encodeHTML=(\" + doT.encodeHTMLSource.toString() + \"(\" + (settings.doNotSkipEncoded || '') + \"));\"\n\t\t+ addexports(exports)\n\t\t+ \"if(typeof module!=='undefined' && module.exports) module.exports=itself;else if(typeof define==='function')define(function(){return itself;});else {\"\n\t\t+ this.__global + \"=\" + this.__global + \"||{};\" + this.__global + \"['\" + modulename + \"']=itself;}}());\");\n};\n\nfunction addexports(exports) {\n\tfor (var ret ='', i=0; i< exports.length; i++) {\n\t\tret += \"itself.\" + exports[i]+ \"=\" + exports[i]+\";\";\n\t}\n\treturn ret;\n}\n\nfunction copy(o, to) {\n\tto = to || {};\n\tfor (var property in o) {\n\t\tto[property] = o[property];\n\t}\n\treturn to;\n}\n\nfunction readdata(path) {\n\tvar data = fs.readFileSync(path);\n\tif (data) return data.toString();\n\tconsole.log(\"problems with \" + path);\n}\n\nInstallDots.prototype.compilePath = function(path) {\n\tvar data = readdata(path);\n\tif (data) {\n\t\treturn doT.template(data,\n\t\t\t\t\tthis.__settings || doT.templateSettings,\n\t\t\t\t\tcopy(this.__includes));\n\t}\n};\n\nInstallDots.prototype.compileAll = function() {\n\tconsole.log(\"Compiling all doT templates...\");\n\n\tvar defFolder = this.__path,\n\t\tsources = fs.readdirSync(defFolder),\n\t\tk, l, name;\n\n\tfor( k = 0, l = sources.length; k < l; k++) {\n\t\tname = sources[k];\n\t\tif (/\\.def(\\.dot|\\.jst)?$/.test(name)) {\n\t\t\tconsole.log(\"Loaded def \" + name);\n\t\t\tthis.__includes[name.substring(0, name.indexOf('.'))] = readdata(defFolder + name);\n\t\t}\n\t}\n\n\tfor( k = 0, l = sources.length; k < l; k++) {\n\t\tname = sources[k];\n\t\tif (/\\.dot(\\.def|\\.jst)?$/.test(name)) {\n\t\t\tconsole.log(\"Compiling \" + name + \" to function\");\n\t\t\tthis.__rendermodule[name.substring(0, name.indexOf('.'))] = this.compilePath(defFolder + name);\n\t\t}\n\t\tif (/\\.jst(\\.dot|\\.def)?$/.test(name)) {\n\t\t\tconsole.log(\"Compiling \" + name + \" to file\");\n\t\t\tthis.compileToFile(this.__destination + name.substring(0, name.indexOf('.')) + '.js',\n\t\t\t\t\treaddata(defFolder + name));\n\t\t}\n\t}\n\treturn this.__rendermodule;\n};\n",
    "'use strict';\n\nvar utils = require('./utils');\n\n\n/**\n * [__Prototype functions__](proto_prototype.js.html)\n *\n * - [extendProto](proto_prototype.js.html#extendProto)\n * - [createSubclass](proto_prototype.js.html#createSubclass)\n * - [makeSubclass](proto_prototype.js.html#makeSubclass)\n * - [newApply](proto_prototype.js.html#newApply)\n */\nvar prototypeMethods = require('./proto_prototype');\n\n\n/**\n * [__Object functions__](proto_object.js.html)\n *\n * - [extend](proto_object.js.html#extend)\n * - [clone](proto_object.js.html#clone)\n * - [defineProperty](proto_object.js.html#defineProperty)\n * - [defineProperties](proto_object.js.html#defineProperties)\n * - [deepExtend](proto_object.js.html#deepExtend)\n * - [deepClone](proto_object.js.html#deepClone)\n * - [keys](proto_object.js.html#keys)\n * - [allKeys](proto_object.js.html#allKeys)\n * - [values](proto_object.js.html#values)\n * - [keyOf](proto_object.js.html#keyOf)\n * - [allKeysOf](proto_object.js.html#allKeysOf)\n * - [eachKey](proto_object.js.html#eachKey)\n * - [mapKeys](proto_object.js.html#mapKeys)\n * - [reduceKeys](proto_object.js.html#reduceKeys)\n * - [filterKeys](proto_object.js.html#filterKeys)\n * - [someKey](proto_object.js.html#someKey)\n * - [everyKey](proto_object.js.html#everyKey)\n * - [findValue](proto_object.js.html#findValue)\n * - [findKey](proto_object.js.html#findKey)\n * - [pickKeys](proto_object.js.html#pickKeys)\n * - [omitKeys](proto_object.js.html#omitKeys)\n * - [isEqual](proto_object.js.html#isEqual)\n * - [isNot](proto_object.js.html#isNot)\n */\nvar objectMethods = require('./proto_object');\n\n\n/**\n * [__Array functions__](proto_array.js.html)\n *\n * - [find](proto_array.js.html#find)\n * - [findIndex](proto_array.js.html#findIndex)\n * - [appendArray](proto_array.js.html#appendArray)\n * - [prependArray](proto_array.js.html#prependArray)\n * - [spliceItem](proto_array.js.html#spliceItem)\n * - [toArray](proto_array.js.html#toArray)\n * - [object](proto_array.js.html#object)\n * - [mapToObject](proto_array.js.html#mapToObject)\n * - [unique](proto_array.js.html#unique)\n * - [deepForEach](proto_array.js.html#deepForEach)\n *\n * Functions that Array [implements natively](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods) are also added - they can be used with array-like objects and for chaining (native functions are always called).\n */\nvar arrayMethods = require('./proto_array');\n\n\n/**\n * [__Function functions__](proto_function.js.html)\n *\n * - [makeFunction](proto_function.js.html#makeFunction)\n * - [partial](proto_function.js.html#partial)\n * - [partialRight](proto_function.js.html#partialRight)\n * - [memoize](proto_function.js.html#memoize)\n * - [delay](proto_function.js.html#delay)\n * - [defer](proto_function.js.html#defer)\n * - [delayed](proto_function.js.html#delayed)\n * - [deferred](proto_function.js.html#deferred)\n * - [deferTicks](proto_function.js.html#deferTicks)\n * - [delayMethod](proto_function.js.html#delayMethod)\n * - [deferMethod](proto_function.js.html#deferMethod)\n * - [debounce](proto_function.js.html#debounce)\n * - [throttle](proto_function.js.html#throttle)\n * - [once](proto_function.js.html#once)\n * - [waitFor](proto_function.js.html#waitFor)\n*/\nvar functionMethods = require('./proto_function');\n\n\n/**\n * [__String functions__](proto_string.js.html)\n *\n * - [firstUpperCase](proto_string.js.html#firstUpperCase)\n * - [firstLowerCase](proto_string.js.html#firstLowerCase)\n * - [toRegExp](proto_string.js.html#toRegExp)\n * - [toFunction](proto_string.js.html#toFunction)\n * - [toDate](proto_string.js.html#toDate)\n * - [toQueryString](proto_string.js.html#toQueryString)\n * - [fromQueryString](proto_string.js.html#fromQueryString)\n * - [jsonParse](proto_string.js.html#jsonParse)\n * - [hashCode](proto_string.js.html#hashCode)\n * - [unPrefix](proto_string.js.html#unPrefix)\n * - [format](proto_string.js.html#format)\n */\nvar stringMethods = require('./proto_string');\n\n\n/**\n * [__Number functions__](proto_number.js.html)\n *\n * - [isNumeric](proto_number.js.html#isNumeric)\n */\nvar numberMethods = require('./proto_number');\n\n\n/**\n * [__Utility functions__](proto_util.js.html)\n *\n * - [times](proto_util.js.html#times)\n * - [repeat](proto_util.js.html#repeat)\n * - [tap](proto_util.js.html#tap)\n * - [result](proto_util.js.html#result)\n * - [identity](proto_util.js.html#identity)\n * - [property](proto_util.js.html#property)\n * - [compareProperty](proto_util.js.html#compareProperty)\n * - [noop](proto_util.js.html#noop)\n */\nvar utilMethods = require('./proto_util');\n\n\n/**\n * Chaining\n * ========\n *\n * `_` can be used to create a wrapped value (object, function, array, etc.) to allow chaining of Proto functions.\n * To unwrap, `_` method of a wrapped value should be used.\n * Usage:\n * ```\n * var arr = _({ 0: 3, 1: 4, 2: 5, length: 3})\n *              .toArray()\n *              .prependArray([1, 2])\n *              .appendArray([6, 7, 8])\n *              ._();\n * ```\n * A wrapped object is an instance of `_` (`Proto` class).\n *\n * Chaining is implemented for development convenience, but it has performance overhead, not only to wrap and unwrap values but in each function call.\n * Although all Proto functions are implemented as methods operating on this and the overhead to redefine them as functions is very small, the overhead to redefine them as methods of wrapped value is slightly higher - chaining is 15-25% slower than using functions (properties of _ that take the first parameter).\n * In cases when performance is critical, you may want to avoid using chaining.\n *\n * @param {Any} self A value to be wrapped\n * @return {Proto}\n */\nfunction Proto(self) {\n    // wrap passed parameter in _ object\n    var wrapped = Object.create(Proto.prototype);\n    wrapped.self = self;\n    return wrapped;\n};\n\nvar _ = Proto;\n\n\n// store raw methods from different modules in __ object (double \"_\")\nvar __ = {};\n\nobjectMethods.extend.call(__, objectMethods);\n__.extend.call(__, prototypeMethods);\n__.extend.call(__, arrayMethods);\n__.extend.call(__, stringMethods);\n__.extend.call(__, numberMethods);\n__.extend.call(__, functionMethods);\n__.extend.call(__, utilMethods);\n\n\n// add __ as property of Proto, so they can be used as mixins in other classes\n__.defineProperty(Proto, '__', __);\n\n\n// add _ method to unwrap wrapped value (Proto instance)\nfunction unwrapProto() { return this.self; }\n__.extendProto.call(Proto, { _: unwrapProto });\n\n// add constants (functions will be overwritten)\n__.extend.call(Proto, objectMethods._constants);\n\n// add functions that take first parameter instead of \"this\" to Proto\nvar protoFuncs = __.mapKeys.call(__, utils.makeProtoFunction, true);\n__.extend.call(Proto, protoFuncs);\n\n// add Proto wrapped value instance methods to Proto prototype\nvar protoInstanceMethods = __.mapKeys.call(__, utils.makeProtoInstanceMethod, true);\n__.extendProto.call(Proto, protoInstanceMethods);\n\n\n/**\n * In windows environment, a global `_` value is preserved in `_.underscore`\n */\nif (typeof window == 'object') {\n    // preserve existing _ object\n    if (window._)\n        Proto.underscore = window._\n\n    // expose global _ and Proto\n    window._ = Proto;\n}\n\nif (typeof module == 'object' && module.exports)\n    // export for node/browserify\n    module.exports = Proto;\n",
    "'use strict';\n\nvar __ = require('./proto_object')\n    , utils = require('./utils');\n\n\n/**\n * - [find](#find)\n * - [findIndex](#findIndex)\n * - [appendArray](#appendArray)\n * - [prependArray](#prependArray)\n * - [spliceItem](#spliceItem)\n * - [toArray](#toArray)\n * - [object](#object)\n * - [mapToObject](#mapToObject)\n * - [unique](#unique)\n * - [deepForEach](#deepForEach)\n *\n * These methods can be [chained](proto.js.html#Proto).\n */\nvar arrayMethods = module.exports = {\n    // find: see below\n    // findIndex: see below\n    appendArray: appendArray,\n    prependArray: prependArray,\n    toArray: toArray,\n    object: object,\n    mapToObject: mapToObject,\n    unique: unique,\n    deepForEach: deepForEach,\n    spliceItem: spliceItem\n};\n\n\n/**\n * Functions that Array [implements natively](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods) are also included for convenience - they can be used with array-like objects and for chaining (native functions are always called).\n * These methods can be [chained](proto.js.html#Proto) too.\n */\nvar nativeArrayMethodsNames = [ 'join', 'pop', 'push', 'concat',\n    'reverse', 'shift', 'unshift', 'slice', 'splice',\n    'sort', 'filter', 'forEach', 'some', 'every',\n    'map', 'indexOf', 'lastIndexOf', 'reduce', 'reduceRight'];\n\nvar nativeArrayMethods = mapToObject.call(nativeArrayMethodsNames,\n        function(methodName) {\n            return Array.prototype[methodName];\n        });\n\n__.extend.call(arrayMethods, nativeArrayMethods);\n\n\n/**\n * Implementation of ES6 [Array __find__ method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) (native method is used if available).\n * Returns array element that passes callback test.\n *\n * @param {Array} self array to search in\n * @param {Function} callback should return `true` for item to pass the test, passed `value`, `index` and `self` as parameters\n * @param {Object} thisArg optional context (`this`) of callback call\n * @return {Any}\n */\narrayMethods.find = Array.prototype.find\n    || utils.makeFindMethod(arrayMethods.some, 'value');\n\n\n/**\n * Implementation of ES6 [Array __findIndex__ method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) (native method is used if available).\n * Returns the index of array element that passes callback test. Returns `-1` if not found.\n *\n * @param {Array} self array to search in\n * @param {Function} callback should return `true` for item to pass the test, passed `value`, `index` and `self` as parameters\n * @param {Object} thisArg optional context (`this`) of callback call\n * @return {Integer}\n */\narrayMethods.findIndex = Array.prototype.findIndex\n    || utils.makeFindMethod(arrayMethods.some, 'index');\n\n\n/**\n * Appends `arrayToAppend` to the end of array `self` in place (can be an instance of Array or array-like object).\n * Changes the value of `self` (it uses `Array.prototype.splice`) and returns `self`.\n *\n * @param {Array} self An array that will be modified\n * @param {Array} arrayToAppend An array that will be appended\n * @return {Array}\n */\nfunction appendArray(arrayToAppend) {\n    if (! arrayToAppend.length) return this;\n    if (! Array.isArray(arrayToAppend))\n        arrayToAppend = toArray.call(arrayToAppend);\n    \n    var args = [this.length, 0].concat(arrayToAppend);\n    arrayMethods.splice.apply(this, args);\n\n    return this;\n}\n\n\n/**\n * Prepends `arrayToPrepend` to the beginnig of array `self` in place (can be an instance of Array or array-like object).\n * Changes the value of `self` (it uses `Array.prototype.splice`) and returns `self`.\n *\n * @param {Array} self An array that will be modified\n * @param {Array} arrayToAppend An array that will be prepended\n * @return {Array}\n */\nfunction prependArray(arrayToPrepend) {\n    if (! arrayToPrepend.length) return this;\n    if (! Array.isArray(arrayToPrepend))\n        arrayToPrepend = toArray.call(arrayToPrepend);\n\n    var args = [0, 0].concat(arrayToPrepend);\n    arrayMethods.splice.apply(this, args);\n\n    return this;\n}\n\n\n/**\n * Removes item from array that is found using indexOf (i.e. '===')\n * Modifies original array and returns the reference to it.\n * \n * @param {Array} self An array that will be modified\n * @param  {Any} item item to be removed\n * @return {Array}\n */\nfunction spliceItem(item) {\n    var index = this.indexOf(item);\n    if (index >= 0) this.splice(index, 1);\n    return this;\n}\n\n\n/**\n * Returns new array created from array-like object (e.g., `arguments` pseudo-array).\n *\n * @param {PseudoArray} self Object with numeric property length\n * @return {Array}\n */\nfunction toArray() {\n    return arrayMethods.slice.call(this);\n}\n\n\n/**\n * Returns an object created from the array of `keys` and optional array of `values`.\n *\n * @param {Array} self Array of keys\n * @param {Array|any} values Optional array of values or the value to be assigned to each property.\n * @return {Object}\n */\nfunction object(values) {\n    var obj = {}\n        , valuesIsArray = Array.isArray(values);\n    arrayMethods.forEach.call(this, function(key, index) {\n        obj[key] = valuesIsArray ? values[index] : values;\n    });\n\n    return obj;\n}\n\n\n/**\n * Maps array to object.\n * Array elements become keys, value are taken from `callback`.\n * \n * @param {Array} self An array which values will become keys of the result\n * @param {Function} callback Callback is passed `value`, `index` and `self` and should return value that will be included in the result.\n * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.\n * @return {Object}\n */\nfunction mapToObject(callback, thisArg) {\n    var result = {};\n    Array.prototype.forEach.call(this, function(value, index) {\n        result[value] = callback.call(thisArg, value, index, this);\n    }, this);\n    return result;\n}\n\n\n/**\n * Returns array without duplicates. Does not modify original array.\n *\n * @param {Array} self original array\n * @param {Function} callback comparison function, should return true for equal items, \"===\" is used if not passed.\n * @return {Array}\n */\nfunction unique(callback) {\n    var filtered = [];\n    if (! callback)\n        itemIndex = itemIndexOf;\n\n    this.forEach(function(item) {\n        var index = itemIndex(item);\n        if (index == -1)\n            filtered.push(item);\n    });\n\n    return filtered;\n\n\n    function itemIndex(item) {\n        return arrayMethods.findIndex.call(filtered, function(it) {\n            return callback(item, it);\n        });\n    }\n\n    function itemIndexOf(item) {\n        return filtered.indexOf(item);\n    }\n}\n\n\n/**\n * Iterates array and elements that are arrays calling callback with each element that is not an array. Can be used to iterate over arguments list to avoid checking whether array or list of parameters is passed.\n *\n * @param {Array} self array of elements and arraysto iterate.\n * @param {Function} callback called for each item that is not an array. Callback is passed item, index and original array as parameters.\n * @param {Any} thisArg optional callback envocation context\n */\nfunction deepForEach(callback, thisArg) {\n    var index = 0, arr = this;\n    _deepForEach.call(this);\n\n    function _deepForEach() {\n        arrayMethods.forEach.call(this, function(value) {\n            if (Array.isArray(value))\n                _deepForEach.call(value);\n            else\n                callback.call(thisArg, value, index++, arr);\n        });\n    }\n}\n",
    "'use strict';\n\n\nvar makeProtoFunction = require('./utils').makeProtoFunction\n    , repeat = require('./proto_util').repeat;\n\n\n/**\n * - [makeFunction](#makeFunction)\n * - [partial](#partial)\n * - [partialRight](#partialRight)\n * - [memoize](#memoize)\n * - [delay](#delay)\n * - [defer](#defer)\n * - [delayed](#delayed)\n * - [deferred](#deferred)\n * - [deferTicks](#deferTicks)\n * - [delayMethod](#delayMethod)\n * - [deferMethod](#deferMethod)\n * - [debounce](#debounce)\n * - [throttle](#throttle)\n * - [once](#once)\n * - [waitFor](#waitFor)\n * - [not](#not)\n *\n * These methods can be [chained](proto.js.html#Proto)\n */\nvar functionMethods = module.exports = {\n    makeFunction: makeFunction,\n    partial: partial,\n    partialRight: partialRight,\n    memoize: memoize,\n    delay: delay,\n    defer: defer,\n    delayed: delayed,\n    deferred: deferred,\n    deferTicks: deferTicks,\n    delayMethod: delayMethod,\n    deferMethod: deferMethod,\n    debounce: debounce,\n    throttle: throttle,\n    once: once,\n    waitFor: waitFor,\n    not: not\n};\n\n\nvar slice = Array.prototype.slice;\n\n\n/**\n * Similarly to Function constructor creates a function from code.\n * Unlike Function constructor, the first argument is a function name\n *\n * @param {String} name new function name\n * @param {String} arg1, arg2, ... the names of function parameters\n * @param {String} funcBody function body\n * @return {Function}\n */\nfunction makeFunction(arg1, arg2, funcBody) {\n    var name = this\n        , count = arguments.length - 1\n        , funcBody = arguments[count]\n        , func\n        , code = '';\n    for (var i = 0; i < count; i++)\n        code += ', ' + arguments[i];\n    code = ['func = function ', name, '(', code.slice(2), ') {\\n'\n                , funcBody, '\\n}'].join('');\n    eval(code);\n    return func;\n}\n\n\n/**\n * Creates a function as a result of partial function application with the passed parameters.\n *\n * @param {Function} self Function to be applied\n * @param {List} arguments Arguments after self will be prepended to the original function call when the partial function is called.\n * @return {Function}\n */\nfunction partial() { // , ... arguments\n    var func = this;\n    var args = slice.call(arguments);\n    return function() {\n        return func.apply(this, args.concat(slice.call(arguments)));\n    };\n}\n\n\n/**\n * Creates a function as a result of partial function application with the passed parameters, but parameters are appended on the right.\n *\n * @param {Function} self Function to be applied\n * @param {List} arguments Arguments after self will be appended on the right to the original function call when the partial function is called.\n * @return {Function}\n */\nfunction partialRight() { // , ... arguments\n    var func = this;\n    var args = slice.call(arguments);\n    return function() {\n        return func.apply(this, slice.call(arguments).concat(args));\n    };\n}\n\n\n/**\n * Creates a memoized version of the function using supplied hash function as key. If the hash is not supplied, uses its first parameter as the hash.\n * \n * @param {Function} self function to be memoized\n * @param {Function} hashFunc optional hash function that is passed all function arguments and should return cache key.\n * @param {Integer} limit optional maximum number of results to be stored in the cache. 1000 by default.\n * @return {Function} memoized function\n */\nfunction memoize(hashFunc, limit) {\n    var func = this;\n    var cache = {}, keysList = [];\n    limit = limit || 1000;\n\n    return function() {\n        var key = hashFunc ? hashFunc.apply(this, arguments) : arguments[0];\n        if (cache.hasOwnProperty(key))\n            return cache[key];\n\n        var result = cache[key] = func.apply(this, arguments);\n        keysList.push(key);\n\n        if (keysList.length > limit)\n            delete cache[keysList.shift()];\n\n        return result;\n    };\n}\n\n\n/**\n * Delays function execution by a given time in milliseconds.\n * The context in function when it is executed is set to `null`.\n *\n * @param {Function} self function that execution has to be delayed\n * @param {Number} wait approximate dalay time in milliseconds\n * @param {List} arguments optional arguments that will be passed to the function\n */\nfunction delay(wait) { // , arguments\n    var args = slice.call(arguments, 1);\n    return _delay(this, wait, args);\n}\n \n\n/**\n * Defers function execution (executes as soon as execution loop becomes free)\n * The context in function when it is executed is set to `null`.\n *\n * @param {Function} self function that execution has to be delayed\n * @param {List} arguments optional arguments that will be passed to the function\n */\nfunction defer() { // , arguments\n    return _delay(this, 1, arguments);\n}\n\nfunction _delay(func, wait, args, context) {\n    return setTimeout(func.apply.bind(func, context || null, args), wait);\n}\n\n/**\n * Same as _.defer, takes first argument as the function to be deferred\n */\nvar deferFunc = makeProtoFunction(defer);\n\n/**\n * Defers function execution for `times` ticks (executes after execution loop becomes free `times` times)\n * The context in function when it is executed is set to `null`.\n *\n * @param {Function} self function that execution has to be delayed\n * @param {Integer} ticks number of times to defer execution\n * @param {List} arguments optional arguments that will be passed to the function\n */\nfunction deferTicks(ticks) { // , arguments\n    if (ticks < 2) return defer.apply(this, arguments);\n    var args = repeat.call(deferFunc, ticks - 1);\n    args = args.concat(this, slice.call(arguments, 1)); \n    return deferFunc.apply(null, args);\n}\n\n\n/**\n * Works like _.delay but allows to defer method call of `self` which will be the first _.delayMethod parameter\n *\n * @param {Object} self object to delay method call of\n * @param {Function|String} funcOrMethodName function or name of method\n * @param {Number} wait approximate dalay time in milliseconds\n * @param {List} arguments arguments to pass to method\n */\nfunction delayMethod(funcOrMethodName, wait) { // , ... arguments\n    var args = slice.call(arguments, 2);\n    return _delayMethod(this, funcOrMethodName, wait, args);\n}\n\n\n/**\n * Works like _.defer but allows to defer method call of `self` which will be the first _.deferMethod parameter\n *\n * @param {Object} self object to defer method call of\n * @param {Function|String} funcOrMethodName function or name of method\n * @param {List} arguments arguments to pass to method\n */\nfunction deferMethod(funcOrMethodName) { // , ... arguments\n    var args = slice.call(arguments, 1);\n    return _delayMethod(this, funcOrMethodName, 1, args);\n}\n\nfunction _delayMethod(object, funcOrMethodName, wait, args) {\n    return setTimeout(function() {\n        var func = typeof funcOrMethodName == 'string'\n                    ? object[funcOrMethodName]\n                    : funcOrMethodName;\n        func.apply(object, args);\n    }, wait);\n}\n\n\n/**\n * Returns function that will execute the original function `wait` ms after it has been called\n * The context in function when it is executed is set to `null`.\n * Arguments passed to the function are appended to the arguments passed to delayed.\n *\n * @param {Function} self function which execution has to be deferred\n * @param {Number} wait approximate dalay time in milliseconds\n * @param {List} arguments optional arguments that will be passed to the function\n * @return {Function}\n */\nfunction delayed(wait) { //, ... arguments\n    var func = this\n        , args = slice.call(arguments, 1);\n    return function() { // ... arguments\n        var passArgs = args.concat(slice.call(arguments));\n        return _delay(func, wait, passArgs, this);\n    };\n}\n\n\n/**\n * Returns function that will execute the original function on the next tick once it has been called\n * The context in function when it is executed is set to `null`.\n * Arguments passed to the function are appended to the arguments passed to deferred.\n *\n * @param {Function} self function which execution has to be deferred\n * @param {List} arguments optional arguments that will be passed to the function\n * @return {Function}\n */\nfunction deferred() { //, ... arguments\n    var func = this\n        , args = slice.call(arguments);\n    return function() { // ... arguments\n        var passArgs = args.concat(slice.call(arguments));\n        return _delay(func, 1, passArgs, this);\n    };\n}\n\n\n/**\n * Creates a function that will call original function once it has not been called for a specified time\n *\n * @param {Function} self function that execution has to be delayed\n * @param {Number} wait approximate dalay time in milliseconds\n * @param {Boolean} immediate true to invoke funciton immediately and then ignore following calls for wait milliseconds\n * @return {Function}\n */\nfunction debounce(wait, immediate) {\n    var func = this; // first parameter of _.debounce\n    var timeout, args, context, timestamp, result;\n    return function() {\n        context = this; // store original context\n        args = arguments;\n        timestamp = Date.now();\n        var callNow = immediate && ! timeout;\n        if (! timeout)\n            timeout = setTimeout(later, wait);\n        if (callNow)\n            result = func.apply(context, args);\n        return result;\n\n        function later() {\n            var last = Date.now() - timestamp;\n            if (last < wait)\n                timeout = setTimeout(later, wait - last);\n            else {\n                timeout = null;\n                if (! immediate)\n                    result = func.apply(context, args);\n            }\n        }\n    };\n}\n\n\n/**\n * Returns a function, that, when invoked, will only be triggered at most once during a given window of time. \n *\n * @param {Function} self function that execution has to be delayed\n * @param {Number} wait approximate delay time in milliseconds\n * @param {Object} options `{leading: false}` to disable the execution on the leading edge\n * @return {Function}\n */\nfunction throttle(wait, options) {\n    var func = this; // first parameter of _.throttle\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n\n    return function() {\n        var now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0) {\n            clearTimeout(timeout);\n            timeout = null;\n            previous = now;\n            result = func.apply(context, args);\n        } else if (!timeout && options.trailing !== false)\n            timeout = setTimeout(later, remaining);\n\n        return result;\n    };\n\n    function later() {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n    }\n}\n\n\n/**\n * Call passed function only once\n * @return {Function} self\n */\nfunction once() {\n    var func = this\n        , ran = false\n        , memo;\n    return function() {\n        if (ran) return memo;\n        ran = true;\n        memo = func.apply(this, arguments);\n        func = null;\n        return memo;\n    };\n}\n\n\n/**\n * Execute a function when the condition function returns a truthy value\n * it runs the condition function every `checkInterval` milliseconds (default 50)\n *\n * @param {Function} self function: if it returns true the callback is executed\n * @param {Function} callback runs when the condition is true\n * @param {Number} maxTimeout timeout before giving up (time in milliseconds)\n * @param {Function} timedOutFunc a function called if timeout is reached\n * @param {Number} checkInterval time interval when you run the condition function (time in milliseconds), default 50 ms\n */\nfunction waitFor(callback, maxTimeout, timedOutFunc, checkInterval){\n    var start = Date.now();\n    var condition = this;\n    checkInterval = checkInterval || 50;\n    var interval = setInterval(testCondition, checkInterval);\n\n    function testCondition() {\n        if (condition()) callback();\n        else if (Date.now() - start >= maxTimeout)\n            timedOutFunc && timedOutFunc();\n        else return;\n        clearInterval(interval);\n    };\n}\n\n\n/**\n * returns the function that negates (! operator) the result of the original function\n * @param {Function} self function to negate\n * @return {Function}\n */\nfunction not() {\n    var func = this;\n    return function() {\n        return !func.apply(this, arguments);\n    };\n}\n",
    "'use strict';\n\n/**\n * - [isNumeric](#isNumeric)\n */\nvar numberMethods = module.exports = {\n    isNumeric: isNumeric\n};\n\n\n/**\n * Function to test if a value is numeric\n *\n * @param {Any} self value to be tested\n * @return {Boolean} true if it is a numeric value\n */\nfunction isNumeric() {\n    return !isNaN(parseFloat(this)) && isFinite(this);\n};\n",
    "'use strict';\n\n\nvar utils = require('./utils');\n\n\n/**\n * - [extend](#extend)\n * - [clone](#clone)\n * - [defineProperty](#defineProperty)\n * - [defineProperties](#defineProperties)\n * - [deepExtend](#deepExtend)\n * - [deepClone](#deepClone)\n * - [keys](#keys)\n * - [allKeys](#allKeys)\n * - [values](#values)\n * - [keyOf](#keyOf)\n * - [allKeysOf](#allKeysOf)\n * - [eachKey](#eachKey)\n * - [mapKeys](#mapKeys)\n * - [reduceKeys](#reduceKeys)\n * - [filterKeys](#filterKeys)\n * - [someKey](#someKey)\n * - [everyKey](#everyKey)\n * - [findValue](#findValue)\n * - [findKey](#findKey)\n * - [pickKeys](#pickKeys)\n * - [omitKeys](#omitKeys)\n * - [isEqual](#isEqual)\n * - [isNot](#isNot)\n *\n * All these methods can be [chained](proto.js.html#Proto)\n */\nvar objectMethods = module.exports = {\n    extend: extend,\n    clone: clone,\n    defineProperty: defineProperty,\n    defineProperties: defineProperties,\n    deepExtend: deepExtend,\n    deepClone: deepClone,\n    keys: keys,\n    allKeys: allKeys,\n    values: values,\n    keyOf: keyOf,\n    allKeysOf: allKeysOf,\n    eachKey: eachKey,\n    mapKeys: mapKeys,\n    reduceKeys: reduceKeys,\n    filterKeys: filterKeys,\n    someKey: someKey,\n    everyKey: everyKey,\n    pickKeys: pickKeys,\n    omitKeys: omitKeys,\n    isEqual: isEqual,\n    isNot: isNot\n};\n\n\n/**\n * ####Property descriptor constants####\n * The sum of these constants can be used as last parameter of defineProperty and defineProperties to determine types of properties.\n */\nvar constants = {\n    ENUMERABLE: 1,\n    ENUM: 1,\n    CONFIGURABLE: 2,\n    CONF: 2,\n    WRITABLE: 4,\n    WRIT: 4\n};\n\ndefineProperty.call(objectMethods, '_constants', constants);\n\n\n/**\n * Analogue of ES6 [Array __find__ method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find).\n * Returns the value of object property that passes callback test.\n *\n * @param {Object} self object to search in\n * @param {Function} callback should return `true` for item to pass the test, passed `value`, `key` and `self` as parameters\n * @param {Object} thisArg optional context (`this`) of callback call\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n * @return {Any}\n */\nobjectMethods.findValue = utils.makeFindMethod(someKey, 'value');\n\n\n/**\n * Analogue of ES6 [Array __findIndex__ method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex).\n * Returns the key of object property that passes callback test. Returns `undefined` if not found (unlike `findIndex`, that returns -1 in this case).\n *\n * @param {Object} self object to search in\n * @param {Function} callback should return `true` for item to pass the test, passed `value`, `key` and `self` as parameters\n * @param {Object} thisArg optional context (`this`) of callback call\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n * @return {Integer}\n */\nobjectMethods.findKey = utils.makeFindMethod(someKey, 'key');\n\n\n/**\n * Extends object `self` with the properties of the object `obj` copying all own properties (not those inherited via prototype chain), including non-enumerable properties (unless `onlyEnumerable` is truthy).\n * Created properties will have the same descriptors as the propertis of `obj`.\n * Returns `self` to allow chaining with other functions.\n * Can be used with functions, to copy class methods, e.g.\n *\n * @param {Object} self An object to be extended\n * @param {Object} obj An object which properties will be copied to self\n * @param {Boolean} onlyEnumerable Optional flag to prevent copying non-enumerable properties, `false` by default\n * @return {Object}\n */\nfunction extend(obj, onlyEnumerable) {\n    var descriptors = {};\n\n    eachKey.call(obj, function(value, prop) {\n        descriptors[prop] = Object.getOwnPropertyDescriptor(obj, prop);\n    }, this, onlyEnumerable);\n\n    Object.defineProperties(this, descriptors);\n\n    return this;\n}\n\n\n/**\n * Makes a shallow clone of object `obj` creating an instance of the same class; the properties will have the same descriptors.\n * To clone an array use\n * ```\n * var clonedArray = [].concat(arr);\n * ```\n * This function should not be used to clone an array, because it is inefficient.\n *\n * @param {Object} self An object to be cloned\n * @return {Object}\n */\nfunction clone() {\n    if (Array.isArray(this)) return this.slice();\n    if (this instanceof Date) return new Date(this);\n    if (this instanceof RegExp) return new RegExp(this);\n    var clonedObject = Object.create(this.constructor.prototype);\n    extend.call(clonedObject, this);\n    return clonedObject;\n}\n\n\n/**\n * Syntax sugar to shorten usage of `Object.defineProperty`.\n * The simplest usage (to add non-enumerable, non-configurable, non-writable property):\n * ```\n * _.defineProperty(obj, 'key', value);\n * ```\n *\n * To define some other properties use sum of the flags `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`):\n * ```\n * _.defineProperty(obj, 'key', value, _.ENUM + _.WRIT);\n * ```\n * Returns `self`.\n *\n * @param {Object} self An object to add a property to\n * @param {String} propertyName the name of the property that will be added\n * @param {Any} value the value of added property\n * @param {Integer} decriptorFlags bit mask of property descriptor properties composed from `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`)\n * @return {Object}\n */\nfunction defineProperty(propertyName, value, decriptorFlags) {\n    Object.defineProperty(this, propertyName,\n        _getDescriptor(value, decriptorFlags));\n    return this;\n}\n\n\nfunction _getDescriptor(value, decriptorFlags) {\n    var descriptor = { value: value };\n    if (decriptorFlags)\n        extend.call(descriptor, {\n            enumerable: !! (decriptorFlags & constants.ENUMERABLE),\n            configurable: !! (decriptorFlags & constants.CONFIGURABLE),\n            writable: !! (decriptorFlags & constants.WRITABLE)\n        });\n\n    return descriptor;\n}\n\n\n/**\n * Syntax sugar to shorten usage of `Object.defineProperties`.\n * The simplest usage (to add non-enumerable, non-configurable, non-writable properties):\n * ```\n * _.defineProperties(obj, {\n *     key1: value1,\n *     key2: value2\n * });\n * ```\n * To define some other properties use sum of the flags `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`):\n * ```\n * _.defineProperties(obj, {\n *     key1: value1,\n *     key2: value2\n * }, _.ENUM + _.WRIT);\n * ```\n * Returns `self`.\n *\n * @param {Object} self An object to add a property to\n * @param {Object} propertyValues A map of keys and values of properties thatwill be added. The descriptors of properties will be defined by the following parameters.\n * @param {Integer} decriptorFlags bit mask of property descriptor properties composed from `_.ENUMERABLE` (or `_.ENUM`), `_.CONFIGURABLE` (or `_.CONF`) and `_.WRITABLE` (or `_.WRIT`)\n * @return {Object}\n */\nfunction defineProperties(propertyValues, decriptorFlags) {\n    var descriptors = mapKeys.call(propertyValues, function(value) {\n        return _getDescriptor(value, decriptorFlags);\n    }, true);\n    Object.defineProperties(this, descriptors);\n    return this;\n}\n\n\n/**\n * Extends object `self` with properties of `obj` to any depth, without overwrtiting existing object properties of `self` with object properties of `obj`.\n * Scalar properties of `obj` will overwrite properties of `self`. Scalar porperties of `self` will also be overwritten.\n * Correctly works with recursive objects.\n * Usage:\n * ```\n * var obj = {\n *     inner: {\n *         a: 1\n *     }\n * };\n *\n * _.deepExtend(obj, {\n *     inner: {\n *         b: 2\n *     }\n * });\n *\n * assert.deepEqual(obj, {\n *     inner: {\n *         a: 1,\n *         b: 2\n *     }\n * }); // assert passes\n * ```\n * Returns `self`.\n *\n * @param {Object} self An object to be extended\n * @param {Object} obj An object with properties to copy to\n * @param {Boolean} onlyEnumerable Optional `true` to use only enumerable properties\n * @param {Boolean} preserveStructure if true will throw at the attempt to overwrite object with scalar value (including Date and Regex) and vice versa\n * @return {Object}\n */\nfunction deepExtend(obj, onlyEnumerable, preserveStructure) {\n    return _extendTree(this, obj, onlyEnumerable, preserveStructure, []);\n}\n\n\nfunction _extendTree(selfNode, objNode, onlyEnumerable, preserveStructure, objTraversed) {\n    if (objTraversed.indexOf(objNode) >= 0) return; // node already traversed, obj has recursion\n\n    // store node to recognise recursion\n    objTraversed.push(objNode);\n\n    var loop = Array.isArray(objNode) ? Array.prototype.forEach : eachKey;\n\n    loop.call(objNode, function(value, prop) {\n        var hasProp = selfNode.hasOwnProperty(prop)\n            , isSelfObj = isNormalObject(selfNode[prop])\n            , isValueObj = isNormalObject(value);\n\n        if (preserveStructure && hasProp && isSelfObj != isValueObj)\n            throw new Error('deepExtend');\n\n        if (isValueObj) {\n            if (!hasProp || !isSelfObj)\n                selfNode[prop] = (Array.isArray(value)) ? [] : {};\n\n            _extendTree(selfNode[prop], value, onlyEnumerable, preserveStructure, objTraversed);\n        } else {\n            var descriptor = Object.getOwnPropertyDescriptor(objNode, prop);\n            Object.defineProperty(selfNode, prop, descriptor);\n        }\n    }, this, onlyEnumerable);\n\n    return selfNode;\n}\n\n\nfunction isNormalObject(value) {\n    return typeof value == 'object' && value != null\n            && !(value instanceof RegExp) && !(value instanceof Date)\n}\n\n\n/**\n * Clones all object tree. Class of original object is not preserved. Returns `self`\n *\n * @param {Object} self An object to be extended\n * @param {Boolean} onlyEnumerable Optional `true` to use only enumerable properties\n * @return {Object}\n */\nfunction deepClone(onlyEnumerable) {\n    if (this instanceof Date) return new Date(this);\n    if (this instanceof RegExp) return new RegExp(this);\n    var clonedObject = Array.isArray(this) ? [] : {};\n    deepExtend.call(clonedObject, this, onlyEnumerable);\n    return clonedObject;\n}\n\n\n/**\n * Returns array of enumerable properties of the object\n *\n * @param {Object} self object to return keys of\n * @return {Array}\n */\nfunction keys() {\n    return Object.keys(this);\n}\n\n\n/**\n * Returns array of values of the object's keys\n *\n * @param {Object} self object to return values from\n * @return {Array}\n */\nfunction values(onlyEnumerable) {\n    var properties = onlyEnumerable\n                ? Object.keys(this)\n                : allKeys.call(this);\n\n    return properties.map(function(prop) {\n        return this[prop];\n    }, this);\n}\n\n\n/**\n * Returns array of all property names of an object `self` (including non-enumerbale).\n * To get only enumerable properties, use `Object.keys()`.\n *\n * @param {Object} self An object to get all properties of.\n * @return {Array}\n */\n function allKeys() {\n    return Object.getOwnPropertyNames(this);\n }\n\n\n/**\n * An analogue of `indexOf` method of Array prototype.\n * Returns the `key` of `searchElement` in the object `self`.\n * As object keys are unsorted, if there are several keys that hold `searchElement` any of them can be returned. Use `allKeysOf` to return all keys.\n * All own properties are searched (not those inherited via prototype chain), including non-enumerable properties (unless `onlyEnumerable` is truthy).\n *\n * @param {Object} self An object to search a value in\n * @param {Any} searchElement An element that will be searched. An exact equality is tested, so `0` is not the same as `'0'`.\n * @param {Boolean} onlyEnumerable An optional true to search among enumerable properties only.\n * @return {String}\n */\nfunction keyOf(searchElement, onlyEnumerable) {\n    var properties = onlyEnumerable\n                        ? Object.keys(this)\n                        : allKeys.call(this);\n\n    for (var i = 0; i < properties.length; i++)\n        if (searchElement === this[properties[i]])\n            return properties[i];\n\n    return undefined;\n}\n\n\n/**\n * Works similarly to the previous function, but returns the array of keys holding `searchElement` as their value.\n *\n * @param {Object} self An object to search a value in\n * @param {Any} searchElement An element that will be searched. An exact equality is tested, so `0` is not the same as `'0'`.\n * @param {Boolean} onlyEnumerable An optional true to search among enumerable properties only.\n * @return {Array<String>}\n */\nfunction allKeysOf(searchElement, onlyEnumerable) {\n    var properties = onlyEnumerable\n                        ? Object.keys(this)\n                        : allKeys.call(this);\n\n    var keys = properties.filter(function(prop) {\n        return searchElement === this[prop];\n    }, this);\n\n    return keys;\n}\n\n\n/**\n * An analogue of [forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) method of Array prototype.\n * Iterates all own properties of `self` (or only enumerable own properties if `onlyEnumerable` is truthy) calling callback for each key.\n * This method should not be used with arrays, it will include `length` property in iteration.\n * To iterate array-like objects (e.g., `arguments` pseudo-array) use:\n * ```\n * _.forEach(arguments, callback, thisArg);\n * ```\n * Function returns `self` to allow [chaining](proto.js.html)\n *\n * @param {Object} self An object which properties will be iterated\n * @param {Function} callback Callback is passed `value`, `key` and `self`, its return value is not used.\n * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n */\nfunction eachKey(callback, thisArg, onlyEnumerable) {\n    var properties = onlyEnumerable\n                        ? Object.keys(this)\n                        : allKeys.call(this);\n\n    properties.forEach(function(prop) {\n        callback.call(thisArg, this[prop], prop, this);\n    }, this);\n\n    return this;\n}\n\n\n/**\n * An analogue of [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) method of Array prototype.\n * Returns the object that is the result of the application of callback to values in all own properties of `self` (or only enumerable own properties if `onlyEnumerable` is truthy).\n * The returned object will be the instance of the same class as `self`.\n * Property descriptors of the returned object will have the same `enumerable`, `configurable` and `writable` settings as the properties of `self`.\n * This method should not be used with arrays, it will include `length` property in iteration.\n * To map array-like objects use:\n * ```\n * var result = _.map(arguments, callback, thisArg);\n * ```\n *\n * @param {Object} self An object which properties will be iterated\n * @param {Function} callback Callback is passed `value`, `key` and `self` and should return value that will be included in the map.\n * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n * @return {Object}\n */\nfunction mapKeys(callback, thisArg, onlyEnumerable) {\n    var descriptors = {};\n    eachKey.call(this, mapProperty, thisArg, onlyEnumerable);\n    return Object.create(this.constructor.prototype, descriptors);\n\n    function mapProperty(value, key, self) {\n        descriptors[key] = Object.getOwnPropertyDescriptor(self, key);\n        descriptors[key].value = callback.call(this, value, key, self);\n    }\n}\n\n\n/**\n * An analogue of [reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) method of Array prototype.\n * This method reduces the object to a single value. Iteration order is impossible to control with object.\n * This method should not be used with arrays, it will include `length` property in iteration.\n * To reduce array-like objects use:\n * ```\n * var result = _.reduce(arguments, callback, initialValue, thisArg);\n * ```\n *\n * @param {Object} self An object which properties will be iterated\n * @param {Function} callback Callback is passed `previousValue`, `value`, `key` and `self` and should return value that will be used as the `previousValue` for the next `callback` call.\n * @param {Any} initialValue The initial value passed to callback as the first parameter on the first call.\n * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n * @return {Any}\n */\nfunction reduceKeys(callback, initialValue, thisArg, onlyEnumerable) {\n    var properties = onlyEnumerable\n                        ? Object.keys(this)\n                        : allKeys.call(this);\n\n    var memo = initialValue;\n\n    properties.forEach(function(prop) {\n        memo = callback.call(thisArg, memo, this[prop], prop, this);\n    }, this);\n\n    return memo;\n}\n\n\n/**\n * An analogue of [filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) method of Array prototype.\n * Returns the new object with keys for which callback returns true.\n * Property descriptors of the returned object will have the same `enumerable`, `configurable` and `writable` settings as the properties of `self`.\n * To filter array-like objects use:\n * ```\n * var result = _.filter(arguments, callback, thisArg);\n * ```\n *\n * @param {Object} self An object which properties will be iterated\n * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns truthy value, the key/value will be included in the resulting object.\n * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n * @return {Object}\n */\nfunction filterKeys(callback, thisArg, onlyEnumerable) {\n    var descriptors = {};\n    eachKey.call(this, filterProperty, thisArg, onlyEnumerable);\n    return Object.create(this.constructor.prototype, descriptors);;\n\n    function filterProperty(value, key, self) {\n        if (callback.call(this, value, key, self))\n            descriptors[key] = Object.getOwnPropertyDescriptor(self, key);\n    }\n}\n\n\nvar _passed = {}\n    , _didNotPass = {};\n\n/**\n * An analogue of [some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method of Array prototype.\n *\n * @param {Object} self An object which properties will be iterated\n * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns truthy value, the function immeaditely returns `true`.\n * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n * @return {Boolean}\n */\nfunction someKey(callback, thisArg, onlyEnumerable) {\n    try {\n        eachKey.call(this, testProperty, thisArg, onlyEnumerable);\n    } catch (test) {\n        if (test === _passed) return true;\n        else throw test;\n    }\n    return false;\n\n    function testProperty(value, key, self) {\n        if (callback.call(this, value, key, self))\n            throw _passed;\n    }\n}\n\n\n/**\n * An analogue of [every](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) method of Array prototype.\n *\n * @param {Object} self An object which properties will be iterated\n * @param {Function} callback Callback is passed `value`, `key` and `self`. If it returns falsy value, the function immeaditely returns `false`.\n * @param {Object} thisArg An optional context of iteration (the valueof `this`), will be undefined if this parameter is not passed.\n * @param {Boolean} onlyEnumerable An optional `true` to iterate enumerable properties only.\n * @return {Boolean}\n */\nfunction everyKey(callback, thisArg, onlyEnumerable) {\n    try {\n        eachKey.call(this, testProperty, thisArg, onlyEnumerable);\n    } catch (test) {\n        if (test === _didNotPass) return false;\n        else throw test;\n    }\n    return true;\n\n    function testProperty(value, key, self) {\n        if (! callback.call(this, value, key, self))\n            throw _didNotPass;\n    }\n}\n\n\nvar ArrayProto = Array.prototype\n    , concat = ArrayProto.concat;\n/**\n * Returns object of the same class with only specified keys, that are passed as string parameters or array(s) of keys.\n *\n * @param {Object} self an object to pick keys from\n * @param {List<String|Array>} arguments list of keys (or array(s) of keys)\n * @return {Object}\n */\nfunction pickKeys() { // , ... keys\n    var keys = concat.apply(ArrayProto, arguments)\n        , obj = Object.create(this.constructor.prototype);\n    keys.forEach(function(key) {\n        if (this.hasOwnProperty(key))\n            obj[key] = this[key];\n    }, this);\n    return obj;\n}\n\n\n/**\n * Returns object of the same class without specified keys, that are passed as string parameters or array(s) of keys.\n *\n * @param {Object} self an object to omit keys in\n * @param {List<String|Array>} arguments list of keys (or array(s) of keys)\n * @return {Object}\n */\nfunction omitKeys() { // , ... keys\n    var keys = concat.apply(ArrayProto, arguments)\n        , obj = clone.call(this);\n    keys.forEach(function(key){\n        delete obj[key];\n    }, this);\n    return obj;\n}\n\n\n/**\n * Performs deep equality test of the object. Does not work with recursive objects\n * @param  {Any} self object to compare\n * @param  {Any} obj object to compare\n * @return {Boolean}\n */\nfunction isEqual(obj) {\n    if (this === obj) return this !== 0 || 1/this == 1/obj; // 0 and -0 are considered not equal, although 0 === -0 is true\n    if (this == null || obj == null) return false;\n    var className = this.constructor.name;\n    if (className != obj.constructor.name) return false;\n    switch (className) {\n        case 'String':\n            return this == String(obj);\n        case 'Number':\n            return this != +this ? obj != +obj : (this == 0 ? 1/this == 1/obj : this == +obj);\n        case 'Date':\n        case 'Boolean':\n            return +this == +obj;\n        case 'RegExp':\n            return this.source == obj.source\n                    && this.global == obj.global\n                    && this.multiline == obj.multiline\n                    && this.ignoreCase == obj.ignoreCase;\n    }\n    if (typeof this != 'object' || typeof obj != 'object') return false;\n\n    if (Array.isArray(this))\n        return this.length == obj.length\n                && this.every(function(item, index) {\n                    return isEqual.call(item, obj[index]);\n                });\n    else {\n        return allKeys.call(this).length == allKeys.call(obj).length\n                && everyKey.call(this, function(value, key) {\n                    return isEqual.call(value, obj[key]);\n                });\n    }\n}\n\n\n/**\n * The opposite of isEqual\n * @param  {Any} self object to compare\n * @param  {Any} obj object to compare\n * @return {Boolean}\n */\nfunction isNot(obj) {\n    return !isEqual.call(this, obj);\n}\n",
    "'use strict';\n\n/**\n * - [extendProto](#extendProto)\n * - [createSubclass](#createSubclass)\n * - [makeSubclass](#makeSubclass)\n * - [newApply](#newApply)\n *\n * These methods can be [chained](proto.js.html#Proto)\n */\nvar prototypeMethods = module.exports = {\n    extendProto: extendProto,\n    createSubclass: createSubclass,\n    makeSubclass: makeSubclass,\n    newApply: newApply\n};\n\n\nvar __ = require('./proto_object');\n\n__.extend.call(__, require('./proto_function'));\n\n\n/**\n * Adds non-enumerable, non-configurable and non-writable properties to the prototype of constructor function.\n * Usage:\n * ```\n * function MyClass() {}\n * _.extendProto(MyClass, {\n *     method1: function() {},\n *     method2: function() {}\n * });\n * ```\n * To extend class via object:\n * ```\n * _.extendProto(obj.constructor, methods);\n * ```\n * Returns passed constructor, so functions _.extendProto, [_.extend](object.js.html#extend) and _.makeSubclass can be [chained](proto.js.html). \n *\n * @param {Function} self constructor function\n * @param {Object} methods a map of functions, keys will be instance methods (properties of the constructor prototype)\n * @return {Function}\n */\nfunction extendProto(methods) {\n    var propDescriptors = {};\n\n    __.eachKey.call(methods, function(method, name) {\n        propDescriptors[name] = {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: method\n        };\n    });\n\n    Object.defineProperties(this.prototype, propDescriptors);\n    return this;\n}\n\n\n/**\n * Makes a subclass of class `thisClass`.\n * The returned function will have specified `name` if supplied.\n * The constructor of superclass will be called in subclass constructor by default unless `applyConstructor === false` (not just falsy).\n * Copies `thisClass` class methods to created subclass. For them to work correctly they should use `this` to refer to the class rather than explicit superclass name.\n *\n * @param {Function} thisClass A class to make subclass of\n * @param {String} name Optional name of subclass constructor function\n * @param {Boolean} applyConstructor Optional false value (not falsy) to prevent call of inherited constructor in the constructor of subclass\n * @return {Function}\n */\nfunction createSubclass(name, applyConstructor) {\n    var thisClass = this;\n    var subclass;\n\n    // name is optional\n    name = name || '';\n\n    // apply superclass constructor\n    var constructorCode = applyConstructor === false\n            ? ''\n            : 'thisClass.apply(this, arguments);';\n\n    eval('subclass = function ' + name + '(){ ' + constructorCode + ' }');\n\n    makeSubclass.call(subclass, thisClass);\n\n    // copy class methods\n    // - for them to work correctly they should not explictly use superclass name\n    // and use \"this\" instead\n    __.deepExtend.call(subclass, thisClass, true);\n\n    return subclass;\n}\n\n\n/**\n * Sets up prototype chain to change `thisClass` (a constructor function) so that it becomes a subclass of `Superclass`.\n * Returns `thisClass` so it can be [chained](proto.js.html) with _.extendProto and [_.extend](object.js.html#extend).\n *\n * @param {Function} thisClass A class that will become a subclass of Superclass\n * @param {Function} Superclass A class that will become a superclass of thisClass\n * @return {Function}\n */\nfunction makeSubclass(Superclass) {\n    // prototype chain\n    this.prototype = Object.create(Superclass.prototype);\n    \n    // subclass identity\n    extendProto.call(this, {\n        constructor: this\n    });\n    return this;\n}\n\n\n/**\n * Calls constructor `this` with arguments passed as array\n * \n * @param {Function} thisClass A class constructor that will be called\n * @return {Array} args Array of arguments that will be passed to constructor\n */\nfunction newApply(args) {\n    if (! Array.isArray(args))\n        args = Array.prototype.slice.call(args);\n    // \"null\" is context to pass to class constructor, first parameter of bind\n    var args = [null].concat(args);\n    return new (Function.prototype.bind.apply(this, args));\n}\n",
    "'use strict';\n\n\nvar __ = require('./proto_object');\n\n\n/**\n * - [firstUpperCase](#firstUpperCase)\n * - [firstLowerCase](#firstLowerCase)\n * - [toRegExp](#toRegExp)\n * - [toFunction](#toFunction)\n * - [toDate](#toDate)\n * - [toQueryString](#toQueryString)\n * - [fromQueryString](#fromQueryString)\n * - [jsonParse](#jsonParse)\n * - [hashCode](#hashCode)\n * - [unPrefix](#unPrefix)\n * - [format](#format)\n */\n var stringMethods = module.exports = {\n    firstUpperCase: firstUpperCase,\n    firstLowerCase: firstLowerCase,\n    toRegExp: toRegExp,\n    toFunction: toFunction,\n    toDate: toDate,\n    toQueryString: toQueryString,\n    fromQueryString: fromQueryString,\n    jsonParse: jsonParse,\n    hashCode: hashCode,\n    unPrefix: unPrefix,\n    format: format\n};\n\n\n/**\n * Returns string with the first character changed to upper case.\n *\n * @param {String} self A string that will have its first character replaced\n */\nfunction firstUpperCase() {\n    return this ? this[0].toUpperCase() + this.slice(1) : this;\n}\n\n\n/**\n * Returns string with the first character changed to lower case.\n *\n * @param {String} self A string that will have its first character replaced\n */\nfunction firstLowerCase() {\n    return this ? this[0].toLowerCase() + this.slice(1) : this;\n}\n\n\n/**\n * Converts string created by `toString` method of RegExp back to RegExp\n *\n * @param {String} self string containing regular expression including enclosing \"/\" symbols and flags\n * @return {RegExp}\n */\nfunction toRegExp() {\n    var rx = this.match(regexpStringPattern);\n    if (rx) return new RegExp(rx[1], rx[2]);\n}\nvar regexpStringPattern = /^\\/(.*)\\/([gimy]*)$/;\n\n\n/**\n * Converts string created by `toString` method of function back to function\n *\n * @param {String} self string containing full function code\n * @return {Function}\n */\nfunction toFunction() {\n    var func;\n    var code = 'func = ' + this + ';';\n    try {\n        eval(code);\n        return func;\n    } catch(e) {\n        return;\n    }\n}\n\n\n/**\n * Converts string to date in a safe way so that the resiult is undefined if date is invalid\n *\n * @param {String|Date} self string or date object to convert to VALID date\n * @return {Date|undefined}\n */\nfunction toDate() {\n    if (! this) return;\n    try {\n        var date = new Date(this);\n    } catch (e) {}\n    if (date && date.getTime && !isNaN(date.getTime()))\n        return date;\n}\n\n\n/**\n * Convert params object to a url style query string (without \"?\")\n * \n * @param {Object} self The object hash to be converted\n * @param {Function} encode optional function used to encode data, encodeURIComponent is used if not specified\n * @return {String} the resulting query string\n */\nfunction toQueryString(encode) {\n    var qs = ''\n        , params = this || {}\n        , encode = encode || encodeURIComponent;\n\n    __.eachKey.call(params, function(value, key) {\n        qs += key + '=' + encode(value) + '&';\n    });\n    \n    return qs.slice(0, -1);\n}\n\n\n/**\n * Convert url style query string (without \"?\") into object hash\n * \n * @param {String} self The string to be converted\n * @param {Function} decode optional decode function, decodeURIComponent will be used if not supplied\n * @return {Object} The resulting object hash\n */\nfunction fromQueryString(decode) {\n    var pairs = this.split('&')\n        , results = {}\n        , decode = decode || decodeURIComponent;\n\n    pairs.forEach(function(pair) {\n        var splitPair = pair.split('=');\n        if (splitPair.length < 2) return;\n        var key = splitPair[0]\n            , value = decode(splitPair[1] || '');\n        if (!key) return;\n        results[key] = value;\n    });\n\n    return results;\n}\n\n\n/**\n * Safe JSON.parse, returns undefined if JSON.parse throws an exception\n *\n * @param {String} self JSON string representation of object\n * @return {Object|undefined}\n */\nfunction jsonParse() {\n    try {\n        return JSON.parse(this);\n    } catch (e) {}\n}\n\n\n/**\n * Dan Bernstein's algorythm to create hash from string\n *\n * @param {String} self string to convert to hash\n * @return {Number}\n */\nfunction hashCode() {\n    var hash = 5381\n        , str = this\n        , len = str.length;\n    for (var i = 0; i < len; i++) {\n        var char = str.charCodeAt(i);\n        hash = ((hash << 5) + hash) + char; /* hash * 33 + c */\n    }\n    return hash;\n}\n\n\n/**\n * Removes given prefix from the string. If string does not begin from the prefix, returns undefined\n * \n * @param {String} self\n * @return {String}\n */\nfunction unPrefix(str) {\n    if (this.indexOf(str) == 0)\n        return this.replace(str, '');\n}\n\n\n/**\n * Regex used to identify format vars\n * @type {RegExp}\n */\nvar formatRegexp = /\\$[0-9]+|\\$\\$/g;\n\n/**\n * String formatting utility to swap out tokens for variables.\n * @param  {String} this The string to be formatted \n * @param  {Array}  args The values to be formatted\n * @return {String}      The formatted string\n */\nfunction format() { // , ... arguments\n    var str = this;\n    var args = arguments;\n    return str.replace(formatRegexp, function (item) {\n        if (item == '$$') return '$';\n        item = item.slice(1);\n        return args[item - 1];\n    });\n};\n",
    "'use strict';\n\n/**\n * - [times](#times)\n * - [repeat](#repeat)\n * - [tap](#tap)\n * - [result](#result)\n * - [identity](#identity)\n * - [property](#property)\n * - [compareProperty](#compareProperty)\n * - [noop](#noop)\n */\nvar utilMethods = module.exports = {\n    times: times,\n    repeat: repeat,\n    tap: tap,\n    result: result,\n    identity: identity,\n    property: property,\n    compareProperty: compareProperty,\n    noop: noop\n};\n\n\n/**\n * Calls `callback` `self` times with `thisArg` as context. Callback is passed iteration index from 0 to `self-1`\n * \n * @param {Integer} self\n * @param {Function} callback\n * @param {Any} thisArg\n * @return {Array}\n */\nfunction times(callback, thisArg) {\n    var arr = Array(Math.max(0, this));\n    for (var i = 0; i < this; i++)\n        arr[i] = callback.call(thisArg, i);\n    return arr;\n}\n\n\n/**\n * Returns array with the first argument repeated `times` times\n * @param  {Any} self\n * @param  {Integer} times\n * @return {Array}\n */\nfunction repeat(times) {\n    var arr = Array(Math.max(0, times));;\n    for (var i = 0; i < times; i++)\n        arr[i] = this;\n    return arr;\n}\n\n\n/**\n * Function to tap into chained methods and to inspect intermediary result\n *\n * @param {Any} self value that's passed between chained methods\n * @param {Function} func function that will be called with the value (both as context and as the first parameter)\n * @return {Any}\n */\nfunction tap(func) {\n    func.call(this, this);\n    return this;\n};\n\n\n/**\n * Calls function `self` (first parameter of _.result) with given context and arguments\n * \n * @param {Function|Any} self\n * @param {Any} thisArg context\n * @param {List} arguments extra arguments\n * @return {Any}\n */\nfunction result(thisArg) { //, arguments\n    var args = Array.prototype.slice.call(arguments, 1);\n    return typeof this == 'function'\n            ? this.apply(thisArg, args)\n            : this;\n}\n\n\n/**\n * Returns self. Useful for using as an iterator if the actual value needs to be returned. Unlike in underscore and lodash, this function is NOT used as default iterator.\n *\n * @param {Any} self \n * @return {Any}\n */\nfunction identity() {\n    return this;\n}\n\n\n/**\n * Returns function that picks the property from the object\n *\n * @param {String} self\n * @return {Function}\n */\nfunction property() {\n    var key = this;\n    return function(obj) {\n        return obj[key];\n    };\n}\n\n\n/**\n * Returns function that can be used in array sort to sort by a given property\n *\n * @param {String} self\n * @return {Function}\n */\nfunction compareProperty() {\n    var key = this;\n    return function(a, b) {\n        return a[key] < b[key]\n            ? -1\n            : a[key] > b[key]\n                ? 1\n                : 0;\n    };\n}\n\n\n/**\n * Function that does nothing\n */\nfunction noop() {}\n",
    "'use strict';\n\nvar utils = module.exports = {\n    makeProtoInstanceMethod: makeProtoInstanceMethod,\n    makeProtoFunction: makeProtoFunction,\n    makeFindMethod: makeFindMethod\n}\n\n\nfunction makeProtoInstanceMethod(method) {\n    return function() {\n        this.self = method.apply(this.self, arguments);\n        return this;\n    };\n}\n\n\nfunction makeProtoFunction(method) {\n    return function() {\n        // when the method is executed, the value of \"this\" will be arguments[0],\n        // other arguments starting from #1 will passed to method as parameters.\n        return method.call.apply(method, arguments);\n    };\n}\n\n\nvar _error = new Error;\n\n/**\n * Returns `find` or `findIndex` method, depending on parameter\n *\n * @param {Function} eachMethod - method to use for iteration (forEach for array or eachKey for object)\n * @param {String} findWhat 'value' - returns find method of Array (implemented in ES6) or findValue method of Object, anything else = returns findIndex/findKey methods.\n * @return {Function}\n */\nfunction makeFindMethod(someMethod, findWhat) {\n    var argIndex = findWhat == 'value' ? 0 : 1;\n\n    return function findValueOrIndex(callback, thisArg, onlyEnumerable) {\n        var foundValueOrIndex;\n        var found = someMethod.call(this, testItem, thisArg, onlyEnumerable);\n        if (found)\n            return foundValueOrIndex;\n        // if looking for index and not found, return -1\n        else if (argIndex && someMethod == Array.prototype.some)\n            return -1;\n\n        function testItem(value, index, self) {\n            var test = callback.call(this, value, index, self);\n            if (test) {\n                foundValueOrIndex = arguments[argIndex]\n                return test;\n            }\n        }\n    }\n}\n"
  ]
}