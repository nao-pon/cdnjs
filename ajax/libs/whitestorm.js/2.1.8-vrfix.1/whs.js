/* WhitestormJS Framework v2.1.8 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :
	typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :
	(factory((global.WHS = global.WHS || {}),global.THREE));
}(this, (function (exports,three) { 'use strict';

var extend = function extend(object) {
  for (var _len = arguments.length, extensions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    extensions[_key - 1] = arguments[_key];
  }

  // $.extend alternative, ... is the spread operator.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var extension = _step.value;

      // console.log(extension);
      // console.log(typeof extension);

      if (!extension) continue; // Ignore null and undefined objects and parameters.

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = Object.getOwnPropertyNames(extension)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var prop = _step2.value;
          // Do not traverse the prototype chain.
          if (object[prop] !== undefined && extension[prop] && object[prop].toString() === '[object Object]' && extension[prop].toString() === '[object Object]') {
            // Goes deep only if object[prop] and extension[prop] are both objects !
            if (object[prop].constructor === Object) extend(object[prop], extension[prop]);
          } else object[prop] = typeof object[prop] === 'undefined' ? extension[prop] : object[prop];

          if (typeof object[prop] === 'undefined' && Array.isArray(extension[prop])) object[prop] = extension[prop].slice(); // Add values that do not already exist.
          else if (typeof object[prop] === 'undefined' && Array.isArray(extension[prop])) object[prop] = extension[prop];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return object;
};

var instruct = function instruct(array, instArray) {
  var tempObject = {};

  for (var i = 0, max = instArray.length; i < max; i++) {
    var guide = instArray[i];

    tempObject[guide] = array[i];
  }

  return tempObject;
};

var transformData = function transformData(object, instructions) {
  for (var key in instructions) {
    if (Array.isArray(object[key])) object[key] = instruct(object[key], instructions[key]);else if (object[key] instanceof Object && !Array.isArray(instructions[key])) object[key] = transformData(object[key], instructions[key]);
  }

  return object;
};

var toArray = function toArray(object, instruction) {
  var tempArray = [];

  for (var i = 0, max = instruction.length; i < max; i++) {
    var guide = instruction[i];

    tempArray[i] = object[guide];
  }

  return tempArray;
};

var minivents_commonjs = function Events(target){
  var events = {}, empty = [];
  target = target || this;
  /**
   *  On: listen to events
   */
  target.on = function(type, func, ctx){
    (events[type] = events[type] || []).push([func, ctx]);
  };
  /**
   *  Off: stop listening to event / specific callback
   */
  target.off = function(type, func){
    type || (events = {});
    var list = events[type] || empty,
        i = list.length = func ? list.length : 0;
    while(i--) func == list[i][0] && list.splice(i,1);
  };
  /** 
   * Emit: send event, callbacks will be triggered
   */
  target.emit = function(type){
    var e = events[type] || empty, list = e.length > 0 ? e.slice(0, e.length) : e, i=0, j;
    while(j=list[i++]) j[0].apply(j[1], empty.slice.call(arguments, 1));
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var CompositionError = function (_Error) {
  inherits(CompositionError, _Error);

  function CompositionError(classInstance, message, component) {
    classCallCheck(this, CompositionError);

    var _this = possibleConstructorReturn(this, (CompositionError.__proto__ || Object.getPrototypeOf(CompositionError)).call(this, '@' + classInstance + ': ' + message));

    var stackArray = _this.stack.split('\n');
    stackArray.splice(1, 2);

    _this.stack = stackArray.join('\n');

    if (console) console.error('Component:', component);

    _this.name = 'CompositionError';
    return _this;
  }

  return CompositionError;
}(Error);

var DependencyError = function (_Error2) {
  inherits(DependencyError, _Error2);

  function DependencyError(classInstance, message, activeModule) {
    var dependencyModule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    classCallCheck(this, DependencyError);

    var _this2 = possibleConstructorReturn(this, (DependencyError.__proto__ || Object.getPrototypeOf(DependencyError)).call(this, '@' + classInstance + ': ' + message));

    var stackArray = _this2.stack.split('\n');
    stackArray.splice(1, 2);

    _this2.stack = stackArray.join('\n');

    if (console) console.error('Active module:', activeModule);
    if (console && dependencyModule) console.error('Dependency published by module:', dependencyModule);

    _this2.name = 'DependencyError';
    return _this2;
  }

  return DependencyError;
}(Error);

var ManagerError = function (_Error3) {
  inherits(ManagerError, _Error3);

  function ManagerError(classInstance, message, component) {
    var activeModule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    classCallCheck(this, ManagerError);

    var _this3 = possibleConstructorReturn(this, (ManagerError.__proto__ || Object.getPrototypeOf(ManagerError)).call(this, '@' + classInstance + ': ' + message));

    var stackArray = _this3.stack.split('\n');
    stackArray.splice(1, 2);

    _this3.stack = stackArray.join('\n');

    if (console) console.error('Component:', component);
    if (console && activeModule) console.error('Active module:', activeModule);

    _this3.name = 'ManagerError';
    return _this3;
  }

  return ManagerError;
}(Error);

// Check for Three.js
var warnDeps = function warnDeps() {
  throw new Error('WhitestormJS Framework requires Three.js r84. https://threejs.org/');
};

try {
  if (!three.REVISION) warnDeps();
} catch (err) {
  warnDeps();
}

/**
 * @class ModuleSystem
 * @category core
 * @description  Provides API for classes that will use Modules.<br/>
 * This class includes basic event system with those supported methods:
 * <pre>.on()</pre><pre>.off()</pre><pre>.emit()</pre>
 * @extends Events
 * @memberof module:core
 */

var ModuleSystem = function (_Events) {
  inherits(ModuleSystem, _Events);

  function ModuleSystem() {
    classCallCheck(this, ModuleSystem);
    return possibleConstructorReturn(this, (ModuleSystem.__proto__ || Object.getPrototypeOf(ModuleSystem)).apply(this, arguments));
  }

  createClass(ModuleSystem, [{
    key: 'integrateModules',

    // INTEGRATING

    /**
     * @method integrateModules
     * @instance
     * @description This method applies all modules from .modules collection.
     * @param {Object} [source] If source (should be a component) is provided, will replace .modules with source's one before executing modules.
     * @memberof module:core.ModuleSystem
     */
    value: function integrateModules(source) {
      if (!this.modules && !source) return;
      if (source && source.modules) this.modules = source.modules.slice(0);

      if (this.modules) {
        for (var i = 0, max = this.modules.length; i < max; i++) {
          this.applyModule(this.modules[i], false);
        }
      }

      if (source) this.applyBridge({ onCopy: source });
    }

    // APPLYING MODULE (...and a "bridge" for module)

    /**
     * @method applyBridge
     * @instance
     * @description Makes component-specific API to work with modules.
     * @param {Object} bridgeMap
     * @return {Object} Returns object with modified values.
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'applyBridge',
    value: function applyBridge() {
      var bridgeMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var modules = this.modules;
      if (!modules) return bridgeMap;

      for (var i = 0, max = modules.length; i < max; i++) {
        for (var key in bridgeMap) {
          if (bridgeMap[key]) {
            var module = modules[i];

            if (module && module.bridge && module.bridge[key]) bridgeMap[key] = module.bridge[key].apply(this, [bridgeMap[key], module]);
          }
        }
      }

      return bridgeMap;
    }

    /**
     * @method applyCommand
     * @instance
     * @description .applyCommand runs a method called `name` on all modules.
     * @param {String} name the method name.
     * @param {Function} [cb=(func, moduleScope) => func.apply(this, [moduleScope])] How the function is wrapped/
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'applyCommand',
    value: function applyCommand(name) {
      var _this2 = this;

      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (func, moduleScope) {
        return func.apply(_this2, [moduleScope]);
      };

      var modules = this.modules;
      if (!modules) return;

      for (var i = 0, max = modules.length; i < max; i++) {
        var module = modules[i];
        if (name in module) cb(module[name], module);
      }
    }

    /**
     * @method applyModule
     * @instance
     * @description .applyModule is also used in .integrateModules() function.
     * It does exactly what its name says (applies module to component or app).
     * @param {Object} module the module to apply
     * @param {Boolean} [push=true]
     * @return {Object} Returns module that was applied.
     * @throws {ManagerError}
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'applyModule',
    value: function applyModule(module) {
      var push = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!module) return;
      if (push && this.modules) this.modules.push(module);else if (push) this.modules = [module];

      if (this.manager) this.manager.active(module);

      if (module.manager && this.manager) module.manager(this.manager);else if (module.manager) {
        throw new ManagerError('Component', 'Module requires ModuleManager that is turned off for this component', this, module);
      }

      if (module.integrate) module.integrate.bind(this)(module);

      return module;
    }

    /**
     * @method disposeModules
     * @instance
     * @description Disposes of all modules
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'disposeModules',
    value: function disposeModules() {
      while (this.modules.length) {
        this.disposeModule(this.modules[0]);
      }
    }

    /**
     * @method disposeModule
     * @instance
     * @description Disposes of the given module
     * @param {Object} module the module to dispose
     * @return {Module} Returns module that was removed.
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'disposeModule',
    value: function disposeModule(module) {
      if (!module) return;

      this.modules.splice(this.modules.indexOf(module), 1);

      if (module.dispose) module.dispose.bind(this)(module);

      return module;
    }

    // PIPED METHOD

    /**
     * @method module
     * @instance
     * @description piped version of .applyModule().
     * @param {Object} module the module to apply
     * @return {this} returns this - app/component
     * @throws {ManagerError}
     * @memberof module:core.ModuleSystem
     * @example <caption>Piped modules</caption>
     * component
     *   .module(new Module1())
     *   .module(new Module2())
     *   .module(new Module3())
     */

  }, {
    key: 'module',
    value: function module(_module) {
      this.applyModule(_module);
      return this;
    }
  }]);
  return ModuleSystem;
}(minivents_commonjs);

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$1.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$1.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$2.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype;
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}

/* global window */
var root$2;

if (typeof self !== 'undefined') {
  root$2 = self;
} else if (typeof window !== 'undefined') {
  root$2 = window;
} else if (typeof global !== 'undefined') {
  root$2 = global;
} else if (typeof module !== 'undefined') {
  root$2 = module;
} else {
  root$2 = Function('return this')();
}

var result = symbolObservablePonyfill(root$2);

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[result] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[result] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (undefined !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

/**
 * @class ModuleManager
 * @category core
 * @param {Object} object handler
 * @description  Solves modules dependencies
 * @memberof module:core
 */
var ModuleManager = function () {
  function ModuleManager(object) {
    classCallCheck(this, ModuleManager);

    this.handler = object;
    this.currentModule = null;

    this.store = createStore(function () {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [{}, ''];
      var action = arguments[1];

      state[0][action.key] = action.data;
      state[1] = action.key;

      return state;
    });

    this.modules = {};
  }

  /**
   * @method active
   * @instance
   * @description Sets .currentModule to provided module.
   * @param {Object} module the module to make current
   * @memberof module:core.ModuleManager
   */


  createClass(ModuleManager, [{
    key: 'active',
    value: function active(module) {
      this.currentModule = module;
    }

    /**
     * @method reset
     * @instance
     * @description Set's .currentModule to null.
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.currentModule = null;
    }

    /**
     * @method define
     * @instance
     * @description Define the module in manager
     * @param name The module name
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'define',
    value: function define(name) {
      this.modules[name] = this.currentModule;
    }

    /**
     * @method use
     * @instance
     * @description Get the defined module from manager
     * @param name The module name
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'use',
    value: function use(name) {
      return this.modules[name];
    }

    /**
     * @method set
     * @instance
     * @description An alias for .add() <br/><br/>
     * Use this method if you know that you will overwrite existing dependency.<br/>
     * Use it in your app, but not in module that you provide to other people.
     * @param {String} key the key of the dependency
     * @param {Object} data the value of the dependency
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'set',
    value: function set$$1(key, data) {
      this.store.dispatch({
        type: 'ADD',
        key: key,
        data: data
      });
    }

    /**
     * @method get
     * @instance
     * @description Returns dependency in store object, by key.
     * @param {String} key the key of the dependency
     * @memberof module:core.ModuleManager
     * @return {Object|Module}
     * @throws {DependencyError} if dependency is not in the store
     * @example <caption>Get the 'hello' dependency</caption>
     * manager.get('hello'); // -> {world: true}
     */

  }, {
    key: 'get',
    value: function get$$1(key) {
      if (!this.store.getState()[0][key]) {
        throw new DependencyError('ModuleManager', 'Module requires \'' + key + '\' dependency', this.currentModule);
      }

      return this.store.getState()[0][key];
    }

    /**
     * @method has
     * @instance
     * @description Returns whether manager has a dependency with the given key
     * @param {String} key the key of the dependency
     * @memberof module:core.ModuleManager
     * @return {Boolean} Promise that is resolved when all promises completed.
     * @example <caption>Check whether the store has the 'hello' dependency</caption>
     * manager.has('hello'); // -> true
     */

  }, {
    key: 'has',
    value: function has(key) {
      return Boolean(this.store.getState()[0][key]);
    }

    /**
     * @method update
     * @instance
     * @description Updates deps
     * @param {Object} [depsMap={}]
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'update',
    value: function update() {
      var _this = this;

      var depsMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.store.subscribe(function () {
        var _store$getState = _this.store.getState(),
            _store$getState2 = slicedToArray(_store$getState, 2),
            data = _store$getState2[0],
            changedKey = _store$getState2[1];

        var callback = depsMap[changedKey];

        if (callback) callback(data[changedKey]);
      });
    }

    /**
     * @method add
     * @alias module:core.ModuleManager#set
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'add',
    value: function add() {
      console.warn('.add() method is deprecated. Use .set() instead');
      return this.set.apply(this, arguments);
    }

    /**
     * @method require
     * @instance
     * @description Require module
     * @param {String} name Defined name
     * @param {Function} moduleExecutor Function that returns applied module
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'require',
    value: function require(name, moduleExecutor) {
      if (this.use(name) === undefined) this.handler.applyModule(moduleExecutor());
    }
  }]);
  return ModuleManager;
}();

var _class;
var _temp;

/**
 * @class Component
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends ModuleSystem
 * @memberof module:core
 */
var Component = (_temp = _class = function (_ModuleSystem) {
  inherits(Component, _ModuleSystem);

  // For keeping children components;

  // Collection of promises;

  /**
   * Collection of `modules`.
   * @member {Array} module:core.Component#modules
   * @public
   */


  /**
   * Static instructions
   * @member {Object} module:core.Component#instructions
   * @static
   * @default {}
   */
  function Component() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Component.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Component.instructions;
    classCallCheck(this, Component);

    // Apply polyfilled parameters to .params;
    var _this = possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this));

    _this._wait = [];
    _this.modules = [];
    _this.children = [];
    _this.params = extend(transformData(params, instructions), defaults$$1);
    if (_this.params.manager) _this.manager = new ModuleManager(_this);

    _this.modules = _this.params.modules;

    _this.integrateModules();
    return _this;
  }

  /**
   * @method wait
   * @instance
   * @description Wait for a promise.
   * @param {Promise} [promise] - The promise that should be added to a queue.
   * @return {Promise} Promise that is resolved when all promises completed.
   * @memberof module:core.Component
   */
  // Collection of modules;

  /**
   * Collection of `child` Components.
   * @member {Array} module:core.Component#children
   * @public
   */


  /**
   * Array of promises that should be resolved before Component is ready.
   * @member {Array} module:core.Component#_wait
   * @private
   */

  /**
   * Default values for parameters
   * @member {Object} module:core.Component#defaults
   * @static
   * @default {
   *   modules: [],
   *   manager: true
   * }
   */


  createClass(Component, [{
    key: 'wait',
    value: function wait(promise) {
      if (promise) this._wait.push(promise);
      return Promise.all(this._wait);
    }

    /**
     * @method defer
     * @instance
     * @description Execute `func` (Callback) when Component is ready.
     * @param {Function} func - Callback.
     * @memberof module:core.Component
     */

  }, {
    key: 'defer',
    value: function defer(func) {
      var _this2 = this;

      if (this.isDeffered) this.wait().then(function () {
        return func(_this2);
      });else func(this);
    }

    // PARAMETERS

    /**
     * @method updateParams
     * @instance
     * @description Updates parameters of the Component.
     * @return {Object} Params of this Component
     * @memberof module:core.Component
     */

  }, {
    key: 'updateParams',
    value: function updateParams() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.params = extend(params, this.params);
      return this.params;
    }

    // COPYING & CLONING

    /**
     * @method clone
     * @instance
     * @description Clone this component
     * @return {object} a cloned component with all its source component' params copied.
     * @memberof module:core.Component
     */

  }, {
    key: 'clone',
    value: function clone() {
      return new this.constructor(this.params).copy(this);
    }

    /**
     * @method copy
     * @instance
     * @description Copy source native and integrate `modules` to it.
     * @param {Component} source - Source component that is used for `copy()` action.
     * @param {Function} [customize] - Callback executed before modules integration process.
     * @return {this} Component
     * @memberof module:core.Component
     */

  }, {
    key: 'copy',
    value: function copy(source, customize) {
      this.params = _extends({}, source.params);

      if (source.native) this.native = source.native.clone(source.params);
      if (customize) customize();
      this.integrateModules(source);

      return this;
    }

    /**
     * @method add
     * @instance
     * @description Add a child `Component`.
     * @param {Component} object - Component that should be added as a `child`.
     * @return {Promise} Resolved when action is done.
     * @memberof module:core.Component
     */

  }, {
    key: 'add',
    value: function add(object) {
      var _this3 = this;

      object.parent = this;

      return new Promise(function (resolve, reject) {
        _this3.defer(function () {
          var native = object.native;

          if (!native) reject();

          var addPromise = _this3.applyBridge({ onAdd: object }).onAdd;

          var resolver = function resolver() {
            _this3.native.add(native);
            _this3.children.push(object);

            resolve(object);
          };

          if (addPromise instanceof Promise) addPromise.then(resolver);else resolver();
        });
      });
    }

    /**
     * @method remove
     * @instance
     * @description Remove a child `Component`.
     * @param {Component} object - Component that should be a **child** of this Component.
     * @memberof module:core.Component
     */

  }, {
    key: 'remove',
    value: function remove(object) {
      object.parent = null;
      this.native.remove(object.native);
    }

    /**
     * @method addTo
     * @instance
     * @description Adds `this` Component to specified `App`/`Component`.
     * @param {Component} object - Component that will be a parent of `this`.
     * @memberof module:core.Component
     */

  }, {
    key: 'addTo',
    value: function addTo(object) {
      return object.add(this);
    }

    /**
     * Returns whether the object is `async` (`wait` promises are more than `0`).
     * @member {Boolean} module:core.Component#isDeffered
     */

  }, {
    key: 'isDeffered',
    get: function get$$1() {
      return this._wait.length > 0;
    }

    /**
     * Returns the `ModuleManager` used for this component.
     * @member {ModuleManager} module:core.Component#manager
     * @throws {ManagerError}
     */

  }, {
    key: 'manager',
    get: function get$$1() {
      if (this._manager) return this._manager;

      throw new ManagerError('Component', 'ModuleManager is not used in this component. \'manager\' parameter should be set as \'true\'', this);
    },
    set: function set$$1(manager) {
      this._manager = manager;
    }

    /**
     * Returns the `native` object used for this component.
     * @member {Object} module:core.Component#native
     */

  }, {
    key: 'native',
    get: function get$$1() {
      return this._native;
    },
    set: function set$$1(mesh) {
      this._native = mesh;
      this._native.component = this;
      return this._native;
    }
  }]);
  return Component;
}(ModuleSystem), _class.defaults = {
  modules: null,
  manager: true
}, _class.instructions = {}, _temp);

function attributes() {
  for (var _len = arguments.length, mappers = Array(_len), _key = 0; _key < _len; _key++) {
    mappers[_key] = arguments[_key];
  }

  return function (target) {
    for (var i = 0; i < mappers.length; i++) {
      var mapper = mappers[i];

      for (var k = 0; k < mapper.map.length; k++) {
        var attribute = mapper.map[k];

        Object.defineProperty(target.prototype, attribute, {
          get: mapper.getter(attribute),
          set: mapper.setter(attribute),
          configurable: mapper.configurable,
          enumerable: mapper.enumerable
        });
      }
    }
  };
}

function copy() {
  for (var _len2 = arguments.length, map = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    map[_key2] = arguments[_key2];
  }

  return {
    map: map,
    getter: function getter(name) {
      return function () {
        return this.native[name];
      };
    },
    setter: function setter(name) {
      return function (value) {
        this.native[name].copy(value);
      };
    },

    configurable: true,
    enumerable: true
  };
}

function mirror() {
  for (var _len3 = arguments.length, map = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    map[_key3] = arguments[_key3];
  }

  return {
    map: map,
    getter: function getter(name) {
      return function () {
        return this.native[name];
      };
    },
    setter: function setter(name) {
      return function (value) {
        this.native[name] = value;
      };
    },

    configurable: true,
    enumerable: true
  };
}

var _dec;
var _class$1;
var _class2;
var _temp$1;

/**
 * @class MeshComponent
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends module:core.Component
 * @memberof module:core
 */
var MeshComponent = (_dec = attributes(copy('position', 'rotation', 'quaternion', 'scale'), mirror('material', 'geometry')), _dec(_class$1 = (_temp$1 = _class2 = function (_Component) {
  inherits(MeshComponent, _Component);
  createClass(MeshComponent, null, [{
    key: 'custom',


    // CUSTOM GEOMETRY HANDLING

    /**
     * Default values for parameters
     * @member {Object} module:core.MeshComponent#defaults
     * @static
     * @default
     * {
     *   build: true,
     *   geometry: {},
     *   material: false,
     *
     *   shadow: {
     *     cast: true,
     *     receive: true
     *   },
     *
     *   position: {x: 0, y: 0, z: 0},
     *   rotation: {x: 0, y: 0, z: 0},
     *   scale: {x: 1, y: 1, z: 1}
     * }
     */
    value: function custom(geom) {
      var constructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : three.Mesh;

      return function (_MeshComponent) {
        inherits(_class3, _MeshComponent);

        function _class3() {
          classCallCheck(this, _class3);
          return possibleConstructorReturn(this, (_class3.__proto__ || Object.getPrototypeOf(_class3)).apply(this, arguments));
        }

        createClass(_class3, [{
          key: 'build',
          value: function build() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

            var _applyBridge = this.applyBridge({
              geometry: geom,
              material: params.material
            }),
                geometry = _applyBridge.geometry,
                material = _applyBridge.material;

            return this.applyBridge({ mesh: new constructor(geometry, material) }).mesh;
          }
        }]);
        return _class3;
      }(MeshComponent);
    }

    /**
     * Static instructions
     * @member {Object} module:core.MeshComponent#instructions
     * @static
     * @default
     * {
     *   position: ['x', 'y', 'z'],
     *   rotation: ['x', 'y', 'z'],
     *   scale: ['x', 'y', 'z']
     * }
     */

  }, {
    key: 'create',
    value: function create(geom, params, constructor) {
      return new (MeshComponent.custom(geom, constructor))(params);
    }
  }, {
    key: 'from',
    value: function from(mesh) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      params.build = false;

      var component = new MeshComponent(params);

      component.native = mesh;
      component.wrap();

      return component;
    }
  }]);

  function MeshComponent(params) {
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MeshComponent.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MeshComponent.instructions;
    classCallCheck(this, MeshComponent);

    var _this = possibleConstructorReturn(this, (MeshComponent.__proto__ || Object.getPrototypeOf(MeshComponent)).call(this, params, defaults$$1, instructions));

    if (_this.params.build) {
      var build = _this.build(_this.params);

      if (!build) {
        throw new CompositionError('MeshComponent', '.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.', _this);
      }

      if (build instanceof Promise) {
        _this.wait(build);

        _this.wait(new Promise(function (resolve) {
          build.then(function (native) {
            _this.native = native;
            _this.wrap().then(resolve);
          });
        }));
      } else {
        _this.native = build;
        _this.wait(_this.wrap());
      }
    }

    _this.applyCommand('postIntegrate');
    return _this;
  }

  // BUILDING & WRAPPING

  /**
   * @method build
   * @description Build livecycle should return a native object.
   * @throws {CompositionError}
   * @memberof module:core.MeshComponent
   */


  createClass(MeshComponent, [{
    key: 'build',
    value: function build() {
      throw new CompositionError('MeshComponent', 'Instance should have it\'s own .build().', this);
    }

    /**
     * @method wrap
     * @instance
     * @description Wraps transforms (`position` & `rotation`)
     * @return {Promise} Resolved when action is completed
     * @memberof module:core.MeshComponent
     */

  }, {
    key: 'wrap',
    value: function wrap() {
      var _this3 = this;

      return new Promise(function (resolve) {
        // TODO: Fix defer with physics
        // this.defer(() => {
        var _params = _this3.params,
            position = _params.position,
            rotation = _params.rotation,
            scale = _params.scale,
            shadow = _params.shadow;


        _this3.position.set(position.x, position.y, position.z);
        _this3.rotation.set(rotation.x, rotation.y, rotation.z);
        _this3.scale.set(scale.x, scale.y, scale.z);

        _this3.native.castShadow = shadow.cast;
        _this3.native.receiveShadow = shadow.receive;

        _this3.applyBridge({ onWrap: 1 });

        resolve(_this3);
        // });
      });
    }

    // COPYING & CLONING

    /**
     * @method copy
     * @instance
     * @description Copy source transforms & execute `Component.copy()`
     * @return {this} MeshComponent
     * @memberof module:core.MeshComponent
     */

  }, {
    key: 'copy',
    value: function copy$$1(source) {
      var _this4 = this;

      return get(MeshComponent.prototype.__proto__ || Object.getPrototypeOf(MeshComponent.prototype), 'copy', this).call(this, source, function () {
        _this4.position.copy(source.position);
        _this4.rotation.copy(source.rotation);
        _this4.quaternion.copy(source.quaternion);
      });
    }

    /**
     * @method clone
     * @instance
     * @description Make a clone of this MeshComponent using `.copy()`
     * @return {MeshComponent} clone of this object
     * @memberof module:core.MeshComponent
     */

  }, {
    key: 'clone',
    value: function clone(geometry, material) {
      var dest = new this.constructor({ build: false }).copy(this);

      if (geometry) dest.geometry = dest.geometry.clone();
      if (material) dest.material = dest.material.clone();

      return dest;
    }
  }]);
  return MeshComponent;
}(Component), _class2.defaults = _extends({}, Component.defaults, {

  build: true,
  geometry: {},
  material: false,

  shadow: {
    cast: true,
    receive: true
  },

  position: { x: 0, y: 0, z: 0 },
  rotation: { x: 0, y: 0, z: 0 },
  scale: { x: 1, y: 1, z: 1 }
}), _class2.instructions = {
  position: ['x', 'y', 'z'],
  rotation: ['x', 'y', 'z'],
  scale: ['x', 'y', 'z']
}, _temp$1)) || _class$1);

var _dec$1;
var _class$2;
var _class2$1;
var _temp$2;

/**
 * @class LightComponent
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends module:core.Component
 * @memberof module:core
 */
var LightComponent = (_dec$1 = attributes(copy('position', 'rotation', 'quaternion', 'target')), _dec$1(_class$2 = (_temp$2 = _class2$1 = function (_Component) {
  inherits(LightComponent, _Component);
  createClass(LightComponent, null, [{
    key: 'from',

    /**
     * Default values for parameters
     * @member {Object} module:core.LightComponent#defaults
     * @static
     * @default
     * {
     *   build: true,
     *
     *   shadow: {
     *     cast: true,
     *
     *     bias: 0,
     *     radius: 1,
     *
     *     mapSize: {
     *       width: 1024,
     *       height: 1024
     *     },
     *
     *     camera: {
     *       near: true,
     *       far: 400,
     *       fov: 90,
     *
     *       top: 200,
     *       bottom: -200,
     *       left: -200,
     *       right: 200
     *     }
     *   },
     *
     *   position: {x: 0, y: 0, z: 0},
     *   rotation: {x: 0, y: 0, z: 0}
     * }
     */
    value: function from(light) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var wrapShadow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      params.build = false;

      var component = new LightComponent(params);

      component.native = light;
      component.wrap();
      if (wrapShadow) component.wrapShadow();

      return component;
    }

    /**
     * Static instructions
     * @member {Object} module:core.LightComponent#instructions
     * @static
     * @default
     * {
     *   position: ['x', 'y', 'z'],
     *   rotation: ['x', 'y', 'z']
     * }
     */

  }]);

  function LightComponent(params) {
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LightComponent.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : LightComponent.instructions;
    classCallCheck(this, LightComponent);

    var _this = possibleConstructorReturn(this, (LightComponent.__proto__ || Object.getPrototypeOf(LightComponent)).call(this, params, defaults$$1, instructions));

    if (_this.params.build) {
      var build = _this.build(_this.params);

      if (!build) {
        throw new CompositionError('LightComponent', '.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.', _this);
      }

      if (build instanceof Promise) {
        build.then(function (native) {
          _this.native = native;
        });
      } else _this.native = build;

      _this.wait(_this.wrap());
    }

    _this.applyCommand('postIntegrate');
    return _this;
  }

  // BUILDING & WRAPPING

  /**
   * @method build
   * @instance
   * @description Build livecycle should return a native object.
   * @throws {CompositionError}
   * @memberof module:core.LightComponent
   */


  createClass(LightComponent, [{
    key: 'build',
    value: function build() {
      throw new CompositionError('MeshComponent', 'Instance should have it\'s own .build().', this);
    }

    /**
     * @method wrap
     * @instance
     * @description Wraps transforms (`position` & `rotation`)
     * @return {Promise} Resolved when action is completed
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'wrap',
    value: function wrap() {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.defer(function () {
          var _params = _this2.params,
              position = _params.position,
              rotation = _params.rotation;


          _this2.position.set(position.x, position.y, position.z);
          _this2.rotation.set(rotation.x, rotation.y, rotation.z);

          _this2.applyBridge({ onWrap: 1 });

          resolve(_this2);
        });
      });
    }

    /**
     * @method wrapShadow
     * @instance
     * @description Wraps shadow properties
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'wrapShadow',
    value: function wrapShadow() {
      var native = this.native,
          shadow = this.params.shadow;


      native.castShadow = shadow.cast;
      native.shadow.mapSize.width = shadow.mapSize.width;
      native.shadow.mapSize.height = shadow.mapSize.height;
      native.shadow.bias = shadow.bias;
      native.shadow.radius = shadow.radius;

      var shadowCamera = native.shadow.camera;
      var camera = shadow.camera;

      shadowCamera.near = camera.near;
      shadowCamera.far = camera.far;
      shadowCamera.fov = camera.fov;

      shadowCamera.left = camera.left;
      shadowCamera.right = camera.right;
      shadowCamera.top = camera.top;
      shadowCamera.bottom = camera.bottom;
    }

    // COPYING & CLONING

    /**
     * @method copy
     * @instance
     * @description Copy source transforms & execute `Component.copy()`
     * @return {this} LightComponent
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'copy',
    value: function copy$$1(source) {
      var _this3 = this;

      return get(LightComponent.prototype.__proto__ || Object.getPrototypeOf(LightComponent.prototype), 'copy', this).call(this, source, function () {
        if (_this3.target) _this3.target.copy(source.target());

        _this3.position.copy(source.position);
        _this3.rotation.copy(source.rotation);
        _this3.quaternion.copy(source.quaternion);
      });
    }

    /**
     * @method clone
     * @instance
     * @description Make a clone of this LightComponent using `.copy()`
     * @return {LightComponent} clone of this object
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'clone',
    value: function clone() {
      return new this.constructor({ build: false }).copy(this);
    }
  }]);
  return LightComponent;
}(Component), _class2$1.defaults = _extends({}, Component.defaults, {

  build: true,

  shadow: {
    cast: true,

    bias: 0,
    radius: 1,

    mapSize: {
      width: 1024,
      height: 1024
    },

    camera: {
      near: true,
      far: 400,
      fov: 90,

      top: 200,
      bottom: -200,
      left: -200,
      right: 200
    }
  },

  position: { x: 0, y: 0, z: 0 },
  rotation: { x: 0, y: 0, z: 0 }
}), _class2$1.instructions = {
  position: ['x', 'y', 'z'],
  rotation: ['x', 'y', 'z']
}, _temp$2)) || _class$2);

var _dec$2;
var _class$3;
var _class2$2;
var _temp$3;

/**
 * @class CameraComponent
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends module:core.Component
 * @memberof module:core
 */
var CameraComponent = (_dec$2 = attributes(copy('position', 'rotation', 'quaternion', 'target')), _dec$2(_class$3 = (_temp$3 = _class2$2 = function (_Component) {
  inherits(CameraComponent, _Component);
  createClass(CameraComponent, null, [{
    key: 'from',

    /**
     * Default values for parameters
     * @member {Object} module:core.CameraComponent#defaults
     * @static
     * @default
     * {
     *   build: true,
     *
     *   position: {x: 0, y: 0, z: 0},
     *   rotation: {x: 0, y: 0, z: 0}
     * }
     */
    value: function from(camera) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      params.build = false;

      var component = new CameraComponent(params);

      component.native = camera;
      component.wrap();

      return component;
    }

    /**
     * Static instructions
     * @member {Object} module:core.CameraComponent#instructions
     * @static
     * @default
     * {
     *   position: ['x', 'y', 'z'],
     *   rotation: ['x', 'y', 'z'],
     *   scale: ['x', 'y', 'z']
     * }
     */

  }]);

  function CameraComponent(params) {
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CameraComponent.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CameraComponent.instructions;
    classCallCheck(this, CameraComponent);

    var _this = possibleConstructorReturn(this, (CameraComponent.__proto__ || Object.getPrototypeOf(CameraComponent)).call(this, params, defaults$$1, instructions));

    if (_this.params.build) {
      var build = _this.build(_this.params);

      if (!build) {
        throw new CompositionError('CameraComponent', '.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.', _this);
      }

      if (build instanceof Promise) {
        build.then(function (native) {
          _this.native = native;
        });
      } else _this.native = build;

      _this.wait(_this.wrap());
    }

    _this.applyCommand('postIntegrate');
    return _this;
  }

  // BUILDING & WRAPPING

  /**
   * @method build
   * @instance
   * @description Build livecycle should return a native object.
   * @throws {CompositionError}
   * @memberof module:core.CameraComponent
   */


  createClass(CameraComponent, [{
    key: 'build',
    value: function build() {
      throw new CompositionError('CameraComponent', 'Instance should have it\'s own .build().', this);
    }

    /**
     * @method wrap
     * @instance
     * @description Wraps transforms (`position` & `rotation`)
     * @return {Promise} Resolved when action is completed
     * @memberof module:core.CameraComponent
     */

  }, {
    key: 'wrap',
    value: function wrap() {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.defer(function () {
          _this2.position.set(_this2.params.position.x, _this2.params.position.y, _this2.params.position.z);
          _this2.rotation.set(_this2.params.rotation.x, _this2.params.rotation.y, _this2.params.rotation.z);

          _this2.applyBridge({ onWrap: 1 });

          resolve(_this2);
        });
      });
    }

    /**
     * @method copy
     * @instance
     * @description Copy source transforms & execute `Component.copy()`
     * @return {this} CameraComponent
     * @memberof module:core.CameraComponent
     */

  }, {
    key: 'copy',
    value: function copy$$1(source) {
      var _this3 = this;

      return get(CameraComponent.prototype.__proto__ || Object.getPrototypeOf(CameraComponent.prototype), 'copy', this).call(this, source, function () {
        if (_this3.target) _this3.target.copy(source.target());

        _this3.position.copy(source.position);
        _this3.rotation.copy(source.rotation);
        _this3.quaternion.copy(source.quaternion);
      });
    }

    /**
     * @method clone
     * @instance
     * @description Make a clone of this CameraComponent using `.copy()`
     * @return {CameraComponent} clone of this object
     * @memberof module:core.CameraComponent
     */

  }, {
    key: 'clone',
    value: function clone() {
      return new this.constructor({ build: false }).copy(this);
    }
  }]);
  return CameraComponent;
}(Component), _class2$2.defaults = _extends({}, Component.defaults, {

  build: true,

  position: { x: 0, y: 0, z: 0 },
  rotation: { x: 0, y: 0, z: 0 }
}), _class2$2.instructions = {
  position: ['x', 'y', 'z'],
  rotation: ['x', 'y', 'z'],
  scale: ['x', 'y', 'z']
}, _temp$3)) || _class$3);

const version = "2.1.8";

var system = {
  window: typeof window === 'undefined' ? global : window
};

/**
 * @class App
 * @category core
 * @description This component is used to prepare a world scene, setup physics, camera, renderer and all other things that you usually do before making meshes.
 * @param {Array} [modules=[]] - Array of Modules
 * @extends ModuleSystem
 * @memberof module:core
 */

var App = function (_ModuleSystem) {
  inherits(App, _ModuleSystem);

  /**
   * @description Defines whether the scene should render or not
   * @member {Boolean} module:core.App#enabled
   * @public
   */
  function App() {
    var modules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, App);

    console.log('WHS.App ' + version);

    var _this = possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this));

    _this.enabled = true;
    _this.loops = [];

    _this.manager = new ModuleManager(_this);
    _this.modules = modules;

    _this.integrateModules();
    return _this;
  }

  // CONTROLS & UPDATING

  /**
   * @method start
   * @description Start rendering loop and physics simulation (if you use version with physics).
   * @memberof module:core.App
   */


  /**
   * Loops in this app
   * @description Array of loops that are executed by this app.
   * @member {Array} module:core.App#loops
   * @public
   */


  createClass(App, [{
    key: 'start',
    value: function start() {
      var requestAnimFrame = function () {
        return system.window.requestAnimationFrame || system.window.webkitRequestAnimationFrame || system.window.mozRequestAnimationFrame || function (callback) {
          system.window.setTimeout(callback, 1000 / 60);
        };
      }();

      var loops = this.loops,
          enabled = this.enabled;


      function process() {
        requestAnimFrame(process);
        if (!enabled) return;

        for (var i = 0, ll = loops.length; i < ll; i++) {
          var e = loops[i];
          if (e.enabled) e.execute(e.clock);
        }
      }

      this.enabled = true;
      process();
    }

    /**
     * @method stop
     * @description Stops rendering loops
     * @memberof module:core.App
     */

  }, {
    key: 'stop',
    value: function stop() {
      this.enabled = false;
    }

    /**
     * @method addLoop
     * @description Adds loop to this app.
     * @param {Object} loop - the loop to add
     * @return {Promise} Promise that is resolved when promises completed.
     * @memberof module:core.App
     * @example <caption>Adding a loop to an app</caption>
     * const loop = new Loop(() => {
     *  // ...
     * });
     *
     * const app = new App();
     *
     * app.addLoop(loop);
     * loop.start();
     */

  }, {
    key: 'addLoop',
    value: function addLoop(loop) {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.loops.push(loop);
        resolve(loop);
      });
    }

    /**
     * @method removeLoop
     * @description Removes loop from this app.
     * @param {Object} loop - the loop to remove
     * @return {Promise} Promise that is resolved when promises completed.
     * @memberof module:core.App
     */

  }, {
    key: 'removeLoop',
    value: function removeLoop(loop) {
      var _this3 = this;

      return new Promise(function (resolve) {
        var index = _this3.loops.indexOf(loop);
        if (index !== -1) _this3.loops.splice(index, 1);

        resolve(loop);
      });
    }
  }, {
    key: 'get',
    value: function get$$1(key) {
      return this.manager.get(key);
    }
  }, {
    key: 'use',
    value: function use(key) {
      return this.manager.use(key);
    }
  }]);
  return App;
}(ModuleSystem);

/**
 * @class Loop
 * @category core
 * @param {Function} func function to execute on each animation frame
 * @param {Boolean} [useClock=true] passes a Clock to the function when called, if true
 * @memberof module:core
 */

var Loop = function () {
  function Loop(func) {
    var useClock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    classCallCheck(this, Loop);

    this.func = func;
    this.clock = useClock ? new three.Clock() : null;
    this.enabled = false;
  }

  // CONTROLS

  /**
   * @method start
   * @instance
   * @description Starts this loop, clock if it has one. Won't do anything if loop enabled already.
   * @param {Component} [world] app to add this loop to, if provided.
   * @memberof module:core.Loop
   */


  createClass(Loop, [{
    key: 'start',
    value: function start(world) {
      if (this.enabled) return;

      if (world) world.addLoop(this);

      if (this.clock) this.clock.start();
      this.enabled = true;
    }

    /**
     * @method stop
     * @instance
     * @description Stops this loop and its clock if it has one, won't do anything if this loop is not enabled)
     * @param {Component} [world] app to remove this loop from, if provided.
     * @memberof module:core.Loop
     */

  }, {
    key: 'stop',
    value: function stop(world) {
      if (!this.enabled) return;

      if (this.clock) this.clock.stop();
      this.enabled = false;

      if (world) world.removeLoop(this);
    }

    // EXECUTION

    /**
     * @method execute
     * @instance
     * @description Executes the function of this loop
     * @memberof module:core.Loop
     * @returns {*} whatever the function of this loop returns
     */

  }, {
    key: 'execute',
    value: function execute() {
      return this.func(this.clock);
    }
  }]);
  return Loop;
}();

/** @module core */

var _class$4;
var _temp$4;

/**
 * @class AmbientLight
 * @category components/lights
 * @description AmbientLight is a simple class, it extends Light and inherits all its methods.
 * AmbientLight creates basic light around all scene, so it doesn't need properties like pos or target.
 * It supports only color and intensity as parameters, which defines the color of the surrounded light and intensity of light.
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating an AmbientLight </caption>
 * new AmbientLight({
 *   color: 0xffffff,
 *   intensity: 0.2
 * }).addTo(world);
 */
var AmbientLight$1 = (_temp$4 = _class$4 = function (_LightComponent) {
  inherits(AmbientLight$$1, _LightComponent);

  function AmbientLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AmbientLight$$1);
    return possibleConstructorReturn(this, (AmbientLight$$1.__proto__ || Object.getPrototypeOf(AmbientLight$$1)).call(this, params, AmbientLight$$1.defaults));
  }

  createClass(AmbientLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new three.AmbientLight(params.color, params.intensity) }).light;
    }
  }]);
  return AmbientLight$$1;
}(LightComponent), _class$4.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1
}), _temp$4);

var _class$5;
var _temp$5;

/**
 * @class DirectionalLight
 * @category components/lights
 * @description DirectinalLight creates a light that shines from a specific direction not from a specific position.<br/><br/>
 * This light will behave as though it is infinitely far away and the rays produced from it are all parallel. <br/><br/>
 * The best analogy would be a light source that acts like the sun: the sun is so far away that all sunlight hitting objects comes from the same angle.<br/><br/>
 * It has the same options as AmbientLight in light paramater, but it also supports pos and target paramaters.
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a DirectionalLight to fall down from vec3(10, 20, 10) to vec3(0, 0, 0)</caption>
 * new DirectionalLight({
 *   color: 0xffffff,
 *   intensity: 0.2,
 *
 *   position: [10, 20, 10]
 * }).addTo(app);
 */
var DirectionalLight$1 = (_temp$5 = _class$5 = function (_LightComponent) {
  inherits(DirectionalLight$$1, _LightComponent);

  function DirectionalLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DirectionalLight$$1);

    var _this = possibleConstructorReturn(this, (DirectionalLight$$1.__proto__ || Object.getPrototypeOf(DirectionalLight$$1)).call(this, params, DirectionalLight$$1.defaults));

    _this.wrapShadow();
    return _this;
  }

  createClass(DirectionalLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new three.DirectionalLight(params.color, params.intensity) }).light;
    }
  }]);
  return DirectionalLight$$1;
}(LightComponent), _class$5.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1
}), _temp$5);

var _class$6;
var _temp$6;

/**
 * @class HemisphereLight
 * @category components/lights
 * @description HemisphereLight is a light source positioned directly above the scene.<br/>
 * It also doesn't need position and target properties.
 * @classDesc
 * <iframe src="https://threejs.org/examples/webgl_lights_hemisphere.html"></iframe>
 * @param {Object} [params={light: {skyColor: 0xffffff, groundColor: 0xffffff, intensity: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a HemisphereLight</caption>
 * new HemisphereLight({
 *   skyColor: 0xff0000,
 *   groundColor: 0x0000ff,
 *   intensity: 0.2
 * }).addTo(app);
 */
var HemisphereLight$1 = (_temp$6 = _class$6 = function (_LightComponent) {
  inherits(HemisphereLight$$1, _LightComponent);

  function HemisphereLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, HemisphereLight$$1);
    return possibleConstructorReturn(this, (HemisphereLight$$1.__proto__ || Object.getPrototypeOf(HemisphereLight$$1)).call(this, params, HemisphereLight$$1.defaults));
  }

  createClass(HemisphereLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new three.HemisphereLight(params.skyColor, params.groundColor, params.intensity) }).light;
    }
  }]);
  return HemisphereLight$$1;
}(LightComponent), _class$6.defaults = _extends({}, LightComponent.defaults, {

  skyColor: 0xffffff,
  groundColor: 0xffffff,
  intensity: 1
}), _temp$6);

var _class$7;
var _temp$7;

/**
 * @class PointLight
 * @category components/lights
 * @description PointLight creates a light at a specific position in the scene. The light shines in all directions (roughly similar to a light bulb.)<br/><br/>
 * It has the same options as AmbientLight in light paramater, but it also supports position, distance and decay.<br/>
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1, distance: 100, decay: 1}}] - The params.
 * @extends LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a PointLight</caption>
 * new PointLight( {
 *   color: 0xff0000,
 *   intensity: 2,
 *   distance: 300
 *
 *   position: [10, 20, 10]
 * }).addTo(app);
 */
var PointLight$1 = (_temp$7 = _class$7 = function (_LightComponent) {
  inherits(PointLight$$1, _LightComponent);

  function PointLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, PointLight$$1);

    var _this = possibleConstructorReturn(this, (PointLight$$1.__proto__ || Object.getPrototypeOf(PointLight$$1)).call(this, params, PointLight$$1.defaults));

    _this.wrapShadow();
    return _this;
  }

  createClass(PointLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new three.PointLight(params.color, params.intensity, params.distance, params.decay) }).light;
    }
  }]);
  return PointLight$$1;
}(LightComponent), _class$7.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1,
  distance: 100,
  decay: 1
}), _temp$7);

var _class$8;
var _temp$8;

/**
 * @class SpotLight
 * @category components/lights
 * @description SpotLight creates spot light that can cast shadow in one direction. <br/><br/>
 * It has the same parameters as AmbientLight in light, but it also supports pos and target. <br/><br/>
 * SpotLight affects meshes with lambert and phong material.
 * @classDesc
 * <iframe src="https://threejs.org/examples/webgl_lights_spotlight.html"></iframe>
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1, distance: 100, angle: Math.PI / 3, exponent: 0, decay: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a SpotLight that falls down from vec3(10, 20, 10) to vec3(0, 0, 0)</caption>
 * new SpotLight({
 *   color: 0x00ff00,
 *   intensity: 3,
 *   distance: 1000
 *
 *   position: [10, 20, 10]
 * }).addTo(app);
 */
var SpotLight$1 = (_temp$8 = _class$8 = function (_LightComponent) {
  inherits(SpotLight$$1, _LightComponent);

  function SpotLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, SpotLight$$1);

    var _this = possibleConstructorReturn(this, (SpotLight$$1.__proto__ || Object.getPrototypeOf(SpotLight$$1)).call(this, params, SpotLight$$1.defaults));

    _this.wrapShadow();
    return _this;
  }

  createClass(SpotLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new three.SpotLight(params.color, params.intensity, params.distance, params.angle, params.exponent, params.decay) }).light;
    }
  }]);
  return SpotLight$$1;
}(LightComponent), _class$8.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1,
  distance: 100,
  angle: Math.PI / 3,
  exponent: 0,
  decay: 1
}), _temp$8);

var _class$9;
var _temp$9;

var AreaLight = (_temp$9 = _class$9 = function (_LightComponent) {
  inherits(AreaLight, _LightComponent);

  function AreaLight() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AreaLight);
    return possibleConstructorReturn(this, (AreaLight.__proto__ || Object.getPrototypeOf(AreaLight)).call(this, params, AreaLight.defaults));
  }

  createClass(AreaLight, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new three.RectAreaLight(params.color, params.intensity, params.width, params.height) }).light;
    }
  }]);
  return AreaLight;
}(LightComponent), _class$9.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1,
  width: 10,
  height: 10
}), _temp$9);

/** @module components/lights */

var _class$10;
var _temp$10;

/**
 * @class CubeCamera
 * @category components/cameras
 * @description Creates 6 cameras that render to a WebGLRenderTargetCube
 * @param {Object} [params] - The parameters object.
 * @memberof module:components/cameras
 * @extends module:core.CameraComponent
 * @example <caption>Creates a CubeCamera and set it as app's camera</caption>
 * const camera = new CubeCamera({
 *   camera: {
 *     cubeResolution: 256
 *   },
 *
 *   position: {
 *     x: 0,
 *     y: 100,
 *     z: 0
 *   }
 * });
 *
 * app.camera = camera;
 */
var CubeCamera$1 = (_temp$10 = _class$10 = function (_CameraComponent) {
  inherits(CubeCamera$$1, _CameraComponent);

  function CubeCamera$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, CubeCamera$$1);
    return possibleConstructorReturn(this, (CubeCamera$$1.__proto__ || Object.getPrototypeOf(CubeCamera$$1)).call(this, params, CubeCamera$$1.defaults));
  }

  /**
   * Default values for parameters
   * @member {Object} module:components/cameras.CubeCamera#defaults
   * @static
   * @default <pre>
   * {
   *   camera: {
   *     near: 1,
   *     far: 1000,
   *     cubeResolution: 128
   *   }
   * }</pre>
   */


  createClass(CubeCamera$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ camera: new three.CubeCamera(params.near, params.far, params.cubeResolution) }).camera;
    }
  }]);
  return CubeCamera$$1;
}(CameraComponent), _class$10.defaults = _extends({}, CameraComponent.defaults, {

  near: 1,
  far: 1000,
  cubeResolution: 128
}), _temp$10);

var _class$11;
var _temp$11;

/**
 * @class OrthographicCamera
 * @category components/cameras
 * @description Camera with orthographic projection.
 * @param {Object} [params] - The parameters object.
 * @memberof module:components/cameras
 * @extends module:core.CameraComponent
 * @example <caption>Create an OrthographicCamera and set it as app's camera</caption>
 * const camera = new OrthographicCamera({
 *   camera: {
 *     far: 10000
 *   },
 *
 *   position: {
 *     y: 50
 *   }
 * });
 *
 * app.camera = camera;
 */
var OrthographicCamera$1 = (_temp$11 = _class$11 = function (_CameraComponent) {
  inherits(OrthographicCamera$$1, _CameraComponent);

  function OrthographicCamera$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, OrthographicCamera$$1);
    return possibleConstructorReturn(this, (OrthographicCamera$$1.__proto__ || Object.getPrototypeOf(OrthographicCamera$$1)).call(this, params, OrthographicCamera$$1.defaults));
  }
  /**
   * Default values for parameters
   * @member {Object} module:components/cameras.OrthographicCamera#defaults
   * @static
   * @default <pre>
   * {
   *   near: 1,
   *   far: 1000,
   *   left: system.window.innerWidth / -2,
   *   right: system.window.innerWidth / 2,
   *   top: system.window.innerHeight / 2,
   *   bottom: system.window.innerHeight / -2
   * }</pre>
   */


  createClass(OrthographicCamera$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ camera: new three.OrthographicCamera(params.left, params.right, params.top, params.bottom, params.near, params.far) }).camera;
    }
  }]);
  return OrthographicCamera$$1;
}(CameraComponent), _class$11.defaults = _extends({}, CameraComponent.defaults, {

  near: 1,
  far: 1000,
  left: system.window.innerWidth / -2,
  right: system.window.innerWidth / 2,
  top: system.window.innerHeight / 2,
  bottom: system.window.innerHeight / -2
}), _temp$11);

var _class$12;
var _temp$12;

/**
 * @class PerspectiveCamera
 * @description Camera with perspective projection.
 * @category components/cameras
 * @param {Object} [params] - The parameters object.
 * @memberof module:components/cameras
 * @extends module:core.CameraComponent
 * @example <caption>Create an PerspectiveCamera and set it as app's camera</caption>
 * const camera = new PerspectiveCamera({
 *   fov: 75,
 *   aspect: window.innerWidth / window.innerHeight,
 *
 *   position: {
 *     x: 0,
 *     y: 100,
 *     z: 0
 *   }
 * });
 *
 * app.camera = camera;
 */
var PerspectiveCamera$1 = (_temp$12 = _class$12 = function (_CameraComponent) {
  inherits(PerspectiveCamera$$1, _CameraComponent);

  function PerspectiveCamera$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, PerspectiveCamera$$1);
    return possibleConstructorReturn(this, (PerspectiveCamera$$1.__proto__ || Object.getPrototypeOf(PerspectiveCamera$$1)).call(this, params, PerspectiveCamera$$1.defaults));
  }
  /**
   * Default values for parameters
   * @member {Object} module:components/cameras.PerspectiveCamera#defaults
   * @static
   * @default <pre>
   * {
   *   near: 1,
   *   far: 1000,
   *   fov: 75,
   *   aspect: system.window.innerWidth / system.window.innerHeight
   * }</pre>
   */


  createClass(PerspectiveCamera$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ camera: new three.PerspectiveCamera(params.fov, params.aspect, params.near, params.far) }).camera;
    }
  }]);
  return PerspectiveCamera$$1;
}(CameraComponent), _class$12.defaults = _extends({}, CameraComponent.defaults, {

  near: 1,
  far: 1000,
  fov: 75,
  aspect: system.window.innerWidth / system.window.innerHeight
}), _temp$12);

/** @module components/cameras */

var _class$13;
var _temp$13;

/**
 * @class Box
 * @category components/meshes
 * @description As told on Component definition, while you can pass any of the inherited params for this component construction, you will need to
 * pass specific parameters to build this mesh as a geometry object.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#BoxGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Box, and adding to app</caption>
 *  new Box({
 *    geometry: {
 *      width: 2,
 *      height: 2,
 *      depth: 2
 *    },
 *
 *    material: new THREE.MeshBasicMaterial({
 *      color: 0xffffff
 *    }),
 *
 *    position: [50, 60, 70]
 * }).addTo(app);
 */
var Box = (_temp$13 = _class$13 = function (_MeshComponent) {
  inherits(Box, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Box#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     width: 1,
   *     height: 1,
   *     depth: 1,
   *     widthSegments: 1,
   *     heightSegments: 1,
   *     depthSegments: 1
   *   }
   * }</pre>
   */
  function Box() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Box);
    return possibleConstructorReturn(this, (Box.__proto__ || Object.getPrototypeOf(Box)).call(this, params, Box.defaults, Box.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Box
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Box#instructions
   * @static
   * @default geometry: ['width', 'height', 'depth', 'widthSegments', 'heightSegments', 'depthSegements']
   */


  createClass(Box, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? three.BoxBufferGeometry : three.BoxGeometry)(params.geometry.width, params.geometry.height, params.geometry.depth, params.geometry.widthSegments, params.geometry.heightSegments, params.geometry.depthSegments);

      return geometry;
    }
  }]);
  return Box;
}(MeshComponent), _class$13.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    width: 1,
    height: 1,
    depth: 1,
    widthSegments: 1,
    heightSegments: 1,
    depthSegments: 1
  }
}), _class$13.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['width', 'height', 'depth', 'widthSegments', 'heightSegments', 'depthSegements']
}), _temp$13);

var _class$14;
var _temp$14;

/**
 * @class Circle
 * @category components/meshes
 * @description As told on Component definition, while you can pass any of the inherited params for this component construction, you will need to
 * pass specific parameters to build this mesh as a geometry object.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#CircleGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Circle, and adding to app</caption>
 *  new Circle({
 *    geometry: {
 *      radius: 4,
 *      segments: 16
 *    },
 *
 *    material: new THREE.MeshBasicMaterial({
 *      color: 0xffffff
 *    }),
 *
 *    position: [50, 60, 70]
 * }).addTo(app);
 */
var Circle = (_temp$14 = _class$14 = function (_MeshComponent) {
  inherits(Circle, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Circle#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 50,
   *     segments: 8,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }</pre>
   */
  function Circle() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Circle);
    return possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, params, Circle.defaults, Circle.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Circle
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Circle#instructions
   * @static
   * @default geometry: ['radius', 'segments', 'thetaStart', 'thetaLength']
   */


  createClass(Circle, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? three.CircleBufferGeometry : three.CircleGeometry)(params.geometry.radius, params.geometry.segments, params.geometry.thetaStart, params.geometry.thetaLength);

      return geometry;
    }
  }]);
  return Circle;
}(MeshComponent), _class$14.defaults = _extends({}, MeshComponent.defaults, {

  geometry: {
    radius: 50,
    segments: 8,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$14.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'segments', 'thetaStart', 'thetaLength']
}), _temp$14);

var _class$15;
var _temp$15;

/**
 * @class Cone
 * @category components/meshes
 * @description A cylinder is one of the most basic curvilinear geometric shapes, the surface formed by the points at a fixed distance from a given straight line, the axis of the cylinder. <br/><br/>
 * The solid enclosed by this surface and by two planes perpendicular to the axis is also called a cylinder.<br/>
 * The surface area and the volume of a cylinder have been known since deep antiquity.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ConeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Cone, and adding to app</caption>
 * new Cone({
 *   geometry: {
 *     radiusTop: 2,
 *     radiusBottom: 4,
 *     height: 5
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   pos: [0, 100, 0]
 * }).addTo(app);
 */
var Cone = (_temp$15 = _class$15 = function (_MeshComponent) {
  inherits(Cone, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Cone#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 20,
   *     height: 100,
   *     radiusSegments: 32,
   *     heightSegments: 1,
   *     openEnded: false,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }</pre>
   */
  function Cone() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Cone);

    var _this = possibleConstructorReturn(this, (Cone.__proto__ || Object.getPrototypeOf(Cone)).call(this, params, Cone.defaults, Cone.instructions));

    if (params.build) {
      _this.build(params);
      get(Cone.prototype.__proto__ || Object.getPrototypeOf(Cone.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Cone
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Cone#instructions
   * @static
   * @default <pre>
   * geometry: [
   *   'radius',
   *   'height',
   *   'radiusSegments',
   *   'heightSegments',
   *   'openEnded',
   *   'thetaStart',
   *   'thetaLength'
   * ]
   * </pre>
   */


  createClass(Cone, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? three.ConeBufferGeometry : three.ConeGeometry)(params.geometry.radius, params.geometry.height, params.geometry.radiusSegments, params.geometry.heightSegments, params.geometry.openEnded, params.geometry.thetaStart, params.geometry.thetaLength);

      return geometry;
    }
  }]);
  return Cone;
}(MeshComponent), _class$15.defaults = _extends({}, MeshComponent.defaults, {

  geometry: {
    radius: 20,
    height: 100,
    radiusSegments: 32,
    heightSegments: 1,
    openEnded: false,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$15.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'height', 'radiusSegments', 'heightSegments', 'openEnded', 'thetaStart', 'thetaLength']
}), _temp$15);

var _class$16;
var _temp$16;

/**
 * @class Cylinder
 * @category components/meshes
 * @description A cylinder is one of the most basic curvilinear geometric shapes, the surface formed by the points at a fixed distance from a given straight line, the axis of the cylinder. <br/><br/>
 * The solid enclosed by this surface and by two planes perpendicular to the axis is also called a cylinder.<br/>
 * The surface area and the volume of a cylinder have been known since deep antiquity.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#CylinderGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Cylinder, and adding to app</caption>
 * new Cylinder({
 *   geometry: {
 *     radiusTop: 2,
 *     radiusBottom: 4,
 *     height: 5
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   pos: [0, 100, 0]
 * }).addTo(app);
 */
var Cylinder = (_temp$16 = _class$16 = function (_MeshComponent) {
  inherits(Cylinder, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Cylinder#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radiusTop: 20,
   *     radiusBottom: 20,
   *     height: 100,
   *     radiusSegments: 32,
   *     heightSegments: 1,
   *     openEnded: false,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }</pre>
   */
  function Cylinder() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Cylinder);

    var _this = possibleConstructorReturn(this, (Cylinder.__proto__ || Object.getPrototypeOf(Cylinder)).call(this, params, Cylinder.defaults, Cylinder.instructions));

    if (params.build) {
      _this.build(params);
      get(Cylinder.prototype.__proto__ || Object.getPrototypeOf(Cylinder.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Cylinder
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Cylinder#instructions
   * @static
   * @default <pre>
   * geometry: [
   *   'radiusTop',
   *   'radiusBottom',
   *   'height',
   *   'radiusSegments',
   *   'heightSegments',
   *   'openEnded',
   *   'thetaStart',
   *   'thetaLength'
   * ]
   * </pre>
   */


  createClass(Cylinder, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? three.CylinderBufferGeometry : three.CylinderGeometry)(params.geometry.radiusTop, params.geometry.radiusBottom, params.geometry.height, params.geometry.radiusSegments, params.geometry.heightSegments, params.geometry.openEnded, params.geometry.thetaStart, params.geometry.thetaLength);

      return geometry;
    }
  }]);
  return Cylinder;
}(MeshComponent), _class$16.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radiusTop: 0,
    radiusBottom: 1,
    height: 1,
    radiusSegments: 32,
    heightSegments: 1,
    openEnded: false,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$16.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radiusTop', 'radiusBottom', 'height', 'radiusSegments', 'heightSegments', 'openEnded', 'thetaStart', 'thetaLength']
}), _temp$16);

var _class$17;
var _temp$17;

/**
 * @class Dodecahedron
 * @category components/meshes
 * @description In geometry, a dodecahedron is any polyhedron with twelve flat faces. <br/><br/>
 * The most familiar dodecahedron is the regular dodecahedron, which is a Platonic solid. <br/>
 * There are also three regular star dodecahedra, which are constructed as stellations of the convex form. <br/>
 * All of these have icosahedral symmetry, order 120.
 * Dodecahedron creates Dodecahedron object by it's radius and detail.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#DodecahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Dodecahedron, and adding to app</caption>
 * new Dodecahedron({
 *   geometry: {
 *     radius: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     y: 10
 *   }
  * }).addTo(app);
 */
var Dodecahedron = (_temp$17 = _class$17 = function (_MeshComponent) {
  inherits(Dodecahedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Dodecahedron#defaults
   * @static
   * @default <pre>
   * geometry: {
   *   radius: 1,
   *   detail: 0
   * }
   * </pre>
   */
  function Dodecahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Dodecahedron);

    var _this = possibleConstructorReturn(this, (Dodecahedron.__proto__ || Object.getPrototypeOf(Dodecahedron)).call(this, params, Dodecahedron.defaults, Dodecahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Dodecahedron.prototype.__proto__ || Object.getPrototypeOf(Dodecahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Dodecahedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Dodecahedron#instructions
   * @static
   * @default <pre>
   * geometry: ['radius', 'detail']
   * </pre>
   */


  createClass(Dodecahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.DodecahedronBufferGeometry : three.DodecahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Dodecahedron;
}(MeshComponent), _class$17.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _class$17.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'detail']
}), _temp$17);

var _class$18;
var _temp$18;

/**
 * @class Extrude
 * @category components/meshes
 * @description Extrude geometry means that you can create a 3D mesh from any 2D shape using three.js geometry based on <a href='https://threejs.org/docs/#api/math/Vector2'>THREE.Vector2.</a> <br/>
 * Such implementation will help you to make volumed shapes that have their own depth and can be seen from all angels.<br/><br/>
 * You can also find some interesting examples made using <a href='threejs.org'>three.js</a> which is a core of whs.js, such as:
 * - <a href='http://threejs.org/examples/webgl_geometry_extrude_shapes.html'>Webgl geometry extrude</a>
 * - <a href='http://threejs.org/examples/webgl_geometry_extrude_shapes2.html'>Extrude shapes from geodata</a>
 * - <a href='http://threejs.org/examples/webgl_geometry_extrude_splines.html'>Extrude splines</a>
 *
 * Such examples can be easily implemented using whitestorm.js or it's plugins. Use `Extrude` class with <a href='https://threejs.org/docs/#api/extras/core/Shape'>THREE.Shape</a> to get extrude effect of shape defined by 2D vectors.
 * This class is similar to <a href='https://threejs.org/docs/#api/geometries/ExtrudeGeometry'>THREE.ExtrudeGeometry</a>,
 * but it also contains all properties, applied by `Shape`, such as material, mass and vectors like position (pos) and rotation (rot).
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ExtrudeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a shape, then an Extrude from it</caption>
 * const shape = new THREE.Shape([
 *   new THREE.Vector2(-4,-4),
 *   new THREE.Vector2(-2,0),
 *   new THREE.Vector2(-4,4),
 *   new THREE.Vector2(0,2),
 *   new THREE.Vector2(4,4),
 *   new THREE.Vector2(2,0),
 *   new THREE.Vector2(4,-4),
 *   new THREE.Vector2(0,-2)
 * ]);
 *
 * const extrude = new Extrude({
 *   geometry: {
 *     shapes: shape,
 *     options: {
 *       bevelEnabled: false,
 *       bevelSize: 0,
 *       amount: 2
 *     }
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * });
 *
 * extrude.addTo(app);
 */
var Extrude = (_temp$18 = _class$18 = function (_MeshComponent) {
  inherits(Extrude, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Extrude#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     shapes: [],
   *     options: {}
   *   }
   * }
   * </pre>
   */
  function Extrude() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Extrude);

    var _this = possibleConstructorReturn(this, (Extrude.__proto__ || Object.getPrototypeOf(Extrude)).call(this, params, Extrude.defaults, Extrude.instructions));

    if (params.build) {
      _this.build(params);
      get(Extrude.prototype.__proto__ || Object.getPrototypeOf(Extrude.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Extrude
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Extrude#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['shapes', 'options']
   * }
   * </pre>
   */


  createClass(Extrude, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new three.ExtrudeGeometry(params.geometry.shapes, params.geometry.options);

      return params.buffer ? new three.BufferGeometry().fromGeometry(geometry) : geometry;
    }
  }]);
  return Extrude;
}(MeshComponent), _class$18.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    shapes: [],
    options: {}
  }
}), _class$18.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['shapes', 'options']
}), _temp$18);

var _class$19;
var _temp$19;

/**
 * @class Icosahedron
 * @category components/meshes
 * @description In geometry, an icosahedron is a polyhedron with 20 faces.<br/>
 * There are many kinds of icosahedra, with some being more symmetrical than others. The most well known is the Platonic, convex regular icosahedron.<br/>
 * `Icosahedron` creates an Icosahedron object by its radius and detail.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#IcosahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Icosahedron, and adding to app</caption>
 * new Icosahedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */
var Icosahedron = (_temp$19 = _class$19 = function (_MeshComponent) {
  inherits(Icosahedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Icosahedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     detail: 0
   *   }
   * }</pre>
   */
  function Icosahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Icosahedron);

    var _this = possibleConstructorReturn(this, (Icosahedron.__proto__ || Object.getPrototypeOf(Icosahedron)).call(this, params, Icosahedron.defaults, Icosahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Icosahedron.prototype.__proto__ || Object.getPrototypeOf(Icosahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Icosahedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Icosahedron#instructions
   * @static
   * @default {geometry: ['radius', 'detail']}
   */


  createClass(Icosahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.IcosahedronBufferGeometry : three.IcosahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Icosahedron;
}(MeshComponent), _class$19.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _class$19.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'detail']
}), _temp$19);

var _class$20;
var _temp$20;

/**
 * @class Lathe
 * @category components/meshes
 * @description A `LatheGeometry` allows you to create shapes from a smooth curve.
 * This curve is defined by a number of points (also called knots) and is most often called a spline. This spline is rotated around a fixed point and results in vase- and bell-like shapes.<br/><br/>
 * In 3D computer graphics, a lathed object is a 3D model whose vertex geometry is produced by rotating the points of a spline or other point set around a fixed axis.
 * The lathing may be partial; the amount of rotation is not necessarily a full 360 degrees.
 * The point set providing the initial source data can be thought of as a cross section through the object along a plane containing its axis of radial symmetry. <br/><br/>
 * The <a href='http://threejs.org/docs/scenes/geometry-browser.html#LatheGeometry'>following example</a> shows a geometry which can be generated using `Lathe` class.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#LatheGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Lath, and adding to app</caption>
 * const points = [];
 *
 * for (let i = 0; i < 10; i++) {
 *   points.push(
 *     new THREE.Vector2(
 *       (Math.sin(i * 0.7) * 15 + 50) / 10,
 *       (i - 5) * 0.2
 *     )
 *   );
 * }
 *
 * const lathe = new Lathe({
 *   geometry: {
 *     points: points
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 50, 10]
 * }).addTo(app);
 */
var Lathe = (_temp$20 = _class$20 = function (_MeshComponent) {
  inherits(Lathe, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Lathe#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     points: []
   *   }
   * }
   * </pre>
   */
  function Lathe() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Lathe);

    var _this = possibleConstructorReturn(this, (Lathe.__proto__ || Object.getPrototypeOf(Lathe)).call(this, params, Lathe.defaults, Lathe.instructions));

    if (params.build) {
      _this.build(params);
      get(Lathe.prototype.__proto__ || Object.getPrototypeOf(Lathe.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Lathe
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Lathe#instructions
   * @static
   * @default <pre>{
   *   geometry: ['points']
   * }
   * </pre>
   */


  createClass(Lathe, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.LatheBufferGeometry : three.LatheGeometry)(params.geometry.points);
    }
  }]);
  return Lathe;
}(MeshComponent), _class$20.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    points: []
  }
}), _class$20.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['points']
}), _temp$20);

var _class$21;
var _temp$21;

/**
 * @class Line
 * @category components/meshes
 * @description Line component is generated from a curve/line and amount of vectors that should be used (points).
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Line, and adding to app</caption>
 * new Line({
 *   geometry: {
 *     curve: new THREE.LineCurve3(new THREE.Vector3(10, 10, 0), new THREE.Vector3(10, 30, 0))
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Line$1 = (_temp$21 = _class$21 = function (_MeshComponent) {
  inherits(Line$$1, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Line#defaults
   * @static
   * @default <pre>
   * {
   *   curve: new LineCurve3(new Vector3(0, 0, 0), new Vector3(10, 0, 0)),
   *   points: 50
   * }
   * </pre>
   */
  function Line$$1(params) {
    classCallCheck(this, Line$$1);
    return possibleConstructorReturn(this, (Line$$1.__proto__ || Object.getPrototypeOf(Line$$1)).call(this, params, Line$$1.defaults, Line$$1.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Line
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Line#instructions
   * @static
   * @default <pre>{
   *   geometry: ['curve', 'points']
   * }
   * </pre>
   */


  createClass(Line$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Line(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = params.buffer ? new three.BufferGeometry() : new three.Geometry();

      if (params.buffer) {
        var pp = params.curve.getPoints(params.points);
        var verts = new Float32Array(pp.length * 3);

        for (var i = 0, max = pp.length; i < max; i++) {
          var i3 = i * 3;

          verts[i3] = pp[i].x;
          verts[i3 + 1] = pp[i].y;
          verts[i3 + 2] = pp[i].z;
        }

        geometry.addAttribute('position', new three.BufferAttribute(verts, 3));
      } else geometry.vertices = params.curve.getPoints(params.points);

      return geometry;
    }
  }]);
  return Line$$1;
}(MeshComponent), _class$21.defaults = _extends({}, MeshComponent.defaults, {

  curve: null,
  points: 50
}), _class$21.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['curve', 'points']
}), _temp$21);

var _class$22;
var _temp$22;

/**
 * @class Importer
 * @category components/meshes
 * @description Importer is a loader for meshes and any other data to your scene
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Importer, and adding to app</caption>
 * new Importer({
 *   loader: new THREE.OBJLoader(),
 *
 *   parser(geometry, material) { // data from loader
 *     return new THREE.Mesh(geometry, material); // should return your .native (mesh in this case)
 *   },
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */
var Importer = (_temp$22 = _class$22 = function (_MeshComponent) {
  inherits(Importer, _MeshComponent);
  createClass(Importer, null, [{
    key: 'filter',


    /**
     * @method filter
     * @description Default values for filter
     * @static
     * @param {THREE.Mesh} object Instance for iterating through it's children.
     * @param {Function} filter Function with child as argument, should return a boolean whether include the child or not.
     * @return {THREE.Mesh} object with children
     * @memberof module:components/meshes.Importer
     * @example <caption>Removing unnecessary lights from children</caption>
     * new Importer({
     *   loader: new THREE.OBJLoader(),
     *
     *   parse(group) { // data from loader
     *     return Importer.filter(group, child => !child.isLight); // remove lights
     *   },
     *
     *   position: [0, 100, 0]
     * }).addTo(app);
     */


    /**
     * Default values for parameters
     * @member {Object} module:components/meshes.Importer#defaults
     * @static
     * @default <pre>
     * {
     *   url: '',
     *   loader: new JSONLoader(),
     *
     *   onLoad() {},
     *   onProgress() {},
     *   onError() {},
     *
     *   texturePath: null,
     *   useCustomMaterial: false,
     *
     *   parser(geometry, materials) {
     *     return new Mesh(geometry, materials);
     *   }
     * }</pre>
     */
    value: function filter(object, _filter) {
      var processFilter = function processFilter(object) {
        object.children.forEach(function (el, index) {
          if (el.children) processFilter(el);
          if (!_filter(el)) object.children.splice(index, 1);
        });

        return object;
      };

      return processFilter(object);
    }
  }]);

  function Importer() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Importer);
    return possibleConstructorReturn(this, (Importer.__proto__ || Object.getPrototypeOf(Importer)).call(this, params, Importer.defaults, Importer.instructions, false));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Importer
   */


  createClass(Importer, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new Promise(function (resolve) {
        if (params.texturePath) params.loader.setTexturePath(params.texturePath);

        params.loader.load(params.url, function () {
          for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
            data[_key] = arguments[_key];
          }

          // geometry, materials
          params.onLoad.apply(params, data);

          var object = params.parser.apply(_this2, data);
          if (params.material) object.material = params.material;

          resolve(object);
        }, params.onProgress, params.onError);
      });
    }
  }]);
  return Importer;
}(MeshComponent), _class$22.defaults = _extends({}, MeshComponent.defaults, {

  url: '',
  loader: new three.JSONLoader(),

  onLoad: function onLoad() {},
  onProgress: function onProgress() {},

  // TODO add onComplete?
  onError: function onError() {},


  texturePath: null,
  useCustomMaterial: false,

  parser: function parser(geometry, material) {
    var _applyBridge = this.applyBridge({ geom: geometry, mat: material }),
        geom = _applyBridge.geom,
        mat = _applyBridge.mat;

    return this.applyBridge({
      mesh: new three.Mesh(geom, mat)
    }).mesh;
  }
}), _class$22.instructions = _extends({}, MeshComponent.instructions), _temp$22);

var _class$23;
var _temp$23;

/**
 * @class Octahedron
 * @category components/meshes
 * @description In geometry, an octahedron is a polyhedron with eight faces.
 * A regular octahedron is a Platonic solid composed of eight equilateral triangles, four of which meet at each vertex.
 * <br/><br/>
 * `Octahedron` creates an Octahedron object by its `radius` and `detail`.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#OctahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating an Octahedron, and adding to app</caption>
 * new Octahedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */
var Octahedron = (_temp$23 = _class$23 = function (_MeshComponent) {
  inherits(Octahedron, _MeshComponent);

  function Octahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Octahedron);

    var _this = possibleConstructorReturn(this, (Octahedron.__proto__ || Object.getPrototypeOf(Octahedron)).call(this, params, Octahedron.defaults, Octahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Octahedron.prototype.__proto__ || Object.getPrototypeOf(Octahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Octahedron
   */

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Octahedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     detail: 0
   *   }
   * }
   * </pre>
   */


  createClass(Octahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.OctahedronBufferGeometry : three.OctahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Octahedron;
}(MeshComponent), _class$23.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _temp$23);

var _class$24;
var _temp$24;

/**
 * @class Parametric
 * @category components/meshes
 * @description `Parametric` generates a geometry representing a <a href='https://en.wikipedia.org/wiki/Parametric_surface'>Parametric surface</a>
 * <br/><br/>
 * It is usually used to develop different kinds of highfields or visualize a <a href='https://stemkoski.github.io/Three.js/Graphulus-Function.html'>math function</a>.
 * <br/>
 * - <a href='http://math.hws.edu/graphicsbook/source/threejs/curves-and-surfaces.html'>Parametric surface</a>
 * - <a href='https://stemkoski.github.io/Three.js/Graphulus-Surface.html'>"Graphulus"</a>
 * <br/><br/>
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ParametricGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Example creating an heightfield-like geometry. `u` and `v` are like `x` and `y` in shape, but their values are always from `0` to `1`.
 * We use them in `THREE.Vector3` like `x` and `z` and `Math.random() * 5` for `y`.</caption>
 * const createParametric = (u, v) => {
 *   return new THREE.Vector3(u * 30, Math.random() * 5, v * 30);
 * }
 *
 * new Parametric({
 *   geometry: {
 *     func: createParametric
 *   },
 *
 *   material: new THREE.MeshLambertMaterial({
 *     color: 0xffffff,
 *     side: THREE.DoubleSide
 *   }),
 *
 *   position: [0, 100, -100]
 * }).addTo(app);
 */
var Parametric = (_temp$24 = _class$24 = function (_MeshComponent) {
  inherits(Parametric, _MeshComponent);

  function Parametric() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Parametric);
    return possibleConstructorReturn(this, (Parametric.__proto__ || Object.getPrototypeOf(Parametric)).call(this, params, Parametric.defaults, Parametric.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Parametric
   */

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Parametric#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     func: (u, v) => new Vector3(u, v, 0),
   *     slices: 10,
   *     tacks: 10
   *   }
   * }
   * </pre>
   */


  createClass(Parametric, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.ParametricBufferGeometry : three.ParametricGeometry)(params.geometry.func, params.geometry.slices, params.geometry.stacks);
    }
  }]);
  return Parametric;
}(MeshComponent), _class$24.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    func: function func(u, v) {
      return new three.Vector3(u, v, 0);
    },
    slices: 10,
    stacks: 10
  }
}), _temp$24);

var _class$25;
var _temp$25;

/**
 * @class Plane
 * @category components/meshes
 * @description `Plane` is used for creating planes given some `width` and `height`.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#PlaneGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Plane, and adding to app</caption>
 * new Plane({
 *   geometry: {
 *     width: 20,
 *     height: 30
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Plane$1 = (_temp$25 = _class$25 = function (_MeshComponent) {
  inherits(Plane$$1, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Plane#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     width: 10,
   *     height: 10,
   *     wSegments: 1,
   *     hSegments: 1
   *   }
   * }
   * </pre>
   */
  function Plane$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Plane$$1);

    var _this = possibleConstructorReturn(this, (Plane$$1.__proto__ || Object.getPrototypeOf(Plane$$1)).call(this, params, Plane$$1.defaults, Plane$$1.instructions));

    if (params.build) {
      _this.build(params);
      get(Plane$$1.prototype.__proto__ || Object.getPrototypeOf(Plane$$1.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Plane
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Plane#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['width', 'height', 'wSegments', 'hSegments']
   * }
   * </pre>
   */


  createClass(Plane$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? three.PlaneBufferGeometry : three.PlaneGeometry)(params.geometry.width, params.geometry.height, params.geometry.wSegments, params.geometry.hSegments);

      return geometry;
    }
  }]);
  return Plane$$1;
}(MeshComponent), _class$25.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    width: 10,
    height: 10,
    wSegments: 1,
    hSegments: 1
  }
}), _class$25.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['width', 'height', 'wSegments', 'hSegments']
}), _temp$25);

var _class$26;
var _temp$26;

var verticesOfCube = [-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1];
var indicesOfFaces = [2, 1, 0, 0, 3, 2, 0, 4, 7, 7, 3, 0, 0, 1, 5, 5, 4, 0, 1, 2, 6, 6, 5, 1, 2, 3, 7, 7, 6, 2, 4, 5, 6, 6, 7, 4];

/**
 * @class Polyhedron
 * @category components/meshes
 * @description In elementary geometry, a polyhedron is a solid in three dimensions with flat polygonal faces, straight edges and sharp corners or vertices.
 * <br/><br/>
 * `Polyhedron` creates a Polyhedron by its `radius` and `detail`.
 * <br/><br/>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating an Polyhedron, and adding to app</caption>
 * new Polyhedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */

var Polyhedron = (_temp$26 = _class$26 = function (_MeshComponent) {
  inherits(Polyhedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Polyhedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     verticesOfCube: [
   *       -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1,
   *       -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1
   *     ],
   *
   *     indicesOfFaces: [
   *       2, 1, 0, 0, 3, 2,
   *       0, 4, 7, 7, 3, 0,
   *       0, 1, 5, 5, 4, 0,
   *       1, 2, 6, 6, 5, 1,
   *       2, 3, 7, 7, 6, 2,
   *       4, 5, 6, 6, 7, 4
   *     ],
   *
   *     radius: 6,
   *     detail: 2
   *   }
   * }
   * </pre>
   */
  function Polyhedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Polyhedron);

    var _this = possibleConstructorReturn(this, (Polyhedron.__proto__ || Object.getPrototypeOf(Polyhedron)).call(this, params, Polyhedron.defaults, Polyhedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Polyhedron.prototype.__proto__ || Object.getPrototypeOf(Polyhedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Polyhedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Polyhedron#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['verticesOfCube', 'indicesOfFaces', 'radius', 'detail']
   * }
   * </pre>
   */


  createClass(Polyhedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.PolyhedronBufferGeometry : three.PolyhedronGeometry)(params.geometry.verticesOfCube, params.geometry.indicesOfFaces, params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Polyhedron;
}(MeshComponent), _class$26.verticesOfCube = verticesOfCube, _class$26.indicesOfFaces = indicesOfFaces, _class$26.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    verticesOfCube: verticesOfCube,
    indicesOfFaces: indicesOfFaces,
    radius: 6,
    detail: 2
  }
}), _class$26.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['verticesOfCube', 'indicesOfFaces', 'radius', 'detail']
}), _temp$26);

var _class$27;
var _temp$27;

/**
 * @class Ring
 * @category components/meshes
 * @description Ring class creates a circle or just 2D Torus. Does not support physics.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#RingGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Ring, and adding to app</caption>
 * new Ring({
 *   geometry: {
 *     innerRadius: 5,
 *     outerRadius: 2
 *   },
 *
 *   material: new THREE.MeshLambertMaterial({
 *     color: 0xffffff,
 *     side THREE.DoubleSide
 *   }),
 *
 *   position: [0, 8, 0],
 *
 *   rotation: {
 *     x: Math.PI/4
 *   }
 * }).addTo(app);
 */
var Ring = (_temp$27 = _class$27 = function (_MeshComponent) {
  inherits(Ring, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Ring#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     innerRadius: 0,
   *     outerRadius: 50,
   *     thetaSegments: 8,
   *     phiSegments: 8,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }
   * </pre>
   */
  function Ring() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Ring);

    var _this = possibleConstructorReturn(this, (Ring.__proto__ || Object.getPrototypeOf(Ring)).call(this, params, Ring.defaults, Ring.instructions));

    if (params.build) {
      _this.build(params);
      get(Ring.prototype.__proto__ || Object.getPrototypeOf(Ring.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Ring
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Ring#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'innerRadius',
   *     'outerRadius',
   *     'thetaSegments',
   *     'phiSegments',
   *     'thetaStart',
   *     'thetaLength'
   *   ]
   * }
   * </pre>
   */


  createClass(Ring, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.RingBufferGeometry : three.RingGeometry)(params.geometry.innerRadius, params.geometry.outerRadius, params.geometry.thetaSegments, params.geometry.phiSegments, params.geometry.thetaStart, params.geometry.thetaLength);
    }
  }]);
  return Ring;
}(MeshComponent), _class$27.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    innerRadius: 0,
    outerRadius: 50,
    thetaSegments: 8,
    phiSegments: 8,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$27.instructions = _extends({}, MeshComponent.defaults, {
  geometry: ['innerRadius', 'outerRadius', 'thetaSegments', 'phiSegments', 'thetaStart', 'thetaLength']
}), _temp$27);

var _class$28;
var _temp$28;

/**
 * @class Shape
 * @category components/meshes
 * @description Shape is a universal class. It allows you to create different 2D shapes in 3D scene.<br/>
 * Unfortunately, not all of them support physics, an alternative is to make a similar 3D object and scale its width down to near zero.
 * <br/><br/>
 * `Shape` consists of shapes that are in its shapes parameter.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ShapeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a plane looking Shape from a THREE.Shape, and adding it to app</caption>
 * const rectWidth = 10,
 * rectLength = 5;
 *
 * const rectShape = new THREE.Shape();
 * rectShape.moveTo(0,0);
 * rectShape.lineTo(0, rectWidth);
 * rectShape.lineTo(rectLength, rectWidth);
 * rectShape.lineTo(rectLength, 0);
 * rectShape.lineTo(0, 0);
 *
 * const plane = new Shape({
 *   geometry: {
 *     shape: rectShape
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Shape = (_temp$28 = _class$28 = function (_MeshComponent) {
  inherits(Shape, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Shape#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     shapes: []
   * }
   * </pre>
   */
  function Shape() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Shape);

    var _this = possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this, params, Shape.defaults, Shape.instructions));

    if (params.build) {
      _this.build(params);
      get(Shape.prototype.__proto__ || Object.getPrototypeOf(Shape.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Shape
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Shape#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['shapes']
   * }
   * </pre>
   */


  createClass(Shape, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.ShapeBufferGeometry : three.ShapeGeometry)(params.geometry.shapes);
    }
  }]);
  return Shape;
}(MeshComponent), _class$28.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    shapes: []
  }
}), _class$28.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['shapes']
}), _temp$28);

var _class$29;
var _temp$29;

/**
 * @class Sphere
 * @category components/meshes
 * @description Sphere class is used to create sphere objects by its radius property and other values that determines its detality.
 * <br/><br/>
 * It is similar to THREE.SphereGeometry, but it also contains all `Shape` properties, such as material, mass and vectors like position (pos) and rotation (rot).
 * <br/><br/>
 * Then it creates an `Three.js mesh` or a `Physijs mesh`, that is similar to `Three.js mesh`, but it also take into consideration collision calculations.
 * This mesh is a combination of `Three.js geometry` and `Physijs material` (The same as in three.js, but with friction and restitution).
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#SphereGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Sphere, and adding it to app</caption>
 * new Sphere({
 *   geometry: {
 *     radius: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     y: 100
 *   }
 * }).addTo(app);
 */
var Sphere = (_temp$29 = _class$29 = function (_MeshComponent) {
  inherits(Sphere, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Sphere#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     widthSegments: 8,
   *     heightSegments: 6
   * }
   * </pre>
   */
  function Sphere() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Sphere);
    return possibleConstructorReturn(this, (Sphere.__proto__ || Object.getPrototypeOf(Sphere)).call(this, params, Sphere.defaults, Sphere.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Sphere
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Sphere#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['radius', 'widthSegments', 'heightSegments']
   * }
   * </pre>
   */


  createClass(Sphere, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? three.SphereBufferGeometry : three.SphereGeometry)(params.geometry.radius, params.geometry.widthSegments, params.geometry.heightSegments);

      return geometry;
    }
  }]);
  return Sphere;
}(MeshComponent), _class$29.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    widthSegments: 8,
    heightSegments: 6
  }
}), _class$29.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'widthSegments', 'heightSegments']
}), _temp$29);

var _class$30;
var _temp$30;

/**
 * @class Tetrahedron
 * @category components/meshes
 * @description In geometry, a tetrahedron is a polyhedron composed of four triangular faces, six straight edges, and four vertex corners.
 * The tetrahedron is the simplest of all the ordinary convex polyhedra and the only one that has fewer than 5 faces.
 * <br/><br/>
 * `Tetrahedron` creates a Tetrahedron object by its `radius` and `detail`
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TetrahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Tetrahedron, and adding it to app</caption>
 * new Tetrahedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     x: 0,
 *     y: 100,
 *     z: 0
 *   }
 * }).addTo(app);
 */
var Tetrahedron = (_temp$30 = _class$30 = function (_MeshComponent) {
  inherits(Tetrahedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Tetrahedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     detail: 0
   * }
   * </pre>
   */
  function Tetrahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Tetrahedron);

    var _this = possibleConstructorReturn(this, (Tetrahedron.__proto__ || Object.getPrototypeOf(Tetrahedron)).call(this, params, Tetrahedron.defaults, Tetrahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Tetrahedron.prototype.__proto__ || Object.getPrototypeOf(Tetrahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Tetrahedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Tetrahedron#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['radius', 'detail']
   * }
   * </pre>
   */


  createClass(Tetrahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? three.TetrahedronBufferGeometry : three.TetrahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Tetrahedron;
}(MeshComponent), _class$30.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _class$30.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'detail']
}), _temp$30);

var _class$31;
var _temp$31;

/**
 * @class Text
 * @category components/meshes
 * @description Text class is made for creating 3D text objects.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TextGeometry"></iframe>
 * <br/><br/>
 * Physics text object can be convex or concave. By default it's convex but you can also switch to concave.
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Text, and adding it to app</caption>
 * new Text({
 *     text: 'Some text',
 *     parameters: {
 *       font: 'path/to/font.typeface.js',
 *       size: 20,
 *       height: 5,
 *       curveSegments: 6
 *     }
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     x: -40,
 *     y: 20,
 *     z: 0
 *   }
 * }).addTo(app);
 */
var Text = (_temp$31 = _class$31 = function (_MeshComponent) {
  inherits(Text, _MeshComponent);
  createClass(Text, null, [{
    key: 'load',


    /**
     * @method load
     * @static
     * @description load() preloads a Font object and returns a Promise with it.
     * @param {String} path Path to the font
     * @return {Promise} A promise resolved with a font
     * @memberof module:components/meshes.Text
     */
    value: function load(path) {
      var loader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Text.loader;

      return new Promise(function (resolve) {
        loader.load(path, resolve);
      });
    }

    /**
     * Default FontLoader
     * @member {Object} module:components/meshes.Text#loader
     * @static
     * @default new FontLoader()
     */

    /**
     * Default values for parameters
     * @member {Object} module:components/meshes.Text#defaults
     * @static
     * @default <pre>
     * {
     *   text: 'Hello World!',
     *   font: null,
     *
     *   geometry: {
     *     size: 12,
     *     height: 50,
     *     curveSegments: 12,
     *     font: new Font(),
     *     bevelEnabled: false,
     *     bevelThickness: 10,
     *     bevelSize: 8
     *   }
     * }
     * </pre>
     */

  }]);

  function Text() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Text);
    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, params, Text.defaults, Text.instructions));
  }

  /**
   * @method build
   * @description Build is called as part of the lifecycle to create a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Text
   */


  createClass(Text, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var promise = new Promise(function (resolve) {
        (params.font instanceof Promise ? params.font : Promise.resolve(params.font)).then(function (font) {
          var _applyBridge = _this2.applyBridge({
            geometry: new three.TextGeometry(params.text, Object.assign(params.geometry, { font: font })),

            material: params.material
          }),
              geometry = _applyBridge.geometry,
              material = _applyBridge.material;

          resolve(_this2.applyBridge({
            mesh: new three.Mesh(geometry, material)
          }).mesh);
        });
      });

      get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), 'wait', this).call(this, promise);

      return promise;
    }
  }]);
  return Text;
}(MeshComponent), _class$31.defaults = _extends({}, MeshComponent.defaults, {
  text: 'Hello World!',
  font: null,

  geometry: {
    size: 12,
    height: 50,
    curveSegments: 12,
    font: new three.Font(),
    bevelEnabled: false,
    bevelThickness: 10,
    bevelSize: 8
  }
}), _class$31.instructions = _extends({}, MeshComponent.instructions), _class$31.loader = new three.FontLoader(), _temp$31);

var _class$32;
var _temp$32;

/**
 * @class Torus
 * @category components/meshes
 * @description Torus class makes a torus figure. A donut is a torus.
 * @classDesc
 * <iframe src="https://threejs.org/docs/index.html#api/geometries/TorusGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Torus, and adding it to app</caption>
 * new Torus({
 *   geometry: {
 *     radius: 5,
 *     tube: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     y: 35
 *   }
 * }).addTo(app);
 */
var Torus = (_temp$32 = _class$32 = function (_MeshComponent) {
  inherits(Torus, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Torus#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 100,
   *     tube: 40,
   *     radialSegments: 8,
   *     tubularSegments: 6,
   *     arc: Math.PI * 2
   *   }
   * }
   * </pre>
   */
  function Torus() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Torus);

    var _this = possibleConstructorReturn(this, (Torus.__proto__ || Object.getPrototypeOf(Torus)).call(this, params, Torus.defaults, Torus.instructions));

    if (params.build) {
      _this.build(params);
      get(Torus.prototype.__proto__ || Object.getPrototypeOf(Torus.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Torus
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Torus#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'radius',
   *     'tube',
   *     'radialSegments',
   *     'tubularSegments',
   *     'arc'
   *   ]
   * }
   * </pre>
   */


  createClass(Torus, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new three.TorusGeometry(params.geometry.radius, params.geometry.tube, params.geometry.radialSegments, params.geometry.tubularSegments, params.geometry.arc);
    }
  }]);
  return Torus;
}(MeshComponent), _class$32.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 100,
    tube: 40,
    radialSegments: 8,
    tubularSegments: 6,
    arc: Math.PI * 2
  }
}), _class$32.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'tube', 'radialSegments', 'tubularSegments', 'arc']
}), _temp$32);

var _class$33;
var _temp$33;

/**
 * @class Torusknot
 * @category components/meshes
 * @description Torusknot class makes a torusknot figure. It's like a crooked donut, very crooked.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TorusKnotGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Torusknot, and adding it to app</caption>
 * new Torusknot({
 *   geometry: {
 *     radius:5,
 *     tube: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   pos: {
 *     y: 100
 *   }
 * }).addTo(app);
 */
var Torusknot = (_temp$33 = _class$33 = function (_MeshComponent) {
  inherits(Torusknot, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Torusknot#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 100,
   *     tube: 40,
   *     radialSegments: 64,
   *     tubularSegments: 8,
   *     p: 2,
   *     q: 3
   *   }
   * }
   * </pre>
   */
  function Torusknot() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Torusknot);

    var _this = possibleConstructorReturn(this, (Torusknot.__proto__ || Object.getPrototypeOf(Torusknot)).call(this, params, Torusknot.defaults, Torusknot.instructions));

    if (params.build) {
      _this.build(params);
      get(Torusknot.prototype.__proto__ || Object.getPrototypeOf(Torusknot.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Torusknot
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Torusknot#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'radius',
   *     'tube',
   *     'radialSegments',
   *     'tubularSegments',
   *     'p',
   *     'q'
   *   ]
   * }
   * </pre>
   */


  createClass(Torusknot, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var GConstruct = params.buffer ? three.TorusKnotBufferGeometry : three.TorusKnotGeometry;

      return new GConstruct(params.geometry.radius, params.geometry.tube, params.geometry.radialSegments, params.geometry.tubularSegments, params.geometry.p, params.geometry.q);
    }
  }]);
  return Torusknot;
}(MeshComponent), _class$33.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 100,
    tube: 40,
    radialSegments: 64,
    tubularSegments: 8,
    p: 2,
    q: 3
  }
}), _class$33.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'tube', 'radialSegments', 'tubularSegments', 'p', 'q']
}), _temp$33);

var _class$34;
var _temp$34;

/**
 * @class Tube
 * @category components/meshes
 * @description Tube class makes a tube that extrudes along a 3d curve.
 * @classDesc
 * <iframe src="https://threejs.org/docs/index.html#api/geometries/TubeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Tube from a three.js Curve, and adding it to app</caption>
 * const CustomSinCurve = THREE.Curve.create(
 *   function (scale) { // custom curve constructor
 *     this.scale = (scale === undefined) ? 1 : scale;
 *   },
 *
 *   function (t) { // getPoint: t is between 0-1
 *     const tx = t * 3 - 1.5,
 *     ty = Math.sin( 2 * Math.PI * t ),
 *     tz = 0;
 *
 *     return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);
 *   }
 * );
 *
 * const path = new CustomSinCurve(10);
 *
 * new Tube({
 *   geometry: {
 *     path: path
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Tube = (_temp$34 = _class$34 = function (_MeshComponent) {
  inherits(Tube, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Tube#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     path: new THREE.LineCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, 1)),
   *     segments: 20,
   *     radius: 2,
   *     radiusSegments: 8,
   *     closed: false
   *   }
   * }
   * </pre>
   */
  function Tube() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Tube);

    var _this = possibleConstructorReturn(this, (Tube.__proto__ || Object.getPrototypeOf(Tube)).call(this, params, Tube.defaults, Tube.instructions));

    if (params.build) {
      _this.build(params);
      get(Tube.prototype.__proto__ || Object.getPrototypeOf(Tube.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Tube
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Tube#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'path',
   *     'segments',
   *     'radius',
   *     'radiusSegments',
   *     'closed'
   *   ]
   * }
   * </pre>
   */


  createClass(Tube, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new three.Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? three.TubeBufferGeometry : three.TubeGeometry)(params.geometry.path, params.geometry.segments, params.geometry.radius, params.geometry.radiusSegments, params.geometry.closed);

      return geometry;
    }
  }]);
  return Tube;
}(MeshComponent), _class$34.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    path: new three.LineCurve3(new three.Vector3(0, 0, 0), new three.Vector3(0, 0, 1)),
    segments: 20,
    radius: 2,
    radiusSegments: 8,
    closed: false
  }
}), _class$34.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['path', 'segments', 'radius', 'radiusSegments', 'closed']
}), _temp$34);

/**
 * @class Group
 * @category components/meshes
 * @description Sometimes you need to make groups of objects (it's not conveniently to apply transforms to each object when can make just one to a group).<br/>
 * In Three.js you make it using `THREE.Object3D` and it's children. <br/><br/>
 * In whs.js we have `Group`
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Approach 2 - Adding objects to an empty group</caption>
 * const sphere = new Sphere();
 * const box = new Box();
 * const group = new Group();
 *
 * sphere.addTo(group);
 * box.addTo(group);
* @example <caption>Approach 2 - Making a group from objects</caption>
 * const sphere = new Sphere();
 * const box = new Box();
 * const group = new Group(box, sphere);
 * // OR: const group = new Group([box, sphere]);
 */

var Group = function (_MeshComponent) {
  inherits(Group, _MeshComponent);

  function Group() {
    classCallCheck(this, Group);

    var _this = possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, {}));

    for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {
      objects[_key] = arguments[_key];
    }

    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];

      if (obj instanceof Component) obj.addTo(_this);else if (obj instanceof three.Object3D) _this.native.add(obj);
    }
    return _this;
  }

  createClass(Group, [{
    key: 'build',
    value: function build() {
      return new three.Object3D();
    }
  }]);
  return Group;
}(MeshComponent);

/** @module components/meshes */

/**
 * @class ElementModule
 * @category modules/app
 * @param {Object} [container=document.body] container is the DOM object to which application's canvas will be added to.
 * @memberof module:modules/app
 * @example <caption>Creating an element module, passing it to the App</caption>
 * new App([
 *   new ElementModule(document.getElementById('app'))
 * ]);
 */
var ElementModule = function () {
  function ElementModule() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;
    classCallCheck(this, ElementModule);

    if (container.container) {
      console.warn('ElementModule now accepts only argument which is a DOM object, not a params object.');
      this.container = container.container;
    } else this.container = container;

    this.createElement();
  }

  /**
   * @method createElement
   * @instance
   * @description Creates a canvas element.
   * @memberof module:modules/app.ResizeModule
   */


  createClass(ElementModule, [{
    key: 'createElement',
    value: function createElement() {
      this.element = window.document.createElement('div');

      this.element.className = 'whs-app';
      this.element.style.width = 'inherit';
      this.element.style.height = 'inherit';
      this.element.style.position = 'relative';
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('element', this.element);
      _manager.set('container', this.container);
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      self.container.appendChild(self.element);
    }
  }]);
  return ElementModule;
}();

var _class$35;
var _temp$35;
var _initialiseProps;

/**
 * @class RenderingModule
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule({
 *     bgColor: 0x162129,
 *
 *     renderer: {
 *       antialias: true
 *     }
 *   }, {shadow: true})
 * ]);
 */
var RenderingModule = (_temp$35 = _class$35 = function () {
  /**
   * additional
   * @description collection of additional scripts
   * @static
   * @member {Object} module:core.App#additional
   * @public
   */
  function RenderingModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var additional = arguments[1];
    classCallCheck(this, RenderingModule);

    _initialiseProps.call(this);

    this.params = Object.assign({
      width: window.innerWidth,
      height: window.innerHeight,

      resolution: new three.Vector2(1, 1),
      pixelRatio: window.devicePixelRatio,

      bgColor: 0x000000,
      bgOpacity: 1,

      renderer: {},
      fix: function fix() {}
    }, params);

    var _params = this.params,
        bgColor = _params.bgColor,
        bgOpacity = _params.bgOpacity,
        renderer = _params.renderer,
        pixelRatio = _params.pixelRatio,
        width = _params.width,
        height = _params.height,
        resolution = _params.resolution,
        fix = _params.fix;


    this.renderer = new three.WebGLRenderer(renderer);
    this.effects = [];

    this.renderer.setClearColor(bgColor, bgOpacity);

    if (pixelRatio) this.renderer.setPixelRatio(pixelRatio);

    this.setSize(Number(width * resolution.x).toFixed(), Number(height * resolution.y).toFixed());

    for (var key in additional) {
      if (additional[key]) this.applyAdditional(key);
    }fix(this.renderer);
  }

  /**
   * @method applyAdditional
   * @description Apply additional script from RenderingModule.additional
   * @param {Stirng} name Script name
   * @return {this}
   * @memberof module:modules/app.RenderingModule
   */


  /**
   * enabled
   * @static
   * @member {Boolean} module:core.App#enabled
   * @public
   */


  createClass(RenderingModule, [{
    key: 'applyAdditional',
    value: function applyAdditional(name) {
      RenderingModule.additional[name].apply(this, [this.renderer]);
    }

    /**
     * @method integrateRenderer
     * @description Integrate renderer
     * @param {NodeElement} element DOM object
     * @param {THREE.Scene} scene used scene
     * @param {THREE.Camera} camera used camera
     * @return {Loop} renderLoop
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'integrateRenderer',
    value: function integrateRenderer(element, scene, camera) {
      var _this = this;

      this.scene = scene;
      this.camera = camera;
      this.attachToCanvas(element);

      return new Loop(function () {
        return _this.renderer.render(_this.scene, _this.camera);
      });
    }

    /**
     * @method effect
     * @description Add three.js effect
     * @param {Object} effect three.js effect
     * @param {function} effectLoop update function for effect
     * @return {this}
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'effect',
    value: function effect(_effect) {
      var _this2 = this;

      var effectLoop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        _effect.render(_this2.scene, _this2.camera);
      };

      this.renderLoop.stop();

      var size = this.renderer.getSize();
      _effect.setSize(size.width, size.height);

      var loop = new Loop(effectLoop);

      this.effects.push(loop);
      if (this.enabled) loop.start(this.app);

      return this;
    }

    /**
     * @method setSize
     * @description Update render target width and height.
     * @param {Number} width
     * @param {Number} height
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'setSize',
    value: function setSize(width, height) {
      if (this.renderer) this.renderer.setSize(width, height);
    }

    /**
     * @method attachToCanvas
     * @description Attach renderer.domElement to element
     * @param {NodeElement} element DOM object
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'attachToCanvas',
    value: function attachToCanvas(element) {
      var canvas = this.renderer.domElement;

      // attach to new parent world dom
      element.appendChild(canvas);
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    }

    /**
     * @method stop
     * @description Stops renderLoop and effect loops
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'stop',
    value: function stop() {
      this.enabled = false;
      this.renderLoop.stop();
      this.effects.forEach(function (loop) {
        return loop.stop();
      });
    }

    /**
     * @method play
     * @description Resumes renderLoop and effect loops
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'play',
    value: function play() {
      this.enabled = true;
      this.renderLoop.start();
      this.effects.forEach(function (loop) {
        return loop.start();
      });
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      var _this3 = this;

      _manager.define('rendering');
      _manager.set('renderer', this.renderer);

      this.app = _manager.handler;

      this.renderLoop = this.integrateRenderer(_manager.get('element'), _manager.get('scene'), _manager.get('camera').native);

      _manager.update({
        element: function element(_element) {
          _this3.attachToCanvas(_element);
        },
        scene: function scene(_scene) {
          _this3.scene = _scene;
        },
        camera: function camera(_camera) {
          _this3.camera = _camera.native;
        }
      });
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      var _this4 = this;

      self.renderLoop.start(this);
      self.effects.forEach(function (loop) {
        return loop.start(_this4);
      });
    }

    /**
     * @method dispose
     * @description Dispose rendering context
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this.stop();
      this.renderer.forceContextLoss();
    }
  }]);
  return RenderingModule;
}(), _class$35.additional = {
  shadow: function shadow(renderer) {
    renderer.shadowMap.enabled = true;
  }
}, _initialiseProps = function _initialiseProps() {
  this.enabled = true;
}, _temp$35);

/**
 * @class SceneModule
 * @category modules/app
 * @param {Boolean} [willSceneBeReplaced=false] willSceneBeReplaced should be true only if you are going to overwrite scene dependency even without the use of default one.
 * @memberof module:modules/app
 */

var SceneModule = function () {
  function SceneModule() {
    var willSceneBeReplaced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    classCallCheck(this, SceneModule);

    this.scene = willSceneBeReplaced ? null : new three.Scene();
  }

  createClass(SceneModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('scene', this.scene);
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      this.children = [];

      this.add = function (object) {
        var _this = this;

        object.parent = this;

        return new Promise(function (resolve, reject) {
          object.defer(function () {
            var native = object.native;

            if (!native) reject();

            var addPromise = _this.applyBridge({ onAdd: object }).onAdd;

            var resolver = function resolver() {
              self.scene.add(native);
              _this.children.push(object);

              resolve(object);
            };

            if (addPromise instanceof Promise) addPromise.then(resolver);else resolver();
          });
        });
      };

      this.remove = function (object) {
        object.parent = null;
        self.scene.remove(object.native);
      };

      this.setScene = function (scene) {
        self.scene = scene;
        this.manager.set('scene', scene);
      };
    }
  }]);
  return SceneModule;
}();

// import {addResizeListener} from 'detect-element-resize';

/**
 * @class ResizeModule
 * @category modules/app
 * @param {Object} [params={auto: true}] - If auto is set to true - resize will be triggered when container resizes
 * @memberof module:modules/app
 */
var ResizeModule = function () {
  function ResizeModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, ResizeModule);

    this.params = Object.assign({
      auto: true
    }, params);

    this.callbacks = [this.setSize.bind(this)];
  }

  /**
   * @function setSize
   * @instance
   * @description This function sets the provided width & height to the renderer object.
   * @param {Number} [width=1] - The promise that should be added to a queue.
   * @param {Number} [height=1] - that is resolved when all promises completed.
   * @memberof module:modules/app.ResizeModule
   */


  createClass(ResizeModule, [{
    key: 'setSize',
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this.camera.native.aspect = width / height;
      this.camera.native.updateProjectionMatrix();

      if (this.rendering) this.rendering.setSize(width, height);
    }

    /**
     * @method trigger
     * @instance
     * @description Triggers resize when called. width & height are determined automatically
     * This invokes each callbacks with the new width and height as params
     * @memberof module:modules/app.ResizeModule
     */

  }, {
    key: 'trigger',
    value: function trigger() {
      var _container = this.container,
          offsetWidth = _container.offsetWidth,
          offsetHeight = _container.offsetHeight,
          resolution = this.resolution;


      var width = Number(offsetWidth * resolution.x).toFixed();
      var height = Number(offsetHeight * resolution.y).toFixed();

      this.callbacks.forEach(function (cb) {
        cb(width, height);
      });
    }

    /**
     * @method addAutoresize
     * @instance
     * @description Sets module to autoresize, this adds an event listene on window resize to trigger the resize
     * @memberof module:modules/app.ResizeModule
     */

  }, {
    key: 'addAutoresize',
    value: function addAutoresize() {
      this.container = this.getContainer();
      this.resolution = this.getResolution();

      if (this.params.auto) window.addEventListener('resize', this.trigger.bind(this));
    }

    /**
     * @method addCallback
     * @instance
     * @description Adds a call back function to the existing callbacks list.
     * @param {Function} func - The callback function to add
     * @memberof module:modules/app.ResizeModule
     */

  }, {
    key: 'addCallback',
    value: function addCallback(func) {
      this.callbacks.push(func);
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      var _this = this;

      _manager.define('resize');

      this.rendering = _manager.get('renderer');
      this.camera = _manager.get('camera');

      this.getResolution = function () {
        return _manager.use('rendering').params.resolution;
      };
      this.getContainer = function () {
        return _manager.get('container');
      };

      _manager.update({
        container: function container(_container2) {
          _this.container = _container2;
        }
      });

      this.addAutoresize();
    }
  }]);
  return ResizeModule;
}();

var fragment = "uniform sampler2D tPreviousLum;\r\nuniform sampler2D tCurrentLum;\r\nuniform float minLuminance;\r\nuniform float delta;\r\nuniform float tau;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tfloat previousLum = texture2D(tPreviousLum, vUv, MIP_LEVEL_1X1).r;\r\n\tfloat currentLum = texture2D(tCurrentLum, vUv, MIP_LEVEL_1X1).r;\r\n\r\n\tpreviousLum = max(minLuminance, previousLum);\r\n\tcurrentLum = max(minLuminance, currentLum);\r\n\r\n\t// Adapt the luminance using Pattanaik's technique.\r\n\tfloat adaptedLum = previousLum + (currentLum - previousLum) * (1.0 - exp(-delta * tau));\r\n\r\n\tgl_FragColor.r = adaptedLum;\r\n\r\n}\r\n";
var vertex = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * An adaptive luminosity shader material.
 */

var AdaptiveLuminosityMaterial = function (_ShaderMaterial) {
			inherits(AdaptiveLuminosityMaterial, _ShaderMaterial);

			/**
    * Constructs a new adaptive luminosity material.
    */

			function AdaptiveLuminosityMaterial() {
						classCallCheck(this, AdaptiveLuminosityMaterial);
						return possibleConstructorReturn(this, (AdaptiveLuminosityMaterial.__proto__ || Object.getPrototypeOf(AdaptiveLuminosityMaterial)).call(this, {

									type: "AdaptiveLuminosityMaterial",

									defines: {

												MIP_LEVEL_1X1: "0.0"

									},

									uniforms: {

												tPreviousLum: new three.Uniform(null),
												tCurrentLum: new three.Uniform(null),
												minLuminance: new three.Uniform(0.01),
												delta: new three.Uniform(0.0),
												tau: new three.Uniform(1.0)

									},

									fragmentShader: fragment,
									vertexShader: vertex,

									depthWrite: false,
									depthTest: false

						}));
			}

			return AdaptiveLuminosityMaterial;
}(three.ShaderMaterial);

var fragment$1 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\n\r\nuniform float focus;\r\nuniform float aspect;\r\nuniform float aperture;\r\nuniform float maxBlur;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tuniform float cameraNear;\r\n\tuniform float cameraFar;\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvec2 aspectCorrection = vec2(1.0, aspect);\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = texture2D(tDepth, vUv).x;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = readDepth(tDepth, vUv);\r\n\r\n\t#endif\r\n\r\n\tfloat factor = depth - focus;\r\n\r\n\tvec2 dofBlur = vec2(clamp(factor * aperture, -maxBlur, maxBlur));\r\n\r\n\tvec2 dofblur9 = dofBlur * 0.9;\r\n\tvec2 dofblur7 = dofBlur * 0.7;\r\n\tvec2 dofblur4 = dofBlur * 0.4;\r\n\r\n\tvec4 color = vec4(0.0);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15,  0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37,  0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37, -0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15, -0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15,  0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37,  0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37, -0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15, -0.37) * aspectCorrection) * dofBlur);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15,  0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37,  0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37, -0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15, -0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15,  0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37,  0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37, -0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15, -0.37) * aspectCorrection) * dofblur9);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur7);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.4,   0.0 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur4);\r\n\r\n\tgl_FragColor = color / 41.0;\r\n\r\n}\r\n";
var vertex$1 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Depth of Field shader (Bokeh).
 *
 * Original shader code by Martins Upitis:
 *  http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

var BokehMaterial = function (_ShaderMaterial) {
	inherits(BokehMaterial, _ShaderMaterial);

	/**
  * Constructs a new bokeh material.
  *
  * @param {PerspectiveCamera} [camera] - A camera.
  * @param {Object} [options] - The options.
  * @param {Number} [options.focus=1.0] - Focus distance.
  * @param {Number} [options.aperture=0.025] - Camera aperture scale. Bigger values for shallower depth of field.
  * @param {Number} [options.maxBlur=1.0] - Maximum blur strength.
  */

	function BokehMaterial() {
		var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		classCallCheck(this, BokehMaterial);


		if (options.focus === undefined) {
			options.focus = 1.0;
		}
		if (options.aperture === undefined) {
			options.aperture = 0.025;
		}
		if (options.maxBlur === undefined) {
			options.maxBlur = 1.0;
		}

		var _this = possibleConstructorReturn(this, (BokehMaterial.__proto__ || Object.getPrototypeOf(BokehMaterial)).call(this, {

			type: "BokehMaterial",

			uniforms: {

				cameraNear: new three.Uniform(0.1),
				cameraFar: new three.Uniform(2000),
				aspect: new three.Uniform(1.0),

				tDiffuse: new three.Uniform(null),
				tDepth: new three.Uniform(null),

				focus: new three.Uniform(options.focus),
				aperture: new three.Uniform(options.aperture),
				maxBlur: new three.Uniform(options.maxBlur)

			},

			fragmentShader: fragment$1,
			vertexShader: vertex$1,

			depthWrite: false,
			depthTest: false

		}));

		if (camera !== null) {
			_this.adoptCameraSettings(camera);
		}

		return _this;
	}

	/**
  * Adopts the settings of the given camera.
  *
  * @param {PerspectiveCamera} camera - A camera.
  */

	createClass(BokehMaterial, [{
		key: "adoptCameraSettings",
		value: function adoptCameraSettings(camera) {

			this.uniforms.cameraNear.value = camera.near;
			this.uniforms.cameraFar.value = camera.far;
			this.uniforms.aspect.value = camera.aspect;
		}
	}]);
	return BokehMaterial;
}(three.ShaderMaterial);

var fragment$2 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\n\r\nuniform vec2 texelSize;\r\nuniform vec2 halfTexelSize;\r\n\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n\r\nuniform float focalLength;\r\nuniform float focalStop;\r\n\r\nuniform float maxBlur;\r\nuniform vec3 luminanceCoefficients;\r\nuniform float luminanceThreshold;\r\nuniform float luminanceGain;\r\nuniform float bias;\r\nuniform float fringe;\r\nuniform float ditherStrength;\r\n\r\n#ifdef SHADER_FOCUS\r\n\r\n\tuniform vec2 focusCoords;\r\n\r\n#else\r\n\r\n\tuniform float focalDepth;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef PENTAGON\r\n\r\n\tfloat penta(vec2 coords) {\r\n\r\n\t\tconst vec4 HS0 = vec4( 1.0,          0.0,         0.0, 1.0);\r\n\t\tconst vec4 HS1 = vec4( 0.309016994,  0.951056516, 0.0, 1.0);\r\n\t\tconst vec4 HS2 = vec4(-0.809016994,  0.587785252, 0.0, 1.0);\r\n\t\tconst vec4 HS3 = vec4(-0.809016994, -0.587785252, 0.0, 1.0);\r\n\t\tconst vec4 HS4 = vec4( 0.309016994, -0.951056516, 0.0, 1.0);\r\n\t\tconst vec4 HS5 = vec4( 0.0,          0.0,         1.0, 1.0);\r\n\r\n\t\tconst vec4 ONE = vec4(1.0);\r\n\r\n\t\tconst float P_FEATHER = 0.4;\r\n\t\tconst float N_FEATHER = -P_FEATHER;\r\n\r\n\t\tfloat inOrOut = -4.0;\r\n\r\n\t\tvec4 P = vec4(coords, vec2(RINGS_FLOAT - 1.3));\r\n\r\n\t\tvec4 dist = vec4(\r\n\t\t\tdot(P, HS0),\r\n\t\t\tdot(P, HS1),\r\n\t\t\tdot(P, HS2),\r\n\t\t\tdot(P, HS3)\r\n\t\t);\r\n\r\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\r\n\r\n\t\tinOrOut += dot(dist, ONE);\r\n\r\n\t\tdist.x = dot(P, HS4);\r\n\t\tdist.y = HS5.w - abs(P.z);\r\n\r\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\r\n\t\tinOrOut += dist.x;\r\n\r\n\t\treturn clamp(inOrOut, 0.0, 1.0);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef SHOW_FOCUS\r\n\r\n\tvec3 debugFocus(vec3 c, float blur, float depth) {\r\n\r\n\t\tfloat edge = 0.002 * depth;\r\n\t\tfloat m = clamp(smoothstep(0.0, edge, blur), 0.0, 1.0);\r\n\t\tfloat e = clamp(smoothstep(1.0 - edge, 1.0, blur), 0.0, 1.0);\r\n\r\n\t\tc = mix(c, vec3(1.0, 0.5, 0.0), (1.0 - m) * 0.6);\r\n\t\tc = mix(c, vec3(0.0, 0.5, 1.0), ((1.0 - e) - (1.0 - m)) * 0.2);\r\n\r\n\t\treturn c;\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef VIGNETTE\r\n\r\n\tfloat vignette() {\r\n\r\n\t\tconst vec2 CENTER = vec2(0.5);\r\n\r\n\t\tconst float VIGNETTE_OUT = 1.3;\r\n\t\tconst float VIGNETTE_IN = 0.0;\r\n\t\tconst float VIGNETTE_FADE = 22.0; \r\n\r\n\t\tfloat d = distance(vUv, CENTER);\r\n\t\td = smoothstep(VIGNETTE_OUT + (focalStop / VIGNETTE_FADE), VIGNETTE_IN + (focalStop / VIGNETTE_FADE), d);\r\n\r\n\t\treturn clamp(d, 0.0, 1.0);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvec2 rand(vec2 coord) {\r\n\r\n\tvec2 noise;\r\n\r\n\t#ifdef NOISE\r\n\r\n\t\tconst float a = 12.9898;\r\n\t\tconst float b = 78.233;\r\n\t\tconst float c = 43758.5453;\r\n\r\n\t\tnoise.x = clamp(fract(sin(mod(dot(coord, vec2(a, b)), 3.14)) * c), 0.0, 1.0) * 2.0 - 1.0;\r\n\t\tnoise.y = clamp(fract(sin(mod(dot(coord, vec2(a, b) * 2.0), 3.14)) * c), 0.0, 1.0) * 2.0 - 1.0;\r\n\r\n\t#else\r\n\r\n\t\tnoise.x = ((fract(1.0 - coord.s * halfTexelSize.x) * 0.25) + (fract(coord.t * halfTexelSize.y) * 0.75)) * 2.0 - 1.0;\r\n\t\tnoise.y = ((fract(1.0 - coord.s * halfTexelSize.x) * 0.75) + (fract(coord.t * halfTexelSize.y) * 0.25)) * 2.0 - 1.0;\r\n\r\n\t#endif\r\n\r\n\treturn noise;\r\n\r\n}\r\n\r\nvec3 processTexel(vec2 coords, float blur) {\r\n\r\n\tvec3 c;\r\n\tc.r = texture2D(tDiffuse, coords + vec2(0.0, 1.0) * texelSize * fringe * blur).r;\r\n\tc.g = texture2D(tDiffuse, coords + vec2(-0.866, -0.5) * texelSize * fringe * blur).g;\r\n\tc.b = texture2D(tDiffuse, coords + vec2(0.866, -0.5) * texelSize * fringe * blur).b;\r\n\r\n\t// Calculate the luminance of the constructed colour.\r\n\tfloat luminance = dot(c, luminanceCoefficients);\r\n\tfloat threshold = max((luminance - luminanceThreshold) * luminanceGain, 0.0);\r\n\r\n\treturn c + mix(vec3(0.0), c, threshold * blur);\r\n\r\n}\r\n\r\nfloat linearize(float depth) {\r\n\r\n\treturn -cameraFar * cameraNear / (depth * (cameraFar - cameraNear) - cameraFar);\r\n\r\n}\r\n\r\nfloat gather(float i, float j, float ringSamples, inout vec3 color, float w, float h, float blur) {\r\n\r\n\tconst float TWO_PI = 6.28318531;\r\n\r\n\tfloat step = TWO_PI / ringSamples;\r\n\tfloat pw = cos(j * step) * i;\r\n\tfloat ph = sin(j * step) * i;\r\n\r\n\t#ifdef PENTAGON\r\n\r\n\t\tfloat p = penta(vec2(pw, ph));\r\n\r\n\t#else\r\n\r\n\t\tfloat p = 1.0;\r\n\r\n\t#endif\r\n\r\n\tcolor += processTexel(vUv + vec2(pw * w, ph * h), blur) * mix(1.0, i / RINGS_FLOAT, bias) * p;\r\n\r\n\treturn mix(1.0, i / RINGS_FLOAT, bias) * p;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = linearize(texture2D(tDepth, vUv).x);\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = linearize(readDepth(tDepth, vUv));\r\n\r\n\t#endif\r\n\r\n\t#ifdef SHADER_FOCUS\r\n\r\n\t\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\t\tfloat fDepth = linearize(texture2D(tDepth, focusCoords).x);\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat fDepth = linearize(readDepth(tDepth, focusCoords));\r\n\r\n\t\t#endif\r\n\r\n\t#else\r\n\r\n\t\tfloat fDepth = focalDepth;\r\n\r\n\t#endif\r\n\r\n\t#ifdef MANUAL_DOF\r\n\r\n\t\tconst float nDoFStart = 1.0; \r\n\t\tconst float nDoFDist = 2.0;\r\n\t\tconst float fDoFStart = 1.0;\r\n\t\tconst float fDoFDist = 3.0;\r\n\r\n\t\tfloat focalPlane = depth - fDepth;\r\n\t\tfloat farDoF = (focalPlane - fDoFStart) / fDoFDist;\r\n\t\tfloat nearDoF = (-focalPlane - nDoFStart) / nDoFDist;\r\n\r\n\t\tfloat blur = (focalPlane > 0.0) ? farDoF : nearDoF;\r\n\r\n\t#else\r\n\r\n\t\tconst float CIRCLE_OF_CONFUSION = 0.03; // 35mm film = 0.03mm CoC.\r\n\r\n\t\tfloat focalPlaneMM = fDepth * 1000.0;\r\n\t\tfloat depthMM = depth * 1000.0;\r\n\r\n\t\tfloat focalPlane = (depthMM * focalLength) / (depthMM - focalLength);\r\n\t\tfloat farDoF = (focalPlaneMM * focalLength) / (focalPlaneMM - focalLength);\r\n\t\tfloat nearDoF = (focalPlaneMM - focalLength) / (focalPlaneMM * focalStop * CIRCLE_OF_CONFUSION);\r\n\r\n\t\tfloat blur = abs(focalPlane - farDoF) * nearDoF;\r\n\r\n\t#endif\r\n\r\n\tblur = clamp(blur, 0.0, 1.0);\r\n\r\n\t// Dithering.\r\n\tvec2 noise = rand(vUv) * ditherStrength * blur;\r\n\r\n\tfloat blurFactorX = texelSize.x * blur * maxBlur + noise.x;\r\n\tfloat blurFactorY = texelSize.y * blur * maxBlur + noise.y;\r\n\r\n\tconst int MAX_RING_SAMPLES = RINGS_INT * SAMPLES_INT;\r\n\r\n\t// Calculation of final color.\r\n\tvec4 color;\r\n\r\n\tif(blur < 0.05) {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t} else {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t\tfloat s = 1.0;\r\n\t\tint ringSamples;\r\n\r\n\t\tfor(int i = 1; i <= RINGS_INT; ++i) {\r\n\r\n\t\t\tringSamples = i * SAMPLES_INT;\r\n\r\n\t\t\t// Constant loop.\r\n\t\t\tfor(int j = 0; j < MAX_RING_SAMPLES; ++j) {\r\n\r\n\t\t\t\t// Break earlier.\r\n\t\t\t\tif(j >= ringSamples) { break; }\r\n\r\n\t\t\t\ts += gather(float(i), float(j), float(ringSamples), color.rgb, blurFactorX, blurFactorY, blur);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcolor.rgb /= s; // Divide by sample count.\r\n\r\n\t}\r\n\r\n\t#ifdef SHOW_FOCUS\r\n\r\n\t\tcolor.rgb = debugFocus(color.rgb, blur, depth);\r\n\r\n\t#endif\r\n\r\n\t#ifdef VIGNETTE\r\n\r\n\t\tcolor.rgb *= vignette();\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$2 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Depth of Field shader version 2.4.
 *
 * Original shader code by Martins Upitis:
 *  http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)
 */

var Bokeh2Material = function (_ShaderMaterial) {
	inherits(Bokeh2Material, _ShaderMaterial);

	/**
  * Constructs a new bokeh2 material.
  *
  * @param {PerspectiveCamera} [camera] - The main camera.
  * @param {Object} [options] - Additional options.
  * @param {Vector2} [options.texelSize] - The absolute screen texel size.
  * @param {Boolean} [options.showFocus=false] - Whether the focus point should be highlighted.
  * @param {Boolean} [options.manualDoF=false] - Enables manual depth of field blur.
  * @param {Boolean} [options.vignette=false] - Enables a vignette effect.
  * @param {Boolean} [options.pentagon=false] - Enable to use a pentagonal shape to scale gathered texels.
  * @param {Boolean} [options.shaderFocus=true] - Disable if you compute your own focalDepth (in metres!).
  * @param {Boolean} [options.noise=true] - Disable if you don't want noise patterns for dithering.
  */

	function Bokeh2Material() {
		var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		classCallCheck(this, Bokeh2Material);


		if (options.rings === undefined) {
			options.rings = 3;
		}
		if (options.samples === undefined) {
			options.samples = 2;
		}
		if (options.showFocus === undefined) {
			options.showFocus = false;
		}
		if (options.showFocus === undefined) {
			options.showFocus = false;
		}
		if (options.manualDoF === undefined) {
			options.manualDoF = false;
		}
		if (options.vignette === undefined) {
			options.vignette = false;
		}
		if (options.pentagon === undefined) {
			options.pentagon = false;
		}
		if (options.shaderFocus === undefined) {
			options.shaderFocus = true;
		}
		if (options.noise === undefined) {
			options.noise = true;
		}

		var _this = possibleConstructorReturn(this, (Bokeh2Material.__proto__ || Object.getPrototypeOf(Bokeh2Material)).call(this, {

			type: "Bokeh2Material",

			defines: {

				RINGS_INT: options.rings.toFixed(0),
				RINGS_FLOAT: options.rings.toFixed(1),
				SAMPLES_INT: options.samples.toFixed(0),
				SAMPLES_FLOAT: options.samples.toFixed(1)

			},

			uniforms: {

				tDiffuse: new three.Uniform(null),
				tDepth: new three.Uniform(null),

				texelSize: new three.Uniform(new three.Vector2()),
				halfTexelSize: new three.Uniform(new three.Vector2()),

				cameraNear: new three.Uniform(0.1),
				cameraFar: new three.Uniform(2000),

				focalLength: new three.Uniform(24.0),
				focalStop: new three.Uniform(0.9),

				maxBlur: new three.Uniform(1.0),
				luminanceThreshold: new three.Uniform(0.5),
				luminanceGain: new three.Uniform(2.0),
				luminanceCoefficients: new three.Uniform(new three.Vector3(0.2126, 0.7152, 0.0722)),
				bias: new three.Uniform(0.5),
				fringe: new three.Uniform(0.7),
				ditherStrength: new three.Uniform(0.0001),

				focusCoords: new three.Uniform(new three.Vector2(0.5, 0.5)),
				focalDepth: new three.Uniform(1.0)

			},

			fragmentShader: fragment$2,
			vertexShader: vertex$2,

			depthWrite: false,
			depthTest: false

		}));

		if (options.showFocus) {
			_this.defines.SHOW_FOCUS = "1";
		}
		if (options.manualDoF) {
			_this.defines.MANUAL_DOF = "1";
		}
		if (options.vignette) {
			_this.defines.VIGNETTE = "1";
		}
		if (options.pentagon) {
			_this.defines.PENTAGON = "1";
		}
		if (options.shaderFocus) {
			_this.defines.SHADER_FOCUS = "1";
		}
		if (options.noise) {
			_this.defines.NOISE = "1";
		}

		if (options.texelSize !== undefined) {
			_this.setTexelSize(options.texelSize.x, options.texelSize.y);
		}
		if (camera !== null) {
			_this.adoptCameraSettings(camera);
		}

		return _this;
	}

	/**
  * Sets the texel size.
  *
  * @param {Number} x - The texel width.
  * @param {Number} y - The texel height.
  */

	createClass(Bokeh2Material, [{
		key: "setTexelSize",
		value: function setTexelSize(x, y) {

			this.uniforms.texelSize.value.set(x, y);
			this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
		}

		/**
   * Adopts the near and far plane and the focal length of the given camera.
   *
   * @param {PerspectiveCamera} camera - The main camera.
   */

	}, {
		key: "adoptCameraSettings",
		value: function adoptCameraSettings(camera) {

			this.uniforms.cameraNear.value = camera.near;
			this.uniforms.cameraFar.value = camera.far;
			this.uniforms.focalLength.value = camera.getFocalLength(); // unit: mm.
		}
	}]);
	return Bokeh2Material;
}(three.ShaderMaterial);

var fragment$3 = "uniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\n\r\nuniform float opacity1;\r\nuniform float opacity2;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel1 = opacity1 * texture2D(texture1, vUv);\r\n\tvec4 texel2 = opacity2 * texture2D(texture2, vUv);\r\n\r\n\t#ifdef SCREEN_MODE\r\n\r\n\t\tvec3 invTexel1 = vec3(1.0) - texel1.rgb;\r\n\t\tvec3 invTexel2 = vec3(1.0) - texel2.rgb;\r\n\r\n\t\tvec4 color = vec4(\r\n\t\t\tvec3(1.0) - invTexel1 * invTexel2,\r\n\t\t\ttexel1.a + texel2.a\r\n\t\t);\r\n\r\n\t#else\r\n\r\n\t\tvec4 color = texel1 + texel2;\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$3 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A material for combining two textures.
 *
 * This material supports the two blend modes Add and Screen.
 *
 * In Screen mode, the two textures are effectively projected on a white screen
 * simultaneously. In Add mode, the textures are simply added together which
 * often produces undesired, washed out results.
 */

var CombineMaterial = function (_ShaderMaterial) {
			inherits(CombineMaterial, _ShaderMaterial);

			/**
    * Constructs a new combine material.
    *
    * @param {Boolean} [screenMode=false] - Whether the screen blend mode should be used.
    */

			function CombineMaterial() {
						var screenMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
						classCallCheck(this, CombineMaterial);

						var _this = possibleConstructorReturn(this, (CombineMaterial.__proto__ || Object.getPrototypeOf(CombineMaterial)).call(this, {

									type: "CombineMaterial",

									uniforms: {

												texture1: new three.Uniform(null),
												texture2: new three.Uniform(null),

												opacity1: new three.Uniform(1.0),
												opacity2: new three.Uniform(1.0)

									},

									fragmentShader: fragment$3,
									vertexShader: vertex$3,

									depthWrite: false,
									depthTest: false

						}));

						if (screenMode) {
									_this.defines.SCREEN_MODE = "1";
						}

						return _this;
			}

			return CombineMaterial;
}(three.ShaderMaterial);

var fragment$4 = "uniform sampler2D tDiffuse;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\t// Sample top left texel.\r\n\tvec4 sum = texture2D(tDiffuse, vUv0);\r\n\r\n\t// Sample top right texel.\r\n\tsum += texture2D(tDiffuse, vUv1);\r\n\r\n\t// Sample bottom right texel.\r\n\tsum += texture2D(tDiffuse, vUv2);\r\n\r\n\t// Sample bottom left texel.\r\n\tsum += texture2D(tDiffuse, vUv3);\r\n\r\n\t// Compute the average.\r\n\tgl_FragColor = sum * 0.25;\r\n\r\n}\r\n";
var vertex$4 = "uniform vec2 texelSize;\r\nuniform vec2 halfTexelSize;\r\nuniform float kernel;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvec2 dUv = (texelSize * vec2(kernel)) + halfTexelSize;\r\n\r\n\tvUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\r\n\tvUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\r\n\tvUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\r\n\tvUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * An optimised convolution shader material.
 *
 * Based on the GDC2003 Presentation by Masaki Kawase, Bunkasha Games:
 *  Frame Buffer Postprocessing Effects in DOUBLE-S.T.E.A.L (Wreckless)
 * and an article by Filip Strugar, Intel:
 *  An investigation of fast real-time GPU-based image blur algorithms
 *
 * Further modified according to Apple's
 * [Best Practices for Shaders](https://goo.gl/lmRoM5).
 */

var ConvolutionMaterial = function (_ShaderMaterial) {
	inherits(ConvolutionMaterial, _ShaderMaterial);

	/**
  * Constructs a new convolution material.
  *
  * @param {Vector2} [texelSize] - The absolute screen texel size.
  */

	function ConvolutionMaterial() {
		var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new three.Vector2();
		classCallCheck(this, ConvolutionMaterial);

		var _this = possibleConstructorReturn(this, (ConvolutionMaterial.__proto__ || Object.getPrototypeOf(ConvolutionMaterial)).call(this, {

			type: "ConvolutionMaterial",

			uniforms: {

				tDiffuse: new three.Uniform(null),
				texelSize: new three.Uniform(new three.Vector2()),
				halfTexelSize: new three.Uniform(new three.Vector2()),
				kernel: new three.Uniform(0.0)

			},

			fragmentShader: fragment$4,
			vertexShader: vertex$4,

			depthWrite: false,
			depthTest: false

		}));

		_this.setTexelSize(texelSize.x, texelSize.y);

		/**
   * The current kernel size.
   *
   * @type {KernelSize}
   * @default KernelSize.LARGE
   */

		_this.kernelSize = KernelSize.LARGE;

		return _this;
	}

	/**
  * Returns the kernel.
  *
  * @return {Float32Array} The kernel.
  */

	createClass(ConvolutionMaterial, [{
		key: "getKernel",
		value: function getKernel() {
			return kernelPresets[this.kernelSize];
		}

		/**
   * Sets the texel size.
   *
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */

	}, {
		key: "setTexelSize",
		value: function setTexelSize(x, y) {

			this.uniforms.texelSize.value.set(x, y);
			this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
		}
	}]);
	return ConvolutionMaterial;
}(three.ShaderMaterial);

/**
 * The Kawase blur kernel presets.
 *
 * @type {Float32Array[]}
 * @private
 */

var kernelPresets = [new Float32Array([0.0, 0.0]), new Float32Array([0.0, 1.0, 1.0]), new Float32Array([0.0, 1.0, 1.0, 2.0]), new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]), new Float32Array([0.0, 1.0, 2.0, 3.0, 4.0, 4.0, 5.0]), new Float32Array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0])];

/**
 * A kernel size enumeration.
 *
 * @type {Object}
 * @property {Number} VERY_SMALL - A very small kernel that matches a 7x7 Gauss blur kernel.
 * @property {Number} SMALL - A small kernel that matches a 15x15 Gauss blur kernel.
 * @property {Number} MEDIUM - A medium sized kernel that matches a 23x23 Gauss blur kernel.
 * @property {Number} LARGE - A large kernel that matches a 35x35 Gauss blur kernel.
 * @property {Number} VERY_LARGE - A very large kernel that matches a 63x63 Gauss blur kernel.
 * @property {Number} HUGE - A huge kernel that matches a 127x127 Gauss blur kernel.
 */

var KernelSize = {

	VERY_SMALL: 0,
	SMALL: 1,
	MEDIUM: 2,
	LARGE: 3,
	VERY_LARGE: 4,
	HUGE: 5

};

var fragment$5 = "uniform sampler2D tDiffuse;\r\nuniform float opacity;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tgl_FragColor = opacity * texel;\r\n\r\n}\r\n";
var vertex$5 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A simple copy shader material.
 */

var CopyMaterial = function (_ShaderMaterial) {
			inherits(CopyMaterial, _ShaderMaterial);

			/**
    * Constructs a new copy material.
    */

			function CopyMaterial() {
						classCallCheck(this, CopyMaterial);
						return possibleConstructorReturn(this, (CopyMaterial.__proto__ || Object.getPrototypeOf(CopyMaterial)).call(this, {

									type: "CopyMaterial",

									uniforms: {

												tDiffuse: new three.Uniform(null),
												opacity: new three.Uniform(1.0)

									},

									fragmentShader: fragment$5,
									vertexShader: vertex$5,

									depthWrite: false,
									depthTest: false

						}));
			}

			return CopyMaterial;
}(three.ShaderMaterial);

var fragment$6 = "uniform sampler2D tDepth;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tuniform float cameraNear;\r\n\tuniform float cameraFar;\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = texture2D(tDepth, vUv).x;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = readDepth(tDepth, vUv);\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = vec4(depth, depth, depth, 1.0);\r\n\r\n}\r\n";
var vertex$6 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A depth shader material.
 */

var DepthMaterial = function (_ShaderMaterial) {
	inherits(DepthMaterial, _ShaderMaterial);

	/**
  * Constructs a new depth material.
  *
  * @param {PerspectiveCamera} [camera] - A camera.
  */

	function DepthMaterial() {
		var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		classCallCheck(this, DepthMaterial);

		var _this = possibleConstructorReturn(this, (DepthMaterial.__proto__ || Object.getPrototypeOf(DepthMaterial)).call(this, {

			type: "DepthMaterial",

			uniforms: {

				cameraNear: new three.Uniform(0.1),
				cameraFar: new three.Uniform(2000),

				tDepth: new three.Uniform(null)

			},

			fragmentShader: fragment$6,
			vertexShader: vertex$6,

			depthWrite: false,
			depthTest: false

		}));

		if (camera !== null) {
			_this.adoptCameraSettings(camera);
		}

		return _this;
	}

	/**
  * Adopts the settings of the given camera.
  *
  * @param {PerspectiveCamera} camera - A camera.
  */

	createClass(DepthMaterial, [{
		key: "adoptCameraSettings",
		value: function adoptCameraSettings(camera) {

			this.uniforms.cameraNear.value = camera.near;
			this.uniforms.cameraFar.value = camera.far;
		}
	}]);
	return DepthMaterial;
}(three.ShaderMaterial);

var fragment$7 = "uniform sampler2D tDiffuse;\r\n\r\nuniform float angle;\r\nuniform float scale;\r\nuniform float intensity;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUvPattern;\r\n\r\nfloat pattern() {\r\n\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\r\n\tvec2 point = vec2(c * vUvPattern.x - s * vUvPattern.y, s * vUvPattern.x + c * vUvPattern.y) * scale;\r\n\r\n\treturn (sin(point.x) * sin(point.y)) * 4.0;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tvec3 color = texel.rgb;\r\n\r\n\t#ifdef AVERAGE\r\n\r\n\t\tcolor = vec3((color.r + color.g + color.b) / 3.0);\r\n\r\n\t#endif\r\n\r\n\tcolor = vec3(color * 10.0 - 5.0 + pattern());\r\n\tcolor = texel.rgb + (color - texel.rgb) * intensity;\r\n\r\n\tgl_FragColor = vec4(color, texel.a);\r\n\r\n}\r\n";
var vertex$7 = "uniform vec4 offsetRepeat;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUvPattern;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tvUvPattern = uv * offsetRepeat.zw + offsetRepeat.xy;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A dot screen shader material.
 */

var DotScreenMaterial = function (_ShaderMaterial) {
			inherits(DotScreenMaterial, _ShaderMaterial);

			/**
    * Constructs a new dot screen material.
    *
    * @param {Boolean} [average=false] - Whether the shader should output the colour average (black and white).
    */

			function DotScreenMaterial() {
						var average = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
						classCallCheck(this, DotScreenMaterial);

						var _this = possibleConstructorReturn(this, (DotScreenMaterial.__proto__ || Object.getPrototypeOf(DotScreenMaterial)).call(this, {

									type: "DotScreenMaterial",

									uniforms: {

												tDiffuse: new three.Uniform(null),

												angle: new three.Uniform(1.57),
												scale: new three.Uniform(1.0),
												intensity: new three.Uniform(1.0),

												offsetRepeat: new three.Uniform(new three.Vector4(0.5, 0.5, 1.0, 1.0))

									},

									fragmentShader: fragment$7,
									vertexShader: vertex$7,

									depthWrite: false,
									depthTest: false

						}));

						if (average) {
									_this.defines.AVERAGE = "1";
						}

						return _this;
			}

			return DotScreenMaterial;
}(three.ShaderMaterial);

var fragment$8 = "uniform sampler2D tDiffuse;\r\nuniform float time;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifdef NOISE\r\n\r\n\tuniform float noiseIntensity;\r\n\r\n#endif\r\n\r\n#ifdef SCANLINES\r\n\r\n\tuniform float scanlineIntensity;\r\n\tuniform float scanlineCount;\r\n\r\n#endif\r\n\r\n#ifdef GREYSCALE\r\n\r\n\tuniform vec3 luminanceCoefficients;\r\n\tuniform float greyscaleIntensity;\r\n\r\n#elif defined(SEPIA)\r\n\r\n\tuniform float sepiaIntensity;\r\n\r\n#endif\r\n\r\n#ifdef VIGNETTE\r\n\r\n\tuniform float vignetteOffset;\r\n\tuniform float vignetteDarkness;\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tvec3 color = texel.rgb;\r\n\r\n\t#ifdef SCREEN_MODE\r\n\r\n\t\tvec3 invColor;\r\n\r\n\t#endif\r\n\r\n\t#ifdef NOISE\r\n\r\n\t\tfloat x = vUv.x * vUv.y * time * 1000.0;\r\n\t\tx = mod(x, 13.0) * mod(x, 123.0);\r\n\t\tx = mod(x, 0.01);\r\n\r\n\t\tvec3 noise = texel.rgb * clamp(0.1 + x * 100.0, 0.0, 1.0) * noiseIntensity;\r\n\r\n\t\t#ifdef SCREEN_MODE\r\n\r\n\t\t\tinvColor = vec3(1.0) - color;\r\n\t\t\tvec3 invNoise = vec3(1.0) - noise;\r\n\r\n\t\t\tcolor = vec3(1.0) - invColor * invNoise;\r\n\r\n\t\t#else\r\n\r\n\t\t\tcolor += noise;\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n\t#ifdef SCANLINES\r\n\r\n\t\tvec2 sl = vec2(sin(vUv.y * scanlineCount), cos(vUv.y * scanlineCount));\r\n\t\tvec3 scanlines = texel.rgb * vec3(sl.x, sl.y, sl.x) * scanlineIntensity;\r\n\r\n\t\t#ifdef SCREEN_MODE\r\n\r\n\t\t\tinvColor = vec3(1.0) - color;\r\n\t\t\tvec3 invScanlines = vec3(1.0) - scanlines;\r\n\r\n\t\t\tcolor = vec3(1.0) - invColor * invScanlines;\r\n\r\n\t\t#else\r\n\r\n\t\t\tcolor += scanlines;\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n\t#ifdef GREYSCALE\r\n\r\n\t\tcolor = mix(color, vec3(dot(color, luminanceCoefficients)), greyscaleIntensity);\r\n\r\n\t#elif defined(SEPIA)\r\n\r\n\t\tvec3 c = color.rgb;\r\n\r\n\t\tcolor.r = dot(c, vec3(1.0 - 0.607 * sepiaIntensity, 0.769 * sepiaIntensity, 0.189 * sepiaIntensity));\r\n\t\tcolor.g = dot(c, vec3(0.349 * sepiaIntensity, 1.0 - 0.314 * sepiaIntensity, 0.168 * sepiaIntensity));\r\n\t\tcolor.b = dot(c, vec3(0.272 * sepiaIntensity, 0.534 * sepiaIntensity, 1.0 - 0.869 * sepiaIntensity));\r\n\r\n\t#endif\r\n\r\n\t#ifdef VIGNETTE\r\n\r\n\t\tconst vec2 center = vec2(0.5);\r\n\r\n\t\t#ifdef ESKIL\r\n\r\n\t\t\tvec2 uv = (vUv - center) * vec2(vignetteOffset);\r\n\t\t\tcolor = mix(color.rgb, vec3(1.0 - vignetteDarkness), dot(uv, uv));\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat dist = distance(vUv, center);\r\n\t\t\tcolor *= smoothstep(0.8, vignetteOffset * 0.799, dist * (vignetteDarkness + vignetteOffset));\r\n\r\n\t\t#endif\t\t\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = vec4(clamp(color, 0.0, 1.0), texel.a);\r\n\r\n}\r\n";
var vertex$8 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A cinematic shader that provides the following effects:
 *  - Film Grain
 *  - Scanlines
 *  - Vignette
 *  - Greyscale
 *  - Sepia
 *
 * Original scanlines algorithm by Pat "Hawthorne" Shearon.
 *  http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Optimised scanlines and noise with intensity scaling by Georg "Leviathan"
 * Steinrohder. This version was provided under a Creative Commons Attribution
 * 3.0 License: http://creativecommons.org/licenses/by/3.0.
 *
 * The sepia effect is based on:
 *  https://github.com/evanw/glfx.js
 *
 * The vignette code is based on PaintEffect postprocess from ro.me:
 *  http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

var FilmMaterial = function (_ShaderMaterial) {
		inherits(FilmMaterial, _ShaderMaterial);

		/**
   * Constructs a new film material.
   *
   * @param {Object} [options] - The options. Disabled effects will not be included in the final shader and have no negative impact on performance.
   * @param {Boolean} [options.greyscale=false] - Enable greyscale effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.sepia=false] - Enable sepia effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.vignette=false] - Apply vignette effect.
   * @param {Boolean} [options.eskil=false] - Use Eskil's vignette approach. The default looks dusty while Eskil looks burned out.
   * @param {Boolean} [options.screenMode=true] - Whether the screen blend mode should be used for noise and scanlines. Both of these effects are computed independently.
   * @param {Boolean} [options.noise=true] - Show noise-based film grain.
   * @param {Boolean} [options.scanlines=true] - Show scanlines.
   * @param {Number} [options.noiseIntensity=0.5] - The noise intensity. 0.0 to 1.0.
   * @param {Number} [options.scanlineIntensity=0.05] - The scanline intensity. 0.0 to 1.0.
   * @param {Number} [options.greyscaleIntensity=1.0] - The intensity of the greyscale effect. 0.0 to 1.0.
   * @param {Number} [options.sepiaIntensity=1.0] - The intensity of the sepia effect. 0.0 to 1.0.
   * @param {Number} [options.vignetteOffset=1.0] - The offset of the vignette effect. 0.0 to 1.0.
   * @param {Number} [options.vignetteDarkness=1.0] - The darkness of the vignette effect. 0.0 to 1.0.
   */

		function FilmMaterial() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, FilmMaterial);


				if (options.screenMode === undefined) {
						options.screenMode = true;
				}
				if (options.noise === undefined) {
						options.noise = true;
				}
				if (options.scanlines === undefined) {
						options.scanlines = true;
				}

				if (options.greyscale === undefined) {
						options.greyscale = false;
				}
				if (options.sepia === undefined) {
						options.sepia = false;
				}
				if (options.vignette === undefined) {
						options.vignette = false;
				}
				if (options.eskil === undefined) {
						options.eskil = false;
				}

				if (options.noiseIntensity === undefined) {
						options.noiseIntensity = 0.5;
				}
				if (options.scanlineIntensity === undefined) {
						options.scanlineIntensity = 0.05;
				}
				if (options.greyscaleIntensity === undefined) {
						options.greyscaleIntensity = 1.0;
				}
				if (options.sepiaIntensity === undefined) {
						options.sepiaIntensity = 1.0;
				}

				if (options.vignetteOffset === undefined) {
						options.vignetteOffset = 1.0;
				}
				if (options.vignetteDarkness === undefined) {
						options.vignetteDarkness = 1.0;
				}

				var _this = possibleConstructorReturn(this, (FilmMaterial.__proto__ || Object.getPrototypeOf(FilmMaterial)).call(this, {

						type: "FilmMaterial",

						uniforms: {

								tDiffuse: new three.Uniform(null),
								time: new three.Uniform(0.0),

								noiseIntensity: new three.Uniform(options.noiseIntensity),
								scanlineIntensity: new three.Uniform(options.scanlineIntensity),
								scanlineCount: new three.Uniform(0.0),

								luminanceCoefficients: new three.Uniform(new three.Vector3(0.2126, 0.7152, 0.0722)),
								greyscaleIntensity: new three.Uniform(options.greyscaleIntensity),
								sepiaIntensity: new three.Uniform(options.sepiaIntensity),

								vignetteOffset: new three.Uniform(options.vignetteOffset),
								vignetteDarkness: new three.Uniform(options.vignetteDarkness)

						},

						fragmentShader: fragment$8,
						vertexShader: vertex$8,

						depthWrite: false,
						depthTest: false

				}));

				if (options.greyscale) {
						_this.defines.GREYSCALE = "1";
				}
				if (options.sepia) {
						_this.defines.SEPIA = "1";
				}
				if (options.vignette) {
						_this.defines.VIGNETTE = "1";
				}
				if (options.eskil) {
						_this.defines.ESKIL = "1";
				}

				if (options.screenMode) {
						_this.defines.SCREEN_MODE = "1";
				}
				if (options.noise) {
						_this.defines.NOISE = "1";
				}
				if (options.scanlines) {
						_this.defines.SCANLINES = "1";
				}

				return _this;
		}

		return FilmMaterial;
}(three.ShaderMaterial);

var fragment$9 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tPerturb;\r\n\r\nuniform bool active;\r\n\r\nuniform float amount;\r\nuniform float angle;\r\nuniform float seed;\r\nuniform float seedX;\r\nuniform float seedY;\r\nuniform float distortionX;\r\nuniform float distortionY;\r\nuniform float colS;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat rand(vec2 tc) {\r\n\r\n\tconst float a = 12.9898;\r\n\tconst float b = 78.233;\r\n\tconst float c = 43758.5453;\r\n\r\n\tfloat dt = dot(tc, vec2(a, b));\r\n\tfloat sn = mod(dt, 3.14);\r\n\r\n\treturn fract(sin(sn) * c);\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec2 coord = vUv;\r\n\r\n\tfloat xs, ys;\r\n\tvec4 normal;\r\n\r\n\tvec2 offset;\r\n\tvec4 cr, cga, cb;\r\n\tvec4 snow, color;\r\n\r\n\tfloat sx, sy;\r\n\r\n\tif(active) {\r\n\r\n\t\txs = floor(gl_FragCoord.x / 0.5);\r\n\t\tys = floor(gl_FragCoord.y / 0.5);\r\n\r\n\t\tnormal = texture2D(tPerturb, coord * seed * seed);\r\n\r\n\t\tif(coord.y < distortionX + colS && coord.y > distortionX - colS * seed) {\r\n\r\n\t\t\tsx = clamp(ceil(seedX), 0.0, 1.0);\r\n\t\t\tcoord.y = sx * (1.0 - (coord.y + distortionY)) + (1.0 - sx) * distortionY;\r\n\r\n\t\t}\r\n\r\n\t\tif(coord.x < distortionY + colS && coord.x > distortionY - colS * seed) {\r\n\r\n\t\t\tsy = clamp(ceil(seedY), 0.0, 1.0);\r\n\t\t\tcoord.x = sy * distortionX + (1.0 - sy) * (1.0 - (coord.x + distortionX));\r\n\r\n\t\t}\r\n\r\n\t\tcoord.x += normal.x * seedX * (seed / 5.0);\r\n\t\tcoord.y += normal.y * seedY * (seed / 5.0);\r\n\r\n\t\toffset = amount * vec2(cos(angle), sin(angle));\r\n\r\n\t\tcr = texture2D(tDiffuse, coord + offset);\r\n\t\tcga = texture2D(tDiffuse, coord);\r\n\t\tcb = texture2D(tDiffuse, coord - offset);\r\n\r\n\t\tcolor = vec4(cr.r, cga.g, cb.b, cga.a);\r\n\t\tsnow = 200.0 * amount * vec4(rand(vec2(xs * seed, ys * seed * 50.0)) * 0.2);\r\n\t\tcolor += snow;\r\n\r\n\t} else {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$9 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A glitch shader material.
 *
 * Reference:
 *  https://github.com/staffantan/unityglitch
 */

var GlitchMaterial = function (_ShaderMaterial) {
			inherits(GlitchMaterial, _ShaderMaterial);

			/**
    * Constructs a new glitch material.
    */

			function GlitchMaterial() {
						classCallCheck(this, GlitchMaterial);
						return possibleConstructorReturn(this, (GlitchMaterial.__proto__ || Object.getPrototypeOf(GlitchMaterial)).call(this, {

									type: "GlitchMaterial",

									uniforms: {

												tDiffuse: new three.Uniform(null),
												tPerturb: new three.Uniform(null),

												active: new three.Uniform(1),

												amount: new three.Uniform(0.8),
												angle: new three.Uniform(0.02),
												seed: new three.Uniform(0.02),
												seedX: new three.Uniform(0.02),
												seedY: new three.Uniform(0.02),
												distortionX: new three.Uniform(0.5),
												distortionY: new three.Uniform(0.6),
												colS: new three.Uniform(0.05)

									},

									fragmentShader: fragment$9,
									vertexShader: vertex$9,

									depthWrite: false,
									depthTest: false

						}));
			}

			return GlitchMaterial;
}(three.ShaderMaterial);

var fragment$10 = "uniform sampler2D tDiffuse;\r\nuniform vec3 lightPosition;\r\n\r\nuniform float exposure;\r\nuniform float decay;\r\nuniform float density;\r\nuniform float weight;\r\nuniform float clampMax;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec2 texCoord = vUv;\r\n\r\n\t// Calculate vector from pixel to light source in screen space.\r\n\tvec2 deltaTexCoord = texCoord - lightPosition.st;\r\n\tdeltaTexCoord *= 1.0 / NUM_SAMPLES_FLOAT * density;\r\n\r\n\t// A decreasing illumination factor.\r\n\tfloat illuminationDecay = 1.0;\r\n\r\n\tvec4 sample;\r\n\tvec4 color = vec4(0.0);\r\n\r\n\t// Estimate the probability of occlusion at each pixel by summing samples along a ray to the light source.\r\n\tfor(int i = 0; i < NUM_SAMPLES_INT; ++i) {\r\n\r\n\t\ttexCoord -= deltaTexCoord;\r\n\t\tsample = texture2D(tDiffuse, texCoord);\r\n\r\n\t\t// Apply sample attenuation scale/decay factors.\r\n\t\tsample *= illuminationDecay * weight;\r\n\r\n\t\tcolor += sample;\r\n\r\n\t\t// Update exponential decay factor.\r\n\t\tilluminationDecay *= decay;\r\n\r\n\t}\r\n\r\n\tgl_FragColor = clamp(color * exposure, 0.0, clampMax);\r\n\r\n}\r\n";
var vertex$10 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A crepuscular rays shader material.
 *
 * References:
 *
 * Thibaut Despoulain, 2012:
 *  [(WebGL) Volumetric Light Approximation in Three.js](
 *  http://bkcore.com/blog/3d/webgl-three-js-volumetric-light-godrays.html)
 *
 * Nvidia, GPU Gems 3, 2008:
 *  [Chapter 13. Volumetric Light Scattering as a Post-Process](
 *  https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch13.html)
 */

var GodRaysMaterial = function (_ShaderMaterial) {
			inherits(GodRaysMaterial, _ShaderMaterial);

			/**
    * Constructs a new god rays material.
    */

			function GodRaysMaterial() {
						classCallCheck(this, GodRaysMaterial);
						return possibleConstructorReturn(this, (GodRaysMaterial.__proto__ || Object.getPrototypeOf(GodRaysMaterial)).call(this, {

									type: "GodRaysMaterial",

									defines: {

												NUM_SAMPLES_FLOAT: "60.0",
												NUM_SAMPLES_INT: "60"

									},

									uniforms: {

												tDiffuse: new three.Uniform(null),
												lightPosition: new three.Uniform(null),

												exposure: new three.Uniform(0.6),
												decay: new three.Uniform(0.93),
												density: new three.Uniform(0.96),
												weight: new three.Uniform(0.4),
												clampMax: new three.Uniform(1.0)

									},

									fragmentShader: fragment$10,
									vertexShader: vertex$10,

									depthWrite: false,
									depthTest: false

						}));
			}

			return GodRaysMaterial;
}(three.ShaderMaterial);

var fragment$11 = "uniform sampler2D tDiffuse;\r\nuniform float distinction;\r\nuniform vec2 range;\r\nuniform vec3 luminanceCoefficients;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tfloat v = dot(texel.rgb, luminanceCoefficients);\r\n\r\n\t#ifdef RANGE\r\n\r\n\t\tfloat low = step(range.x, v);\r\n\t\tfloat high = step(v, range.y);\r\n\r\n\t\t// Apply the mask.\r\n\t\tv *= low * high;\r\n\r\n\t#endif\r\n\r\n\tv = pow(abs(v), distinction);\r\n\r\n\t#ifdef COLOR\r\n\r\n\t\tgl_FragColor = vec4(texel.rgb * v, texel.a);\r\n\r\n\t#else\r\n\r\n\t\tgl_FragColor = vec4(v, v, v, texel.a);\r\n\r\n\t#endif\r\n\r\n}\r\n";
var vertex$11 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A luminosity shader material.
 *
 * This shader produces a greyscale luminance map that describes the absolute
 * amount of light emitted by a scene. It can also be configured to output
 * colours that are scaled with their respective luminance value. Additionally,
 * a range may be provided to mask out undesired texels.
 *
 * The alpha channel will remain unaffected in all cases.
 *
 * On luminance coefficients:
 *  http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9
 *
 * Coefficients for different colour spaces:
 *  https://hsto.org/getpro/habr/post_images/2ab/69d/084/2ab69d084f9a597e032624bcd74d57a7.png
 *
 * Luminance range reference:
 *  https://cycling74.com/2007/05/23/your-first-shader/#.Vty9FfkrL4Z
 */

var LuminosityMaterial = function (_ShaderMaterial) {
	inherits(LuminosityMaterial, _ShaderMaterial);

	/**
  * Constructs a new luminosity material.
  *
  * @param {Boolean} [color=false] - Defines whether the shader should output colours scaled with their luminance value.
  * @param {Vector2} [range] - If provided, the shader will mask out texels that aren't in the specified luminance range.
  */

	function LuminosityMaterial() {
		var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
		var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		classCallCheck(this, LuminosityMaterial);

		var _this = possibleConstructorReturn(this, (LuminosityMaterial.__proto__ || Object.getPrototypeOf(LuminosityMaterial)).call(this, {

			type: "LuminosityMaterial",

			uniforms: {

				tDiffuse: new three.Uniform(null),
				distinction: new three.Uniform(1.0),
				range: new three.Uniform(range !== null ? range : new three.Vector2()),
				luminanceCoefficients: new three.Uniform(new three.Vector3(0.2126, 0.7152, 0.0722))

			},

			fragmentShader: fragment$11,
			vertexShader: vertex$11

		}));

		if (color) {
			_this.defines.COLOR = "1";
		}
		if (range !== null) {
			_this.defines.RANGE = "1";
		}

		return _this;
	}

	return LuminosityMaterial;
}(three.ShaderMaterial);

var fragment$12 = "uniform sampler2D tDiffuse;\r\nuniform float granularity;\r\nuniform float dx;\r\nuniform float dy;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel;\r\n\r\n\tif(granularity > 0.0) {\r\n\r\n\t\tvec2 coord = vec2(\r\n\t\t\tdx * (floor(vUv.x / dx) + 0.5),\r\n\t\t\tdy * (floor(vUv.y / dy) + 0.5)\r\n\t\t);\r\n\r\n\t\ttexel = texture2D(tDiffuse, coord);\r\n\r\n\t} else {\r\n\r\n\t\ttexel = texture2D(tDiffuse, vUv);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = texel;\r\n\r\n}\r\n";
var vertex$12 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A pixelation shader material.
 *
 * Original shader code by Robert Casanova:
 *  https://github.com/robertcasanova/pixelate-shader
 */

var PixelationMaterial = function (_ShaderMaterial) {
	inherits(PixelationMaterial, _ShaderMaterial);

	/**
  * Constructs a new pixelation material.
  */

	function PixelationMaterial() {
		classCallCheck(this, PixelationMaterial);
		return possibleConstructorReturn(this, (PixelationMaterial.__proto__ || Object.getPrototypeOf(PixelationMaterial)).call(this, {

			type: "PixelationMaterial",

			uniforms: {

				tDiffuse: new three.Uniform(null),
				granularity: new three.Uniform(1.0),
				resolution: new three.Uniform(new three.Vector2(1.0, 1.0)),
				dx: new three.Uniform(1.0),
				dy: new three.Uniform(1.0)

			},

			fragmentShader: fragment$12,
			vertexShader: vertex$12,

			depthWrite: false,
			depthTest: false

		}));
	}

	/**
  * The pixel granularity.
  *
  * @type {Number}
  */

	createClass(PixelationMaterial, [{
		key: "setResolution",


		/**
   * Sets the resolution.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */

		value: function setResolution(width, height) {

			this.uniforms.resolution.value.set(width, height);
			this.granularity = this.granularity;
		}
	}, {
		key: "granularity",
		get: function get$$1() {
			return this.uniforms.granularity.value;
		}

		/**
   * A higher value yields coarser visuals.
   *
   * @type {Number}
   */

		,
		set: function set$$1(x) {

			var uniforms = this.uniforms;
			var resolution = uniforms.resolution.value;

			uniforms.granularity.value = x;
			uniforms.dx.value = x / resolution.x;
			uniforms.dy.value = x / resolution.y;
		}
	}]);
	return PixelationMaterial;
}(three.ShaderMaterial);

var fragment$13 = "#include <common>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform vec2 center;\r\nuniform float aspect;\r\nuniform float waveSize;\r\nuniform float radius;\r\nuniform float maxRadius;\r\nuniform float amplitude;\r\n\r\nvarying vec2 vUv;\r\nvarying float vSize;\r\n\r\nvoid main() {\r\n\r\n\tvec2 aspectCorrection = vec2(aspect, 1.0);\r\n\r\n\tvec2 difference = vUv * aspectCorrection - center * aspectCorrection;\r\n\tfloat distance = sqrt(dot(difference, difference)) * vSize;\r\n\r\n\tvec2 displacement = vec2(0.0);\r\n\r\n\tif(distance > radius) {\r\n\r\n\t\tif(distance < radius + waveSize) {\r\n\r\n\t\t\tfloat angle = (distance - radius) * PI2 / waveSize;\r\n\t\t\tfloat cosSin = (1.0 - cos(angle)) * 0.5;\r\n\r\n\t\t\tfloat extent = maxRadius + waveSize;\r\n\t\t\tfloat decay = max(extent - distance * distance, 0.0) / extent;\r\n\r\n\t\t\tdisplacement = ((cosSin * amplitude * difference) / distance) * decay;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgl_FragColor = texture2D(tDiffuse, vUv - displacement);\r\n\r\n}\r\n";
var vertex$13 = "uniform float size;\r\nuniform float scale;\r\nuniform float cameraDistance;\r\n\r\nvarying vec2 vUv;\r\nvarying float vSize;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tvSize = (0.1 * cameraDistance) / size;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A shock wave shader material.
 *
 * Based on a Gist by Jean-Philippe Sarda:
 *  https://gist.github.com/jpsarda/33cea67a9f2ecb0a0eda
 */

var ShockWaveMaterial = function (_ShaderMaterial) {
			inherits(ShockWaveMaterial, _ShaderMaterial);

			/**
    * Constructs a new shock wave material.
    *
    * @param {Object} [options] - The options.
    * @param {Number} [options.waveSize=0.2] - The wave size.
    * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
    */

			function ShockWaveMaterial() {
						var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
						classCallCheck(this, ShockWaveMaterial);


						if (options.maxRadius === undefined) {
									options.maxRadius = 1.0;
						}
						if (options.waveSize === undefined) {
									options.waveSize = 0.2;
						}
						if (options.amplitude === undefined) {
									options.amplitude = 0.05;
						}

						return possibleConstructorReturn(this, (ShockWaveMaterial.__proto__ || Object.getPrototypeOf(ShockWaveMaterial)).call(this, {

									type: "ShockWaveMaterial",

									uniforms: {

												tDiffuse: new three.Uniform(null),

												center: new three.Uniform(new three.Vector2(0.5, 0.5)),
												aspect: new three.Uniform(1.0),
												cameraDistance: new three.Uniform(1.0),

												size: new three.Uniform(1.0),
												radius: new three.Uniform(-options.waveSize),
												maxRadius: new three.Uniform(options.maxRadius),
												waveSize: new three.Uniform(options.waveSize),
												amplitude: new three.Uniform(options.amplitude)

									},

									fragmentShader: fragment$13,
									vertexShader: vertex$13,

									depthWrite: false,
									depthTest: false

						}));
			}

			return ShockWaveMaterial;
}(three.ShaderMaterial);

var fragment$14 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tWeights;\r\n\r\nuniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset;\r\n\r\nvoid main() {\r\n\r\n\t// Fetch the blending weights for current pixel.\r\n\tvec4 a;\r\n\ta.xz = texture2D(tWeights, vUv).xz;\r\n\ta.y = texture2D(tWeights, vOffset.zw).g;\r\n\ta.w = texture2D(tWeights, vOffset.xy).a;\r\n\r\n\tvec4 color;\r\n\r\n\t// Check if there is any blending weight with a value greater than 0.0.\r\n\tif(dot(a, vec4(1.0)) < 1e-5) {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv, 0.0);\r\n\r\n\t} else {\r\n\r\n\t\t/* Up to four lines can be crossing a pixel (one through each edge). We favor\r\n\t\t * blending by choosing the line with the maximum weight for each direction.\r\n\t\t */\r\n\r\n\t\tvec2 offset;\r\n\t\toffset.x = a.a > a.b ? a.a : -a.b; // Left vs. right.\r\n\t\toffset.y = a.g > a.r ? -a.g : a.r; // Top vs. bottom (changed signs).\r\n\r\n\t\t// Then we go in the direction that has the maximum weight (horizontal vs. vertical).\r\n\t\tif(abs(offset.x) > abs(offset.y)) {\r\n\r\n\t\t\toffset.y = 0.0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\toffset.x = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\t// Fetch the opposite color and lerp by hand.\r\n\t\tcolor = texture2D(tDiffuse, vUv, 0.0);\r\n\t\tvec2 coord = vUv + sign(offset) * texelSize;\r\n\t\tvec4 oppositeColor = texture2D(tDiffuse, coord, 0.0);\r\n\t\tfloat s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\r\n\r\n\t\t// Gamma correction.\r\n\t\tcolor.rgb = pow(abs(color.rgb), vec3(2.2));\r\n\t\toppositeColor.rgb = pow(abs(oppositeColor.rgb), vec3(2.2));\r\n\t\tcolor = mix(color, oppositeColor, s);\r\n\t\tcolor.rgb = pow(abs(color.rgb), vec3(1.0 / 2.2));\r\n\r\n\t}\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$14 = "uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvOffset = uv.xyxy + texelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // Changed sign in W component.\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Subpixel Morphological Antialiasing.
 *
 * This material is used to render the final antialiasing.
 */

var SMAABlendMaterial = function (_ShaderMaterial) {
			inherits(SMAABlendMaterial, _ShaderMaterial);

			/**
    * Constructs a new SMAA blend material.
    *
    * @param {Vector2} [texelSize] - The absolute screen texel size.
    */

			function SMAABlendMaterial() {
						var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new three.Vector2();
						classCallCheck(this, SMAABlendMaterial);
						return possibleConstructorReturn(this, (SMAABlendMaterial.__proto__ || Object.getPrototypeOf(SMAABlendMaterial)).call(this, {

									type: "SMAABlendMaterial",

									uniforms: {

												tDiffuse: new three.Uniform(null),
												tWeights: new three.Uniform(null),
												texelSize: new three.Uniform(texelSize)

									},

									fragmentShader: fragment$14,
									vertexShader: vertex$14,

									depthWrite: false,
									depthTest: false

						}));
			}

			return SMAABlendMaterial;
}(three.ShaderMaterial);

var fragment$15 = "uniform sampler2D tDiffuse;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\n\r\nvoid main() {\r\n\r\n\tconst vec2 THRESHOLD = vec2(EDGE_THRESHOLD);\r\n\r\n\t// Calculate color deltas.\r\n\tvec4 delta;\r\n\tvec3 c = texture2D(tDiffuse, vUv).rgb;\r\n\r\n\tvec3 cLeft = texture2D(tDiffuse, vOffset[0].xy).rgb;\r\n\tvec3 t = abs(c - cLeft);\r\n\tdelta.x = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cTop = texture2D(tDiffuse, vOffset[0].zw).rgb;\r\n\tt = abs(c - cTop);\r\n\tdelta.y = max(max(t.r, t.g), t.b);\r\n\r\n\t// We do the usual threshold.\r\n\tvec2 edges = step(THRESHOLD, delta.xy);\r\n\r\n\t// Then discard if there is no edge.\r\n\tif(dot(edges, vec2(1.0)) == 0.0) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\t// Calculate right and bottom deltas.\r\n\tvec3 cRight = texture2D(tDiffuse, vOffset[1].xy).rgb;\r\n\tt = abs(c - cRight);\r\n\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cBottom  = texture2D(tDiffuse, vOffset[1].zw).rgb;\r\n\tt = abs(c - cBottom);\r\n\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t// Calculate the maximum delta in the direct neighborhood.\r\n\tfloat maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\r\n\r\n\t// Calculate left-left and top-top deltas.\r\n\tvec3 cLeftLeft  = texture2D(tDiffuse, vOffset[2].xy).rgb;\r\n\tt = abs(c - cLeftLeft);\r\n\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cTopTop = texture2D(tDiffuse, vOffset[2].zw).rgb;\r\n\tt = abs(c - cTopTop);\r\n\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t// Calculate the final maximum delta.\r\n\tmaxDelta = max(max(maxDelta, delta.z), delta.w);\r\n\r\n\t// Local contrast adaptation in action.\r\n\tedges.xy *= step(0.5 * maxDelta, delta.xy);\r\n\r\n\tgl_FragColor = vec4(edges, 0.0, 0.0);\r\n\r\n}\r\n";
var vertex$15 = "uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvOffset[0] = uv.xyxy + texelSize.xyxy * vec4(-1.0, 0.0, 0.0, 1.0); // Changed sign in W component.\r\n\tvOffset[1] = uv.xyxy + texelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // Changed sign in W component.\r\n\tvOffset[2] = uv.xyxy + texelSize.xyxy * vec4(-2.0, 0.0, 0.0, 2.0); // Changed sign in W component.\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Subpixel Morphological Antialiasing.
 *
 * This material detects edges in a color texture.
 */

var SMAAColorEdgesMaterial = function (_ShaderMaterial) {
			inherits(SMAAColorEdgesMaterial, _ShaderMaterial);

			/**
    * Constructs a new SMAA color edges material.
    *
    * @param {Vector2} [texelSize] - The absolute screen texel size.
    */

			function SMAAColorEdgesMaterial() {
						var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new three.Vector2();
						classCallCheck(this, SMAAColorEdgesMaterial);
						return possibleConstructorReturn(this, (SMAAColorEdgesMaterial.__proto__ || Object.getPrototypeOf(SMAAColorEdgesMaterial)).call(this, {

									type: "SMAAColorEdgesMaterial",

									defines: {

												EDGE_THRESHOLD: "0.1"

									},

									uniforms: {

												tDiffuse: new three.Uniform(null),
												texelSize: new three.Uniform(texelSize)

									},

									fragmentShader: fragment$15,
									vertexShader: vertex$15,

									depthWrite: false,
									depthTest: false

						}));
			}

			return SMAAColorEdgesMaterial;
}(three.ShaderMaterial);

var areaImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";

var searchImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";

var fragment$16 = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + float(offset) * texelSize, 0.0)\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tArea;\r\nuniform sampler2D tSearch;\r\n\r\nuniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\nvec2 round(vec2 x) {\r\n\r\n\treturn sign(x) * floor(abs(x) + 0.5);\r\n\r\n}\r\n\r\nfloat searchLength(vec2 e, float bias, float scale) {\r\n\r\n\t// Not required if tSearch accesses are set to point.\r\n\t// const vec2 SEARCH_TEX_PIXEL_SIZE = 1.0 / vec2(66.0, 33.0);\r\n\t// e = vec2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE + e * vec2(scale, 1.0) * vec2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\r\n\r\n\te.r = bias + e.r * scale;\r\n\r\n\treturn 255.0 * texture2D(tSearch, e, 0.0).r;\r\n\r\n}\r\n\r\nfloat searchXLeft(vec2 texCoord, float end) {\r\n\r\n\t/* @PSEUDO_GATHER4\r\n\t * This texCoord has been offset by (-0.25, -0.125) in the vertex shader to\r\n\t * sample between edge, thus fetching four edges in a row.\r\n\t * Sampling with different offsets in each direction allows to disambiguate\r\n\t * which edges are active from the four fetched ones.\r\n\t */\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord -= vec2(2.0, 0.0) * texelSize;\r\n\r\n\t\tif(!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\t// Correct the previously applied offset (-0.25, -0.125).\r\n\ttexCoord.x += 0.25 * texelSize.x;\r\n\r\n\t// The searches are biased by 1, so adjust the coords accordingly.\r\n\ttexCoord.x += texelSize.x;\r\n\r\n\t// Disambiguate the length added by the last step.\r\n\ttexCoord.x += 2.0 * texelSize.x; // Undo last step.\r\n\ttexCoord.x -= texelSize.x * searchLength(e, 0.0, 0.5);\r\n\r\n\treturn texCoord.x;\r\n\r\n}\r\n\r\nfloat searchXRight(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord += vec2(2.0, 0.0) * texelSize;\r\n\r\n\t\tif(!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.x -= 0.25 * texelSize.x;\r\n\ttexCoord.x -= texelSize.x;\r\n\ttexCoord.x -= 2.0 * texelSize.x;\r\n\ttexCoord.x += texelSize.x * searchLength(e, 0.5, 0.5);\r\n\r\n\treturn texCoord.x;\r\n\r\n}\r\n\r\nfloat searchYUp(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord += vec2(0.0, 2.0) * texelSize; // Changed sign.\r\n\r\n\t\tif(!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.y -= 0.25 * texelSize.y; // Changed sign.\r\n\ttexCoord.y -= texelSize.y; // Changed sign.\r\n\ttexCoord.y -= 2.0 * texelSize.y; // Changed sign.\r\n\ttexCoord.y += texelSize.y * searchLength(e.gr, 0.0, 0.5); // Changed sign.\r\n\r\n\treturn texCoord.y;\r\n\r\n}\r\n\r\nfloat searchYDown(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i ) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord -= vec2(0.0, 2.0) * texelSize; // Changed sign.\r\n\r\n\t\tif(!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.y += 0.25 * texelSize.y; // Changed sign.\r\n\ttexCoord.y += texelSize.y; // Changed sign.\r\n\ttexCoord.y += 2.0 * texelSize.y; // Changed sign.\r\n\ttexCoord.y -= texelSize.y * searchLength(e.gr, 0.5, 0.5); // Changed sign.\r\n\r\n\treturn texCoord.y;\r\n\r\n}\r\n\r\nvec2 area(vec2 dist, float e1, float e2, float offset) {\r\n\r\n\t// Rounding prevents precision errors of bilinear filtering.\r\n\tvec2 texCoord = SMAA_AREATEX_MAX_DISTANCE * round(4.0 * vec2(e1, e2)) + dist;\r\n\r\n\t// Scale and bias for texel space translation.\r\n\ttexCoord = SMAA_AREATEX_PIXEL_SIZE * texCoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);\r\n\r\n\t// Move to proper place, according to the subpixel offset.\r\n\ttexCoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\r\n\r\n\treturn texture2D(tArea, texCoord, 0.0).rg;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 weights = vec4(0.0);\r\n\tvec4 subsampleIndices = vec4(0.0);\r\n\tvec2 e = texture2D(tDiffuse, vUv).rg;\r\n\r\n\tif(e.g > 0.0) {\r\n\r\n\t\t// Edge at north.\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the left.\r\n\t\tvec2 coords;\r\n\t\tcoords.x = searchXLeft(vOffset[0].xy, vOffset[2].x);\r\n\t\tcoords.y = vOffset[1].y; // vOffset[1].y = vUv.y - 0.25 * texelSize.y (@CROSSING_OFFSET)\r\n\t\td.x = coords.x;\r\n\r\n\t\t/* Now fetch the left crossing edges, two at a time using bilinear filtering.\r\n\t\tSampling at -0.25 (see @CROSSING_OFFSET) enables to discern what value each edge has. */\r\n\r\n\t\tfloat e1 = texture2D(tDiffuse, coords, 0.0).r;\r\n\r\n\t\t// Find the distance to the right.\r\n\t\tcoords.x = searchXRight(vOffset[0].zw, vOffset[2].y);\r\n\t\td.y = coords.x;\r\n\r\n\t\t// Translate distances to pixel units for better interleave arithmetic and memory accesses.\r\n\t\td = d / texelSize.x - vPixCoord.x;\r\n\r\n\t\t// The area below needs a sqrt, as the areas texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the right crossing edges.\r\n\t\tcoords.y -= texelSize.y; // WebGL port note: Added.\r\n\t\tfloat e2 = sampleLevelZeroOffset(tDiffuse, coords, ivec2(1, 0)).r;\r\n\r\n\t\t// Pattern recognised, now get the actual area.\r\n\t\tweights.rg = area(sqrtD, e1, e2, subsampleIndices.y);\r\n\r\n\t}\r\n\r\n\tif(e.r > 0.0) {\r\n\r\n\t\t// Edge at west.\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the top.\r\n\t\tvec2 coords;\r\n\r\n\t\tcoords.y = searchYUp(vOffset[1].xy, vOffset[2].z);\r\n\t\tcoords.x = vOffset[0].x; // vOffset[1].x = vUv.x - 0.25 * texelSize.x;\r\n\t\td.x = coords.y;\r\n\r\n\t\t// Fetch the top crossing edges.\r\n\t\tfloat e1 = texture2D(tDiffuse, coords, 0.0).g;\r\n\r\n\t\t// Find the distance to the bottom.\r\n\t\tcoords.y = searchYDown(vOffset[1].zw, vOffset[2].w);\r\n\t\td.y = coords.y;\r\n\r\n\t\t// Distances in pixel units.\r\n\t\td = d / texelSize.y - vPixCoord.y;\r\n\r\n\t\t// The area below needs a sqrt, as the areas texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the bottom crossing edges.\r\n\t\tcoords.y -= texelSize.y; // WebGL port note: Added.\r\n\t\tfloat e2 = sampleLevelZeroOffset(tDiffuse, coords, ivec2(0, 1)).g;\r\n\r\n\t\t// Get the area for this direction.\r\n\t\tweights.ba = area(sqrtD, e1, e2, subsampleIndices.x);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = weights;\r\n\r\n}\r\n";
var vertex$16 = "uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvPixCoord = uv / texelSize;\r\n\r\n\t// Offsets for the searches (see @PSEUDO_GATHER4).\r\n\tvOffset[0] = uv.xyxy + texelSize.xyxy * vec4(-0.25, 0.125, 1.25, 0.125); // Changed sign in Y and W components.\r\n\tvOffset[1] = uv.xyxy + texelSize.xyxy * vec4(-0.125, 0.25, -0.125, -1.25); //Changed sign in Y and W components.\r\n\r\n\t// This indicates the ends of the loops.\r\n\tvOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * texelSize.xxyy * SMAA_MAX_SEARCH_STEPS_FLOAT;\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Subpixel Morphological Antialiasing.
 *
 * This material computes weights for detected edges.
 */

var SMAAWeightsMaterial = function (_ShaderMaterial) {
			inherits(SMAAWeightsMaterial, _ShaderMaterial);

			/**
    * Constructs a new SMAA weights material.
    *
    * @param {Vector2} [texelSize] - The absolute screen texel size.
    */

			function SMAAWeightsMaterial() {
						var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new three.Vector2();
						classCallCheck(this, SMAAWeightsMaterial);

						/**
       * The area pattern recognition image. Encoded as base64.
       *
       * @type {String}
       */

						var _this = possibleConstructorReturn(this, (SMAAWeightsMaterial.__proto__ || Object.getPrototypeOf(SMAAWeightsMaterial)).call(this, {

									type: "SMAAWeightsMaterial",

									defines: {

												SMAA_MAX_SEARCH_STEPS_INT: "8",
												SMAA_MAX_SEARCH_STEPS_FLOAT: "8.0",

												SMAA_AREATEX_MAX_DISTANCE: "16.0",

												SMAA_AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
												SMAA_AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)"

									},

									uniforms: {

												tDiffuse: new three.Uniform(null),
												tArea: new three.Uniform(null),
												tSearch: new three.Uniform(null),
												texelSize: new three.Uniform(texelSize)

									},

									fragmentShader: fragment$16,
									vertexShader: vertex$16,

									depthWrite: false,
									depthTest: false

						}));

						_this.areaImage = areaImage;

						/**
       * The search image. Encoded as base64.
       *
       * @type {String}
       */

						_this.searchImage = searchImage;

						return _this;
			}

			return SMAAWeightsMaterial;
}(three.ShaderMaterial);

var fragment$17 = "uniform sampler2D tDiffuse;\r\nuniform float middleGrey;\r\nuniform float maxLuminance;\r\nuniform vec3 luminanceCoefficients;\r\n\r\n#ifdef ADAPTED_LUMINANCE\r\n\r\n\tuniform sampler2D luminanceMap;\r\n\r\n#else\r\n\r\n\tuniform float averageLuminance;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvec3 toneMap(vec3 c) {\r\n\r\n\t#ifdef ADAPTED_LUMINANCE\r\n\r\n\t\t// Get the calculated average luminance by sampling the center.\r\n\t\tfloat lumAvg = texture2D(luminanceMap, vec2(0.5)).r;\r\n\r\n\t#else\r\n\r\n\t\tfloat lumAvg = averageLuminance;\r\n\r\n\t#endif\r\n\r\n\t// Calculate the luminance of the current pixel.\r\n\tfloat lumPixel = dot(c, luminanceCoefficients);\r\n\r\n\t// Apply the modified operator (Reinhard Eq. 4).\r\n\tfloat lumScaled = (lumPixel * middleGrey) / lumAvg;\r\n\r\n\tfloat lumCompressed = (lumScaled * (1.0 + (lumScaled / (maxLuminance * maxLuminance)))) / (1.0 + lumScaled);\r\n\r\n\treturn lumCompressed * c;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tgl_FragColor = vec4(toneMap(texel.rgb), texel.a);\r\n\r\n}\r\n";
var vertex$17 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Full-screen tone-mapping shader material.
 *
 * Reference:
 *  http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf
 */

var ToneMappingMaterial = function (_ShaderMaterial) {
			inherits(ToneMappingMaterial, _ShaderMaterial);

			/**
    * Constructs a new tone mapping material.
    */

			function ToneMappingMaterial() {
						classCallCheck(this, ToneMappingMaterial);
						return possibleConstructorReturn(this, (ToneMappingMaterial.__proto__ || Object.getPrototypeOf(ToneMappingMaterial)).call(this, {

									type: "ToneMappingMaterial",

									uniforms: {

												tDiffuse: new three.Uniform(null),
												luminanceMap: new three.Uniform(null),
												averageLuminance: new three.Uniform(1.0),
												luminanceCoefficients: new three.Uniform(new three.Vector3(0.2126, 0.7152, 0.0722)),
												maxLuminance: new three.Uniform(16.0),
												middleGrey: new three.Uniform(0.6)

									},

									fragmentShader: fragment$17,
									vertexShader: vertex$17,

									depthWrite: false,
									depthTest: false

						}));
			}

			return ToneMappingMaterial;
}(three.ShaderMaterial);

/**
 * A collection of shader materials that are used in the post processing passes.
 *
 * @module postprocessing/materials
 */

/**
 * An abstract pass.
 *
 * Passes that do not rely on the depth buffer should explicitly disable the
 * depth test and depth write in their respective shader materials.
 *
 * This class implements a {@link Pass#dispose} method that frees memory on
 * demand.
 */

var Pass = function () {

		/**
   * Constructs a new pass.
   *
   * @param {Scene} [scene] - The scene to render.
   * @param {Camera} [camera] - The camera.
   * @param {Mesh} [quad] - A quad that fills the screen to render 2D filter effects. Set this to null, if you don't need it (see {@link RenderPass}).
   */

		function Pass() {
				var scene = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new three.Scene();
				var camera = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new three.OrthographicCamera(-1, 1, 1, -1, 0, 1);
				var quad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new three.Mesh(new three.PlaneBufferGeometry(2, 2), null);
				classCallCheck(this, Pass);


				/**
     * The name of this pass.
     *
     * @type {String}
     */

				this.name = "Pass";

				/**
     * The scene to render.
     *
     * @type {Scene}
     * @protected
     * @default new Scene()
     */

				this.scene = scene;

				/**
     * The camera.
     *
     * @type {Camera}
     * @protected
     * @default new OrthographicCamera(-1, 1, 1, -1, 0, 1)
     */

				this.camera = camera;

				/**
     * A quad mesh that fills the screen.
     *
     * Assign your shader material to this mesh!
     *
     * @type {Mesh}
     * @protected
     * @default new Mesh(new PlaneBufferGeometry(2, 2), null)
     * @example this.quad.material = this.myMaterial;
     */

				this.quad = quad;

				if (this.quad !== null) {

						this.quad.frustumCulled = false;

						if (this.scene !== null) {

								this.scene.add(this.quad);
						}
				}

				/**
     * Indicates whether the read and write buffers should be swapped after this
     * pass has finished rendering.
     *
     * Set this to true if this pass renders to the write buffer so that a
     * following pass can find the result in the read buffer.
     *
     * @type {Boolean}
     * @default false
     */

				this.needsSwap = false;

				/**
     * Enabled flag.
     *
     * @type {Boolean}
     * @default true
     */

				this.enabled = true;

				/**
     * Render to screen flag.
     *
     * @type {Boolean}
     * @default false
     */

				this.renderToScreen = false;
		}

		/**
   * Renders the effect.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - A read buffer. Contains the result of the previous pass.
   * @param {WebGLRenderTarget} writeBuffer - A write buffer. Normally used as the render target when the read buffer is used as input.
   * @param {Number} [delta] - The delta time.
   * @param {Boolean} [maskActive] - Indicates whether a stencil test mask is active or not.
   */

		createClass(Pass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer, delta, maskActive) {

						throw new Error("Render method not implemented!");
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * You may override this method in case you want to be informed about the main
     * render size.
     *
     * The {@link EffectComposer} calls this method before this pass is
     * initialised and every time its own size is updated.
     *
     * @param {Number} width - The renderer's width.
     * @param {Number} height - The renderer's height.
     * @example this.myRenderTarget.setSize(width, height);
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {}

				/**
     * Performs initialisation tasks.
     *
     * By overriding this method you gain access to the renderer. You'll also be
     * able to configure your custom render targets to use the appropriate format
     * (RGB or RGBA).
     *
     * The provided renderer can be used to warm up special off-screen render
     * targets by performing a preliminary render operation.
     *
     * The {@link EffectComposer} calls this method when this pass is added to its
     * queue.
     *
     * @method initialise
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     * @example if(!alpha) { this.myRenderTarget.texture.format = RGBFormat; }
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {}

				/**
     * Performs a shallow search for properties that define a dispose method and
     * deletes them. The pass will be inoperative after this method was called!
     *
     * Disposable objects:
     *  - render targets
     *  - materials
     *  - textures
     *
     * The {@link EffectComposer} calls this method when it is being destroyed.
     * You may, however, use it independently to free memory when you are certain
     * that you don't need this pass anymore.
     */

		}, {
				key: "dispose",
				value: function dispose() {

						var keys = Object.keys(this);

						var key = void 0;

						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
								for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
										key = _step.value;


										if (this[key] !== null && typeof this[key].dispose === "function") {

												this[key].dispose();
												this[key] = null;
										}
								}
						} catch (err) {
								_didIteratorError = true;
								_iteratorError = err;
						} finally {
								try {
										if (!_iteratorNormalCompletion && _iterator.return) {
												_iterator.return();
										}
								} finally {
										if (_didIteratorError) {
												throw _iteratorError;
										}
								}
						}
				}
		}]);
		return Pass;
}();

/**
 * A blur pass.
 */

var BlurPass = function (_Pass) {
		inherits(BlurPass, _Pass);

		/**
   * Constructs a new blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
   * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
   */

		function BlurPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, BlurPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (BlurPass.__proto__ || Object.getPrototypeOf(BlurPass)).call(this));

				_this.name = "BlurPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetX = new three.WebGLRenderTarget(1, 1, {
						minFilter: three.LinearFilter,
						magFilter: three.LinearFilter,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetX.texture.name = "Blur.TargetX";
				_this.renderTargetX.texture.generateMipmaps = false;

				/**
     * A second render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetY = _this.renderTargetX.clone();

				_this.renderTargetY.texture.name = "Blur.TargetY";

				/**
     * The resolution scale.
     *
     * You need to call {@link EffectComposer#setSize} after changing this
     * value.
     *
     * @type {Number}
     * @default 0.5
     */

				_this.resolutionScale = options.resolutionScale !== undefined ? options.resolutionScale : 0.5;

				/**
     * A convolution shader material.
     *
     * @type {ConvolutionMaterial}
     * @private
     */

				_this.convolutionMaterial = new ConvolutionMaterial();

				_this.kernelSize = options.kernelSize;

				_this.quad.material = _this.convolutionMaterial;

				return _this;
		}

		/**
   * The absolute width of the internal render targets.
   *
   * @type {Number}
   */

		createClass(BlurPass, [{
				key: "render",


				/**
     * Blurs the read buffer.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

				value: function render(renderer, readBuffer, writeBuffer) {

						var scene = this.scene;
						var camera = this.camera;

						var renderTargetX = this.renderTargetX;
						var renderTargetY = this.renderTargetY;

						var material = this.convolutionMaterial;
						var uniforms = material.uniforms;
						var kernel = material.getKernel();

						var lastRT = readBuffer;
						var destRT = void 0;
						var i = void 0,
						    l = void 0;

						// Apply the multi-pass blur.
						for (i = 0, l = kernel.length - 1; i < l; ++i) {

								// Alternate between targets.
								destRT = i % 2 === 0 ? renderTargetX : renderTargetY;

								uniforms.kernel.value = kernel[i];
								uniforms.tDiffuse.value = lastRT.texture;
								renderer.render(scene, camera, destRT);

								lastRT = destRT;
						}

						uniforms.kernel.value = kernel[i];
						uniforms.tDiffuse.value = lastRT.texture;
						renderer.render(scene, camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Adjusts the format of the render targets.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {

						if (!alpha) {

								this.renderTargetX.texture.format = three.RGBFormat;
								this.renderTargetY.texture.format = three.RGBFormat;
						}
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						width = Math.max(1, Math.floor(width * this.resolutionScale));
						height = Math.max(1, Math.floor(height * this.resolutionScale));

						this.renderTargetX.setSize(width, height);
						this.renderTargetY.setSize(width, height);

						this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);
				}
		}, {
				key: "width",
				get: function get$$1() {
						return this.renderTargetX.width;
				}

				/**
     * The absolute height of the internal render targets.
     *
     * @type {Number}
     */

		}, {
				key: "height",
				get: function get$$1() {
						return this.renderTargetX.height;
				}

				/**
     * The kernel size.
     *
     * @type {KernelSize}
     * @default KernelSize.LARGE
     */

		}, {
				key: "kernelSize",
				get: function get$$1() {
						return this.convolutionMaterial.kernelSize;
				}

				/**
     * @type {KernelSize}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : KernelSize.LARGE;
						this.convolutionMaterial.kernelSize = x;
				}
		}]);
		return BlurPass;
}(Pass);

/**
 * A bloom pass.
 *
 * This pass renders a scene with superimposed blur by utilising the fast Kawase
 * convolution approach.
 */

var BloomPass = function (_Pass) {
	inherits(BloomPass, _Pass);

	/**
  * Constructs a new bloom pass.
  *
  * @param {Object} [options] - The options.
  * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
  * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
  * @param {Number} [options.intensity=1.0] - The strength of the bloom effect.
  * @param {Number} [options.distinction=1.0] - The luminance distinction factor. Raise this value to bring out the brighter elements in the scene.
  * @param {Number} [options.screenMode=true] - Whether the screen blend mode should be used for combining the bloom texture with the scene colors.
  */

	function BloomPass() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		classCallCheck(this, BloomPass);

		/**
   * The name of this pass.
   */

		var _this = possibleConstructorReturn(this, (BloomPass.__proto__ || Object.getPrototypeOf(BloomPass)).call(this));

		_this.name = "BloomPass";

		/**
   * This pass renders to the write buffer.
   */

		_this.needsSwap = true;

		/**
   * A blur pass.
   *
   * @type {BlurPass}
   * @private
   */

		_this.blurPass = new BlurPass(options);

		/**
   * A render target.
   *
   * @type {WebGLRenderTarget}
   * @private
   */

		_this.renderTarget = new three.WebGLRenderTarget(1, 1, {
			minFilter: three.LinearFilter,
			magFilter: three.LinearFilter,
			stencilBuffer: false,
			depthBuffer: false
		});

		_this.renderTarget.texture.name = "Bloom.Target";
		_this.renderTarget.texture.generateMipmaps = false;

		/**
   * A combine shader material.
   *
   * @type {CombineMaterial}
   * @private
   */

		_this.combineMaterial = new CombineMaterial(options.screenMode !== undefined ? options.screenMode : true);

		_this.intensity = options.intensity;

		/**
   * A luminosity shader material.
   *
   * @type {LuminosityMaterial}
   * @private
   */

		_this.luminosityMaterial = new LuminosityMaterial(true);

		_this.distinction = options.distinction;

		return _this;
	}

	/**
  * The resolution scale.
  *
  * @type {Number}
  * @default 0.5
  */

	createClass(BloomPass, [{
		key: "render",


		/**
   * Renders the effect.
   *
   * Extracts a luminance map from the read buffer, blurs it and combines it
   * with the read buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		value: function render(renderer, readBuffer, writeBuffer) {

			var quad = this.quad;
			var scene = this.scene;
			var camera = this.camera;
			var blurPass = this.blurPass;

			var luminosityMaterial = this.luminosityMaterial;
			var combineMaterial = this.combineMaterial;
			var renderTarget = this.renderTarget;

			// Luminance filter.
			quad.material = luminosityMaterial;
			luminosityMaterial.uniforms.tDiffuse.value = readBuffer.texture;
			renderer.render(scene, camera, renderTarget);

			// Convolution phase.
			blurPass.render(renderer, renderTarget, renderTarget);

			// Render the original scene with superimposed blur.
			quad.material = combineMaterial;
			combineMaterial.uniforms.texture1.value = readBuffer.texture;
			combineMaterial.uniforms.texture2.value = renderTarget.texture;

			renderer.render(scene, camera, this.renderToScreen ? null : writeBuffer);
		}

		/**
   * Adjusts the format of the render targets.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   */

	}, {
		key: "initialise",
		value: function initialise(renderer, alpha) {

			this.blurPass.initialise(renderer, alpha);

			if (!alpha) {
				this.renderTarget.texture.format = three.RGBFormat;
			}
		}

		/**
   * Updates this pass with the renderer's size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */

	}, {
		key: "setSize",
		value: function setSize(width, height) {

			this.blurPass.setSize(width, height);

			width = this.blurPass.width;
			height = this.blurPass.height;

			this.renderTarget.setSize(width, height);
		}
	}, {
		key: "resolutionScale",
		get: function get$$1() {
			return this.blurPass.resolutionScale;
		}

		/**
   * You need to call {@link EffectComposer#setSize} after changing this value.
   *
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
			this.blurPass.resolutionScale = x;
		}

		/**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @default KernelSize.LARGE
   */

	}, {
		key: "kernelSize",
		get: function get$$1() {
			return this.blurPass.kernelSize;
		}

		/**
   * @type {KernelSize}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : KernelSize.LARGE;
			this.blurPass.kernelSize = x;
		}

		/**
   * The overall intensity of the effect.
   *
   * @type {Number}
   * @default 1.0
   */

	}, {
		key: "intensity",
		get: function get$$1() {
			return this.combineMaterial.uniforms.opacity2.value;
		}

		/**
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
			this.combineMaterial.uniforms.opacity2.value = x;
		}

		/**
   * The luminance distinction factor.
   *
   * @type {Number}
   * @default 1.0
   */

	}, {
		key: "distinction",
		get: function get$$1() {
			return this.luminosityMaterial.uniforms.distinction.value;
		}

		/**
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
			this.luminosityMaterial.uniforms.distinction.value = x;
		}
	}]);
	return BloomPass;
}(Pass);

/**
 * A Depth of Field (DoF) pass using a bokeh shader.
 *
 * This pass requires a {@link EffectComposer#depthTexture}.
 */

var BokehPass = function (_Pass) {
		inherits(BokehPass, _Pass);

		/**
   * Constructs a new bokeh pass.
   *
   * @param {PerspectiveCamera} camera - The main camera. Used to obtain the aspect ratio and the near and far plane settings.
   * @param {Object} [options] - Additional parameters.
   * @param {Number} [options.focus=1.0] - Focus distance.
   * @param {Number} [options.aperture=0.025] - Camera aperture scale. Bigger values for shallower depth of field.
   * @param {Number} [options.maxBlur=1.0] - Maximum blur strength.
   */

		function BokehPass(camera) {
				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
				classCallCheck(this, BokehPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (BokehPass.__proto__ || Object.getPrototypeOf(BokehPass)).call(this));

				_this.name = "BokehPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A bokeh shader material.
     *
     * @type {BokehMaterial}
     * @private
     */

				_this.bokehMaterial = new BokehMaterial(camera, options);

				_this.quad.material = _this.bokehMaterial;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(BokehPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.bokehMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						this.bokehMaterial.uniforms.tDepth.value = readBuffer.depthTexture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.bokehMaterial.uniforms.aspect.value = width / height;
				}
		}]);
		return BokehPass;
}(Pass);

/**
 * An advanced Depth of Field (DoF) pass.
 *
 * Yields more realistic results but is also more demanding.
 *
 * This pass requires a {@link EffectComposer#depthTexture}.
 */

var Bokeh2Pass = function (_Pass) {
		inherits(Bokeh2Pass, _Pass);

		/**
   * Constructs a new bokeh2 pass.
   *
   * @param {PerspectiveCamera} camera - The main camera. Used to obtain the focal length and the near and far plane settings.
   * @param {Object} [options] - Additional parameters.
   * @param {Number} [options.rings=3] - The amount of blur rings.
   * @param {Number} [options.samples=4] - The amount of samples per ring.
   * @param {Boolean} [options.showFocus=false] - Whether the focus point should be highlighted.
   * @param {Boolean} [options.manualDoF=false] - Enables manual depth of field blur.
   * @param {Boolean} [options.vignette=false] - Enables a vignette effect.
   * @param {Boolean} [options.pentagon=false] - Enable to use a pentagonal shape to scale gathered texels.
   * @param {Boolean} [options.shaderFocus=true] - Disable if you compute your own focalDepth (in metres!).
   * @param {Boolean} [options.noise=true] - Disable if you don't want noise patterns for dithering.
   */

		function Bokeh2Pass(camera) {
				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
				classCallCheck(this, Bokeh2Pass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (Bokeh2Pass.__proto__ || Object.getPrototypeOf(Bokeh2Pass)).call(this));

				_this.name = "Bokeh2Pass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A bokeh shader material.
     *
     * @type {BokehMaterial}
     * @private
     */

				_this.bokehMaterial = new Bokeh2Material(camera, options);

				_this.quad.material = _this.bokehMaterial;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(Bokeh2Pass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.bokehMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						this.bokehMaterial.uniforms.tDepth.value = readBuffer.depthTexture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.bokehMaterial.setTexelSize(1.0 / width, 1.0 / height);
				}
		}]);
		return Bokeh2Pass;
}(Pass);

/**
 * A pass that disables the stencil mask.
 */

var ClearMaskPass = function (_Pass) {
	inherits(ClearMaskPass, _Pass);

	/**
  * Constructs a new clear mask pass.
  */

	function ClearMaskPass() {
		classCallCheck(this, ClearMaskPass);

		/**
   * The name of this pass.
   */

		var _this = possibleConstructorReturn(this, (ClearMaskPass.__proto__ || Object.getPrototypeOf(ClearMaskPass)).call(this, null, null, null));

		_this.name = "ClearMaskPass";

		return _this;
	}

	/**
  * Disables the stencil test.
  *
  * @param {WebGLRenderer} renderer - The renderer.
  */

	createClass(ClearMaskPass, [{
		key: "render",
		value: function render(renderer) {

			renderer.state.buffers.stencil.setTest(false);
		}
	}]);
	return ClearMaskPass;
}(Pass);

/**
 * Used for saving the original clear color of the renderer.
 *
 * @type Color
 * @private
 * @static
 */

var color = new three.Color();

/**
 * A clear pass.
 *
 * You can prevent specific buffers from being cleared by setting either the
 * autoClearColor, autoClearStencil or autoClearDepth properties of the renderer
 * to false.
 */

var ClearPass = function (_Pass) {
		inherits(ClearPass, _Pass);

		/**
   * Constructs a new clear pass.
   *
   * @param {Object} [options] - Additional options.
   * @param {Color} [options.clearColor=null] - An override clear color.
   * @param {Number} [options.clearAlpha=0.0] - An override clear alpha.
   */

		function ClearPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, ClearPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ClearPass.__proto__ || Object.getPrototypeOf(ClearPass)).call(this, null, null, null));

				_this.name = "ClearPass";

				/**
     * Clear color.
     *
     * @type {Color}
     * @default null
     */

				_this.clearColor = options.clearColor !== undefined ? options.clearColor : null;

				/**
     * Clear alpha.
     *
     * @type {Number}
     * @default 0.0
     */

				_this.clearAlpha = options.clearAlpha !== undefined ? options.clearAlpha : 0.0;

				return _this;
		}

		/**
   * Clears the read buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		createClass(ClearPass, [{
				key: "render",
				value: function render(renderer, readBuffer) {

						var clearColor = this.clearColor;

						var clearAlpha = void 0;

						if (clearColor !== null) {

								color.copy(renderer.getClearColor());
								clearAlpha = renderer.getClearAlpha();
								renderer.setClearColor(clearColor, this.clearAlpha);
						}

						renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
						renderer.clear();

						if (clearColor !== null) {

								renderer.setClearColor(color, clearAlpha);
						}
				}
		}]);
		return ClearPass;
}(Pass);

/**
 * A dot screen pass.
 */

var DotScreenPass = function (_Pass) {
		inherits(DotScreenPass, _Pass);

		/**
   * Constructs a new dot screen pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.angle=1.57] - The angle of the pattern.
   * @param {Number} [options.scale=1.0] - The scale of the overall effect.
   * @param {Number} [options.intensity=1.0] - The intensity of the effect.
   * @param {Boolean} [options.average=false] - Whether the shader should output a colour average (black and white).
   */

		function DotScreenPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, DotScreenPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (DotScreenPass.__proto__ || Object.getPrototypeOf(DotScreenPass)).call(this));

				_this.name = "DotScreenPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A dot screen shader material.
     *
     * @type {DotScreenMaterial}
     * @private
     */

				_this.material = new DotScreenMaterial(options.average);

				if (options.angle !== undefined) {
						_this.material.uniforms.angle.value = options.angle;
				}
				if (options.scale !== undefined) {
						_this.material.uniforms.scale.value = options.scale;
				}
				if (options.intensity !== undefined) {
						_this.material.uniforms.intensity.value = options.intensity;
				}

				_this.quad.material = _this.material;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(DotScreenPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.material.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} heght - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						width = Math.max(1, width);
						height = Math.max(1, height);

						this.material.uniforms.offsetRepeat.value.z = width;
						this.material.uniforms.offsetRepeat.value.w = height;
				}
		}]);
		return DotScreenPass;
}(Pass);

/**
 * A depth pass.
 *
 * Reads the depth from a depth texture and renders it.
 *
 * This pass requires a {@link EffectComposer#depthTexture}.
 */

var DepthPass = function (_Pass) {
		inherits(DepthPass, _Pass);

		/**
   * Constructs a new depth pass.
   *
   * @param {PerspectiveCamera} camera - The main camera. Used to obtain the near and far plane settings.
   */

		function DepthPass(camera) {
				classCallCheck(this, DepthPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (DepthPass.__proto__ || Object.getPrototypeOf(DepthPass)).call(this));

				_this.name = "DepthPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A depth shader material.
     *
     * @type {DepthMaterial}
     * @private
     */

				_this.depthMaterial = new DepthMaterial(camera);

				_this.quad.material = _this.depthMaterial;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(DepthPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.depthMaterial.uniforms.tDepth.value = readBuffer.depthTexture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}
		}]);
		return DepthPass;
}(Pass);

/**
 * A film pass.
 *
 * Provides various cinematic effects.
 */

var FilmPass = function (_Pass) {
		inherits(FilmPass, _Pass);

		/**
   * Constructs a new film pass.
   *
   * @param {Object} [options] - The options. Disabled effects have no negative impact on performance.
   * @param {Boolean} [options.greyscale=false] - Enable greyscale effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.sepia=false] - Enable sepia effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.vignette=false] - Apply vignette effect.
   * @param {Boolean} [options.eskil=false] - Use Eskil's vignette approach. The default looks dusty while Eskil looks more burned out.
   * @param {Boolean} [options.screenMode=true] - Whether the screen blend mode should be used for noise and scanlines.
   * @param {Boolean} [options.scanlines=true] - Show scanlines.
   * @param {Boolean} [options.noise=true] - Show noise-based film grain.
   * @param {Number} [options.noiseIntensity=0.5] - The noise intensity. 0.0 to 1.0.
   * @param {Number} [options.scanlineIntensity=0.05] - The scanline intensity. 0.0 to 1.0.
   * @param {Number} [options.scanlineDensity=1.0] - The number of scanlines in percent, relative to the screen height.
   * @param {Number} [options.greyscaleIntensity=1.0] - The intensity of the greyscale effect.
   * @param {Number} [options.sepiaIntensity=1.0] - The intensity of the sepia effect.
   * @param {Number} [options.vignetteOffset=1.0] - The offset of the vignette effect.
   * @param {Number} [options.vignetteDarkness=1.0] - The darkness of the vignette effect.
   */

		function FilmPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, FilmPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (FilmPass.__proto__ || Object.getPrototypeOf(FilmPass)).call(this));

				_this.name = "FilmPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * Film shader material.
     *
     * @type {FilmMaterial}
     * @private
     */

				_this.material = new FilmMaterial(options);

				_this.quad.material = _this.material;

				/**
     * The amount of scanlines in percent, relative to the screen height.
     *
     * You need to call {@link EffectComposer#setSize} after changing this
     * value.
     *
     * @type {Number}
     * @default 1.25
     */

				_this.scanlineDensity = options.scanlineDensity === undefined ? 1.25 : options.scanlineDensity;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   * @param {Number} delta - The render delta time.
   */

		createClass(FilmPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer, delta) {

						this.material.uniforms.tDiffuse.value = readBuffer.texture;
						this.material.uniforms.time.value += delta;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Adjusts the scanline count using the renderer's height.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.material.uniforms.scanlineCount.value = Math.round(height * this.scanlineDensity);
				}
		}]);
		return FilmPass;
}(Pass);

/**
 * Returns a random integer in the specified range.
 *
 * @private
 * @static
 * @param {Number} low - The lowest possible value.
 * @param {Number} high - The highest possible value.
 * @return {Number} The random value.
 */

function randomInt(low, high) {

		return low + Math.floor(Math.random() * (high - low + 1));
}

/**
 * Returns a random float in the specified range.
 *
 * @private
 * @static
 * @param {Number} low - The lowest possible value.
 * @param {Number} high - The highest possible value.
 * @return {Number} The random value.
 */

function randomFloat(low, high) {

		return low + Math.random() * (high - low);
}

/**
 * A glitch pass.
 */

var GlitchPass = function (_Pass) {
		inherits(GlitchPass, _Pass);

		/**
   * Constructs a new glitch pass.
   *
   * @param {Object} [options] - The options.
   * @param {Texture} [options.perturbMap] - A perturbation map. If none is provided, a noise texture will be created.
   * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.
   */

		function GlitchPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, GlitchPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (GlitchPass.__proto__ || Object.getPrototypeOf(GlitchPass)).call(this));

				_this.name = "GlitchPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * Glitch shader material.
     *
     * @type {GlitchMaterial}
     * @private
     */

				_this.material = new GlitchMaterial();

				_this.quad.material = _this.material;

				/**
     * A perturbation map.
     *
     * @type {Texture}
     * @private
     */

				_this.texture = null;

				_this.perturbMap = options.perturbMap !== undefined ? options.perturbMap : _this.generatePerturbMap(options.dtSize);
				_this.perturbMap.name = "Glitch.Perturbation";
				_this.perturbMap.generateMipmaps = false;

				/**
     * The effect mode.
     *
     * @type {GlitchMode}
     * @default GlitchMode.SPORADIC
     */

				_this.mode = GlitchMode.SPORADIC;

				/**
     * Counter for glitch activation and deactivation.
     *
     * @type {Number}
     * @private
     */

				_this.counter = 0;

				/**
     * A random break point for the sporadic glitch activation.
     *
     * @type {Number}
     * @private
     */

				_this.breakPoint = randomInt(120, 240);

				return _this;
		}

		/**
   * The current perturbation map.
   *
   * @type {Texture}
   */

		createClass(GlitchPass, [{
				key: "generatePerturbMap",


				/**
     * Destroys the current perturbation map and replaces it with a new one.
     *
     * @param {Number} [size=64] - The texture size.
     * @return {DataTexture} The perturbation texture.
     */

				value: function generatePerturbMap() {
						var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;


						var pixels = size * size;
						var data = new Float32Array(pixels * 3);

						var dt = this.perturbMap;
						var i = void 0,
						    x = void 0;

						for (i = 0; i < pixels; ++i) {

								x = Math.random();

								data[i * 3] = x;
								data[i * 3 + 1] = x;
								data[i * 3 + 2] = x;
						}

						if (dt !== null) {

								dt.dispose();
						}

						dt = new three.DataTexture(data, size, size, three.RGBFormat, three.FloatType);
						dt.needsUpdate = true;

						this.perturbMap = dt;

						return dt;
				}

				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

		}, {
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						var mode = this.mode;
						var counter = this.counter;
						var breakPoint = this.breakPoint;
						var uniforms = this.material.uniforms;

						uniforms.tDiffuse.value = readBuffer.texture;
						uniforms.seed.value = Math.random();
						uniforms.active.value = true;

						if (counter % breakPoint === 0 || mode === GlitchMode.CONSTANT_WILD) {

								uniforms.amount.value = Math.random() / 30.0;
								uniforms.angle.value = randomFloat(-Math.PI, Math.PI);
								uniforms.seedX.value = randomFloat(-1.0, 1.0);
								uniforms.seedY.value = randomFloat(-1.0, 1.0);
								uniforms.distortionX.value = randomFloat(0.0, 1.0);
								uniforms.distortionY.value = randomFloat(0.0, 1.0);

								this.breakPoint = randomInt(120, 240);
								this.counter = 0;
						} else {

								if (counter % breakPoint < breakPoint / 5 || mode === GlitchMode.CONSTANT_MILD) {

										uniforms.amount.value = Math.random() / 90.0;
										uniforms.angle.value = randomFloat(-Math.PI, Math.PI);
										uniforms.distortionX.value = randomFloat(0.0, 1.0);
										uniforms.distortionY.value = randomFloat(0.0, 1.0);
										uniforms.seedX.value = randomFloat(-0.3, 0.3);
										uniforms.seedY.value = randomFloat(-0.3, 0.3);
								} else {

										// Sporadic.
										uniforms.active.value = false;
								}
						}

						++this.counter;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}
		}, {
				key: "perturbMap",
				get: function get$$1() {
						return this.texture;
				}

				/**
     * Assigning a new perturbation map does not destroy the current one!
     *
     * @type {Texture}
     */

				,
				set: function set$$1(x) {

						this.texture = x;
						this.material.uniforms.tPerturb.value = x;
				}
		}]);
		return GlitchPass;
}(Pass);

/**
 * A glitch mode enumeration.
 *
 * @type {Object}
 * @property {Number} SPORADIC - Sporadic glitches.
 * @property {Number} CONSTANT_MILD - Constant mild glitches.
 * @property {Number} CONSTANT_WILD - Constant wild glitches.
 */

var GlitchMode = {

		SPORADIC: 0,
		CONSTANT_MILD: 1,
		CONSTANT_WILD: 2

};

/**
 * A pass that renders a given scene directly on screen or into the read buffer
 * for further processing.
 */

var RenderPass = function (_Pass) {
		inherits(RenderPass, _Pass);

		/**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - Additional options.
   * @param {Material} [options.overrideMaterial=null] - An override material for the scene.
   * @param {Color} [options.clearColor=null] - An override clear color.
   * @param {Number} [options.clearAlpha=1.0] - An override clear alpha.
   * @param {Boolean} [options.clearDepth=false] - Whether depth should be cleared explicitly.
   * @param {Boolean} [options.clear=true] - Whether all buffers should be cleared.
   */

		function RenderPass(scene, camera) {
				var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
				classCallCheck(this, RenderPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (RenderPass.__proto__ || Object.getPrototypeOf(RenderPass)).call(this, scene, camera, null));

				_this.name = "RenderPass";

				/**
     * A clear pass.
     *
     * @type {ClearPass}
     */

				_this.clearPass = new ClearPass(options);

				/**
     * An override material.
     *
     * @type {Material}
     * @default null
     */

				_this.overrideMaterial = options.overrideMaterial !== undefined ? options.overrideMaterial : null;

				/**
     * Indicates whether the depth buffer should be cleared explicitly.
     *
     * @type {Boolean}
     * @default false
     */

				_this.clearDepth = options.clearDepth !== undefined ? options.clearDepth : false;

				/**
     * Indicates whether the color, depth and stencil buffers should be cleared.
     *
     * Even with clear set to true you can prevent specific buffers from being
     * cleared by setting either the autoClearColor, autoClearStencil or
     * autoClearDepth properties of the renderer to false.
     *
     * @type {Boolean}
     * @default true
     */

				_this.clear = options.clear !== undefined ? options.clear : true;

				return _this;
		}

		/**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		createClass(RenderPass, [{
				key: "render",
				value: function render(renderer, readBuffer) {

						var scene = this.scene;
						var target = this.renderToScreen ? null : readBuffer;

						if (this.clear) {

								this.clearPass.render(renderer, target);
						} else if (this.clearDepth) {

								renderer.setRenderTarget(target);
								renderer.clearDepth();
						}

						scene.overrideMaterial = this.overrideMaterial;
						renderer.render(scene, this.camera, target);
						scene.overrideMaterial = null;
				}
		}]);
		return RenderPass;
}(Pass);

/**
 * Clamps a given value.
 *
 * @private
 * @static
 * @param {Number} value - The value to clamp.
 * @param {Number} min - The lowest possible value.
 * @param {Number} max - The highest possible value.
 * @return {Number} The clamped value.
 */

function clamp(value, min, max) {

		return Math.max(min, Math.min(max, value));
}

/**
 * A crepuscular rays pass.
 */

var GodRaysPass = function (_Pass) {
		inherits(GodRaysPass, _Pass);

		/**
   * Constructs a new god rays pass.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object3D} lightSource - The main light source.
   * @param {Object} [options] - The options.
   * @param {Number} [options.density=0.96] - The density of the light rays.
   * @param {Number} [options.decay=0.93] - An illumination decay factor.
   * @param {Number} [options.weight=0.4] - A light ray weight factor.
   * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.
   * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.
   * @param {Number} [options.intensity=1.0] - A constant factor for additive blending.
   * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
   * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
   * @param {Number} [options.samples=60] - The number of samples per pixel.
   * @param {Number} [options.screenMode=true] - Whether the screen blend mode should be used for combining the god rays texture with the scene colors.
   */

		function GodRaysPass(scene, camera, lightSource) {
				var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
				classCallCheck(this, GodRaysPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (GodRaysPass.__proto__ || Object.getPrototypeOf(GodRaysPass)).call(this));

				_this.name = "GodRaysPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A scene that only contains the light source.
     *
     * @type {Scene}
     * @private
     */

				_this.lightScene = new three.Scene();

				/**
     * The main scene.
     *
     * @type {Scene}
     * @private
     */

				_this.mainScene = scene;

				/**
     * The main camera.
     *
     * @type {Camera}
     * @private
     */

				_this.mainCamera = camera;

				/**
     * A pass that only renders the light source.
     *
     * @type {RenderPass}
     * @private
     */

				_this.renderPassLight = new RenderPass(_this.lightScene, _this.mainCamera);

				/**
     * A pass that renders the masked scene over the light.
     *
     * @type {RenderPass}
     * @private
     */

				_this.renderPassMask = new RenderPass(_this.mainScene, _this.mainCamera, {
						overrideMaterial: new three.MeshBasicMaterial({ color: 0x000000 }),
						clearColor: new three.Color(0x000000)
				});

				_this.renderPassMask.clear = false;

				/**
     * A blur pass.
     *
     * @type {BlurPass}
     * @private
     */

				_this.blurPass = new BlurPass(options);

				/**
     * A render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetX = new three.WebGLRenderTarget(1, 1, {
						minFilter: three.LinearFilter,
						magFilter: three.LinearFilter,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetX.texture.name = "GodRays.TargetX";
				_this.renderTargetX.texture.generateMipmaps = false;

				/**
     * A second render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetY = _this.renderTargetX.clone();

				_this.renderTargetY.texture.name = "GodRays.TargetY";

				/**
     * A render target for the masked light scene.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetMask = new three.WebGLRenderTarget(1, 1, {
						minFilter: three.LinearFilter,
						magFilter: three.LinearFilter
				});

				_this.renderTargetMask.texture.name = "GodRays.Mask";
				_this.renderTargetMask.texture.generateMipmaps = false;

				/**
     * The light source.
     *
     * @type {Object3D}
     */

				_this.lightSource = lightSource;

				/**
     * The light position in screen space.
     *
     * @type {Vector3}
     * @private
     */

				_this.screenPosition = new three.Vector3();

				/**
     * A god rays shader material.
     *
     * @type {GodRaysMaterial}
     * @private
     */

				_this.godRaysMaterial = new GodRaysMaterial();
				_this.godRaysMaterial.uniforms.lightPosition.value = _this.screenPosition;

				if (options.exposure !== undefined) {
						_this.godRaysMaterial.uniforms.exposure.value = options.exposure;
				}
				if (options.density !== undefined) {
						_this.godRaysMaterial.uniforms.density.value = options.density;
				}
				if (options.decay !== undefined) {
						_this.godRaysMaterial.uniforms.decay.value = options.decay;
				}
				if (options.weight !== undefined) {
						_this.godRaysMaterial.uniforms.weight.value = options.weight;
				}
				if (options.clampMax !== undefined) {
						_this.godRaysMaterial.uniforms.clampMax.value = options.clampMax;
				}

				_this.samples = options.samples;

				/**
     * A combine shader material.
     *
     * @type {CombineMaterial}
     * @private
     */

				_this.combineMaterial = new CombineMaterial(options.screenMode !== undefined ? options.screenMode : true);

				_this.intensity = options.intensity;

				return _this;
		}

		/**
   * The resolution scale.
   *
   * @type {Number}
   * @default 0.5
   */

		createClass(GodRaysPass, [{
				key: "render",


				/**
     * Renders the scene.
     *
     * The god rays pass has four phases:
     *
     * Mask Phase:
     *  First, the light source is rendered. Then the scene is rendered into the
     *  same buffer using a mask override material with depth test enabled.
     *
     * Preliminary Blur Phase:
     *  The masked scene is blurred.
     *
     * God Rays Phase:
     *  The blurred scene is blurred again, but this time along radial lines
     *  towards the light source.
     *
     * Composite Phase:
     *  The final result is combined with the read buffer.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

				value: function render(renderer, readBuffer, writeBuffer) {

						var quad = this.quad;
						var scene = this.scene;
						var camera = this.camera;
						var mainScene = this.mainScene;

						var lightSource = this.lightSource;
						var screenPosition = this.screenPosition;

						var godRaysMaterial = this.godRaysMaterial;
						var combineMaterial = this.combineMaterial;

						var renderTargetMask = this.renderTargetMask;
						var renderTargetX = this.renderTargetX;
						var renderTargetY = this.renderTargetY;

						var background = void 0,
						    parent = void 0;

						// Compute the screen light position and translate it to [0, 1].
						screenPosition.copy(lightSource.position).project(this.mainCamera);
						screenPosition.x = clamp((screenPosition.x + 1.0) * 0.5, 0.0, 1.0);
						screenPosition.y = clamp((screenPosition.y + 1.0) * 0.5, 0.0, 1.0);

						// Render the masked scene.
						parent = lightSource.parent;
						background = mainScene.background;
						mainScene.background = null;
						this.lightScene.add(lightSource);

						this.renderPassLight.render(renderer, renderTargetMask);
						this.renderPassMask.render(renderer, renderTargetMask);

						if (parent !== null) {

								parent.add(lightSource);
						}

						mainScene.background = background;

						// Convolution phase.
						this.blurPass.render(renderer, renderTargetMask, renderTargetX);

						// God rays pass.
						quad.material = godRaysMaterial;
						godRaysMaterial.uniforms.tDiffuse.value = renderTargetX.texture;
						renderer.render(scene, camera, renderTargetY);

						// Final pass - composite god rays onto colours.
						quad.material = combineMaterial;
						combineMaterial.uniforms.texture1.value = readBuffer.texture;
						combineMaterial.uniforms.texture2.value = renderTargetY.texture;

						renderer.render(scene, camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Adjusts the format of the render targets.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {

						this.renderPassLight.initialise(renderer, alpha);
						this.renderPassMask.initialise(renderer, alpha);
						this.blurPass.initialise(renderer, alpha);

						if (!alpha) {

								this.renderTargetMask.texture.format = three.RGBFormat;
								this.renderTargetX.texture.format = three.RGBFormat;
								this.renderTargetY.texture.format = three.RGBFormat;
						}
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.renderPassLight.setSize(width, height);
						this.renderPassMask.setSize(width, height);
						this.blurPass.setSize(width, height);

						width = this.blurPass.width;
						height = this.blurPass.height;

						this.renderTargetMask.setSize(width, height);
						this.renderTargetX.setSize(width, height);
						this.renderTargetY.setSize(width, height);
				}
		}, {
				key: "resolutionScale",
				get: function get$$1() {
						return this.blurPass.resolutionScale;
				}

				/**
     * You need to call {@link EffectComposer#setSize} after changing this value.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
						this.blurPass.resolutionScale = x;
				}

				/**
     * The blur kernel size.
     *
     * @type {KernelSize}
     * @default KernelSize.LARGE
     */

		}, {
				key: "kernelSize",
				get: function get$$1() {
						return this.blurPass.kernelSize;
				}

				/**
     * @type {KernelSize}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : KernelSize.LARGE;
						this.blurPass.kernelSize = x;
				}

				/**
     * The overall intensity of the effect.
     *
     * @type {Number}
     * @default 1.0
     */

		}, {
				key: "intensity",
				get: function get$$1() {
						return this.combineMaterial.uniforms.opacity2.value;
				}

				/**
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
						this.combineMaterial.uniforms.opacity2.value = x;
				}

				/**
     * The number of samples per pixel.
     *
     * @type {Number}
     * @default 60
     */

		}, {
				key: "samples",
				get: function get$$1() {
						return Number.parseInt(this.godRaysMaterial.defines.NUM_SAMPLES_INT);
				}

				/**
     * This value must be carefully chosen. A higher value directly increases the
     * GPU load.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60;


						x = Math.floor(x);

						this.godRaysMaterial.defines.NUM_SAMPLES_FLOAT = x.toFixed(1);
						this.godRaysMaterial.defines.NUM_SAMPLES_INT = x.toFixed(0);
						this.godRaysMaterial.needsUpdate = true;
				}
		}]);
		return GodRaysPass;
}(Pass);

/**
 * A mask pass.
 */

var MaskPass = function (_Pass) {
		inherits(MaskPass, _Pass);

		/**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use.
   */

		function MaskPass(scene, camera) {
				classCallCheck(this, MaskPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (MaskPass.__proto__ || Object.getPrototypeOf(MaskPass)).call(this, scene, camera, null));

				_this.name = "MaskPass";

				/**
     * Inverse flag.
     *
     * @type {Boolean}
     * @default false
     */

				_this.inverse = false;

				/**
     * Stencil buffer clear flag.
     *
     * @type {Boolean}
     * @default true
     */

				_this.clearStencil = true;

				return _this;
		}

		/**
   * Creates a stencil bit mask.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(MaskPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						var context = renderer.context;
						var state = renderer.state;

						var scene = this.scene;
						var camera = this.camera;

						var writeValue = this.inverse ? 0 : 1;
						var clearValue = 1 - writeValue;

						// Don't update color or depth.
						state.buffers.color.setMask(false);
						state.buffers.depth.setMask(false);

						// Lock the buffers.
						state.buffers.color.setLocked(true);
						state.buffers.depth.setLocked(true);

						// Configure the stencil.
						state.buffers.stencil.setTest(true);
						state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
						state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
						state.buffers.stencil.setClear(clearValue);

						// Clear the stencil.
						if (this.clearStencil) {

								renderer.setRenderTarget(readBuffer);
								renderer.clearStencil();

								renderer.setRenderTarget(writeBuffer);
								renderer.clearStencil();
						}

						// Draw the mask into both buffers.
						renderer.render(scene, camera, readBuffer);
						renderer.render(scene, camera, writeBuffer);

						// Unlock the buffers.
						state.buffers.color.setLocked(false);
						state.buffers.depth.setLocked(false);

						// Only render where the stencil is set to 1.
						state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff);
						state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
				}
		}]);
		return MaskPass;
}(Pass);

/**
 * A pixelation pass.
 */

var PixelationPass = function (_Pass) {
		inherits(PixelationPass, _Pass);

		/**
   * Constructs a new pixelation pass.
   *
   * @param {Number} [granularity=30.0] - The intensity of the effect.
   */

		function PixelationPass() {
				var granularity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30.0;
				classCallCheck(this, PixelationPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (PixelationPass.__proto__ || Object.getPrototypeOf(PixelationPass)).call(this));

				_this.name = "PixelationPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A pixelation shader material.
     *
     * @type {PixelationMaterial}
     * @private
     */

				_this.pixelationMaterial = new PixelationMaterial();

				_this.granularity = granularity;

				_this.quad.material = _this.pixelationMaterial;

				return _this;
		}

		/**
   * The pixel granularity.
   *
   * @type {Number}
   * @default 30.0
   */

		createClass(PixelationPass, [{
				key: "render",


				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

				value: function render(renderer, readBuffer, writeBuffer) {

						this.pixelationMaterial.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.pixelationMaterial.setResolution(width, height);
				}
		}, {
				key: "granularity",
				get: function get$$1() {
						return this.pixelationMaterial.granularity;
				}

				/**
     * A higher value yields coarser visuals.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;


						x = Math.floor(x);

						if (x % 2 > 0) {

								x += 1;
						}

						this.pixelationMaterial.granularity = x;
				}
		}]);
		return PixelationPass;
}(Pass);

/**
 * A pass that renders the result from a previous pass to another render target.
 */

var SavePass = function (_Pass) {
		inherits(SavePass, _Pass);

		/**
   * Constructs a new save pass.
   *
   * @param {WebGLRenderTarget} [renderTarget] - The render target to use for saving the read buffer.
   * @param {Boolean} [resize=true] - Whether the render target should adjust to the size of the read/write buffer.
   */

		function SavePass(renderTarget) {
				var resize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
				classCallCheck(this, SavePass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (SavePass.__proto__ || Object.getPrototypeOf(SavePass)).call(this));

				_this.name = "SavePass";

				/**
     * Copy shader material.
     *
     * @type {CopyMaterial}
     * @private
     */

				_this.material = new CopyMaterial();

				_this.quad.material = _this.material;

				/**
     * The render target.
     *
     * @type {WebGLRenderTarget}
     */

				_this.renderTarget = renderTarget !== undefined ? renderTarget : new three.WebGLRenderTarget(1, 1, {
						minFilter: three.LinearFilter,
						magFilter: three.LinearFilter,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTarget.texture.name = "Save.Target";
				_this.renderTarget.texture.generateMipmaps = false;

				/**
     * Indicates whether the render target should be resized when the size of
     * the composer's read/write buffer changes.
     *
     * @type {Boolean}
     * @default true
     */

				_this.resize = resize;

				return _this;
		}

		/**
   * Saves the read buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		createClass(SavePass, [{
				key: "render",
				value: function render(renderer, readBuffer) {

						this.material.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderTarget);
				}

				/**
     * Adjusts the format of the render target.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {

						if (!alpha) {

								this.renderTarget.texture.format = three.RGBFormat;
						}
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						if (this.resize) {

								width = Math.max(1, width);
								height = Math.max(1, height);

								this.renderTarget.setSize(width, height);
						}
				}
		}]);
		return SavePass;
}(Pass);

/**
 * A shader pass.
 *
 * Used to render any shader material as a 2D filter.
 */

var ShaderPass = function (_Pass) {
		inherits(ShaderPass, _Pass);

		/**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - The shader material to use.
   * @param {String} [textureID="tDiffuse"] - The texture uniform identifier.
   */

		function ShaderPass(material) {
				var textureID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "tDiffuse";
				classCallCheck(this, ShaderPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ShaderPass.__proto__ || Object.getPrototypeOf(ShaderPass)).call(this));

				_this.name = "ShaderPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * The shader material to use for rendering.
     *
     * @type {ShaderMaterial}
     */

				_this.material = material;

				_this.quad.material = _this.material;

				/**
     * The name of the color sampler uniform of the given material.
     *
     * @type {String}
     * @default "tDiffuse"
     */

				_this.textureID = textureID;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(ShaderPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						if (this.material.uniforms[this.textureID] !== undefined) {

								this.material.uniforms[this.textureID].value = readBuffer.texture;
						}

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}
		}]);
		return ShaderPass;
}(Pass);

/**
 * Half PI.
 *
 * @type {Number}
 * @private
 * @static
 * @final
 */

var HALF_PI = Math.PI * 0.5;

/**
 * A vector.
 *
 * @type {Vector3}
 * @private
 * @static
 * @final
 */

var v = new three.Vector3();

/**
 * A vector.
 *
 * @type {Vector3}
 * @private
 * @static
 * @final
 */

var ab = new three.Vector3();

/**
 * A shock wave pass.
 */

var ShockWavePass = function (_Pass) {
		inherits(ShockWavePass, _Pass);

		/**
   * Constructs a new shock wave pass.
   *
   * @param {Camera} camera - The main camera.
   * @param {Vector3} [epicenter] - The world position of the shock wave epicenter.
   * @param {Object} [options] - The options.
   * @param {Number} [options.speed=1.0] - The animation speed.
   * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.
   * @param {Number} [options.waveSize=0.2] - The wave size.
   * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
   */

		function ShockWavePass(camera) {
				var epicenter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new three.Vector3();
				var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
				classCallCheck(this, ShockWavePass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ShockWavePass.__proto__ || Object.getPrototypeOf(ShockWavePass)).call(this));

				_this.name = "ShockWavePass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * The main camera.
     *
     * @type {Object3D}
     */

				_this.mainCamera = camera;

				/**
     * The epicenter.
     *
     * @type {Vector3}
     * @example shockWavePass.epicenter = myMesh.position;
     */

				_this.epicenter = epicenter;

				/**
     * The object position in screen space.
     *
     * @type {Vector3}
     * @private
     */

				_this.screenPosition = new three.Vector3();

				/**
     * The speed of the shock wave animation.
     *
     * @type {Number}
     * @default 2.0
     */

				_this.speed = options.speed !== undefined ? options.speed : 2.0;

				/**
     * A time accumulator.
     *
     * @type {Number}
     * @private
     */

				_this.time = 0.0;

				/**
     * Indicates whether the shock wave animation is active.
     *
     * @type {Boolean}
     * @private
     */

				_this.active = false;

				/**
     * A shock wave shader material.
     *
     * @type {ShockWaveMaterial}
     * @private
     */

				_this.shockWaveMaterial = new ShockWaveMaterial(options);

				_this.shockWaveMaterial.uniforms.center.value = _this.screenPosition;

				/**
     * A copy shader material.
     *
     * @type {CopyMaterial}
     * @private
     */

				_this.copyMaterial = new CopyMaterial();

				return _this;
		}

		/**
   * Emits the shock wave.
   */

		createClass(ShockWavePass, [{
				key: "explode",
				value: function explode() {

						this.time = 0.0;
						this.active = true;
				}

				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     * @param {Number} delta - The render delta time.
     */

		}, {
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer, delta) {

						var epicenter = this.epicenter;
						var mainCamera = this.mainCamera;
						var screenPosition = this.screenPosition;

						var shockWaveMaterial = this.shockWaveMaterial;
						var uniforms = shockWaveMaterial.uniforms;
						var center = uniforms.center;
						var radius = uniforms.radius;
						var maxRadius = uniforms.maxRadius;
						var waveSize = uniforms.waveSize;

						this.copyMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						this.quad.material = this.copyMaterial;

						if (this.active) {

								// Calculate direction vectors.
								mainCamera.getWorldDirection(v);
								ab.copy(mainCamera.position).sub(epicenter);

								// Don't render the effect if the object is behind the camera.
								if (v.angleTo(ab) > HALF_PI) {

										// Scale the effect based on distance to the object.
										uniforms.cameraDistance.value = mainCamera.position.distanceTo(epicenter);

										// Calculate the screen position of the epicenter.
										screenPosition.copy(epicenter).project(mainCamera);
										center.value.x = (screenPosition.x + 1.0) * 0.5;
										center.value.y = (screenPosition.y + 1.0) * 0.5;

										uniforms.tDiffuse.value = readBuffer.texture;
										this.quad.material = shockWaveMaterial;
								}

								// Update the shock wave radius based on time.
								this.time += delta * this.speed;
								radius.value = this.time - waveSize.value;

								if (radius.value >= (maxRadius.value + waveSize.value) * 2) {

										this.active = false;
								}
						}

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.shockWaveMaterial.uniforms.aspect.value = width / height;
				}
		}]);
		return ShockWavePass;
}(Pass);

/**
 * Subpixel Morphological Antialiasing (SMAA) v2.8.
 *
 * Preset: SMAA 1x Medium (with color edge detection).
 *  https://github.com/iryoku/smaa/releases/tag/v2.8
 */

var SMAAPass = function (_Pass) {
		inherits(SMAAPass, _Pass);

		/**
   * Constructs a new SMAA pass.
   *
   * @param {Image} Image - This pass requires an Image class to create internal textures. Provide window.Image in a browser environment.
   */

		function SMAAPass(Image) {
				classCallCheck(this, SMAAPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (SMAAPass.__proto__ || Object.getPrototypeOf(SMAAPass)).call(this));

				_this.name = "SMAAPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A render target for the color edge detection.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetColorEdges = new three.WebGLRenderTarget(1, 1, {
						minFilter: three.LinearFilter,
						format: three.RGBFormat,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetColorEdges.texture.name = "SMAA.ColorEdges";
				_this.renderTargetColorEdges.texture.generateMipmaps = false;

				/**
     * A render target for the SMAA weights.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetWeights = _this.renderTargetColorEdges.clone();

				_this.renderTargetWeights.texture.name = "SMAA.Weights";
				_this.renderTargetWeights.texture.format = three.RGBAFormat;

				/**
     * SMAA color edge detection shader material.
     *
     * @type {SMAAColorEdgesMaterial}
     * @private
     */

				_this.colorEdgesMaterial = new SMAAColorEdgesMaterial();

				/**
     * SMAA weights shader material.
     *
     * @type {SMAAWeightsMaterial}
     * @private
     */

				_this.weightsMaterial = new SMAAWeightsMaterial();

				var areaImage = new Image();
				areaImage.src = _this.weightsMaterial.areaImage;

				var areaTexture = new three.Texture();
				areaTexture.image = areaImage;
				areaTexture.name = "SMAA.Area";
				areaTexture.minFilter = three.LinearFilter;
				areaTexture.format = three.RGBFormat;
				areaTexture.generateMipmaps = false;
				areaTexture.needsUpdate = true;
				areaTexture.flipY = false;

				var searchImage = new Image();
				searchImage.src = _this.weightsMaterial.searchImage;

				var searchTexture = new three.Texture();
				searchTexture.image = searchImage;
				searchTexture.name = "SMAA.Search";
				searchTexture.magFilter = three.NearestFilter;
				searchTexture.minFilter = three.NearestFilter;
				searchTexture.generateMipmaps = false;
				searchTexture.needsUpdate = true;
				searchTexture.flipY = false;

				_this.weightsMaterial.uniforms.tDiffuse.value = _this.renderTargetColorEdges.texture;
				_this.weightsMaterial.uniforms.tArea.value = areaTexture;
				_this.weightsMaterial.uniforms.tSearch.value = searchTexture;

				/**
     * SMAA blend shader material.
     *
     * @type {SMAABlendMaterial}
     * @private
     */

				_this.blendMaterial = new SMAABlendMaterial();

				_this.blendMaterial.uniforms.tWeights.value = _this.renderTargetWeights.texture;

				_this.quad.material = _this.blendMaterial;

				return _this;
		}

		/**
   * Antialiases the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(SMAAPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						// Detect color edges.
						this.quad.material = this.colorEdgesMaterial;
						this.colorEdgesMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						renderer.render(this.scene, this.camera, this.renderTargetColorEdges, true);

						// Compute edge weights.
						this.quad.material = this.weightsMaterial;
						renderer.render(this.scene, this.camera, this.renderTargetWeights, false);

						// Apply the antialiasing filter to the colors.
						this.quad.material = this.blendMaterial;
						this.blendMaterial.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.renderTargetColorEdges.setSize(width, height);
						this.renderTargetWeights.setSize(width, height);

						this.colorEdgesMaterial.uniforms.texelSize.value.copy(this.weightsMaterial.uniforms.texelSize.value.copy(this.blendMaterial.uniforms.texelSize.value.set(1.0 / width, 1.0 / height)));
				}
		}]);
		return SMAAPass;
}(Pass);

/**
 * A pass that renders a given texture.
 */

var TexturePass = function (_Pass) {
	inherits(TexturePass, _Pass);

	/**
  * Constructs a new texture pass.
  *
  * @param {Texture} texture - The texture.
  * @param {Number} [opacity=1.0] - The texture opacity.
  */

	function TexturePass(texture) {
		var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
		classCallCheck(this, TexturePass);

		/**
   * The name of this pass.
   */

		var _this = possibleConstructorReturn(this, (TexturePass.__proto__ || Object.getPrototypeOf(TexturePass)).call(this));

		_this.name = "TexturePass";

		/**
   * A copy shader material used for rendering to texture.
   *
   * @type {CopyMaterial}
   * @private
   */

		_this.copyMaterial = new CopyMaterial();
		_this.copyMaterial.blending = three.AdditiveBlending;
		_this.copyMaterial.transparent = true;

		_this.texture = texture;
		_this.opacity = opacity;

		_this.quad.material = _this.copyMaterial;

		return _this;
	}

	/**
  * The texture.
  *
  * @type {Texture}
  */

	createClass(TexturePass, [{
		key: "render",


		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		value: function render(renderer, readBuffer) {

			renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer);
		}
	}, {
		key: "texture",
		get: function get$$1() {
			return this.copyMaterial.uniforms.tDiffuse.value;
		}

		/**
   * @type {Texture}
   */

		,
		set: function set$$1(x) {
			this.copyMaterial.uniforms.tDiffuse.value = x;
		}

		/**
   * The opacity.
   *
   * @type {Number}
   * @default 1.0
   */

	}, {
		key: "opacity",
		get: function get$$1() {
			return this.copyMaterial.uniforms.opacity.value;
		}

		/**
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
			this.copyMaterial.uniforms.opacity.value = x;
		}
	}]);
	return TexturePass;
}(Pass);

/**
 * Rounds the given number up to the next power of two.
 *
 * @private
 * @static
 * @param {Number} n - A number.
 * @return {Number} The next power of two.
 */

function ceil2(n) {
		return Math.pow(2, Math.max(0, Math.ceil(Math.log2(n))));
}

/**
 * A tone mapping pass that supports adaptive luminosity.
 *
 * If adaptivity is enabled, this pass generates a texture that represents the
 * luminosity of the current scene and adjusts it over time to simulate the
 * optic nerve responding to the amount of light it is receiving.
 *
 * Reference:
 *  GDC2007 - Wolfgang Engel, Post-Processing Pipeline
 *  http://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/GAMA/2007/gdc07/Post-Processing_Pipeline.pdf
 */

var ToneMappingPass = function (_Pass) {
		inherits(ToneMappingPass, _Pass);

		/**
   * Constructs a new tone mapping pass.
   *
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.adaptive=true] - Whether the tone mapping should use an adaptive luminance map.
   * @param {Number} [options.resolution=256] - The render texture resolution.
   * @param {Number} [options.distinction=1.0] - A luminance distinction factor.
   */

		function ToneMappingPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, ToneMappingPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ToneMappingPass.__proto__ || Object.getPrototypeOf(ToneMappingPass)).call(this));

				_this.name = "ToneMappingPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * The render target for the current luminosity.
     *
     * @type {WebGLRenderTarget}
     * @private
     * @todo Use RED format in WebGL 2.0.
     */

				_this.renderTargetLuminosity = new three.WebGLRenderTarget(1, 1, {
						minFilter: three.LinearMipMapLinearFilter,
						magFilter: three.LinearFilter,
						format: three.RGBFormat,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetLuminosity.texture.name = "ToneMapping.Luminosity";

				/**
     * The render target for adapted luminosity.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetAdapted = _this.renderTargetLuminosity.clone();

				_this.renderTargetAdapted.texture.name = "ToneMapping.AdaptedLuminosity";
				_this.renderTargetAdapted.texture.generateMipmaps = false;
				_this.renderTargetAdapted.texture.minFilter = three.LinearFilter;

				/**
     * A render target that holds a copy of the adapted limonosity.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetPrevious = _this.renderTargetAdapted.clone();

				_this.renderTargetPrevious.texture.name = "ToneMapping.PreviousLuminosity";

				/**
     * Copy shader material used for saving the luminance map.
     *
     * @type {CopyMaterial}
     * @private
     */

				_this.copyMaterial = new CopyMaterial();

				/**
     * A luminosity shader material.
     *
     * @type {LuminosityMaterial}
     * @private
     */

				_this.luminosityMaterial = new LuminosityMaterial();

				_this.luminosityMaterial.uniforms.distinction.value = options.distinction !== undefined ? options.distinction : 1.0;

				/**
     * An adaptive luminance shader material.
     *
     * @type {AdaptiveLuminosityMaterial}
     * @private
     */

				_this.adaptiveLuminosityMaterial = new AdaptiveLuminosityMaterial();

				_this.resolution = options.resolution;

				/**
     * A tone mapping shader material.
     *
     * @type {ToneMappingMaterial}
     * @private
     */

				_this.toneMappingMaterial = new ToneMappingMaterial();

				_this.adaptive = options.adaptive;

				return _this;
		}

		/**
   * The resolution of the render targets.
   *
   * @type {Number}
   * @default 256
   */

		createClass(ToneMappingPass, [{
				key: "render",


				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     * @param {Number} delta - The render delta time.
     */

				value: function render(renderer, readBuffer, writeBuffer, delta) {

						var quad = this.quad;
						var scene = this.scene;
						var camera = this.camera;

						var adaptiveLuminosityMaterial = this.adaptiveLuminosityMaterial;
						var luminosityMaterial = this.luminosityMaterial;
						var toneMappingMaterial = this.toneMappingMaterial;
						var copyMaterial = this.copyMaterial;

						var renderTargetPrevious = this.renderTargetPrevious;
						var renderTargetLuminosity = this.renderTargetLuminosity;
						var renderTargetAdapted = this.renderTargetAdapted;

						if (this.adaptive) {

								// Render the luminance of the current scene into a render target with mipmapping enabled.
								quad.material = luminosityMaterial;
								luminosityMaterial.uniforms.tDiffuse.value = readBuffer.texture;
								renderer.render(scene, camera, renderTargetLuminosity);

								// Use the new luminance values, the previous luminance and the frame delta to adapt the luminance over time.
								quad.material = adaptiveLuminosityMaterial;
								adaptiveLuminosityMaterial.uniforms.delta.value = delta;
								adaptiveLuminosityMaterial.uniforms.tPreviousLum.value = renderTargetPrevious.texture;
								adaptiveLuminosityMaterial.uniforms.tCurrentLum.value = renderTargetLuminosity.texture;
								renderer.render(scene, camera, renderTargetAdapted);

								// Copy the new adapted luminance value so that it can be used by the next frame.
								quad.material = copyMaterial;
								copyMaterial.uniforms.tDiffuse.value = renderTargetAdapted.texture;
								renderer.render(scene, camera, renderTargetPrevious);
						}

						// Apply the tone mapping to the colours.
						quad.material = toneMappingMaterial;
						toneMappingMaterial.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Renders something into the previous luminosity texture.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer) {

						this.quad.material = new three.MeshBasicMaterial({ color: 0x7fffff });
						renderer.render(this.scene, this.camera, this.renderTargetPrevious);
						this.quad.material.dispose();
				}
		}, {
				key: "resolution",
				get: function get$$1() {
						return this.renderTargetLuminosity.width;
				}

				/**
     * The resolution of the render targets. Must be a power of two for mipmaps.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;


						x = ceil2(x);

						this.renderTargetLuminosity.setSize(x, x);
						this.renderTargetPrevious.setSize(x, x);
						this.renderTargetAdapted.setSize(x, x);

						this.adaptiveLuminosityMaterial.defines.MIP_LEVEL_1X1 = (Math.round(Math.log(x)) / Math.log(2)).toFixed(1);
						this.adaptiveLuminosityMaterial.needsUpdate = true;
				}

				/**
     * Whether this pass uses adaptive luminosity.
     *
     * @type {Boolean}
     * @default true
     */

		}, {
				key: "adaptive",
				get: function get$$1() {
						return this.toneMappingMaterial.defines.ADAPTED_LUMINANCE !== undefined;
				}

				/**
     * Whether this pass should use adaptive luminosity.
     *
     * @type {Boolean}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


						if (x) {

								this.toneMappingMaterial.defines.ADAPTED_LUMINANCE = "1";
								this.toneMappingMaterial.uniforms.luminanceMap.value = this.renderTargetAdapted.texture;
						} else {

								delete this.toneMappingMaterial.defines.ADAPTED_LUMINANCE;
								this.toneMappingMaterial.uniforms.luminanceMap.value = null;
						}

						this.toneMappingMaterial.needsUpdate = true;
				}
		}]);
		return ToneMappingPass;
}(Pass);

/**
 * A compilation of the post processing passes.
 *
 * @module postprocessing/passes
 */

/**
 * The EffectComposer may be used in place of a normal WebGLRenderer.
 *
 * The auto clear behaviour of the provided renderer will be disabled to prevent
 * unnecessary clear operations.
 *
 * It is common practice to use a {@link RenderPass} as the first pass to
 * automatically clear the screen and render the scene to a texture for further
 * processing.
 */

var EffectComposer = function () {

		/**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} [renderer] - The renderer that should be used.
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
   * @param {Boolean} [options.depthTexture=false] - Set to true if one of your passes relies on a depth texture.
   */

		function EffectComposer() {
				var renderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
				classCallCheck(this, EffectComposer);


				/**
     * The renderer.
     *
     * You may replace the renderer at any time by using
     * {@link EffectComposer#replaceRenderer}.
     *
     * @type {WebGLRenderer}
     */

				this.renderer = renderer;

				/**
     * The read buffer.
     *
     * Reading from and writing to the same render target should be avoided.
     * Therefore, two seperate yet identical buffers are used.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				this.readBuffer = null;

				/**
     * The write buffer.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				this.writeBuffer = null;

				if (this.renderer !== null) {

						this.renderer.autoClear = false;

						this.readBuffer = this.createBuffer(options.depthBuffer !== undefined ? options.depthBuffer : true, options.stencilBuffer !== undefined ? options.stencilBuffer : false, options.depthTexture !== undefined ? options.depthTexture : false);

						this.writeBuffer = this.readBuffer.clone();
				}

				/**
     * A copy pass used for copying masked scenes.
     *
     * @type {ShaderPass}
     * @private
     */

				this.copyPass = new ShaderPass(new CopyMaterial());

				/**
     * The passes.
     *
     * @type {Pass[]}
     * @private
     */

				this.passes = [];
		}

		/**
   * The depth texture of the read and write buffers.
   *
   * @type {DepthTexture}
   * @default null
   */

		createClass(EffectComposer, [{
				key: "replaceRenderer",


				/**
     * Replaces the current renderer with the given one. The DOM element of the
     * current renderer will automatically be removed from its parent node and the
     * DOM element of the new renderer will take its place.
     *
     * The auto clear mechanism of the provided renderer will be disabled.
     *
     * Switching between renderers allows you to dynamically enable or disable
     * antialiasing.
     *
     * @param {WebGLRenderer} renderer - The new renderer.
     * @return {WebGLRenderer} The old renderer.
     */

				value: function replaceRenderer(renderer) {

						var oldRenderer = this.renderer;

						var parent = void 0,
						    oldSize = void 0,
						    newSize = void 0;

						if (oldRenderer !== null && oldRenderer !== renderer) {

								this.renderer = renderer;
								this.renderer.autoClear = false;

								parent = oldRenderer.domElement.parentNode;
								oldSize = oldRenderer.getSize();
								newSize = renderer.getSize();

								if (parent !== null) {

										parent.removeChild(oldRenderer.domElement);
										parent.appendChild(renderer.domElement);
								}

								if (oldSize.width !== newSize.width || oldSize.height !== newSize.height) {

										this.setSize();
								}
						}

						return oldRenderer;
				}

				/**
     * Creates a new render target by replicating the renderer's canvas.
     *
     * The created render target uses a linear filter for texel minification and
     * magnification. Its render texture format depends on whether the renderer
     * uses the alpha channel. Mipmaps are disabled.
     *
     * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
     * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
     * @param {Boolean} depthTexture - Whether the render target should have a depth texture.
     * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
     */

		}, {
				key: "createBuffer",
				value: function createBuffer(depthBuffer, stencilBuffer, depthTexture) {

						var size = this.renderer.getSize();
						var pixelRatio = this.renderer.getPixelRatio();
						var alpha = this.renderer.context.getContextAttributes().alpha;

						var renderTarget = new three.WebGLRenderTarget(size.width * pixelRatio, size.height * pixelRatio, {
								minFilter: three.LinearFilter,
								magFilter: three.LinearFilter,
								format: alpha ? three.RGBAFormat : three.RGBFormat,
								depthBuffer: depthBuffer,
								stencilBuffer: stencilBuffer,
								depthTexture: depthTexture ? new three.DepthTexture() : null
						});

						if (depthTexture && stencilBuffer) {

								renderTarget.depthTexture.format = three.DepthStencilFormat;
								renderTarget.depthTexture.type = three.UnsignedInt248Type;
						}

						renderTarget.texture.name = "EffectComposer.Buffer";
						renderTarget.texture.generateMipmaps = false;

						return renderTarget;
				}

				/**
     * Adds a pass, optionally at a specific index.
     *
     * @param {Pass} pass - A new pass.
     * @param {Number} [index] - An index at which the pass should be inserted.
     */

		}, {
				key: "addPass",
				value: function addPass(pass, index) {

						var renderer = this.renderer;
						var size = renderer.getSize();
						var pixelRatio = renderer.getPixelRatio();

						pass.setSize(size.width * pixelRatio, size.height * pixelRatio);
						pass.initialise(renderer, renderer.context.getContextAttributes().alpha);

						if (index !== undefined) {

								this.passes.splice(index, 0, pass);
						} else {

								this.passes.push(pass);
						}
				}

				/**
     * Removes a pass.
     *
     * @param {Pass} pass - The pass.
     */

		}, {
				key: "removePass",
				value: function removePass(pass) {

						this.passes.splice(this.passes.indexOf(pass), 1);
				}

				/**
     * Renders all enabled passes in the order in which they were added.
     *
     * @param {Number} delta - The time between the last frame and the current one in seconds.
     */

		}, {
				key: "render",
				value: function render(delta) {

						var passes = this.passes;
						var renderer = this.renderer;
						var copyPass = this.copyPass;

						var readBuffer = this.readBuffer;
						var writeBuffer = this.writeBuffer;

						var maskActive = false;
						var pass = void 0,
						    context = void 0,
						    buffer = void 0;
						var i = void 0,
						    l = void 0;

						for (i = 0, l = passes.length; i < l; ++i) {

								pass = passes[i];

								if (pass.enabled) {

										pass.render(renderer, readBuffer, writeBuffer, delta, maskActive);

										if (pass.needsSwap) {

												if (maskActive) {

														context = renderer.context;
														context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
														copyPass.render(renderer, readBuffer, writeBuffer);
														context.stencilFunc(context.EQUAL, 1, 0xffffffff);
												}

												buffer = readBuffer;
												readBuffer = writeBuffer;
												writeBuffer = buffer;
										}

										if (pass instanceof MaskPass) {

												maskActive = true;
										} else if (pass instanceof ClearMaskPass) {

												maskActive = false;
										}
								}
						}
				}

				/**
     * Sets the size of the buffers and the renderer's output canvas.
     *
     * Every pass will be informed of the new size. It's up to each pass how that
     * information is used.
     *
     * If no width or height is specified, the render targets and passes will be
     * updated with the current size of the renderer.
     *
     * @param {Number} [width] - The width.
     * @param {Number} [height] - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						var passes = this.passes;
						var size = this.renderer.getSize();
						var pixelRatio = this.renderer.getPixelRatio();

						var i = void 0,
						    l = void 0;

						if (width === undefined || height === undefined) {

								width = size.width;
								height = size.height;
						}

						this.renderer.setSize(width, height);

						width *= pixelRatio;
						height *= pixelRatio;

						this.readBuffer.setSize(width, height);
						this.writeBuffer.setSize(width, height);

						for (i = 0, l = passes.length; i < l; ++i) {

								passes[i].setSize(width, height);
						}
				}

				/**
     * Resets this composer by deleting all passes and creating new buffers.
     *
     * @param {WebGLRenderTarget} [renderTarget] - A new render target. If none is provided, the settings of the renderer will be used.
     */

		}, {
				key: "reset",
				value: function reset(renderTarget) {

						var depthBuffer = this.readBuffer.depthBuffer;
						var stencilBuffer = this.readBuffer.stencilBuffer;
						var depthTexture = this.readBuffer.depthTexture !== null;

						this.dispose(renderTarget === undefined ? this.createBuffer(depthBuffer, stencilBuffer, depthTexture) : renderTarget);
				}

				/**
     * Destroys all passes and render targets.
     *
     * This method deallocates all render targets, textures and materials created
     * by the passes. It also deletes this composer's frame buffers.
     *
     * @param {WebGLRenderTarget} [renderTarget] - A new render target. If none is provided, the composer will become inoperative.
     */

		}, {
				key: "dispose",
				value: function dispose(renderTarget) {

						var passes = this.passes;

						if (this.readBuffer !== null && this.writeBuffer !== null) {

								this.readBuffer.dispose();
								this.writeBuffer.dispose();

								this.readBuffer = null;
								this.writeBuffer = null;
						}

						while (passes.length > 0) {

								passes.pop().dispose();
						}

						if (renderTarget !== undefined) {

								// Reanimate.
								this.readBuffer = renderTarget;
								this.writeBuffer = this.readBuffer.clone();
						} else {

								this.copyPass.dispose();
						}
				}
		}, {
				key: "depthTexture",
				get: function get$$1() {
						return this.readBuffer.depthTexture;
				}

				/**
     * The read and write buffers share a single depth texture. Depth will be
     * written to this texture when something is rendered into one of the buffers
     * and the involved materials have depth write enabled.
     *
     * You may enable this mechanism during the instantiation of the composer or
     * by assigning a DepthTexture instance later on. You may also disable it by
     * assigning null.
     *
     * @type {DepthTexture}
     */

				,
				set: function set$$1(x) {

						this.readBuffer.depthTexture = x;
						this.writeBuffer.depthTexture = x;
				}
		}]);
		return EffectComposer;
}();

var _class$36;
var _temp$36;

var polyfill = function polyfill(object, method) {
  var showWarn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (object[method]) return;
  if (showWarn) console.warn('@PostProcessorModule: pass.' + method + '() was not found.', object);
  object[method] = function () {};
};

/**
 * @class PostProcessorModule
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new WHS.PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule(),
 *   new PostProcessorModule()
 * ]);
 *
 * const processor = app.use('postprocessor');
 *
 * processor
 *   .render()
 *   .pass(new GlitchPass())
 *   .renderToScreen()
 */
var PostProcessorModule = (_temp$36 = _class$36 = function () {
  function PostProcessorModule() {
    var _this = this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PostProcessorModule.defaults;
    classCallCheck(this, PostProcessorModule);
    this.currentPass = null;
    this.defer = new Promise(function (resolve) {
      _this.resolve = resolve;
    });

    this.debug = params.debug;
    this.params = params;
  }

  createClass(PostProcessorModule, [{
    key: 'manager',
    value: function manager(_manager) {
      var _this2 = this;

      _manager.define('postprocessor');

      this.effects = _manager.use('rendering').effects;
      this.renderer = _manager.get('renderer');
      this.scene = _manager.get('scene');
      this.camera = _manager.get('camera');

      this.composer = new EffectComposer(this.renderer, this.params);

      _manager.use('rendering').stop();

      var composer = this.composer;
      this.renderLoop = new Loop(function (clock) {
        return composer.render(clock.getDelta());
      }).start(_manager.handler);

      _manager.update({
        renderer: function renderer(_renderer) {
          _this2.composer.replaceRenderer(_renderer);
        },

        scene: function scene(_scene) {
          _this2.scene = _scene;
        },

        camera: function camera(_camera) {
          _this2.camera = _camera;
        }
      });

      this.resolve();
    }

    /**
     * @method render
     * @description Adds RenderPass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      this.defer.then(function () {
        var pass = new RenderPass(_this3.scene, _this3.camera.native);

        // TODO: Support for effects.

        _this3.composer.addPass(pass);
        _this3.currentPass = pass;
      });

      return this;
    }

    /**
     * @method pass
     * @description Adds your custom pass
     * @param {Pass} pass A custom pass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'pass',
    value: function pass(_pass) {
      var _this4 = this;

      this.defer.then(function () {
        polyfill(_pass, 'setSize', _this4.debug);
        polyfill(_pass, 'initialise', _this4.debug);

        _this4.composer.addPass(_pass);
        _this4.currentPass = _pass;
      });

      return this;
    }

    /**
     * @method shader
     * @description Adds a pass made from shader material
     * @param {Material} material A ShaderMaterial
     * @param {String} textureID Name of the readBuffer uniform
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'shader',
    value: function shader(material) {
      var _this5 = this;

      var textureID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'readBuffer';

      this.defer.then(function () {
        if (!material.uniforms[textureID]) material.uniforms[textureID] = { value: null };

        var pass = new ShaderPass(material, textureID);

        _this5.composer.addPass(pass);
        _this5.currentPass = pass;
      });

      return this;
    }

    /**
     * @method get
     * @description Returns a pass by the given name
     * @param {String} name The name of the pass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'get',
    value: function get$$1(name) {
      return name ? this.composer.passes.filter(function (pass) {
        return pass.name === name;
      })[0] : this.currentPass;
    }

    /**
     * @method renderToScreen
     * @description Sets the renderToScreen property of currentPass
     * @param {String} [name=true] The name of the pass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'renderToScreen',
    value: function renderToScreen() {
      var _this6 = this;

      var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.defer.then(function () {
        _this6.currentPass.renderToScreen = bool;
      });

      return this;
    }
  }]);
  return PostProcessorModule;
}(), _class$36.defaults = {
  debug: true
}, _temp$36);

/**
 * @class EventsPatchModule
 * @description This one is used in the core to handle events used by modules. If you want to make custom events - please make a similar one.
 * @category modules/app
 * @memberof module:modules/app
 */
var EventsPatchModule = function () {
  function EventsPatchModule() {
    classCallCheck(this, EventsPatchModule);
  }

  createClass(EventsPatchModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('events');
      this.element = _manager.get('renderer').domElement;
    }

    /**
     * @function patchEvents
     * @description This methods patches the list of events on specific object.
     * @param {Number} originObject - The object that gives events.
     * @param {Number} [destObject=this] - The object that takes events.
     * @param {Array[Strings]} [events=[]] - The list of events by names.
     * @memberof module:modules/app.EventsPatchModule
     */

  }, {
    key: 'patchEvents',
    value: function patchEvents(originObject) {
      var destObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      events.forEach(function (event) {
        return originObject.addEventListener(event, function (e) {
          return destObject.emit(event, e);
        });
      });
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      var element = self.element,
          patchEvents = self.patchEvents;


      patchEvents(element, this, ['mousemove', 'mouseup', 'contextmenu', 'mousedown', 'click', 'wheel', 'touchstart', 'touchend', 'touchmove', 'keydown', 'keyup', 'keypress']);
    }
  }]);
  return EventsPatchModule;
}();

/**
 * @class VirtualMouseModule
 * @category modules/app
 * @param {Boolean} [globalMovement=false]
 * @memberof module:modules/app
 * @extends Events
 */

var VirtualMouseModule = function (_Events) {
  inherits(VirtualMouseModule, _Events);

  function VirtualMouseModule() {
    var globalMovement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    classCallCheck(this, VirtualMouseModule);

    var _this = possibleConstructorReturn(this, (VirtualMouseModule.__proto__ || Object.getPrototypeOf(VirtualMouseModule)).call(this));

    _this.mouse = new three.Vector2();
    _this.raycaster = new three.Raycaster();
    _this.world = null;
    _this.canvas = null;
    _this.projectionPlane = new three.Plane(new three.Vector3(0, 0, 1), 0);

    _this.globalMovement = globalMovement;
    return _this;
  }

  createClass(VirtualMouseModule, [{
    key: 'update',
    value: function update(e, customX, customY) {
      var rect = this.canvas.getBoundingClientRect();

      var x = customX || e.clientX;
      var y = customY || e.clientY;

      this.mouse.x = (x - rect.left) / (rect.right - rect.left) * 2 - 1;
      this.mouse.y = -((y - rect.top) / (rect.bottom - rect.top)) * 2 + 1;

      this.projectionPlane.normal.copy(this.camera.getWorldDirection());

      this.raycaster.setFromCamera(this.mouse, this.camera);
      this.emit('move');
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('mouse');
      _manager.require('events', function () {
        return new EventsPatchModule();
      });

      this.canvas = _manager.get('renderer').domElement;
      this.camera = _manager.get('camera').native;
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      var _this2 = this;

      ['click', 'mousedown', 'mouseup', 'mousemove'].forEach(function (ev) {
        return _this2.on(ev, function (e) {
          return self.emit(ev, e);
        });
      });

      self.globalX = 0;
      self.globalY = 0;

      this.on('mousemove', function (e) {
        if (document.pointerLockElement !== null) {
          self.globalX += e.movementX;
          self.globalY += e.movementY;

          self.update(e, self.globalX, self.globalY);
        } else self.update(e);
      });
    }

    /**
     * @method track
     * @description Starts tracking events on a component
     * @param {Component} component A component, that should be tracked by the mouse
     * @param {Boolean} nested Whether component's children should be tracked or not
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'track',
    value: function track(component) {
      var _this3 = this;

      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var isHovered = false;

      this.on('move', function () {
        if (_this3.hovers(component, nested)) {
          if (isHovered) component.emit('mousemove');else {
            component.emit('mouseover');
            isHovered = true;
          }
        } else if (isHovered) {
          component.emit('mouseout');
          isHovered = false;
        }
      });

      this.on('click', function () {
        if (isHovered) component.emit('click');else component.emit('offClick');
      });

      this.on('mousedown', function () {
        if (isHovered) component.emit('mousedown');
      });

      this.on('mouseup', function () {
        if (isHovered) component.emit('mouseup');
      });
    }

    /**
     * @method intersection
     * @description Returns an intersection data
     * @param {Component} component A component that intersects with mouse ray (or doesn't)
     * @param {Boolean} nested Whether component's children should be tracked or not
     * @return {Array} intersection data.
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'intersection',
    value: function intersection(_ref) {
      var native = _ref.native;
      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (native.children.length > 0 && nested) {
        var objects = [];
        native.traverse(function (child) {
          return objects.push(child);
        });

        return this.raycaster.intersectObjects(objects);
      }

      return this.raycaster.intersectObject(native);
    }

    /**
     * @method project
     * @description Returns a vector based on mouse ray intersection with plane
     * @param {THREE.Plane} [plane=this.projectionPlane] Math plane that is used
     * @param {Vector3} [target] Optional target
     * @return {Vector3} An intersection point.
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'project',
    value: function project() {
      var plane = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.projectionPlane;
      var target = arguments[1];

      return this.raycaster.ray.intersectPlane(plane, target);
    }

    /**
     * @method hovers
     * @description Returns a boolean based on intersection data (Whether mouse hovers the component)
     * @param {Component} component A component that intersects with mouse ray (or doesn't)
     * @param {Boolean} nested Whether component's children should be tracked or not
     * @return {Boolean} Whether the component is hovered.
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'hovers',
    value: function hovers(component) {
      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.intersection(component, nested).length > 0;
    }

    /**
     * Mouse ray
     * @member {THREE.Ray} module:modules/app.VirtualMouseModule#ray
     * @public
     */

  }, {
    key: 'ray',
    get: function get$$1() {
      return this.raycaster.ray;
    }

    /**
     * Mouse x [-1; 1]
     * @member {Number} module:modules/app.VirtualMouseModule#x
     * @public
     */

  }, {
    key: 'x',
    get: function get$$1() {
      return this.mouse.x;
    }

    /**
     * Mouse y [-1; 1]
     * @member {Number} module:modules/app.VirtualMouseModule#y
     * @public
     */

  }, {
    key: 'y',
    get: function get$$1() {
      return this.mouse.y;
    }
  }]);
  return VirtualMouseModule;
}(minivents_commonjs);

/**
 * @class ControlsModule
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new WHS.PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule(),
 *   new ControlsModule.from(new THREE.TrackballControls())
 * ]);
 */

var ControlsModule = function () {
  createClass(ControlsModule, null, [{
    key: 'from',
    value: function from(controls) {
      return new ControlsModule({ controls: controls });
    }
  }]);

  function ControlsModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, ControlsModule);

    this.params = Object.assign({
      controls: false,
      fix: function fix(controls) {
        return controls;
      },

      update: function update(c) {
        this.controls.update(c.getDelta());
      }
    }, params);

    this.controls = this.params.controls;
    this.update = this.params.update;
  }

  createClass(ControlsModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('controls');
      _manager.require('events', function () {
        return new EventsPatchModule();
      });
    }

    /**
     * @method setControls
     * @description Set working controls
     * @param {Object} controls Working three.js controls object.
     * @return {this}
     * @memberof module:modules/app.ControlsModule
     */

  }, {
    key: 'setControls',
    value: function setControls(controls) {
      this.controls = controls;
      return this;
    }

    /**
     * @method setUpdate
     * @description Set controls update function
     * @param {Function} update Update function
     * @return {this}
     * @memberof module:modules/app.ControlsModule
     */

  }, {
    key: 'setUpdate',
    value: function setUpdate(update) {
      this.update = update;
      return this;
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      self.updateLoop = new Loop(self.update.bind(self));
      self.updateLoop.start(this);
    }
  }]);
  return ControlsModule;
}();

/**
 * @class FogModule
 * @category modules/app
 * @param {Object} [params={color: 0xefd1b5, density: 0.020, near: 10, far: 1000}] - The parameters object.
 * @param {String} [type=exp2] - The type of fog - exp2 or linear
 * @memberof module:modules/app
 * @example <caption>How to create and apply a FogModule</caption>
 * const fogModule = new FogModule({
 *    color: 0xffffff,
 *    density: 0.03,
 *    near: 20,
 *    far: 200
 *  }, 'exp2');
 *
 * new App([
 *  ...,
 *  fogModule
 * ]);
 */

var FogModule = function () {
  function FogModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var type = arguments[1];
    classCallCheck(this, FogModule);

    this.params = Object.assign({
      color: 0xefd1b5,
      density: 0.020,
      near: 10,
      far: 1000
    }, params);
    if (!type || type === 'exp2') this.fog = new three.FogExp2(this.params.color, this.params.density);else if (type === 'linear') this.fog = new three.Fog(this.params.color, this.params.near, this.params.far);
  }

  createClass(FogModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('fog', this.fog);
      _manager.get('scene').fog = this.fog;
    }
  }]);
  return FogModule;
}();

var isEqualDefault = function isEqualDefault(a, b) {
  if (a === b) return true;else if (a && a.equals && a.equals(b)) return true;

  return false;
};

/**
 * @class StateModule
 * @description `StateModule` is useful for apps, where you need state manipulation.
 * This can be: _transitions between screens, games, development moments_.
 * You can check [basic/state](https://whs-dev.surge.sh/examples/?basic/state) example.
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a state module</caption>
 * new App([
 *   // ...
 *   new StateModule().default({
 *     sphereColor: 0xff0000
 *   })
 * ]);
 */

var StateModule = function () {
  createClass(StateModule, null, [{
    key: 'actionGenerate',
    value: function actionGenerate(isEqual) {
      return function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [{}, ''];
        var _ref = arguments[1];
        var key = _ref.key,
            data = _ref.data;

        if (isEqual(state[0][key], data)) return state;

        state[0][key] = data;
        state[1] = key;

        return state;
      };
    }
  }]);

  function StateModule() {
    var equalCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isEqualDefault;
    classCallCheck(this, StateModule);

    this.store = createStore(StateModule.actionGenerate(equalCheck));

    this.configuration = {};
    this.currentConfig = 'default';
    this.prevConfig = 'default';
  }

  /**
   * @method default
   * @description Add default configuration.
   * @param {Object} data Configuration setup
   * @memberof module:modules/app.StateModule
   * @example
   * new WHS.StateModule().default({
   *   sphereColor: UTILS.$colors.mesh,
   *   planeColor: 0x447F8B
   * })
   */


  createClass(StateModule, [{
    key: 'default',
    value: function _default(data) {
      this.config({ default: data });
      return this;
    }

    /**
     * @method setEqualCheck
     * @description Sets an equalCheck function
     * @param {Function} func function to generate equal check
     * @memberof module:modules/app.StateModule
     */

  }, {
    key: 'setEqualCheck',
    value: function setEqualCheck(func) {
      this.store.replaceReducer(StateModule.actionGenerate(func));
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('state');
    }

    /**
     * @method config
     * @description Load configurations from object.
     * @param {Object} configs Configuration data
     * @memberof module:modules/app.StateModule
     * @example <caption> Adding `green` configuration</caption>
     * state.config({
     *   green: {
     *     sphereColor: 0x00ff00,
     *     planeColor: 0x00ff00
     *   }
     * });
     */

  }, {
    key: 'config',
    value: function config(configs) {
      for (var key in configs) {
        if (key) {
          this.configuration[key] = key === 'default' ? configs[key] : Object.assign({}, this.configuration.default, configs[key]);
        }
      }
    }

    /**
     * @method update
     * @description Load updates from object.
     * @param {Object} updates Updates data
     * @memberof module:modules/app.StateModule
     * @example <caption> Update callback for `sphereColor`</caption>
     * state.update({
     *   sphereColor: color => sphere.material.color.setHex(color)
     * });
     */

  }, {
    key: 'update',
    value: function update() {
      var _this = this;

      var updates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.store.subscribe(function () {
        var _store$getState = _this.store.getState(),
            _store$getState2 = slicedToArray(_store$getState, 2),
            data = _store$getState2[0],
            changedKey = _store$getState2[1];

        var callback = updates[changedKey];

        if (callback) callback(data[changedKey]);
      });
    }

    /**
     * @method to
     * @description Switch to configuration.
     * @param {String} configName Configuration name.
     * @memberof module:modules/app.StateModule
     * @example <caption> Changes configuration to `green`</caption>
     * state.to('green');
     */

  }, {
    key: 'to',
    value: function to(configName) {
      this.prevConfig = this.currentConfig;
      this.currentConfig = configName;

      var config = this.configuration[configName] ? this.configuration[configName] : this.configuration.default;

      this.set(config);
    }

    /**
     * @method set
     * @description Set current parameters.
     * @param {Object} data Configuration parameters.
     * @memberof module:modules/app.StateModule
     * @example
     * state.set({
     *   sphereColor: 0x00ff00
     * });
     */

  }, {
    key: 'set',
    value: function set$$1(data) {
      for (var key in data) {
        if (key) this.store.dispatch({ type: 'ADD', key: key, data: data[key] });
      }
    }

    /**
     * @method get
     * @description Return data of parameter.
     * @param {String} key Parameter name.
     * @memberof module:modules/app.StateModule
     * @example
     * state.get('sphereColor'); // 0x00ff00
     */

  }, {
    key: 'get',
    value: function get$$1(key) {
      return this.store.getState()[0][key];
    }

    /**
     * @method prev
     * @description Return `trueVal` if `config` match previous configuration, in other case - return `falseVal`.
     * @param {String} config Configuration name.
     * @param {Any} trueVal Value returned if condition is truthy.
     * @param {Any} falseVal Value returned if condition is falsy.
     * @memberof module:modules/app.StateModule
     */

  }, {
    key: 'prev',
    value: function prev(config, trueVal, falseVal) {
      return this.prevConfig === config ? trueVal : falseVal;
    }

    /**
     * @method current
     * @description Return `trueVal` if `config` match current configuration, in other case - return `falseVal`.
     * @param {String} config Configuration name.
     * @param {Any} trueVal Value returned if condition is truthy.
     * @param {Any} falseVal Value returned if condition is falsy.
     * @memberof module:modules/app.StateModule
     */

  }, {
    key: 'current',
    value: function current(config, trueVal, falseVal) {
      return this.currentConfig === config ? trueVal : falseVal;
    }
  }]);
  return StateModule;
}();

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe

var ThreeOrbitControls = function (_EventDispatcher) {
  inherits(ThreeOrbitControls, _EventDispatcher);

  function ThreeOrbitControls(object, domElement, eventHandler) {
    classCallCheck(this, ThreeOrbitControls);

    var _this = possibleConstructorReturn(this, (ThreeOrbitControls.__proto__ || Object.getPrototypeOf(ThreeOrbitControls)).call(this));

    _this.object = object;

    _this.domElement = domElement === undefined ? document : domElement;
    _this.eventHandler = eventHandler;

    // Set to false to disable this control
    _this.enabled = true;

    // "target" sets the location of focus, where the object orbits around
    _this.target = new three.Vector3();

    // How far you can dolly in and out ( PerspectiveCamera only )
    _this.minDistance = 0;
    _this.maxDistance = Infinity;

    // How far you can zoom in and out ( OrthographicCamera only )
    _this.minZoom = 0;
    _this.maxZoom = Infinity;

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    _this.minPolarAngle = 0; // radians
    _this.maxPolarAngle = Math.PI; // radians

    // How far you can orbit horizontally, upper and lower limits.
    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
    _this.minAzimuthAngle = -Infinity; // radians
    _this.maxAzimuthAngle = Infinity; // radians

    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop
    _this.enableDamping = false;
    _this.dampingFactor = 0.25;

    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming
    _this.enableZoom = true;
    _this.zoomSpeed = 1.0;

    // Set to false to disable rotating
    _this.enableRotate = true;
    _this.rotateSpeed = 1.0;

    // Set to false to disable panning
    _this.enablePan = true;
    _this.keyPanSpeed = 7.0; // pixels moved per arrow key push

    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop
    _this.autoRotate = false;
    _this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

    // Set to false to disable use of the keys
    _this.enableKeys = true;

    // The four arrow keys
    _this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

    // Mouse buttons
    _this.mouseButtons = { ORBIT: three.MOUSE.LEFT, ZOOM: three.MOUSE.MIDDLE, PAN: three.MOUSE.RIGHT };

    // for reset
    _this.target0 = _this.target.clone();
    _this.position0 = _this.object.position.clone();
    _this.zoom0 = _this.object.zoom;

    //
    // public methods
    //

    _this.getPolarAngle = function () {
      return spherical.phi;
    };

    _this.getAzimuthalAngle = function () {
      return spherical.theta;
    };

    _this.reset = function () {
      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.zoom = _this.zoom0;

      _this.object.updateProjectionMatrix();
      _this.dispatchEvent(changeEvent);

      _this.update();

      state = STATE.NONE;
    };

    // this method is exposed, but perhaps it would be better if we can make it private...
    _this.update = function () {
      var offset = new three.Vector3();

      // so camera.up is the orbit axis
      var quat = new three.Quaternion().setFromUnitVectors(object.up, new three.Vector3(0, 1, 0));
      var quatInverse = quat.clone().inverse();

      var lastPosition = new three.Vector3();
      var lastQuaternion = new three.Quaternion();

      return function () {
        var position = _this.object.position;

        offset.copy(position).sub(_this.target);

        // rotate offset to "y-axis-is-up" space
        offset.applyQuaternion(quat);

        // angle from z-axis around y-axis
        spherical.setFromVector3(offset);

        if (_this.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle());

        spherical.theta += sphericalDelta.theta;
        spherical.phi += sphericalDelta.phi;

        // restrict theta to be between desired limits
        spherical.theta = Math.max(_this.minAzimuthAngle, Math.min(_this.maxAzimuthAngle, spherical.theta));

        // restrict phi to be between desired limits
        spherical.phi = Math.max(_this.minPolarAngle, Math.min(_this.maxPolarAngle, spherical.phi));

        spherical.makeSafe();

        spherical.radius *= scale;

        // restrict radius to be between desired limits
        spherical.radius = Math.max(_this.minDistance, Math.min(_this.maxDistance, spherical.radius));

        // move target to panned location
        _this.target.add(panOffset);

        offset.setFromSpherical(spherical);

        // rotate offset back to "camera-up-vector-is-up" space
        offset.applyQuaternion(quatInverse);

        position.copy(_this.target).add(offset);

        _this.object.lookAt(_this.target);

        if (_this.enableDamping === true) {
          sphericalDelta.theta *= 1 - _this.dampingFactor;
          sphericalDelta.phi *= 1 - _this.dampingFactor;
        } else sphericalDelta.set(0, 0, 0);

        scale = 1;
        panOffset.set(0, 0, 0);

        // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > EPS
        // using small-angle approximation cos(x/2) = 1 - x^2 / 8

        if (zoomChanged || lastPosition.distanceToSquared(_this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(_this.object.quaternion)) > EPS) {
          _this.dispatchEvent(changeEvent);

          lastPosition.copy(_this.object.position);
          lastQuaternion.copy(_this.object.quaternion);
          zoomChanged = false;

          return true;
        }

        return false;
      }();
    };

    _this.dispose = function () {
      _this.domElement.removeEventListener('contextmenu', onContextMenu, false);
      _this.domElement.removeEventListener('mousedown', onMouseDown, false);
      _this.domElement.removeEventListener('wheel', onMouseWheel, false);

      _this.domElement.removeEventListener('touchstart', onTouchStart, false);
      _this.domElement.removeEventListener('touchend', onTouchEnd, false);
      _this.domElement.removeEventListener('touchmove', onTouchMove, false);

      document.removeEventListener('mousemove', onMouseMove, false);
      document.removeEventListener('mouseup', onMouseUp, false);

      window.removeEventListener('keydown', onKeyDown, false);

      // this.dispatchEvent( { type: 'dispose' } ); // should this be added here?
    };

    //
    // internals
    //

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

    var state = STATE.NONE;

    var EPS = 0.000001;

    // current position in spherical coordinates
    var spherical = new three.Spherical();
    var sphericalDelta = new three.Spherical();

    var scale = 1;
    var panOffset = new three.Vector3();
    var zoomChanged = false;

    var rotateStart = new three.Vector2();
    var rotateEnd = new three.Vector2();
    var rotateDelta = new three.Vector2();

    var panStart = new three.Vector2();
    var panEnd = new three.Vector2();
    var panDelta = new three.Vector2();

    var dollyStart = new three.Vector2();
    var dollyEnd = new three.Vector2();
    var dollyDelta = new three.Vector2();

    var getAutoRotationAngle = function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * _this.autoRotateSpeed;
    };

    var getZoomScale = function getZoomScale() {
      return Math.pow(0.95, _this.zoomSpeed);
    };

    var rotateLeft = function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    };

    var rotateUp = function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    };

    var panLeft = function () {
      var v = new three.Vector3();

      return function (distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();

    var panUp = function () {
      var v = new three.Vector3();

      return function (distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();

    // deltaX and deltaY are in pixels; right and down are positive
    var pan = function () {
      var offset = new three.Vector3();

      return function (deltaX, deltaY) {
        var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

        if (_this.object instanceof three.PerspectiveCamera) {
          // perspective
          var position = _this.object.position;
          offset.copy(position).sub(_this.target);
          var targetDistance = offset.length();

          // half of the fov is center to top of screen
          targetDistance *= Math.tan(_this.object.fov / 2 * Math.PI / 180.0);

          // we actually don't use screenWidth, since perspective camera is fixed to screen height
          panLeft(2 * deltaX * targetDistance / element.clientHeight, _this.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, _this.object.matrix);
        } else if (_this.object instanceof three.OrthographicCamera) {
          // orthographic
          panLeft(deltaX * (_this.object.right - _this.object.left) / _this.object.zoom / element.clientWidth, _this.object.matrix);
          panUp(deltaY * (_this.object.top - _this.object.bottom) / _this.object.zoom / element.clientHeight, _this.object.matrix);
        } else {
          // camera neither orthographic nor perspective
          console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - pan disabled.');
          _this.enablePan = false;
        }
      };
    }();

    var dollyIn = function dollyIn(dollyScale) {
      if (_this.object instanceof three.PerspectiveCamera) scale /= dollyScale;else if (_this.object instanceof three.OrthographicCamera) {
        _this.object.zoom = Math.max(_this.minZoom, Math.min(_this.maxZoom, _this.object.zoom * dollyScale));
        _this.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - dolly/zoom disabled.');
        _this.enableZoom = false;
      }
    };

    var dollyOut = function dollyOut(dollyScale) {
      if (_this.object instanceof three.PerspectiveCamera) scale *= dollyScale;else if (_this.object instanceof three.OrthographicCamera) {
        _this.object.zoom = Math.max(_this.minZoom, Math.min(_this.maxZoom, _this.object.zoom / dollyScale));
        _this.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - dolly/zoom disabled.');
        _this.enableZoom = false;
      }
    };

    //
    // event callbacks - update the object state
    //

    var handleMouseDownRotate = function handleMouseDownRotate(event) {
      // console.log( 'handleMouseDownRotate' );

      rotateStart.set(event.clientX, event.clientY);
    };

    var handleMouseDownDolly = function handleMouseDownDolly(event) {
      // console.log( 'handleMouseDownDolly' );

      dollyStart.set(event.clientX, event.clientY);
    };

    var handleMouseDownPan = function handleMouseDownPan(event) {
      // console.log( 'handleMouseDownPan' );

      panStart.set(event.clientX, event.clientY);
    };

    var handleMouseMoveRotate = function handleMouseMoveRotate(event) {
      // console.log( 'handleMouseMoveRotate' );

      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart);

      var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

      // rotating across whole screen goes 360 degrees around
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * _this.rotateSpeed);

      // rotating up and down along whole screen attempts to go 360, but limited to 180
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * _this.rotateSpeed);

      rotateStart.copy(rotateEnd);

      _this.update();
    };

    var handleMouseMoveDolly = function handleMouseMoveDolly(event) {
      // console.log( 'handleMouseMoveDolly' );

      dollyEnd.set(event.clientX, event.clientY);

      dollyDelta.subVectors(dollyEnd, dollyStart);

      if (dollyDelta.y > 0) dollyIn(getZoomScale());else if (dollyDelta.y < 0) dollyOut(getZoomScale());

      dollyStart.copy(dollyEnd);

      _this.update();
    };

    var handleMouseMovePan = function handleMouseMovePan(event) {
      // console.log( 'handleMouseMovePan' );

      panEnd.set(event.clientX, event.clientY);

      panDelta.subVectors(panEnd, panStart);

      pan(panDelta.x, panDelta.y);

      panStart.copy(panEnd);

      _this.update();
    };

    var handleMouseUp = function handleMouseUp(event) {
      // console.log( 'handleMouseUp' );
    };

    var handleMouseWheel = function handleMouseWheel(event) {
      // console.log( 'handleMouseWheel' );

      if (event.deltaY < 0) dollyOut(getZoomScale());else if (event.deltaY > 0) dollyIn(getZoomScale());

      _this.update();
    };

    var handleKeyDown = function handleKeyDown(event) {
      // console.log( 'handleKeyDown' );

      switch (event.keyCode) {
        case _this.keys.UP:
          pan(0, _this.keyPanSpeed);
          _this.update();
          break;

        case _this.keys.BOTTOM:
          pan(0, -_this.keyPanSpeed);
          _this.update();
          break;

        case _this.keys.LEFT:
          pan(_this.keyPanSpeed, 0);
          _this.update();
          break;

        case _this.keys.RIGHT:
          pan(-_this.keyPanSpeed, 0);
          _this.update();
          break;

      }
    };

    var handleTouchStartRotate = function handleTouchStartRotate(event) {
      // console.log( 'handleTouchStartRotate' );

      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    };

    var handleTouchStartDolly = function handleTouchStartDolly(event) {
      // console.log( 'handleTouchStartDolly' );

      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;

      var distance = Math.sqrt(dx * dx + dy * dy);

      dollyStart.set(0, distance);
    };

    var handleTouchStartPan = function handleTouchStartPan(event) {
      // console.log( 'handleTouchStartPan' );

      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    };

    var handleTouchMoveRotate = function handleTouchMoveRotate(event) {
      // console.log( 'handleTouchMoveRotate' );

      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      rotateDelta.subVectors(rotateEnd, rotateStart);

      var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

      // rotating across whole screen goes 360 degrees around
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * _this.rotateSpeed);

      // rotating up and down along whole screen attempts to go 360, but limited to 180
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * _this.rotateSpeed);

      rotateStart.copy(rotateEnd);

      _this.update();
    };

    var handleTouchMoveDolly = function handleTouchMoveDolly(event) {
      // console.log( 'handleTouchMoveDolly' );

      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;

      var distance = Math.sqrt(dx * dx + dy * dy);

      dollyEnd.set(0, distance);

      dollyDelta.subVectors(dollyEnd, dollyStart);

      if (dollyDelta.y > 0) dollyOut(getZoomScale());else if (dollyDelta.y < 0) dollyIn(getZoomScale());

      dollyStart.copy(dollyEnd);

      _this.update();
    };

    var handleTouchMovePan = function handleTouchMovePan(event) {
      // console.log( 'handleTouchMovePan' );

      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

      panDelta.subVectors(panEnd, panStart);

      pan(panDelta.x, panDelta.y);

      panStart.copy(panEnd);

      _this.update();
    };

    var handleTouchEnd = function handleTouchEnd() {
      // console.log( 'handleTouchEnd' );
    };

    //
    // event handlers - FSM: listen for events and reset state
    //

    var onMouseDown = function onMouseDown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();

      if (event.button === _this.mouseButtons.ORBIT) {
        if (_this.enableRotate === false) return;

        handleMouseDownRotate(event);

        state = STATE.ROTATE;
      } else if (event.button === _this.mouseButtons.ZOOM) {
        if (_this.enableZoom === false) return;

        handleMouseDownDolly(event);

        state = STATE.DOLLY;
      } else if (event.button === _this.mouseButtons.PAN) {
        if (_this.enablePan === false) return;

        handleMouseDownPan(event);

        state = STATE.PAN;
      }

      if (state !== STATE.NONE) {
        _this.eventHandler.on('mousemove', onMouseMove, false);
        _this.eventHandler.on('mouseup', onMouseUp, false);

        _this.dispatchEvent(startEvent);
      }
    };

    var onMouseMove = function onMouseMove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();

      if (state === STATE.ROTATE) {
        if (_this.enableRotate === false) return;

        handleMouseMoveRotate(event);
      } else if (state === STATE.DOLLY) {
        if (_this.enableZoom === false) return;

        handleMouseMoveDolly(event);
      } else if (state === STATE.PAN) {
        if (_this.enablePan === false) return;

        handleMouseMovePan(event);
      }
    };

    var onMouseUp = function onMouseUp(event) {
      if (_this.enabled === false) return;

      handleMouseUp(event);

      document.removeEventListener('mousemove', onMouseMove, false);
      document.removeEventListener('mouseup', onMouseUp, false);

      _this.dispatchEvent(endEvent);

      state = STATE.NONE;
    };

    var onMouseWheel = function onMouseWheel(event) {
      if (_this.enabled === false || _this.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

      event.preventDefault();
      event.stopPropagation();

      handleMouseWheel(event);

      _this.dispatchEvent(startEvent); // not sure why these are here...
      _this.dispatchEvent(endEvent);
    };

    var onKeyDown = function onKeyDown(event) {
      if (_this.enabled === false || _this.enableKeys === false || _this.enablePan === false) return;

      handleKeyDown(event);
    };

    var onTouchStart = function onTouchStart(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {
        case 1:
          // one-fingered touch: rotate

          if (_this.enableRotate === false) return;

          handleTouchStartRotate(event);

          state = STATE.TOUCH_ROTATE;

          break;

        case 2:
          // two-fingered touch: dolly

          if (_this.enableZoom === false) return;

          handleTouchStartDolly(event);

          state = STATE.TOUCH_DOLLY;

          break;

        case 3:
          // three-fingered touch: pan

          if (_this.enablePan === false) return;

          handleTouchStartPan(event);

          state = STATE.TOUCH_PAN;

          break;

        default:

          state = STATE.NONE;

      }

      if (state !== STATE.NONE) _this.dispatchEvent(startEvent);
    };

    var onTouchMove = function onTouchMove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {
        case 1:
          // one-fingered touch: rotate

          if (_this.enableRotate === false) return;
          if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

          handleTouchMoveRotate(event);

          break;

        case 2:
          // two-fingered touch: dolly

          if (_this.enableZoom === false) return;
          if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

          handleTouchMoveDolly(event);

          break;

        case 3:
          // three-fingered touch: pan

          if (_this.enablePan === false) return;
          if (state !== STATE.TOUCH_PAN) return; // is this needed?...

          handleTouchMovePan(event);

          break;

        default:

          state = STATE.NONE;

      }
    };

    var onTouchEnd = function onTouchEnd(event) {
      if (_this.enabled === false) return;

      handleTouchEnd(event);

      _this.dispatchEvent(endEvent);

      state = STATE.NONE;
    };

    var onContextMenu = function onContextMenu(event) {
      event.preventDefault();
    };

    //

    _this.eventHandler.on('contextmenu', onContextMenu, false);

    _this.eventHandler.on('mousedown', onMouseDown, false);
    _this.eventHandler.on('wheel', onMouseWheel, false);

    _this.eventHandler.on('touchstart', onTouchStart, false);
    _this.eventHandler.on('touchend', onTouchEnd, false);
    _this.eventHandler.on('touchmove', onTouchMove, false);

    _this.eventHandler.on('keydown', onKeyDown, false);

    // force an update at start

    _this.update();
    return _this;
  }

  createClass(ThreeOrbitControls, [{
    key: 'center',
    get: function get$$1() {
      console.warn('OrbitControls: .center has been renamed to .target');
      return this.target;
    }
  }, {
    key: 'noZoom',
    get: function get$$1() {
      console.warn('OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      return !this.enableZoom;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      this.enableZoom = !value;
    }
  }, {
    key: 'noRotate',
    get: function get$$1() {
      console.warn('OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      return !this.enableRotate;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      this.enableRotate = !value;
    }
  }, {
    key: 'noPan',
    get: function get$$1() {
      console.warn('OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      return !this.enablePan;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      this.enablePan = !value;
    }
  }, {
    key: 'noKeys',
    get: function get$$1() {
      console.warn('OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      return !this.enableKeys;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      this.enableKeys = !value;
    }
  }, {
    key: 'staticMoving',
    get: function get$$1() {
      console.warn('OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      return !this.enableDamping;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      this.enableDamping = !value;
    }
  }, {
    key: 'dynamicDampingFactor',
    get: function get$$1() {
      console.warn('OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      return this.dampingFactor;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      this.dampingFactor = value;
    }
  }]);
  return ThreeOrbitControls;
}(three.EventDispatcher);

/**
 * @class OrbitControlsModule
 * @category modules/app
 * @param {Object} [params]
 * @param {Object} [params.object=camera] Object to which controls are applied.
 * @param {THREE.Vector3} [params.target=new Vector3()] Controls center vector.
 * @param {Boolean} [params.follow=false] Follow the target
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new WHS.PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule(),
 *   new OrbitControlsModule()
 * ]);
 */

var OrbitControlsModule = function (_ControlsModule) {
  inherits(OrbitControlsModule, _ControlsModule);

  function OrbitControlsModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, OrbitControlsModule);

    var _this = possibleConstructorReturn(this, (OrbitControlsModule.__proto__ || Object.getPrototypeOf(OrbitControlsModule)).call(this, params));

    _this.params = Object.assign({
      follow: false,
      object: null,
      target: new three.Vector3()
    }, params);
    return _this;
  }

  createClass(OrbitControlsModule, [{
    key: 'manager',
    value: function manager(_manager) {
      get(OrbitControlsModule.prototype.__proto__ || Object.getPrototypeOf(OrbitControlsModule.prototype), 'manager', this).call(this, _manager);

      var _params = this.params,
          obj = _params.object,
          follow = _params.follow,
          target = _params.target;

      var object = obj ? obj.native : _manager.get('camera').native;

      var controls = new ThreeOrbitControls(object, _manager.get('element'), _manager.handler);

      var updateProcessor = follow ? function (c) {
        controls.update(c.getDelta());
        controls.target.copy(target);
      } : function (c) {
        controls.update(c.getDelta());
      };

      this.setControls(controls);
      this.setUpdate(updateProcessor);

      _manager.update({
        camera: function camera(_camera) {
          if (obj) return;
          controls.object = _camera.native;
        },
        element: function element(_element) {
          controls.domElement = _element;
        }
      });

      controls.target.copy(target);
    }
  }]);
  return OrbitControlsModule;
}(ControlsModule);

/** @module modules/app/controls */

/** @module modules/app */

/**
 * @class DynamicGeometryModule
 * @category modules/mesh
 * @param {Object} [params={attributes: false}] - params
 * @param {Boolean} [patchEvents=true]
 * @memberof module:modules/mesh
 */
var DynamicGeometryModule = function () {
  function DynamicGeometryModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DynamicGeometryModule);

    this.params = Object.assign({
      attributes: false
    }, params);
  }

  createClass(DynamicGeometryModule, [{
    key: "integrate",
    value: function integrate(self) {
      var _this = this;

      var params = self.params;

      this.g_ = function () {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (this.buildGeometry) {
          this.native.geometry = this.buildGeometry(this.updateParams({ geometry: params }));
        }
      };

      if (params.attributes) {
        var _loop = function _loop(key) {
          if (key) {
            Object.defineProperty(_this, "g_" + key, {
              get: function get$$1() {
                return this.native.geometry.parameters[key];
              },
              set: function set$$1(value) {
                this.native.geometry = this.buildGeometry(this.updateParams({ geometry: defineProperty({}, key, value) }));
              },

              configurable: true,
              enumerable: true
            });
          }
        };

        for (var key in this.params.geometry) {
          _loop(key);
        }
      }
    }
  }]);
  return DynamicGeometryModule;
}();

var loader = new three.TextureLoader();

/**
 * @class TextureModule
 * @category modules/mesh
 * @description A TextureModule can be applied to any Mesh or Model.
 * @param {Array} [textures] - array of texture objects
 * @memberof module:modules/mesh
 * @example <caption>Creating an instance. url takes a path, or a data object.</caption>
 * var woodTexture = new TextureModule({
 *   url: `${process.assetsPath}/textures/wood.jpg`
 * });
 * @example <caption>More comprehensive example, wood texture applied to a Box.</caption>
 * new Box({
 *   geometry: {
 *     width: 2,
 *     height: 2,
 *     depth: 2
 *   },
 *   modules: [
 *     new TextureModule({
 *       url: `path/to/texture.jpg`,
 *       repeat: new THREE.Vector2(1, 1) // optional
 *     })
 *   ],
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *   position: [50, 60, 70]
 * }).addTo(app);
 */
var TextureModule = function () {
  createClass(TextureModule, null, [{
    key: 'load',
    value: function load(url) {
      return new TextureModule({ url: url }).textures[0][1];
    }
  }]);

  function TextureModule() {
    var _this = this;

    classCallCheck(this, TextureModule);
    this.textures = [];
    this.bridge = {
      material: function material(_material, self) {
        self.textures.forEach(function (texture) {
          _material[texture[0]] = texture[1];
        });

        return _material;
      }
    };

    for (var _len = arguments.length, textures = Array(_len), _key = 0; _key < _len; _key++) {
      textures[_key] = arguments[_key];
    }

    textures.forEach(function (_ref) {
      var url = _ref.url,
          _ref$type = _ref.type,
          type = _ref$type === undefined ? 'map' : _ref$type,
          _ref$offset = _ref.offset,
          offset = _ref$offset === undefined ? new three.Vector2(0, 0) : _ref$offset,
          _ref$repeat = _ref.repeat,
          repeat = _ref$repeat === undefined ? new three.Vector2(1, 1) : _ref$repeat,
          _ref$wrap = _ref.wrap,
          wrap = _ref$wrap === undefined ? three.RepeatWrapping : _ref$wrap,
          _ref$mapping = _ref.mapping,
          mapping = _ref$mapping === undefined ? three.UVMapping : _ref$mapping,
          _ref$fix = _ref.fix,
          fix = _ref$fix === undefined ? function (tex) {
        return tex;
      } : _ref$fix;

      var texture = loader.load(url);

      if (wrap.length > 0) {
        texture.wrapS = wrap[0];
        texture.wrapT = wrap[1];
      } else texture.wrapS = texture.wrapT = wrap;

      texture.mapping = mapping;

      texture.offset.copy(offset);
      texture.repeat.copy(repeat);

      texture.magFilter = three.NearestFilter;
      texture.minFilter = three.LinearMipMapLinearFilter;

      _this.textures.push([type, fix(texture)]);
    });
  }

  return TextureModule;
}();

/**
 * @class AnimationModule
 * @category modules/mesh
 * @description Convenience module that wraps the <a href='https://threejs.org/docs/#manual/introduction/Animation-system'>three.js animation system</a>
 * @param {App} app - the app
 * @param {Boolean} [isDeferred=false] - set to true if animation should not start automatically
 * @param {Object} [params={speed: 1}] - the params
 * @memberof module:modules/mesh
 * @example <caption>Create animation module and play a given clip of an imported model</caption>
 * const animationModule = new AnimationModule(app, false, {
 *   speed: 1.2 // speed up animation by 20%
 * });
 *
 * new Importer({
 *   parser(geometry, materials) {
 *     // Override parse to generate a skinnedMesh, needed for skinned models
 *     return new THREE.SkinnedMesh(geometry, materials);
 *   },
 *
 *   url: `path/to/model.json`,
 *   useCustomMaterial: true,
 *
 *   material: new THREE.MeshStandardMaterial({
 *     skinning: true
 *   }),
 *
 *   modules: [animationModule]
 * }).addTo(app).then(() => {
 *   // adding model to app returns a promise, so pipe the function to kick off the animation clip
 *   animationModule.play('clipName');
 * });
 */

var AnimationModule = function () {
  function AnimationModule(app, isDeferred) {
    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, AnimationModule);
    this.bridge = {
      mesh: function mesh(_mesh, self) {
        _mesh.geometry.skeleton = _mesh.skeleton;

        self.mixer = new three.AnimationMixer(_mesh.geometry);
        self.clips = _mesh.geometry.animations;

        return _mesh;
      }
    };

    this.params = Object.assign({
      speed: 1
    }, params);
    this.clock = new three.Clock();

    this.app = app;
    this.isDeferred = isDeferred;
  }

  /**
   * @method play
   * @instance
   * @description Plays the given clip name
   * @param {String} clipName - the clip to play
   * @memberof module:modules/mesh.AnimationModule
   */


  createClass(AnimationModule, [{
    key: 'play',
    value: function play(clipName) {
      var clip = three.AnimationClip.findByName(this.clips, clipName);
      var action = this.mixer.clipAction(clip);

      action.play();
    }

    /**
     * @method update
     * @instance
     * @description Update the mixer (being called on frame animation loop)
     * @memberof module:modules/mesh.AnimationModule
     */

  }, {
    key: 'update',
    value: function update() {
      if (this.mixer) this.mixer.update(this.clock.getDelta() * this.params.speed);
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      self.loop = new Loop(function () {
        self.update();
      });

      if (!self.isDeferred) self.loop.start(self.app);
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('animation');
    }
  }]);
  return AnimationModule;
}();

/** @module modules/mesh */

/**
 * @class DefineModule
 * @category modules
 * @param {String} name
 * @param {Object} data
 * @memberof module:modules
 * @example <caption> Creating a DefineModule with PerspectiveCamera as camera module and passing it to App's modules</caption>
 * new App([
 *   // ...
 *   new DefineModule('camera', new PerspectiveCamera())
 * ]);
 */
var DefineModule = function () {
  function DefineModule(name, data) {
    classCallCheck(this, DefineModule);

    this.name = name;
    this.data = data;
  }

  createClass(DefineModule, [{
    key: "manager",
    value: function manager(_manager) {
      _manager.set(this.name, this.data);
    }
  }]);
  return DefineModule;
}();

/** @module modules */

var Model = function (_Importer) {
  inherits(Model, _Importer);

  function Model(params) {
    var _ref;

    classCallCheck(this, Model);

    console.warn('Model is deprecated. Use Importer instead.');

    if (params.geometry) {
      params.url = params.geometry.path;
      params.loader = params.geometry.loader;
    }

    for (var _len = arguments.length, additional = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      additional[_key - 1] = arguments[_key];
    }

    return possibleConstructorReturn(this, (_ref = Model.__proto__ || Object.getPrototypeOf(Model)).call.apply(_ref, [this, params].concat(additional)));
  }

  return Model;
}(Importer);

var CameraModule = function () {
  function CameraModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, CameraModule);

    console.warn('CameraModule is deprecated. Use DefineModule instead.');
    this.camera = new PerspectiveCamera$1(params);
  }

  createClass(CameraModule, [{
    key: 'integrate',
    value: function integrate(self) {
      this.add(self.camera);
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('camera', this.camera);
    }
  }]);
  return CameraModule;
}();

/**
 * Namespace containing all classes from all modules. Used as global in UMD pattern.
 * @namespace WHS
 * @example <caption>The use of WHS namespace.</caption>
 * new WHS.App() // core
 * new WHS.PerspectiveCamera() // components
 * new WHS.ResizeModule() // modules
 * WHS.extend() // utils
 */

exports.Component = Component;
exports.MeshComponent = MeshComponent;
exports.LightComponent = LightComponent;
exports.CameraComponent = CameraComponent;
exports.App = App;
exports.Loop = Loop;
exports.ModuleManager = ModuleManager;
exports.AmbientLight = AmbientLight$1;
exports.DirectionalLight = DirectionalLight$1;
exports.HemisphereLight = HemisphereLight$1;
exports.PointLight = PointLight$1;
exports.SpotLight = SpotLight$1;
exports.AreaLight = AreaLight;
exports.CubeCamera = CubeCamera$1;
exports.OrthographicCamera = OrthographicCamera$1;
exports.PerspectiveCamera = PerspectiveCamera$1;
exports.Box = Box;
exports.Circle = Circle;
exports.Cone = Cone;
exports.Cylinder = Cylinder;
exports.Dodecahedron = Dodecahedron;
exports.Extrude = Extrude;
exports.Icosahedron = Icosahedron;
exports.Lathe = Lathe;
exports.Line = Line$1;
exports.Importer = Importer;
exports.Octahedron = Octahedron;
exports.Parametric = Parametric;
exports.Plane = Plane$1;
exports.Polyhedron = Polyhedron;
exports.Ring = Ring;
exports.Shape = Shape;
exports.Sphere = Sphere;
exports.Tetrahedron = Tetrahedron;
exports.Text = Text;
exports.Torus = Torus;
exports.Torusknot = Torusknot;
exports.Tube = Tube;
exports.Group = Group;
exports.extend = extend;
exports.instruct = instruct;
exports.transformData = transformData;
exports.toArray = toArray;
exports.ElementModule = ElementModule;
exports.RenderingModule = RenderingModule;
exports.SceneModule = SceneModule;
exports.ResizeModule = ResizeModule;
exports.PostProcessorModule = PostProcessorModule;
exports.VirtualMouseModule = VirtualMouseModule;
exports.EventsPatchModule = EventsPatchModule;
exports.ControlsModule = ControlsModule;
exports.FogModule = FogModule;
exports.StateModule = StateModule;
exports.OrbitControlsModule = OrbitControlsModule;
exports.DynamicGeometryModule = DynamicGeometryModule;
exports.TextureModule = TextureModule;
exports.AnimationModule = AnimationModule;
exports.DefineModule = DefineModule;
exports.Model = Model;
exports.CameraModule = CameraModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2hzLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvZXh0ZW5kLmpzIiwiLi4vc3JjL3V0aWxzL3RyYW5zZm9ybURhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbWluaXZlbnRzL2Rpc3QvbWluaXZlbnRzLmNvbW1vbmpzLmpzIiwiLi4vc3JjL2NvcmUvZXJyb3JzLmpzIiwiLi4vc3JjL2NvcmUvTW9kdWxlU3lzdGVtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvcG9ueWZpbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvY3JlYXRlU3RvcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jb21wb3NlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2luZGV4LmpzIiwiLi4vc3JjL2NvcmUvTW9kdWxlTWFuYWdlci5qcyIsIi4uL3NyYy9jb3JlL0NvbXBvbmVudC5qcyIsIi4uL3NyYy9jb3JlL3Byb3RvdHlwZS9hdHRyaWJ1dGVzLmpzIiwiLi4vc3JjL2NvcmUvTWVzaENvbXBvbmVudC5qcyIsIi4uL3NyYy9jb3JlL0xpZ2h0Q29tcG9uZW50LmpzIiwiLi4vc3JjL2NvcmUvQ2FtZXJhQ29tcG9uZW50LmpzIiwiLi4vc3JjL3BvbHlmaWxsLmpzIiwiLi4vc3JjL2NvcmUvQXBwLmpzIiwiLi4vc3JjL2NvcmUvTG9vcC5qcyIsIi4uL3NyYy9jb3JlL2luZGV4LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbGlnaHRzL0FtYmllbnRMaWdodC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL2xpZ2h0cy9Qb2ludExpZ2h0LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbGlnaHRzL1Nwb3RMaWdodC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL2xpZ2h0cy9BcmVhTGlnaHQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9saWdodHMvaW5kZXguanMiLCIuLi9zcmMvY29tcG9uZW50cy9jYW1lcmFzL0N1YmVDYW1lcmEuanMiLCIuLi9zcmMvY29tcG9uZW50cy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMiLCIuLi9zcmMvY29tcG9uZW50cy9jYW1lcmFzL2luZGV4LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL0JveC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9DaXJjbGUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvQ29uZS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9DeWxpbmRlci5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9Eb2RlY2FoZWRyb24uanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvRXh0cnVkZS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9JY29zYWhlZHJvbi5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9MYXRoZS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9MaW5lLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL0ltcG9ydGVyLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL09jdGFoZWRyb24uanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvUGFyYW1ldHJpYy5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9QbGFuZS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9Qb2x5aGVkcm9uLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1JpbmcuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvU2hhcGUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvU3BoZXJlLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1RldHJhaGVkcm9uLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1RleHQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvVG9ydXMuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvVG9ydXNrbm90LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1R1YmUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvR3JvdXAuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvaW5kZXguanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvRWxlbWVudE1vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL2FwcC9SZW5kZXJpbmdNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvU2NlbmVNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvUmVzaXplTW9kdWxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvQWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9Cb2tlaE1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvQm9rZWgyTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9Db21iaW5lTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9Db252b2x1dGlvbk1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvQ29weU1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvRGVwdGhNYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL0RvdFNjcmVlbk1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvRmlsbU1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvR2xpdGNoTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9Hb2RSYXlzTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9MdW1pbm9zaXR5TWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9QaXhlbGF0aW9uTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9TaG9ja1dhdmVNYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL1NNQUFCbGVuZE1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvU01BQUNvbG9yRWRnZXNNYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL2ltYWdlcy9zbWFhL2FyZWFJbWFnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL2ltYWdlcy9zbWFhL3NlYXJjaEltYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvU01BQVdlaWdodHNNYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL1RvbmVNYXBwaW5nTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL1Bhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9CbHVyUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0Jsb29tUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0Jva2VoUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0Jva2VoMlBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9DbGVhck1hc2tQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvQ2xlYXJQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvRG90U2NyZWVuUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0RlcHRoUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0ZpbG1QYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvR2xpdGNoUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL1JlbmRlclBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9Hb2RSYXlzUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL01hc2tQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvUGl4ZWxhdGlvblBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9TYXZlUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL1NoYWRlclBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9TaG9ja1dhdmVQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvU01BQVBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9UZXh0dXJlUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL1RvbmVNYXBwaW5nUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9jb3JlL0VmZmVjdENvbXBvc2VyLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL1Bvc3RQcm9jZXNzb3JNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvRXZlbnRzUGF0Y2hNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvVmlydHVhbE1vdXNlTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL0NvbnRyb2xzTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL0ZvZ01vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL2FwcC9TdGF0ZU1vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL2FwcC9jb250cm9scy9saWIvVGhyZWVPcmJpdENvbnRyb2xzLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL2NvbnRyb2xzL09yYml0Q29udHJvbHNNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvY29udHJvbHMvaW5kZXguanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvaW5kZXguanMiLCIuLi9zcmMvbW9kdWxlcy9tZXNoL0R5bmFtaWNHZW9tZXRyeU1vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL21lc2gvVGV4dHVyZU1vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL21lc2gvQW5pbWF0aW9uTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvbWVzaC9pbmRleC5qcyIsIi4uL3NyYy9tb2R1bGVzL0RlZmluZU1vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL2luZGV4LmpzIiwiLi4vc3JjL2RlcHJlY2F0aW9uLmpzIiwiLi4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBleHRlbmQgPSAob2JqZWN0LCAuLi5leHRlbnNpb25zKSA9PiB7IC8vICQuZXh0ZW5kIGFsdGVybmF0aXZlLCAuLi4gaXMgdGhlIHNwcmVhZCBvcGVyYXRvci5cbiAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgIC8vIGNvbnNvbGUubG9nKGV4dGVuc2lvbik7XG4gICAgLy8gY29uc29sZS5sb2codHlwZW9mIGV4dGVuc2lvbik7XG5cbiAgICBpZiAoIWV4dGVuc2lvbilcbiAgICAgIGNvbnRpbnVlOyAvLyBJZ25vcmUgbnVsbCBhbmQgdW5kZWZpbmVkIG9iamVjdHMgYW5kIHBhcmFtZXRlcnMuXG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXh0ZW5zaW9uKSkgeyAvLyBEbyBub3QgdHJhdmVyc2UgdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgIGlmIChvYmplY3RbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb25bcHJvcF1cbiAgICAgICAgJiYgb2JqZWN0W3Byb3BdLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgICYmIGV4dGVuc2lvbltwcm9wXS50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAvLyBHb2VzIGRlZXAgb25seSBpZiBvYmplY3RbcHJvcF0gYW5kIGV4dGVuc2lvbltwcm9wXSBhcmUgYm90aCBvYmplY3RzICFcbiAgICAgICAgaWYgKG9iamVjdFtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSBleHRlbmQob2JqZWN0W3Byb3BdLCBleHRlbnNpb25bcHJvcF0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHR5cGVvZiBvYmplY3RbcHJvcF0gPT09ICd1bmRlZmluZWQnID8gZXh0ZW5zaW9uW3Byb3BdIDogb2JqZWN0W3Byb3BdO1xuXG4gICAgICBpZiAodHlwZW9mIG9iamVjdFtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheShleHRlbnNpb25bcHJvcF0pKSBvYmplY3RbcHJvcF0gPSBleHRlbnNpb25bcHJvcF0uc2xpY2UoKTsgLy8gQWRkIHZhbHVlcyB0aGF0IGRvIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdFtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheShleHRlbnNpb25bcHJvcF0pKSBvYmplY3RbcHJvcF0gPSBleHRlbnNpb25bcHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJleHBvcnQgY29uc3QgaW5zdHJ1Y3QgPSAoYXJyYXksIGluc3RBcnJheSkgPT4ge1xuICBjb25zdCB0ZW1wT2JqZWN0ID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGluc3RBcnJheS5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgIGNvbnN0IGd1aWRlID0gaW5zdEFycmF5W2ldO1xuXG4gICAgdGVtcE9iamVjdFtndWlkZV0gPSBhcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wT2JqZWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybURhdGEgPSAob2JqZWN0LCBpbnN0cnVjdGlvbnMpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdHJ1Y3Rpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0W2tleV0pKVxuICAgICAgb2JqZWN0W2tleV0gPSBpbnN0cnVjdChvYmplY3Rba2V5XSwgaW5zdHJ1Y3Rpb25zW2tleV0pO1xuICAgIGVsc2UgaWYgKG9iamVjdFtrZXldIGluc3RhbmNlb2YgT2JqZWN0ICYmICEoQXJyYXkuaXNBcnJheShpbnN0cnVjdGlvbnNba2V5XSkpKVxuICAgICAgb2JqZWN0W2tleV0gPSB0cmFuc2Zvcm1EYXRhKG9iamVjdFtrZXldLCBpbnN0cnVjdGlvbnNba2V5XSk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSAob2JqZWN0LCBpbnN0cnVjdGlvbikgPT4ge1xuICBjb25zdCB0ZW1wQXJyYXkgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMCwgbWF4ID0gaW5zdHJ1Y3Rpb24ubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICBjb25zdCBndWlkZSA9IGluc3RydWN0aW9uW2ldO1xuXG4gICAgdGVtcEFycmF5W2ldID0gb2JqZWN0W2d1aWRlXTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wQXJyYXk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBFdmVudHModGFyZ2V0KXtcbiAgdmFyIGV2ZW50cyA9IHt9LCBlbXB0eSA9IFtdO1xuICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpc1xuICAvKipcbiAgICogIE9uOiBsaXN0ZW4gdG8gZXZlbnRzXG4gICAqL1xuICB0YXJnZXQub24gPSBmdW5jdGlvbih0eXBlLCBmdW5jLCBjdHgpe1xuICAgIChldmVudHNbdHlwZV0gPSBldmVudHNbdHlwZV0gfHwgW10pLnB1c2goW2Z1bmMsIGN0eF0pXG4gIH1cbiAgLyoqXG4gICAqICBPZmY6IHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50IC8gc3BlY2lmaWMgY2FsbGJhY2tcbiAgICovXG4gIHRhcmdldC5vZmYgPSBmdW5jdGlvbih0eXBlLCBmdW5jKXtcbiAgICB0eXBlIHx8IChldmVudHMgPSB7fSlcbiAgICB2YXIgbGlzdCA9IGV2ZW50c1t0eXBlXSB8fCBlbXB0eSxcbiAgICAgICAgaSA9IGxpc3QubGVuZ3RoID0gZnVuYyA/IGxpc3QubGVuZ3RoIDogMDtcbiAgICB3aGlsZShpLS0pIGZ1bmMgPT0gbGlzdFtpXVswXSAmJiBsaXN0LnNwbGljZShpLDEpXG4gIH1cbiAgLyoqIFxuICAgKiBFbWl0OiBzZW5kIGV2ZW50LCBjYWxsYmFja3Mgd2lsbCBiZSB0cmlnZ2VyZWRcbiAgICovXG4gIHRhcmdldC5lbWl0ID0gZnVuY3Rpb24odHlwZSl7XG4gICAgdmFyIGUgPSBldmVudHNbdHlwZV0gfHwgZW1wdHksIGxpc3QgPSBlLmxlbmd0aCA+IDAgPyBlLnNsaWNlKDAsIGUubGVuZ3RoKSA6IGUsIGk9MCwgajtcbiAgICB3aGlsZShqPWxpc3RbaSsrXSkgalswXS5hcHBseShqWzFdLCBlbXB0eS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gIH07XG59OyIsImV4cG9ydCBjbGFzcyBDb21wb3NpdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjbGFzc0luc3RhbmNlLCBtZXNzYWdlLCBjb21wb25lbnQpIHtcbiAgICBzdXBlcihgQCR7Y2xhc3NJbnN0YW5jZX06ICR7bWVzc2FnZX1gKTtcblxuICAgIGNvbnN0IHN0YWNrQXJyYXkgPSB0aGlzLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICBzdGFja0FycmF5LnNwbGljZSgxLCAyKTtcblxuICAgIHRoaXMuc3RhY2sgPSBzdGFja0FycmF5LmpvaW4oJ1xcbicpO1xuXG4gICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoJ0NvbXBvbmVudDonLCBjb21wb25lbnQpO1xuXG4gICAgdGhpcy5uYW1lID0gJ0NvbXBvc2l0aW9uRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXBlbmRlbmN5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNsYXNzSW5zdGFuY2UsIG1lc3NhZ2UsIGFjdGl2ZU1vZHVsZSwgZGVwZW5kZW5jeU1vZHVsZSA9IGZhbHNlKSB7XG4gICAgc3VwZXIoYEAke2NsYXNzSW5zdGFuY2V9OiAke21lc3NhZ2V9YCk7XG5cbiAgICBjb25zdCBzdGFja0FycmF5ID0gdGhpcy5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgc3RhY2tBcnJheS5zcGxpY2UoMSwgMik7XG5cbiAgICB0aGlzLnN0YWNrID0gc3RhY2tBcnJheS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChjb25zb2xlKSBjb25zb2xlLmVycm9yKCdBY3RpdmUgbW9kdWxlOicsIGFjdGl2ZU1vZHVsZSk7XG4gICAgaWYgKGNvbnNvbGUgJiYgZGVwZW5kZW5jeU1vZHVsZSkgY29uc29sZS5lcnJvcignRGVwZW5kZW5jeSBwdWJsaXNoZWQgYnkgbW9kdWxlOicsIGRlcGVuZGVuY3lNb2R1bGUpO1xuXG4gICAgdGhpcy5uYW1lID0gJ0RlcGVuZGVuY3lFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hbmFnZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2xhc3NJbnN0YW5jZSwgbWVzc2FnZSwgY29tcG9uZW50LCBhY3RpdmVNb2R1bGUgPSBmYWxzZSkge1xuICAgIHN1cGVyKGBAJHtjbGFzc0luc3RhbmNlfTogJHttZXNzYWdlfWApO1xuXG4gICAgY29uc3Qgc3RhY2tBcnJheSA9IHRoaXMuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIHN0YWNrQXJyYXkuc3BsaWNlKDEsIDIpO1xuXG4gICAgdGhpcy5zdGFjayA9IHN0YWNrQXJyYXkuam9pbignXFxuJyk7XG5cbiAgICBpZiAoY29uc29sZSkgY29uc29sZS5lcnJvcignQ29tcG9uZW50OicsIGNvbXBvbmVudCk7XG4gICAgaWYgKGNvbnNvbGUgJiYgYWN0aXZlTW9kdWxlKSBjb25zb2xlLmVycm9yKCdBY3RpdmUgbW9kdWxlOicsIGFjdGl2ZU1vZHVsZSk7XG5cbiAgICB0aGlzLm5hbWUgPSAnTWFuYWdlckVycm9yJztcbiAgfVxufVxuIiwiaW1wb3J0IHtSRVZJU0lPTn0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICdtaW5pdmVudHMnO1xuaW1wb3J0IHtNYW5hZ2VyRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuLy8gQ2hlY2sgZm9yIFRocmVlLmpzXG5jb25zdCB3YXJuRGVwcyA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdXaGl0ZXN0b3JtSlMgRnJhbWV3b3JrIHJlcXVpcmVzIFRocmVlLmpzIHI4NC4gaHR0cHM6Ly90aHJlZWpzLm9yZy8nKTtcbn07XG5cbnRyeSB7XG4gIGlmICghUkVWSVNJT04pIHdhcm5EZXBzKCk7XG59IGNhdGNoIChlcnIpIHtcbiAgd2FybkRlcHMoKTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgTW9kdWxlU3lzdGVtXG4gKiBAY2F0ZWdvcnkgY29yZVxuICogQGRlc2NyaXB0aW9uICBQcm92aWRlcyBBUEkgZm9yIGNsYXNzZXMgdGhhdCB3aWxsIHVzZSBNb2R1bGVzLjxici8+XG4gKiBUaGlzIGNsYXNzIGluY2x1ZGVzIGJhc2ljIGV2ZW50IHN5c3RlbSB3aXRoIHRob3NlIHN1cHBvcnRlZCBtZXRob2RzOlxuICogPHByZT4ub24oKTwvcHJlPjxwcmU+Lm9mZigpPC9wcmU+PHByZT4uZW1pdCgpPC9wcmU+XG4gKiBAZXh0ZW5kcyBFdmVudHNcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZVxuICovXG5leHBvcnQgY2xhc3MgTW9kdWxlU3lzdGVtIGV4dGVuZHMgRXZlbnRzIHtcbiAgLy8gSU5URUdSQVRJTkdcblxuICAvKipcbiAgICogQG1ldGhvZCBpbnRlZ3JhdGVNb2R1bGVzXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBtZXRob2QgYXBwbGllcyBhbGwgbW9kdWxlcyBmcm9tIC5tb2R1bGVzIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc291cmNlXSBJZiBzb3VyY2UgKHNob3VsZCBiZSBhIGNvbXBvbmVudCkgaXMgcHJvdmlkZWQsIHdpbGwgcmVwbGFjZSAubW9kdWxlcyB3aXRoIHNvdXJjZSdzIG9uZSBiZWZvcmUgZXhlY3V0aW5nIG1vZHVsZXMuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVTeXN0ZW1cbiAgICovXG4gIGludGVncmF0ZU1vZHVsZXMoc291cmNlKSB7XG4gICAgaWYgKCF0aGlzLm1vZHVsZXMgJiYgIXNvdXJjZSkgcmV0dXJuO1xuICAgIGlmIChzb3VyY2UgJiYgc291cmNlLm1vZHVsZXMpIHRoaXMubW9kdWxlcyA9IHNvdXJjZS5tb2R1bGVzLnNsaWNlKDApO1xuXG4gICAgaWYgKHRoaXMubW9kdWxlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKylcbiAgICAgICAgdGhpcy5hcHBseU1vZHVsZSh0aGlzLm1vZHVsZXNbaV0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlKSB0aGlzLmFwcGx5QnJpZGdlKHtvbkNvcHk6IHNvdXJjZX0pO1xuICB9XG5cbiAgLy8gQVBQTFlJTkcgTU9EVUxFICguLi5hbmQgYSBcImJyaWRnZVwiIGZvciBtb2R1bGUpXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYXBwbHlCcmlkZ2VcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBNYWtlcyBjb21wb25lbnQtc3BlY2lmaWMgQVBJIHRvIHdvcmsgd2l0aCBtb2R1bGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYnJpZGdlTWFwXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBvYmplY3Qgd2l0aCBtb2RpZmllZCB2YWx1ZXMuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVTeXN0ZW1cbiAgICovXG4gIGFwcGx5QnJpZGdlKGJyaWRnZU1hcCA9IHt9KSB7XG4gICAgY29uc3QgbW9kdWxlcyA9IHRoaXMubW9kdWxlcztcbiAgICBpZiAoIW1vZHVsZXMpIHJldHVybiBicmlkZ2VNYXA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbWF4ID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYnJpZGdlTWFwKSB7XG4gICAgICAgIGlmIChicmlkZ2VNYXBba2V5XSkge1xuICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IG1vZHVsZXNbaV07XG5cbiAgICAgICAgICBpZiAobW9kdWxlICYmIG1vZHVsZS5icmlkZ2UgJiYgbW9kdWxlLmJyaWRnZVtrZXldKVxuICAgICAgICAgICAgYnJpZGdlTWFwW2tleV0gPSBtb2R1bGUuYnJpZGdlW2tleV0uYXBwbHkodGhpcywgW2JyaWRnZU1hcFtrZXldLCBtb2R1bGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBicmlkZ2VNYXA7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBhcHBseUNvbW1hbmRcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiAuYXBwbHlDb21tYW5kIHJ1bnMgYSBtZXRob2QgY2FsbGVkIGBuYW1lYCBvbiBhbGwgbW9kdWxlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG1ldGhvZCBuYW1lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2I9KGZ1bmMsIG1vZHVsZVNjb3BlKSA9PiBmdW5jLmFwcGx5KHRoaXMsIFttb2R1bGVTY29wZV0pXSBIb3cgdGhlIGZ1bmN0aW9uIGlzIHdyYXBwZWQvXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVTeXN0ZW1cbiAgICovXG4gIGFwcGx5Q29tbWFuZChuYW1lLCBjYiA9IChmdW5jLCBtb2R1bGVTY29wZSkgPT4gZnVuYy5hcHBseSh0aGlzLCBbbW9kdWxlU2NvcGVdKSkge1xuICAgIGNvbnN0IG1vZHVsZXMgPSB0aGlzLm1vZHVsZXM7XG4gICAgaWYgKCFtb2R1bGVzKSByZXR1cm47XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbWF4ID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgY29uc3QgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICAgIGlmIChuYW1lIGluIG1vZHVsZSkgY2IobW9kdWxlW25hbWVdLCBtb2R1bGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFwcGx5TW9kdWxlXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gLmFwcGx5TW9kdWxlIGlzIGFsc28gdXNlZCBpbiAuaW50ZWdyYXRlTW9kdWxlcygpIGZ1bmN0aW9uLlxuICAgKiBJdCBkb2VzIGV4YWN0bHkgd2hhdCBpdHMgbmFtZSBzYXlzIChhcHBsaWVzIG1vZHVsZSB0byBjb21wb25lbnQgb3IgYXBwKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgbW9kdWxlIHRvIGFwcGx5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3B1c2g9dHJ1ZV1cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG1vZHVsZSB0aGF0IHdhcyBhcHBsaWVkLlxuICAgKiBAdGhyb3dzIHtNYW5hZ2VyRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVTeXN0ZW1cbiAgICovXG4gIGFwcGx5TW9kdWxlKG1vZHVsZSwgcHVzaCA9IHRydWUpIHtcbiAgICBpZiAoIW1vZHVsZSkgcmV0dXJuO1xuICAgIGlmIChwdXNoICYmIHRoaXMubW9kdWxlcykgdGhpcy5tb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICBlbHNlIGlmIChwdXNoKSB0aGlzLm1vZHVsZXMgPSBbbW9kdWxlXTtcblxuICAgIGlmICh0aGlzLm1hbmFnZXIpIHRoaXMubWFuYWdlci5hY3RpdmUobW9kdWxlKTtcblxuICAgIGlmIChtb2R1bGUubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIpIG1vZHVsZS5tYW5hZ2VyKHRoaXMubWFuYWdlcik7XG4gICAgZWxzZSBpZiAobW9kdWxlLm1hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBNYW5hZ2VyRXJyb3IoXG4gICAgICAgICdDb21wb25lbnQnLFxuICAgICAgICBgTW9kdWxlIHJlcXVpcmVzIE1vZHVsZU1hbmFnZXIgdGhhdCBpcyB0dXJuZWQgb2ZmIGZvciB0aGlzIGNvbXBvbmVudGAsXG4gICAgICAgIHRoaXMsIG1vZHVsZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobW9kdWxlLmludGVncmF0ZSkgbW9kdWxlLmludGVncmF0ZS5iaW5kKHRoaXMpKG1vZHVsZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGlzcG9zZU1vZHVsZXNcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBEaXNwb3NlcyBvZiBhbGwgbW9kdWxlc1xuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlU3lzdGVtXG4gICAqL1xuICBkaXNwb3NlTW9kdWxlcygpIHtcbiAgICB3aGlsZSAodGhpcy5tb2R1bGVzLmxlbmd0aClcbiAgICAgIHRoaXMuZGlzcG9zZU1vZHVsZSh0aGlzLm1vZHVsZXNbMF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGlzcG9zZU1vZHVsZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIERpc3Bvc2VzIG9mIHRoZSBnaXZlbiBtb2R1bGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgbW9kdWxlIHRvIGRpc3Bvc2VcbiAgICogQHJldHVybiB7TW9kdWxlfSBSZXR1cm5zIG1vZHVsZSB0aGF0IHdhcyByZW1vdmVkLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlU3lzdGVtXG4gICAqL1xuICBkaXNwb3NlTW9kdWxlKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlKSByZXR1cm47XG5cbiAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKHRoaXMubW9kdWxlcy5pbmRleE9mKG1vZHVsZSksIDEpO1xuXG4gICAgaWYgKG1vZHVsZS5kaXNwb3NlKSBtb2R1bGUuZGlzcG9zZS5iaW5kKHRoaXMpKG1vZHVsZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9XG5cbiAgLy8gUElQRUQgTUVUSE9EXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbW9kdWxlXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gcGlwZWQgdmVyc2lvbiBvZiAuYXBwbHlNb2R1bGUoKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgbW9kdWxlIHRvIGFwcGx5XG4gICAqIEByZXR1cm4ge3RoaXN9IHJldHVybnMgdGhpcyAtIGFwcC9jb21wb25lbnRcbiAgICogQHRocm93cyB7TWFuYWdlckVycm9yfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlU3lzdGVtXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlBpcGVkIG1vZHVsZXM8L2NhcHRpb24+XG4gICAqIGNvbXBvbmVudFxuICAgKiAgIC5tb2R1bGUobmV3IE1vZHVsZTEoKSlcbiAgICogICAubW9kdWxlKG5ldyBNb2R1bGUyKCkpXG4gICAqICAgLm1vZHVsZShuZXcgTW9kdWxlMygpKVxuICAgKi9cbiAgbW9kdWxlKG1vZHVsZSkge1xuICAgIHRoaXMuYXBwbHlNb2R1bGUobW9kdWxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBwb255ZmlsbCBmcm9tICcuL3BvbnlmaWxsJztcblxudmFyIHJvb3Q7XG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9IHBvbnlmaWxsKHJvb3QpO1xuZXhwb3J0IGRlZmF1bHQgcmVzdWx0O1xuIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0ICQkb2JzZXJ2YWJsZSBmcm9tICdzeW1ib2wtb2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG5leHBvcnQgdmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAgICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gICAqXG4gICAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAgICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICAgKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAgICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICAgKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICAgKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICAgKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gICAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbmhhbmNlcl0gVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICAgKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gICAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAgICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAgICpcbiAgICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAgICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICAgKi9cbn07ZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn0iLCIvKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59IiwiaW1wb3J0IGNyZWF0ZVN0b3JlIGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGNvbWJpbmVSZWR1Y2VycyBmcm9tICcuL2NvbWJpbmVSZWR1Y2Vycyc7XG5pbXBvcnQgYmluZEFjdGlvbkNyZWF0b3JzIGZyb20gJy4vYmluZEFjdGlvbkNyZWF0b3JzJztcbmltcG9ydCBhcHBseU1pZGRsZXdhcmUgZnJvbSAnLi9hcHBseU1pZGRsZXdhcmUnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgY29tYmluZVJlZHVjZXJzLCBiaW5kQWN0aW9uQ3JlYXRvcnMsIGFwcGx5TWlkZGxld2FyZSwgY29tcG9zZSB9OyIsImltcG9ydCB7Y3JlYXRlU3RvcmV9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7RGVwZW5kZW5jeUVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8qKlxuICogQGNsYXNzIE1vZHVsZU1hbmFnZXJcbiAqIEBjYXRlZ29yeSBjb3JlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IGhhbmRsZXJcbiAqIEBkZXNjcmlwdGlvbiAgU29sdmVzIG1vZHVsZXMgZGVwZW5kZW5jaWVzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE1vZHVsZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvYmplY3QpIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBvYmplY3Q7XG4gICAgdGhpcy5jdXJyZW50TW9kdWxlID0gbnVsbDtcblxuICAgIHRoaXMuc3RvcmUgPSBjcmVhdGVTdG9yZSgoc3RhdGUgPSBbe30sICcnXSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZVswXVthY3Rpb24ua2V5XSA9IGFjdGlvbi5kYXRhO1xuICAgICAgc3RhdGVbMV0gPSBhY3Rpb24ua2V5O1xuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFjdGl2ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFNldHMgLmN1cnJlbnRNb2R1bGUgdG8gcHJvdmlkZWQgbW9kdWxlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIHRoZSBtb2R1bGUgdG8gbWFrZSBjdXJyZW50XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyXG4gICAqL1xuICBhY3RpdmUobW9kdWxlKSB7XG4gICAgdGhpcy5jdXJyZW50TW9kdWxlID0gbW9kdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVzZXRcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBTZXQncyAuY3VycmVudE1vZHVsZSB0byBudWxsLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlclxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdXJyZW50TW9kdWxlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRlZmluZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIERlZmluZSB0aGUgbW9kdWxlIGluIG1hbmFnZXJcbiAgICogQHBhcmFtIG5hbWUgVGhlIG1vZHVsZSBuYW1lXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyXG4gICAqL1xuICBkZWZpbmUobmFtZSkge1xuICAgIHRoaXMubW9kdWxlc1tuYW1lXSA9IHRoaXMuY3VycmVudE1vZHVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHVzZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgZGVmaW5lZCBtb2R1bGUgZnJvbSBtYW5hZ2VyXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBtb2R1bGUgbmFtZVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlclxuICAgKi9cbiAgdXNlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQW4gYWxpYXMgZm9yIC5hZGQoKSA8YnIvPjxici8+XG4gICAqIFVzZSB0aGlzIG1ldGhvZCBpZiB5b3Uga25vdyB0aGF0IHlvdSB3aWxsIG92ZXJ3cml0ZSBleGlzdGluZyBkZXBlbmRlbmN5Ljxici8+XG4gICAqIFVzZSBpdCBpbiB5b3VyIGFwcCwgYnV0IG5vdCBpbiBtb2R1bGUgdGhhdCB5b3UgcHJvdmlkZSB0byBvdGhlciBwZW9wbGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgdGhlIGtleSBvZiB0aGUgZGVwZW5kZW5jeVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgdmFsdWUgb2YgdGhlIGRlcGVuZGVuY3lcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZU1hbmFnZXJcbiAgICovXG4gIHNldChrZXksIGRhdGEpIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdBREQnLFxuICAgICAga2V5LFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBkZXBlbmRlbmN5IGluIHN0b3JlIG9iamVjdCwgYnkga2V5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgb2YgdGhlIGRlcGVuZGVuY3lcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZU1hbmFnZXJcbiAgICogQHJldHVybiB7T2JqZWN0fE1vZHVsZX1cbiAgICogQHRocm93cyB7RGVwZW5kZW5jeUVycm9yfSBpZiBkZXBlbmRlbmN5IGlzIG5vdCBpbiB0aGUgc3RvcmVcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IHRoZSAnaGVsbG8nIGRlcGVuZGVuY3k8L2NhcHRpb24+XG4gICAqIG1hbmFnZXIuZ2V0KCdoZWxsbycpOyAvLyAtPiB7d29ybGQ6IHRydWV9XG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgaWYgKCF0aGlzLnN0b3JlLmdldFN0YXRlKClbMF1ba2V5XSkge1xuICAgICAgdGhyb3cgbmV3IERlcGVuZGVuY3lFcnJvcihcbiAgICAgICAgJ01vZHVsZU1hbmFnZXInLFxuICAgICAgICBgTW9kdWxlIHJlcXVpcmVzICcke2tleX0nIGRlcGVuZGVuY3lgLFxuICAgICAgICB0aGlzLmN1cnJlbnRNb2R1bGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVswXVtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGFzXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB3aGV0aGVyIG1hbmFnZXIgaGFzIGEgZGVwZW5kZW5jeSB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IG9mIHRoZSBkZXBlbmRlbmN5XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIGFsbCBwcm9taXNlcyBjb21wbGV0ZWQuXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkNoZWNrIHdoZXRoZXIgdGhlIHN0b3JlIGhhcyB0aGUgJ2hlbGxvJyBkZXBlbmRlbmN5PC9jYXB0aW9uPlxuICAgKiBtYW5hZ2VyLmhhcygnaGVsbG8nKTsgLy8gLT4gdHJ1ZVxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVswXVtrZXldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgZGVwc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2RlcHNNYXA9e31dXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyXG4gICAqL1xuICB1cGRhdGUoZGVwc01hcCA9IHt9KSB7XG4gICAgdGhpcy5zdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgW2RhdGEsIGNoYW5nZWRLZXldID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBkZXBzTWFwW2NoYW5nZWRLZXldO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGRhdGFbY2hhbmdlZEtleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkXG4gICAqIEBhbGlhcyBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyI3NldFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlclxuICAgKi9cbiAgYWRkKC4uLmRhdGEpIHtcbiAgICBjb25zb2xlLndhcm4oJy5hZGQoKSBtZXRob2QgaXMgZGVwcmVjYXRlZC4gVXNlIC5zZXQoKSBpbnN0ZWFkJyk7XG4gICAgcmV0dXJuIHRoaXMuc2V0KC4uLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVxdWlyZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFJlcXVpcmUgbW9kdWxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIERlZmluZWQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2R1bGVFeGVjdXRvciBGdW5jdGlvbiB0aGF0IHJldHVybnMgYXBwbGllZCBtb2R1bGVcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZU1hbmFnZXJcbiAgICovXG4gIHJlcXVpcmUobmFtZSwgbW9kdWxlRXhlY3V0b3IpIHtcbiAgICBpZiAodGhpcy51c2UobmFtZSkgPT09IHVuZGVmaW5lZCkgdGhpcy5oYW5kbGVyLmFwcGx5TW9kdWxlKG1vZHVsZUV4ZWN1dG9yKCkpO1xuICB9XG59XG4iLCJpbXBvcnQge2V4dGVuZCwgdHJhbnNmb3JtRGF0YX0gZnJvbSAnLi4vdXRpbHMvaW5kZXgnO1xuaW1wb3J0IHtNb2R1bGVTeXN0ZW19IGZyb20gJy4vTW9kdWxlU3lzdGVtJztcbmltcG9ydCB7TW9kdWxlTWFuYWdlcn0gZnJvbSAnLi9Nb2R1bGVNYW5hZ2VyJztcbmltcG9ydCB7TWFuYWdlckVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8qKlxuICogQGNsYXNzIENvbXBvbmVudFxuICogQGNhdGVnb3J5IGNvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5zdHJ1Y3Rpb25zXSAtIFRoZSBpbnN0cnVjdGlvbnMgb2JqZWN0LlxuICogQGV4dGVuZHMgTW9kdWxlU3lzdGVtXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmVcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgTW9kdWxlU3lzdGVtIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvcmUuQ29tcG9uZW50I2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQge1xuICAgKiAgIG1vZHVsZXM6IFtdLFxuICAgKiAgIG1hbmFnZXI6IHRydWVcbiAgICogfVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIG1vZHVsZXM6IG51bGwsXG4gICAgbWFuYWdlcjogdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgaW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvcmUuQ29tcG9uZW50I2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge307XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIHByb21pc2VzIHRoYXQgc2hvdWxkIGJlIHJlc29sdmVkIGJlZm9yZSBDb21wb25lbnQgaXMgcmVhZHkuXG4gICAqIEBtZW1iZXIge0FycmF5fSBtb2R1bGU6Y29yZS5Db21wb25lbnQjX3dhaXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93YWl0ID0gW107IC8vIENvbGxlY3Rpb24gb2YgcHJvbWlzZXM7XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgYG1vZHVsZXNgLlxuICAgKiBAbWVtYmVyIHtBcnJheX0gbW9kdWxlOmNvcmUuQ29tcG9uZW50I21vZHVsZXNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbW9kdWxlcyA9IFtdOyAvLyBDb2xsZWN0aW9uIG9mIG1vZHVsZXM7XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgYGNoaWxkYCBDb21wb25lbnRzLlxuICAgKiBAbWVtYmVyIHtBcnJheX0gbW9kdWxlOmNvcmUuQ29tcG9uZW50I2NoaWxkcmVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNoaWxkcmVuID0gW107IC8vIEZvciBrZWVwaW5nIGNoaWxkcmVuIGNvbXBvbmVudHM7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30sIGRlZmF1bHRzID0gQ29tcG9uZW50LmRlZmF1bHRzLCBpbnN0cnVjdGlvbnMgPSBDb21wb25lbnQuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vIEFwcGx5IHBvbHlmaWxsZWQgcGFyYW1ldGVycyB0byAucGFyYW1zO1xuICAgIHRoaXMucGFyYW1zID0gZXh0ZW5kKHRyYW5zZm9ybURhdGEocGFyYW1zLCBpbnN0cnVjdGlvbnMpLCBkZWZhdWx0cyk7XG4gICAgaWYgKHRoaXMucGFyYW1zLm1hbmFnZXIpIHRoaXMubWFuYWdlciA9IG5ldyBNb2R1bGVNYW5hZ2VyKHRoaXMpO1xuXG4gICAgdGhpcy5tb2R1bGVzID0gdGhpcy5wYXJhbXMubW9kdWxlcztcblxuICAgIHRoaXMuaW50ZWdyYXRlTW9kdWxlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgd2FpdFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFdhaXQgZm9yIGEgcHJvbWlzZS5cbiAgICogQHBhcmFtIHtQcm9taXNlfSBbcHJvbWlzZV0gLSBUaGUgcHJvbWlzZSB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byBhIHF1ZXVlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBhbGwgcHJvbWlzZXMgY29tcGxldGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ29tcG9uZW50XG4gICAqL1xuICB3YWl0KHByb21pc2UpIHtcbiAgICBpZiAocHJvbWlzZSkgdGhpcy5fd2FpdC5wdXNoKHByb21pc2UpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLl93YWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRlZmVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gRXhlY3V0ZSBgZnVuY2AgKENhbGxiYWNrKSB3aGVuIENvbXBvbmVudCBpcyByZWFkeS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIENhbGxiYWNrLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ29tcG9uZW50XG4gICAqL1xuICBkZWZlcihmdW5jKSB7XG4gICAgaWYgKHRoaXMuaXNEZWZmZXJlZCkgdGhpcy53YWl0KCkudGhlbigoKSA9PiBmdW5jKHRoaXMpKTtcbiAgICBlbHNlIGZ1bmModGhpcyk7XG4gIH1cblxuICAvLyBQQVJBTUVURVJTXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdXBkYXRlUGFyYW1zXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gVXBkYXRlcyBwYXJhbWV0ZXJzIG9mIHRoZSBDb21wb25lbnQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUGFyYW1zIG9mIHRoaXMgQ29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAgICovXG4gIHVwZGF0ZVBhcmFtcyhwYXJhbXMgPSB7fSkge1xuICAgIHRoaXMucGFyYW1zID0gZXh0ZW5kKHBhcmFtcywgdGhpcy5wYXJhbXMpO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8vIENPUFlJTkcgJiBDTE9OSU5HXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY2xvbmVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBDbG9uZSB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGEgY2xvbmVkIGNvbXBvbmVudCB3aXRoIGFsbCBpdHMgc291cmNlIGNvbXBvbmVudCcgcGFyYW1zIGNvcGllZC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkNvbXBvbmVudFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucGFyYW1zKS5jb3B5KHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIENvcHkgc291cmNlIG5hdGl2ZSBhbmQgaW50ZWdyYXRlIGBtb2R1bGVzYCB0byBpdC5cbiAgICogQHBhcmFtIHtDb21wb25lbnR9IHNvdXJjZSAtIFNvdXJjZSBjb21wb25lbnQgdGhhdCBpcyB1c2VkIGZvciBgY29weSgpYCBhY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVdIC0gQ2FsbGJhY2sgZXhlY3V0ZWQgYmVmb3JlIG1vZHVsZXMgaW50ZWdyYXRpb24gcHJvY2Vzcy5cbiAgICogQHJldHVybiB7dGhpc30gQ29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAgICovXG4gIGNvcHkoc291cmNlLCBjdXN0b21pemUpIHtcbiAgICB0aGlzLnBhcmFtcyA9IHsuLi5zb3VyY2UucGFyYW1zfTtcblxuICAgIGlmIChzb3VyY2UubmF0aXZlKSB0aGlzLm5hdGl2ZSA9IHNvdXJjZS5uYXRpdmUuY2xvbmUoc291cmNlLnBhcmFtcyk7XG4gICAgaWYgKGN1c3RvbWl6ZSkgY3VzdG9taXplKCk7XG4gICAgdGhpcy5pbnRlZ3JhdGVNb2R1bGVzKHNvdXJjZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIEFkZCBhIGNoaWxkIGBDb21wb25lbnRgLlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb2JqZWN0IC0gQ29tcG9uZW50IHRoYXQgc2hvdWxkIGJlIGFkZGVkIGFzIGEgYGNoaWxkYC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBhY3Rpb24gaXMgZG9uZS5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkNvbXBvbmVudFxuICAgKi9cbiAgYWRkKG9iamVjdCkge1xuICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZGVmZXIoKCkgPT4ge1xuICAgICAgICBjb25zdCB7bmF0aXZlfSA9IG9iamVjdDtcbiAgICAgICAgaWYgKCFuYXRpdmUpIHJlamVjdCgpO1xuXG4gICAgICAgIGNvbnN0IGFkZFByb21pc2UgPSB0aGlzLmFwcGx5QnJpZGdlKHtvbkFkZDogb2JqZWN0fSkub25BZGQ7XG5cbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5uYXRpdmUuYWRkKG5hdGl2ZSk7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG9iamVjdCk7XG5cbiAgICAgICAgICByZXNvbHZlKG9iamVjdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFkZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSBhZGRQcm9taXNlLnRoZW4ocmVzb2x2ZXIpO1xuICAgICAgICBlbHNlIHJlc29sdmVyKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZSBhIGNoaWxkIGBDb21wb25lbnRgLlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb2JqZWN0IC0gQ29tcG9uZW50IHRoYXQgc2hvdWxkIGJlIGEgKipjaGlsZCoqIG9mIHRoaXMgQ29tcG9uZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ29tcG9uZW50XG4gICAqL1xuICByZW1vdmUob2JqZWN0KSB7XG4gICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmUucmVtb3ZlKG9iamVjdC5uYXRpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkVG9cbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGB0aGlzYCBDb21wb25lbnQgdG8gc3BlY2lmaWVkIGBBcHBgL2BDb21wb25lbnRgLlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb2JqZWN0IC0gQ29tcG9uZW50IHRoYXQgd2lsbCBiZSBhIHBhcmVudCBvZiBgdGhpc2AuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAgICovXG4gIGFkZFRvKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QuYWRkKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2JqZWN0IGlzIGBhc3luY2AgKGB3YWl0YCBwcm9taXNlcyBhcmUgbW9yZSB0aGFuIGAwYCkuXG4gICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vZHVsZTpjb3JlLkNvbXBvbmVudCNpc0RlZmZlcmVkXG4gICAqL1xuICBnZXQgaXNEZWZmZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2FpdC5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBNb2R1bGVNYW5hZ2VyYCB1c2VkIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICogQG1lbWJlciB7TW9kdWxlTWFuYWdlcn0gbW9kdWxlOmNvcmUuQ29tcG9uZW50I21hbmFnZXJcbiAgICogQHRocm93cyB7TWFuYWdlckVycm9yfVxuICAgKi9cbiAgZ2V0IG1hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIpIHJldHVybiB0aGlzLl9tYW5hZ2VyO1xuXG4gICAgdGhyb3cgbmV3IE1hbmFnZXJFcnJvcihcbiAgICAgICdDb21wb25lbnQnLFxuICAgICAgYE1vZHVsZU1hbmFnZXIgaXMgbm90IHVzZWQgaW4gdGhpcyBjb21wb25lbnQuICdtYW5hZ2VyJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNldCBhcyAndHJ1ZSdgLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cblxuICBzZXQgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYG5hdGl2ZWAgb2JqZWN0IHVzZWQgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb3JlLkNvbXBvbmVudCNuYXRpdmVcbiAgICovXG4gIGdldCBuYXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hdGl2ZTtcbiAgfVxuXG4gIHNldCBuYXRpdmUobWVzaCkge1xuICAgIHRoaXMuX25hdGl2ZSA9IG1lc2g7XG4gICAgdGhpcy5fbmF0aXZlLmNvbXBvbmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuX25hdGl2ZTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBDb21wb25lbnRcbn07XG4iLCJleHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlcyguLi5tYXBwZXJzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXBwZXIgPSBtYXBwZXJzW2ldO1xuXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IG1hcHBlci5tYXAubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbWFwcGVyLm1hcFtrXTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LnByb3RvdHlwZSwgYXR0cmlidXRlLCB7XG4gICAgICAgICAgZ2V0OiBtYXBwZXIuZ2V0dGVyKGF0dHJpYnV0ZSksXG4gICAgICAgICAgc2V0OiBtYXBwZXIuc2V0dGVyKGF0dHJpYnV0ZSksXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBtYXBwZXIuY29uZmlndXJhYmxlLFxuICAgICAgICAgIGVudW1lcmFibGU6IG1hcHBlci5lbnVtZXJhYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoLi4ubWFwKSB7XG4gIHJldHVybiB7XG4gICAgbWFwLFxuICAgIGdldHRlcihuYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVbbmFtZV07XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0dGVyKG5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVbbmFtZV0uY29weSh2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pcnJvciguLi5tYXApIHtcbiAgcmV0dXJuIHtcbiAgICBtYXAsXG4gICAgZ2V0dGVyKG5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVtuYW1lXTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXR0ZXIobmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm5hdGl2ZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG59XG4iLCJpbXBvcnQge01lc2h9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICcuL0NvbXBvbmVudCc7XG5cbmltcG9ydCB7YXR0cmlidXRlcywgY29weSwgbWlycm9yfSBmcm9tICcuL3Byb3RvdHlwZS9hdHRyaWJ1dGVzJztcbmltcG9ydCB7Q29tcG9zaXRpb25FcnJvcn0gZnJvbSAnLi9lcnJvcnMnO1xuXG5AYXR0cmlidXRlcyhcbiAgY29weSgncG9zaXRpb24nLCAncm90YXRpb24nLCAncXVhdGVybmlvbicsICdzY2FsZScpLFxuICBtaXJyb3IoJ21hdGVyaWFsJywgJ2dlb21ldHJ5Jylcbilcbi8qKlxuICogQGNsYXNzIE1lc2hDb21wb25lbnRcbiAqIEBjYXRlZ29yeSBjb3JlXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1ldGVycyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW2luc3RydWN0aW9uc10gLSBUaGUgaW5zdHJ1Y3Rpb25zIG9iamVjdC5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLkNvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlXG4gKi9cbmNsYXNzIE1lc2hDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50I2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHRcbiAgICoge1xuICAgKiAgIGJ1aWxkOiB0cnVlLFxuICAgKiAgIGdlb21ldHJ5OiB7fSxcbiAgICogICBtYXRlcmlhbDogZmFsc2UsXG4gICAqXG4gICAqICAgc2hhZG93OiB7XG4gICAqICAgICBjYXN0OiB0cnVlLFxuICAgKiAgICAgcmVjZWl2ZTogdHJ1ZVxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgcG9zaXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfSxcbiAgICogICByb3RhdGlvbjoge3g6IDAsIHk6IDAsIHo6IDB9LFxuICAgKiAgIHNjYWxlOiB7eDogMSwgeTogMSwgejogMX1cbiAgICogfVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLkNvbXBvbmVudC5kZWZhdWx0cyxcblxuICAgIGJ1aWxkOiB0cnVlLFxuICAgIGdlb21ldHJ5OiB7fSxcbiAgICBtYXRlcmlhbDogZmFsc2UsXG5cbiAgICBzaGFkb3c6IHtcbiAgICAgIGNhc3Q6IHRydWUsXG4gICAgICByZWNlaXZlOiB0cnVlXG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiB7eDogMCwgeTogMCwgejogMH0sXG4gICAgcm90YXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfSxcbiAgICBzY2FsZToge3g6IDEsIHk6IDEsIHo6IDF9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBpbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50I2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0XG4gICAqIHtcbiAgICogICBwb3NpdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgKiAgIHJvdGF0aW9uOiBbJ3gnLCAneScsICd6J10sXG4gICAqICAgc2NhbGU6IFsneCcsICd5JywgJ3onXVxuICAgKiB9XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIHBvc2l0aW9uOiBbJ3gnLCAneScsICd6J10sXG4gICAgcm90YXRpb246IFsneCcsICd5JywgJ3onXSxcbiAgICBzY2FsZTogWyd4JywgJ3knLCAneiddXG4gIH07XG5cbiAgLy8gQ1VTVE9NIEdFT01FVFJZIEhBTkRMSU5HXG5cbiAgc3RhdGljIGN1c3RvbShnZW9tLCBjb25zdHJ1Y3RvciA9IE1lc2gpIHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgICAgIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICAgICAgZ2VvbWV0cnk6IGdlb20sXG4gICAgICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGdlb20sIHBhcmFtcywgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IChNZXNoQ29tcG9uZW50LmN1c3RvbShnZW9tLCBjb25zdHJ1Y3RvcikpKHBhcmFtcyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbShtZXNoLCBwYXJhbXMgPSB7fSkge1xuICAgIHBhcmFtcy5idWlsZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gbmV3IE1lc2hDb21wb25lbnQocGFyYW1zKTtcblxuICAgIGNvbXBvbmVudC5uYXRpdmUgPSBtZXNoO1xuICAgIGNvbXBvbmVudC53cmFwKCk7XG5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgY29uc3RydWN0b3IocGFyYW1zLCBkZWZhdWx0cyA9IE1lc2hDb21wb25lbnQuZGVmYXVsdHMsIGluc3RydWN0aW9ucyA9IE1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgc3VwZXIocGFyYW1zLCBkZWZhdWx0cywgaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmICh0aGlzLnBhcmFtcy5idWlsZCkge1xuICAgICAgY29uc3QgYnVpbGQgPSB0aGlzLmJ1aWxkKHRoaXMucGFyYW1zKTtcblxuICAgICAgaWYgKCFidWlsZCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29tcG9zaXRpb25FcnJvcihcbiAgICAgICAgICAnTWVzaENvbXBvbmVudCcsXG4gICAgICAgICAgJy5idWlsZCgpIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgVEhSRUUuT2JqZWN0M0Qgb3IgYSBQcm9taXNlIHJlc29sdmVkIHdpdGggVEhSRUUuT2JqZWN0M0QuJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChidWlsZCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy53YWl0KGJ1aWxkKTtcblxuICAgICAgICB0aGlzLndhaXQobmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgYnVpbGQudGhlbihuYXRpdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmUgPSBuYXRpdmU7XG4gICAgICAgICAgICB0aGlzLndyYXAoKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5hdGl2ZSA9IGJ1aWxkO1xuICAgICAgICB0aGlzLndhaXQodGhpcy53cmFwKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXBwbHlDb21tYW5kKCdwb3N0SW50ZWdyYXRlJyk7XG4gIH1cblxuICAvLyBCVUlMRElORyAmIFdSQVBQSU5HXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpdmVjeWNsZSBzaG91bGQgcmV0dXJuIGEgbmF0aXZlIG9iamVjdC5cbiAgICogQHRocm93cyB7Q29tcG9zaXRpb25FcnJvcn1cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAgICovXG4gIGJ1aWxkKCkge1xuICAgIHRocm93IG5ldyBDb21wb3NpdGlvbkVycm9yKFxuICAgICAgJ01lc2hDb21wb25lbnQnLFxuICAgICAgJ0luc3RhbmNlIHNob3VsZCBoYXZlIGl0XFwncyBvd24gLmJ1aWxkKCkuJyxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgd3JhcFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFdyYXBzIHRyYW5zZm9ybXMgKGBwb3NpdGlvbmAgJiBgcm90YXRpb25gKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGFjdGlvbiBpcyBjb21wbGV0ZWRcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAgICovXG4gIHdyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgLy8gVE9ETzogRml4IGRlZmVyIHdpdGggcGh5c2ljc1xuICAgICAgLy8gdGhpcy5kZWZlcigoKSA9PiB7XG4gICAgICBjb25zdCB7cG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZSwgc2hhZG93fSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICB0aGlzLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcbiAgICAgIHRoaXMucm90YXRpb24uc2V0KHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnopO1xuICAgICAgdGhpcy5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueik7XG5cbiAgICAgIHRoaXMubmF0aXZlLmNhc3RTaGFkb3cgPSBzaGFkb3cuY2FzdDtcbiAgICAgIHRoaXMubmF0aXZlLnJlY2VpdmVTaGFkb3cgPSBzaGFkb3cucmVjZWl2ZTtcblxuICAgICAgdGhpcy5hcHBseUJyaWRnZSh7b25XcmFwOiAxfSk7XG5cbiAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAvLyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENPUFlJTkcgJiBDTE9OSU5HXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIENvcHkgc291cmNlIHRyYW5zZm9ybXMgJiBleGVjdXRlIGBDb21wb25lbnQuY29weSgpYFxuICAgKiBAcmV0dXJuIHt0aGlzfSBNZXNoQ29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gICAqL1xuICBjb3B5KHNvdXJjZSkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KHNvdXJjZSwgKCkgPT4ge1xuICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHNvdXJjZS5wb3NpdGlvbik7XG4gICAgICB0aGlzLnJvdGF0aW9uLmNvcHkoc291cmNlLnJvdGF0aW9uKTtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KHNvdXJjZS5xdWF0ZXJuaW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gTWFrZSBhIGNsb25lIG9mIHRoaXMgTWVzaENvbXBvbmVudCB1c2luZyBgLmNvcHkoKWBcbiAgICogQHJldHVybiB7TWVzaENvbXBvbmVudH0gY2xvbmUgb2YgdGhpcyBvYmplY3RcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAgICovXG4gIGNsb25lKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuICAgIGNvbnN0IGRlc3QgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7YnVpbGQ6IGZhbHNlfSkuY29weSh0aGlzKTtcblxuICAgIGlmIChnZW9tZXRyeSkgZGVzdC5nZW9tZXRyeSA9IGRlc3QuZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICBpZiAobWF0ZXJpYWwpIGRlc3QubWF0ZXJpYWwgPSBkZXN0Lm1hdGVyaWFsLmNsb25lKCk7XG5cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxufVxuXG5leHBvcnQge1xuICBNZXNoQ29tcG9uZW50XG59O1xuIiwiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJy4vQ29tcG9uZW50JztcblxuaW1wb3J0IHthdHRyaWJ1dGVzLCBjb3B5fSBmcm9tICcuL3Byb3RvdHlwZS9hdHRyaWJ1dGVzJztcbmltcG9ydCB7Q29tcG9zaXRpb25FcnJvcn0gZnJvbSAnLi9lcnJvcnMnO1xuXG5AYXR0cmlidXRlcyhcbiAgY29weSgncG9zaXRpb24nLCAncm90YXRpb24nLCAncXVhdGVybmlvbicsICd0YXJnZXQnKVxuKVxuLyoqXG4gKiBAY2xhc3MgTGlnaHRDb21wb25lbnRcbiAqIEBjYXRlZ29yeSBjb3JlXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1ldGVycyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW2luc3RydWN0aW9uc10gLSBUaGUgaW5zdHJ1Y3Rpb25zIG9iamVjdC5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLkNvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlXG4gKi9cbmNsYXNzIExpZ2h0Q29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvcmUuTGlnaHRDb21wb25lbnQjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdFxuICAgKiB7XG4gICAqICAgYnVpbGQ6IHRydWUsXG4gICAqXG4gICAqICAgc2hhZG93OiB7XG4gICAqICAgICBjYXN0OiB0cnVlLFxuICAgKlxuICAgKiAgICAgYmlhczogMCxcbiAgICogICAgIHJhZGl1czogMSxcbiAgICpcbiAgICogICAgIG1hcFNpemU6IHtcbiAgICogICAgICAgd2lkdGg6IDEwMjQsXG4gICAqICAgICAgIGhlaWdodDogMTAyNFxuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIGNhbWVyYToge1xuICAgKiAgICAgICBuZWFyOiB0cnVlLFxuICAgKiAgICAgICBmYXI6IDQwMCxcbiAgICogICAgICAgZm92OiA5MCxcbiAgICpcbiAgICogICAgICAgdG9wOiAyMDAsXG4gICAqICAgICAgIGJvdHRvbTogLTIwMCxcbiAgICogICAgICAgbGVmdDogLTIwMCxcbiAgICogICAgICAgcmlnaHQ6IDIwMFxuICAgKiAgICAgfVxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgcG9zaXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfSxcbiAgICogICByb3RhdGlvbjoge3g6IDAsIHk6IDAsIHo6IDB9XG4gICAqIH1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5Db21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBidWlsZDogdHJ1ZSxcblxuICAgIHNoYWRvdzoge1xuICAgICAgY2FzdDogdHJ1ZSxcblxuICAgICAgYmlhczogMCxcbiAgICAgIHJhZGl1czogMSxcblxuICAgICAgbWFwU2l6ZToge1xuICAgICAgICB3aWR0aDogMTAyNCxcbiAgICAgICAgaGVpZ2h0OiAxMDI0XG4gICAgICB9LFxuXG4gICAgICBjYW1lcmE6IHtcbiAgICAgICAgbmVhcjogdHJ1ZSxcbiAgICAgICAgZmFyOiA0MDAsXG4gICAgICAgIGZvdjogOTAsXG5cbiAgICAgICAgdG9wOiAyMDAsXG4gICAgICAgIGJvdHRvbTogLTIwMCxcbiAgICAgICAgbGVmdDogLTIwMCxcbiAgICAgICAgcmlnaHQ6IDIwMFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwb3NpdGlvbjoge3g6IDAsIHk6IDAsIHo6IDB9LFxuICAgIHJvdGF0aW9uOiB7eDogMCwgeTogMCwgejogMH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhdGljIGluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50I2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0XG4gICAqIHtcbiAgICogICBwb3NpdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgKiAgIHJvdGF0aW9uOiBbJ3gnLCAneScsICd6J11cbiAgICogfVxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICBwb3NpdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgIHJvdGF0aW9uOiBbJ3gnLCAneScsICd6J11cbiAgfTtcblxuICBzdGF0aWMgZnJvbShsaWdodCwgcGFyYW1zID0ge30sIHdyYXBTaGFkb3cgPSB0cnVlKSB7XG4gICAgcGFyYW1zLmJ1aWxkID0gZmFsc2U7XG5cbiAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgTGlnaHRDb21wb25lbnQocGFyYW1zKTtcblxuICAgIGNvbXBvbmVudC5uYXRpdmUgPSBsaWdodDtcbiAgICBjb21wb25lbnQud3JhcCgpO1xuICAgIGlmICh3cmFwU2hhZG93KSBjb21wb25lbnQud3JhcFNoYWRvdygpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgZGVmYXVsdHMgPSBMaWdodENvbXBvbmVudC5kZWZhdWx0cywgaW5zdHJ1Y3Rpb25zID0gTGlnaHRDb21wb25lbnQuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgc3VwZXIocGFyYW1zLCBkZWZhdWx0cywgaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmICh0aGlzLnBhcmFtcy5idWlsZCkge1xuICAgICAgY29uc3QgYnVpbGQgPSB0aGlzLmJ1aWxkKHRoaXMucGFyYW1zKTtcblxuICAgICAgaWYgKCFidWlsZCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29tcG9zaXRpb25FcnJvcihcbiAgICAgICAgICAnTGlnaHRDb21wb25lbnQnLFxuICAgICAgICAgICcuYnVpbGQoKSBtZXRob2Qgc2hvdWxkIHJldHVybiBhIFRIUkVFLk9iamVjdDNEIG9yIGEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIFRIUkVFLk9iamVjdDNELicsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVpbGQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGJ1aWxkLnRoZW4obmF0aXZlID0+IHtcbiAgICAgICAgICB0aGlzLm5hdGl2ZSA9IG5hdGl2ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgdGhpcy5uYXRpdmUgPSBidWlsZDtcblxuICAgICAgdGhpcy53YWl0KHRoaXMud3JhcCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGx5Q29tbWFuZCgncG9zdEludGVncmF0ZScpO1xuICB9XG5cbiAgLy8gQlVJTERJTkcgJiBXUkFQUElOR1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGl2ZWN5Y2xlIHNob3VsZCByZXR1cm4gYSBuYXRpdmUgb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtDb21wb3NpdGlvbkVycm9yfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTGlnaHRDb21wb25lbnRcbiAgICovXG4gIGJ1aWxkKCkge1xuICAgIHRocm93IG5ldyBDb21wb3NpdGlvbkVycm9yKFxuICAgICAgJ01lc2hDb21wb25lbnQnLFxuICAgICAgJ0luc3RhbmNlIHNob3VsZCBoYXZlIGl0XFwncyBvd24gLmJ1aWxkKCkuJyxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgd3JhcFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFdyYXBzIHRyYW5zZm9ybXMgKGBwb3NpdGlvbmAgJiBgcm90YXRpb25gKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGFjdGlvbiBpcyBjb21wbGV0ZWRcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50XG4gICAqL1xuICB3cmFwKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuZGVmZXIoKCkgPT4ge1xuICAgICAgICBjb25zdCB7cG9zaXRpb24sIHJvdGF0aW9ufSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuICAgICAgICB0aGlzLnJvdGF0aW9uLnNldChyb3RhdGlvbi54LCByb3RhdGlvbi55LCByb3RhdGlvbi56KTtcblxuICAgICAgICB0aGlzLmFwcGx5QnJpZGdlKHtvbldyYXA6IDF9KTtcblxuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB3cmFwU2hhZG93XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gV3JhcHMgc2hhZG93IHByb3BlcnRpZXNcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50XG4gICAqL1xuICB3cmFwU2hhZG93KCkge1xuICAgIGNvbnN0IHtuYXRpdmUsIHBhcmFtczoge3NoYWRvd319ID0gdGhpcztcblxuICAgIG5hdGl2ZS5jYXN0U2hhZG93ID0gc2hhZG93LmNhc3Q7XG4gICAgbmF0aXZlLnNoYWRvdy5tYXBTaXplLndpZHRoID0gc2hhZG93Lm1hcFNpemUud2lkdGg7XG4gICAgbmF0aXZlLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IHNoYWRvdy5tYXBTaXplLmhlaWdodDtcbiAgICBuYXRpdmUuc2hhZG93LmJpYXMgPSBzaGFkb3cuYmlhcztcbiAgICBuYXRpdmUuc2hhZG93LnJhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XG5cbiAgICBjb25zdCBzaGFkb3dDYW1lcmEgPSBuYXRpdmUuc2hhZG93LmNhbWVyYTtcbiAgICBjb25zdCBjYW1lcmEgPSBzaGFkb3cuY2FtZXJhO1xuXG4gICAgc2hhZG93Q2FtZXJhLm5lYXIgPSBjYW1lcmEubmVhcjtcbiAgICBzaGFkb3dDYW1lcmEuZmFyID0gY2FtZXJhLmZhcjtcbiAgICBzaGFkb3dDYW1lcmEuZm92ID0gY2FtZXJhLmZvdjtcblxuICAgIHNoYWRvd0NhbWVyYS5sZWZ0ID0gY2FtZXJhLmxlZnQ7XG4gICAgc2hhZG93Q2FtZXJhLnJpZ2h0ID0gY2FtZXJhLnJpZ2h0O1xuICAgIHNoYWRvd0NhbWVyYS50b3AgPSBjYW1lcmEudG9wO1xuICAgIHNoYWRvd0NhbWVyYS5ib3R0b20gPSBjYW1lcmEuYm90dG9tO1xuICB9XG5cbiAgLy8gQ09QWUlORyAmIENMT05JTkdcblxuICAvKipcbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQ29weSBzb3VyY2UgdHJhbnNmb3JtcyAmIGV4ZWN1dGUgYENvbXBvbmVudC5jb3B5KClgXG4gICAqIEByZXR1cm4ge3RoaXN9IExpZ2h0Q29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5MaWdodENvbXBvbmVudFxuICAgKi9cbiAgY29weShzb3VyY2UpIHtcbiAgICByZXR1cm4gc3VwZXIuY29weShzb3VyY2UsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRhcmdldCkgdGhpcy50YXJnZXQuY29weShzb3VyY2UudGFyZ2V0KCkpO1xuXG4gICAgICB0aGlzLnBvc2l0aW9uLmNvcHkoc291cmNlLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMucm90YXRpb24uY29weShzb3VyY2Uucm90YXRpb24pO1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoc291cmNlLnF1YXRlcm5pb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY2xvbmVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBNYWtlIGEgY2xvbmUgb2YgdGhpcyBMaWdodENvbXBvbmVudCB1c2luZyBgLmNvcHkoKWBcbiAgICogQHJldHVybiB7TGlnaHRDb21wb25lbnR9IGNsb25lIG9mIHRoaXMgb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5MaWdodENvbXBvbmVudFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtidWlsZDogZmFsc2V9KS5jb3B5KHRoaXMpO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIExpZ2h0Q29tcG9uZW50XG59O1xuIiwiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJy4vQ29tcG9uZW50JztcblxuaW1wb3J0IHthdHRyaWJ1dGVzLCBjb3B5fSBmcm9tICcuL3Byb3RvdHlwZS9hdHRyaWJ1dGVzJztcbmltcG9ydCB7Q29tcG9zaXRpb25FcnJvcn0gZnJvbSAnLi9lcnJvcnMnO1xuXG5AYXR0cmlidXRlcyhcbiAgY29weSgncG9zaXRpb24nLCAncm90YXRpb24nLCAncXVhdGVybmlvbicsICd0YXJnZXQnKVxuKVxuLyoqXG4gKiBAY2xhc3MgQ2FtZXJhQ29tcG9uZW50XG4gKiBAY2F0ZWdvcnkgY29yZVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtpbnN0cnVjdGlvbnNdIC0gVGhlIGluc3RydWN0aW9ucyBvYmplY3QuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZVxuICovXG5jbGFzcyBDYW1lcmFDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29yZS5DYW1lcmFDb21wb25lbnQjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdFxuICAgKiB7XG4gICAqICAgYnVpbGQ6IHRydWUsXG4gICAqXG4gICAqICAgcG9zaXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfSxcbiAgICogICByb3RhdGlvbjoge3g6IDAsIHk6IDAsIHo6IDB9XG4gICAqIH1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5Db21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBidWlsZDogdHJ1ZSxcblxuICAgIHBvc2l0aW9uOiB7eDogMCwgeTogMCwgejogMH0sXG4gICAgcm90YXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgaW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvcmUuQ2FtZXJhQ29tcG9uZW50I2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0XG4gICAqIHtcbiAgICogICBwb3NpdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgKiAgIHJvdGF0aW9uOiBbJ3gnLCAneScsICd6J10sXG4gICAqICAgc2NhbGU6IFsneCcsICd5JywgJ3onXVxuICAgKiB9XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIHBvc2l0aW9uOiBbJ3gnLCAneScsICd6J10sXG4gICAgcm90YXRpb246IFsneCcsICd5JywgJ3onXSxcbiAgICBzY2FsZTogWyd4JywgJ3knLCAneiddXG4gIH07XG5cbiAgc3RhdGljIGZyb20oY2FtZXJhLCBwYXJhbXMgPSB7fSkge1xuICAgIHBhcmFtcy5idWlsZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gbmV3IENhbWVyYUNvbXBvbmVudChwYXJhbXMpO1xuXG4gICAgY29tcG9uZW50Lm5hdGl2ZSA9IGNhbWVyYTtcbiAgICBjb21wb25lbnQud3JhcCgpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgZGVmYXVsdHMgPSBDYW1lcmFDb21wb25lbnQuZGVmYXVsdHMsIGluc3RydWN0aW9ucyA9IENhbWVyYUNvbXBvbmVudC5pbnN0cnVjdGlvbnMpIHtcbiAgICBzdXBlcihwYXJhbXMsIGRlZmF1bHRzLCBpbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMucGFyYW1zLmJ1aWxkKSB7XG4gICAgICBjb25zdCBidWlsZCA9IHRoaXMuYnVpbGQodGhpcy5wYXJhbXMpO1xuXG4gICAgICBpZiAoIWJ1aWxkKSB7XG4gICAgICAgIHRocm93IG5ldyBDb21wb3NpdGlvbkVycm9yKFxuICAgICAgICAgICdDYW1lcmFDb21wb25lbnQnLFxuICAgICAgICAgICcuYnVpbGQoKSBtZXRob2Qgc2hvdWxkIHJldHVybiBhIFRIUkVFLk9iamVjdDNEIG9yIGEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIFRIUkVFLk9iamVjdDNELicsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVpbGQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGJ1aWxkLnRoZW4obmF0aXZlID0+IHtcbiAgICAgICAgICB0aGlzLm5hdGl2ZSA9IG5hdGl2ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgdGhpcy5uYXRpdmUgPSBidWlsZDtcblxuICAgICAgdGhpcy53YWl0KHRoaXMud3JhcCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGx5Q29tbWFuZCgncG9zdEludGVncmF0ZScpO1xuICB9XG5cbiAgLy8gQlVJTERJTkcgJiBXUkFQUElOR1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGl2ZWN5Y2xlIHNob3VsZCByZXR1cm4gYSBuYXRpdmUgb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtDb21wb3NpdGlvbkVycm9yfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ2FtZXJhQ29tcG9uZW50XG4gICAqL1xuICBidWlsZCgpIHtcbiAgICB0aHJvdyBuZXcgQ29tcG9zaXRpb25FcnJvcihcbiAgICAgICdDYW1lcmFDb21wb25lbnQnLFxuICAgICAgJ0luc3RhbmNlIHNob3VsZCBoYXZlIGl0XFwncyBvd24gLmJ1aWxkKCkuJyxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgd3JhcFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFdyYXBzIHRyYW5zZm9ybXMgKGBwb3NpdGlvbmAgJiBgcm90YXRpb25gKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGFjdGlvbiBpcyBjb21wbGV0ZWRcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkNhbWVyYUNvbXBvbmVudFxuICAgKi9cbiAgd3JhcCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLmRlZmVyKCgpID0+IHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5zZXQodGhpcy5wYXJhbXMucG9zaXRpb24ueCwgdGhpcy5wYXJhbXMucG9zaXRpb24ueSwgdGhpcy5wYXJhbXMucG9zaXRpb24ueik7XG4gICAgICAgIHRoaXMucm90YXRpb24uc2V0KHRoaXMucGFyYW1zLnJvdGF0aW9uLngsIHRoaXMucGFyYW1zLnJvdGF0aW9uLnksIHRoaXMucGFyYW1zLnJvdGF0aW9uLnopO1xuXG4gICAgICAgIHRoaXMuYXBwbHlCcmlkZ2Uoe29uV3JhcDogMX0pO1xuXG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBDb3B5IHNvdXJjZSB0cmFuc2Zvcm1zICYgZXhlY3V0ZSBgQ29tcG9uZW50LmNvcHkoKWBcbiAgICogQHJldHVybiB7dGhpc30gQ2FtZXJhQ29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5DYW1lcmFDb21wb25lbnRcbiAgICovXG4gIGNvcHkoc291cmNlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoc291cmNlLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy50YXJnZXQpIHRoaXMudGFyZ2V0LmNvcHkoc291cmNlLnRhcmdldCgpKTtcblxuICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHNvdXJjZS5wb3NpdGlvbik7XG4gICAgICB0aGlzLnJvdGF0aW9uLmNvcHkoc291cmNlLnJvdGF0aW9uKTtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KHNvdXJjZS5xdWF0ZXJuaW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gTWFrZSBhIGNsb25lIG9mIHRoaXMgQ2FtZXJhQ29tcG9uZW50IHVzaW5nIGAuY29weSgpYFxuICAgKiBAcmV0dXJuIHtDYW1lcmFDb21wb25lbnR9IGNsb25lIG9mIHRoaXMgb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5DYW1lcmFDb21wb25lbnRcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7YnVpbGQ6IGZhbHNlfSkuY29weSh0aGlzKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBDYW1lcmFDb21wb25lbnRcbn07XG4iLCJleHBvcnQgY29uc3Qgc3lzdGVtID0ge1xuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG59O1xuIiwiaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHtzeXN0ZW19IGZyb20gJy4uL3BvbHlmaWxsJztcbmltcG9ydCB7TW9kdWxlU3lzdGVtfSBmcm9tICcuL01vZHVsZVN5c3RlbSc7XG5pbXBvcnQge01vZHVsZU1hbmFnZXJ9IGZyb20gJy4vTW9kdWxlTWFuYWdlcic7XG5cbi8qKlxuICogQGNsYXNzIEFwcFxuICogQGNhdGVnb3J5IGNvcmVcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHByZXBhcmUgYSB3b3JsZCBzY2VuZSwgc2V0dXAgcGh5c2ljcywgY2FtZXJhLCByZW5kZXJlciBhbmQgYWxsIG90aGVyIHRoaW5ncyB0aGF0IHlvdSB1c3VhbGx5IGRvIGJlZm9yZSBtYWtpbmcgbWVzaGVzLlxuICogQHBhcmFtIHtBcnJheX0gW21vZHVsZXM9W11dIC0gQXJyYXkgb2YgTW9kdWxlc1xuICogQGV4dGVuZHMgTW9kdWxlU3lzdGVtXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmVcbiAqL1xuY2xhc3MgQXBwIGV4dGVuZHMgTW9kdWxlU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBEZWZpbmVzIHdoZXRoZXIgdGhlIHNjZW5lIHNob3VsZCByZW5kZXIgb3Igbm90XG4gICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vZHVsZTpjb3JlLkFwcCNlbmFibGVkXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBMb29wcyBpbiB0aGlzIGFwcFxuICAgKiBAZGVzY3JpcHRpb24gQXJyYXkgb2YgbG9vcHMgdGhhdCBhcmUgZXhlY3V0ZWQgYnkgdGhpcyBhcHAuXG4gICAqIEBtZW1iZXIge0FycmF5fSBtb2R1bGU6Y29yZS5BcHAjbG9vcHNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbG9vcHMgPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihtb2R1bGVzID0gW10pIHtcbiAgICBjb25zb2xlLmxvZyhgV0hTLkFwcCAke3ZlcnNpb259YCk7XG5cbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWFuYWdlciA9IG5ldyBNb2R1bGVNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMubW9kdWxlcyA9IG1vZHVsZXM7XG5cbiAgICB0aGlzLmludGVncmF0ZU1vZHVsZXMoKTtcbiAgfVxuXG4gIC8vIENPTlRST0xTICYgVVBEQVRJTkdcblxuICAvKipcbiAgICogQG1ldGhvZCBzdGFydFxuICAgKiBAZGVzY3JpcHRpb24gU3RhcnQgcmVuZGVyaW5nIGxvb3AgYW5kIHBoeXNpY3Mgc2ltdWxhdGlvbiAoaWYgeW91IHVzZSB2ZXJzaW9uIHdpdGggcGh5c2ljcykuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5BcHBcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoKCkgPT4ge1xuICAgICAgcmV0dXJuIHN5c3RlbS53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgIHx8IHN5c3RlbS53aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgIHx8IHN5c3RlbS53aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgIHx8IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgIHN5c3RlbS53aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgY29uc3Qge2xvb3BzLCBlbmFibGVkfSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZShwcm9jZXNzKTtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGwgPSBsb29wcy5sZW5ndGg7IGkgPCBsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBsb29wc1tpXTtcbiAgICAgICAgaWYgKGUuZW5hYmxlZCkgZS5leGVjdXRlKGUuY2xvY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgcHJvY2VzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc3RvcFxuICAgKiBAZGVzY3JpcHRpb24gU3RvcHMgcmVuZGVyaW5nIGxvb3BzXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5BcHBcbiAgICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBhZGRMb29wXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGxvb3AgdG8gdGhpcyBhcHAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb29wIC0gdGhlIGxvb3AgdG8gYWRkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHByb21pc2VzIGNvbXBsZXRlZC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkFwcFxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5BZGRpbmcgYSBsb29wIHRvIGFuIGFwcDwvY2FwdGlvbj5cbiAgICogY29uc3QgbG9vcCA9IG5ldyBMb29wKCgpID0+IHtcbiAgICogIC8vIC4uLlxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgYXBwID0gbmV3IEFwcCgpO1xuICAgKlxuICAgKiBhcHAuYWRkTG9vcChsb29wKTtcbiAgICogbG9vcC5zdGFydCgpO1xuICAgKi9cbiAgYWRkTG9vcChsb29wKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5sb29wcy5wdXNoKGxvb3ApO1xuICAgICAgcmVzb2x2ZShsb29wKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZUxvb3BcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgbG9vcCBmcm9tIHRoaXMgYXBwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9vcCAtIHRoZSBsb29wIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBwcm9taXNlcyBjb21wbGV0ZWQuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5BcHBcbiAgICovXG4gIHJlbW92ZUxvb3AobG9vcCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5sb29wcy5pbmRleE9mKGxvb3ApO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgdGhpcy5sb29wcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICByZXNvbHZlKGxvb3ApO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0KGtleSk7XG4gIH1cblxuICB1c2Uoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFuYWdlci51c2Uoa2V5KTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBBcHBcbn07XG4iLCJpbXBvcnQge0Nsb2NrfSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogQGNsYXNzIExvb3BcbiAqIEBjYXRlZ29yeSBjb3JlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBhbmltYXRpb24gZnJhbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNsb2NrPXRydWVdIHBhc3NlcyBhIENsb2NrIHRvIHRoZSBmdW5jdGlvbiB3aGVuIGNhbGxlZCwgaWYgdHJ1ZVxuICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlXG4gKi9cbmNsYXNzIExvb3Age1xuICBjb25zdHJ1Y3RvcihmdW5jLCB1c2VDbG9jayA9IHRydWUpIHtcbiAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIHRoaXMuY2xvY2sgPSB1c2VDbG9jayA/IG5ldyBDbG9jaygpIDogbnVsbDtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIENPTlRST0xTXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc3RhcnRcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBTdGFydHMgdGhpcyBsb29wLCBjbG9jayBpZiBpdCBoYXMgb25lLiBXb24ndCBkbyBhbnl0aGluZyBpZiBsb29wIGVuYWJsZWQgYWxyZWFkeS5cbiAgICogQHBhcmFtIHtDb21wb25lbnR9IFt3b3JsZF0gYXBwIHRvIGFkZCB0aGlzIGxvb3AgdG8sIGlmIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTG9vcFxuICAgKi9cbiAgc3RhcnQod29ybGQpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkKSByZXR1cm47XG5cbiAgICBpZiAod29ybGQpIHdvcmxkLmFkZExvb3AodGhpcyk7XG5cbiAgICBpZiAodGhpcy5jbG9jaykgdGhpcy5jbG9jay5zdGFydCgpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzdG9wXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gU3RvcHMgdGhpcyBsb29wIGFuZCBpdHMgY2xvY2sgaWYgaXQgaGFzIG9uZSwgd29uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBsb29wIGlzIG5vdCBlbmFibGVkKVxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gW3dvcmxkXSBhcHAgdG8gcmVtb3ZlIHRoaXMgbG9vcCBmcm9tLCBpZiBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkxvb3BcbiAgICovXG4gIHN0b3Aod29ybGQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuY2xvY2spIHRoaXMuY2xvY2suc3RvcCgpO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHdvcmxkKSB3b3JsZC5yZW1vdmVMb29wKHRoaXMpO1xuICB9XG5cbiAgLy8gRVhFQ1VUSU9OXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZXhlY3V0ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBvZiB0aGlzIGxvb3BcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkxvb3BcbiAgICogQHJldHVybnMgeyp9IHdoYXRldmVyIHRoZSBmdW5jdGlvbiBvZiB0aGlzIGxvb3AgcmV0dXJuc1xuICAgKi9cbiAgZXhlY3V0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jKHRoaXMuY2xvY2spO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIExvb3Bcbn07XG4iLCIvKiogQG1vZHVsZSBjb3JlICovXG5leHBvcnQgKiBmcm9tICcuL0NvbXBvbmVudCc7XG5leHBvcnQgKiBmcm9tICcuL01lc2hDb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9MaWdodENvbXBvbmVudCc7XG5leHBvcnQgKiBmcm9tICcuL0NhbWVyYUNvbXBvbmVudCc7XG5leHBvcnQgKiBmcm9tICcuL0FwcCc7XG5leHBvcnQgKiBmcm9tICcuL0xvb3AnO1xuZXhwb3J0ICogZnJvbSAnLi9Nb2R1bGVNYW5hZ2VyJztcbiIsImltcG9ydCB7QW1iaWVudExpZ2h0IGFzIEFtYmllbnRMaWdodE5hdGl2ZX0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHtMaWdodENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9MaWdodENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIEFtYmllbnRMaWdodFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZGVzY3JpcHRpb24gQW1iaWVudExpZ2h0IGlzIGEgc2ltcGxlIGNsYXNzLCBpdCBleHRlbmRzIExpZ2h0IGFuZCBpbmhlcml0cyBhbGwgaXRzIG1ldGhvZHMuXG4gKiBBbWJpZW50TGlnaHQgY3JlYXRlcyBiYXNpYyBsaWdodCBhcm91bmQgYWxsIHNjZW5lLCBzbyBpdCBkb2Vzbid0IG5lZWQgcHJvcGVydGllcyBsaWtlIHBvcyBvciB0YXJnZXQuXG4gKiBJdCBzdXBwb3J0cyBvbmx5IGNvbG9yIGFuZCBpbnRlbnNpdHkgYXMgcGFyYW1ldGVycywgd2hpY2ggZGVmaW5lcyB0aGUgY29sb3Igb2YgdGhlIHN1cnJvdW5kZWQgbGlnaHQgYW5kIGludGVuc2l0eSBvZiBsaWdodC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXtsaWdodDoge2NvbG9yOiAweGZmZmZmZiwgaW50ZW5zaXR5OiAxfX1dIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhbiBBbWJpZW50TGlnaHQgPC9jYXB0aW9uPlxuICogbmV3IEFtYmllbnRMaWdodCh7XG4gKiAgIGNvbG9yOiAweGZmZmZmZixcbiAqICAgaW50ZW5zaXR5OiAwLjJcbiAqIH0pLmFkZFRvKHdvcmxkKTtcbiAqL1xuY2xhc3MgQW1iaWVudExpZ2h0IGV4dGVuZHMgTGlnaHRDb21wb25lbnQge1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTGlnaHRDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgaW50ZW5zaXR5OiAxXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIEFtYmllbnRMaWdodC5kZWZhdWx0cyk7XG4gIH1cblxuICBidWlsZChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHtsaWdodDogbmV3IEFtYmllbnRMaWdodE5hdGl2ZShcbiAgICAgIHBhcmFtcy5jb2xvcixcbiAgICAgIHBhcmFtcy5pbnRlbnNpdHlcbiAgICApfSkubGlnaHQ7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgQW1iaWVudExpZ2h0XG59O1xuIiwiaW1wb3J0IHtEaXJlY3Rpb25hbExpZ2h0IGFzIERpcmVjdGlvbmFsTGlnaHROYXRpdmUsIERpcmVjdGlvbmFsTGlnaHRIZWxwZXJ9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7TGlnaHRDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTGlnaHRDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBEaXJlY3Rpb25hbExpZ2h0XG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9saWdodHNcbiAqIEBkZXNjcmlwdGlvbiBEaXJlY3RpbmFsTGlnaHQgY3JlYXRlcyBhIGxpZ2h0IHRoYXQgc2hpbmVzIGZyb20gYSBzcGVjaWZpYyBkaXJlY3Rpb24gbm90IGZyb20gYSBzcGVjaWZpYyBwb3NpdGlvbi48YnIvPjxici8+XG4gKiBUaGlzIGxpZ2h0IHdpbGwgYmVoYXZlIGFzIHRob3VnaCBpdCBpcyBpbmZpbml0ZWx5IGZhciBhd2F5IGFuZCB0aGUgcmF5cyBwcm9kdWNlZCBmcm9tIGl0IGFyZSBhbGwgcGFyYWxsZWwuIDxici8+PGJyLz5cbiAqIFRoZSBiZXN0IGFuYWxvZ3kgd291bGQgYmUgYSBsaWdodCBzb3VyY2UgdGhhdCBhY3RzIGxpa2UgdGhlIHN1bjogdGhlIHN1biBpcyBzbyBmYXIgYXdheSB0aGF0IGFsbCBzdW5saWdodCBoaXR0aW5nIG9iamVjdHMgY29tZXMgZnJvbSB0aGUgc2FtZSBhbmdsZS48YnIvPjxici8+XG4gKiBJdCBoYXMgdGhlIHNhbWUgb3B0aW9ucyBhcyBBbWJpZW50TGlnaHQgaW4gbGlnaHQgcGFyYW1hdGVyLCBidXQgaXQgYWxzbyBzdXBwb3J0cyBwb3MgYW5kIHRhcmdldCBwYXJhbWF0ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXM9e2xpZ2h0OiB7Y29sb3I6IDB4ZmZmZmZmLCBpbnRlbnNpdHk6IDF9fV0gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTGlnaHRDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9saWdodHNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgRGlyZWN0aW9uYWxMaWdodCB0byBmYWxsIGRvd24gZnJvbSB2ZWMzKDEwLCAyMCwgMTApIHRvIHZlYzMoMCwgMCwgMCk8L2NhcHRpb24+XG4gKiBuZXcgRGlyZWN0aW9uYWxMaWdodCh7XG4gKiAgIGNvbG9yOiAweGZmZmZmZixcbiAqICAgaW50ZW5zaXR5OiAwLjIsXG4gKlxuICogICBwb3NpdGlvbjogWzEwLCAyMCwgMTBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBEaXJlY3Rpb25hbExpZ2h0IGV4dGVuZHMgTGlnaHRDb21wb25lbnQge1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTGlnaHRDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgaW50ZW5zaXR5OiAxXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIERpcmVjdGlvbmFsTGlnaHQuZGVmYXVsdHMpO1xuICAgIHRoaXMud3JhcFNoYWRvdygpO1xuICB9XG5cbiAgYnVpbGQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bGlnaHQ6IG5ldyBEaXJlY3Rpb25hbExpZ2h0TmF0aXZlKFxuICAgICAgcGFyYW1zLmNvbG9yLFxuICAgICAgcGFyYW1zLmludGVuc2l0eVxuICAgICl9KS5saWdodDtcbiAgfVxufVxuXG5leHBvcnQge1xuICBEaXJlY3Rpb25hbExpZ2h0XG59O1xuIiwiaW1wb3J0IHtIZW1pc3BoZXJlTGlnaHQgYXMgSGVtaXNwaGVyZUxpZ2h0TmF0aXZlLCBIZW1pc3BoZXJlTGlnaHRIZWxwZXJ9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7TGlnaHRDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTGlnaHRDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBIZW1pc3BoZXJlTGlnaHRcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL2xpZ2h0c1xuICogQGRlc2NyaXB0aW9uIEhlbWlzcGhlcmVMaWdodCBpcyBhIGxpZ2h0IHNvdXJjZSBwb3NpdGlvbmVkIGRpcmVjdGx5IGFib3ZlIHRoZSBzY2VuZS48YnIvPlxuICogSXQgYWxzbyBkb2Vzbid0IG5lZWQgcG9zaXRpb24gYW5kIHRhcmdldCBwcm9wZXJ0aWVzLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzL3dlYmdsX2xpZ2h0c19oZW1pc3BoZXJlLmh0bWxcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXtsaWdodDoge3NreUNvbG9yOiAweGZmZmZmZiwgZ3JvdW5kQ29sb3I6IDB4ZmZmZmZmLCBpbnRlbnNpdHk6IDF9fV0gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTGlnaHRDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9saWdodHNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgSGVtaXNwaGVyZUxpZ2h0PC9jYXB0aW9uPlxuICogbmV3IEhlbWlzcGhlcmVMaWdodCh7XG4gKiAgIHNreUNvbG9yOiAweGZmMDAwMCxcbiAqICAgZ3JvdW5kQ29sb3I6IDB4MDAwMGZmLFxuICogICBpbnRlbnNpdHk6IDAuMlxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgSGVtaXNwaGVyZUxpZ2h0IGV4dGVuZHMgTGlnaHRDb21wb25lbnQge1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTGlnaHRDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBza3lDb2xvcjogMHhmZmZmZmYsXG4gICAgZ3JvdW5kQ29sb3I6IDB4ZmZmZmZmLFxuICAgIGludGVuc2l0eTogMVxuICB9XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIEhlbWlzcGhlcmVMaWdodC5kZWZhdWx0cyk7XG4gIH1cblxuICBidWlsZChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHtsaWdodDogbmV3IEhlbWlzcGhlcmVMaWdodE5hdGl2ZShcbiAgICAgIHBhcmFtcy5za3lDb2xvcixcbiAgICAgIHBhcmFtcy5ncm91bmRDb2xvcixcbiAgICAgIHBhcmFtcy5pbnRlbnNpdHlcbiAgICApfSkubGlnaHQ7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgSGVtaXNwaGVyZUxpZ2h0XG59O1xuIiwiaW1wb3J0IHtQb2ludExpZ2h0IGFzIFBvaW50TGlnaHROYXRpdmUsIFBvaW50TGlnaHRIZWxwZXJ9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7TGlnaHRDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTGlnaHRDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBQb2ludExpZ2h0XG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9saWdodHNcbiAqIEBkZXNjcmlwdGlvbiBQb2ludExpZ2h0IGNyZWF0ZXMgYSBsaWdodCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIGluIHRoZSBzY2VuZS4gVGhlIGxpZ2h0IHNoaW5lcyBpbiBhbGwgZGlyZWN0aW9ucyAocm91Z2hseSBzaW1pbGFyIHRvIGEgbGlnaHQgYnVsYi4pPGJyLz48YnIvPlxuICogSXQgaGFzIHRoZSBzYW1lIG9wdGlvbnMgYXMgQW1iaWVudExpZ2h0IGluIGxpZ2h0IHBhcmFtYXRlciwgYnV0IGl0IGFsc28gc3VwcG9ydHMgcG9zaXRpb24sIGRpc3RhbmNlIGFuZCBkZWNheS48YnIvPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXM9e2xpZ2h0OiB7Y29sb3I6IDB4ZmZmZmZmLCBpbnRlbnNpdHk6IDEsIGRpc3RhbmNlOiAxMDAsIGRlY2F5OiAxfX1dIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIExpZ2h0Q29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIFBvaW50TGlnaHQ8L2NhcHRpb24+XG4gKiBuZXcgUG9pbnRMaWdodCgge1xuICogICBjb2xvcjogMHhmZjAwMDAsXG4gKiAgIGludGVuc2l0eTogMixcbiAqICAgZGlzdGFuY2U6IDMwMFxuICpcbiAqICAgcG9zaXRpb246IFsxMCwgMjAsIDEwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIExpZ2h0Q29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRzPSB7XG4gICAgLi4uTGlnaHRDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgaW50ZW5zaXR5OiAxLFxuICAgIGRpc3RhbmNlOiAxMDAsXG4gICAgZGVjYXk6IDFcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBQb2ludExpZ2h0LmRlZmF1bHRzKTtcbiAgICB0aGlzLndyYXBTaGFkb3coKTtcbiAgfVxuXG4gIGJ1aWxkKHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe2xpZ2h0OiBuZXcgUG9pbnRMaWdodE5hdGl2ZShcbiAgICAgIHBhcmFtcy5jb2xvcixcbiAgICAgIHBhcmFtcy5pbnRlbnNpdHksXG4gICAgICBwYXJhbXMuZGlzdGFuY2UsXG4gICAgICBwYXJhbXMuZGVjYXlcbiAgICApfSkubGlnaHQ7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgUG9pbnRMaWdodFxufTtcbiIsImltcG9ydCB7U3BvdExpZ2h0IGFzIFNwb3RMaWdodE5hdGl2ZX0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHtMaWdodENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9MaWdodENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIFNwb3RMaWdodFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZGVzY3JpcHRpb24gU3BvdExpZ2h0IGNyZWF0ZXMgc3BvdCBsaWdodCB0aGF0IGNhbiBjYXN0IHNoYWRvdyBpbiBvbmUgZGlyZWN0aW9uLiA8YnIvPjxici8+XG4gKiBJdCBoYXMgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyBBbWJpZW50TGlnaHQgaW4gbGlnaHQsIGJ1dCBpdCBhbHNvIHN1cHBvcnRzIHBvcyBhbmQgdGFyZ2V0LiA8YnIvPjxici8+XG4gKiBTcG90TGlnaHQgYWZmZWN0cyBtZXNoZXMgd2l0aCBsYW1iZXJ0IGFuZCBwaG9uZyBtYXRlcmlhbC5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy93ZWJnbF9saWdodHNfc3BvdGxpZ2h0Lmh0bWxcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXtsaWdodDoge2NvbG9yOiAweGZmZmZmZiwgaW50ZW5zaXR5OiAxLCBkaXN0YW5jZTogMTAwLCBhbmdsZTogTWF0aC5QSSAvIDMsIGV4cG9uZW50OiAwLCBkZWNheTogMX19XSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5MaWdodENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL2xpZ2h0c1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBTcG90TGlnaHQgdGhhdCBmYWxscyBkb3duIGZyb20gdmVjMygxMCwgMjAsIDEwKSB0byB2ZWMzKDAsIDAsIDApPC9jYXB0aW9uPlxuICogbmV3IFNwb3RMaWdodCh7XG4gKiAgIGNvbG9yOiAweDAwZmYwMCxcbiAqICAgaW50ZW5zaXR5OiAzLFxuICogICBkaXN0YW5jZTogMTAwMFxuICpcbiAqICAgcG9zaXRpb246IFsxMCwgMjAsIDEwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgTGlnaHRDb21wb25lbnQge1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTGlnaHRDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgaW50ZW5zaXR5OiAxLFxuICAgIGRpc3RhbmNlOiAxMDAsXG4gICAgYW5nbGU6IE1hdGguUEkgLyAzLFxuICAgIGV4cG9uZW50OiAwLFxuICAgIGRlY2F5OiAxXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFNwb3RMaWdodC5kZWZhdWx0cyk7XG4gICAgdGhpcy53cmFwU2hhZG93KCk7XG4gIH1cblxuICBidWlsZChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHtsaWdodDogbmV3IFNwb3RMaWdodE5hdGl2ZShcbiAgICAgIHBhcmFtcy5jb2xvcixcbiAgICAgIHBhcmFtcy5pbnRlbnNpdHksXG4gICAgICBwYXJhbXMuZGlzdGFuY2UsXG4gICAgICBwYXJhbXMuYW5nbGUsXG4gICAgICBwYXJhbXMuZXhwb25lbnQsXG4gICAgICBwYXJhbXMuZGVjYXlcbiAgICApfSkubGlnaHQ7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgU3BvdExpZ2h0XG59O1xuIiwiaW1wb3J0IHtSZWN0QXJlYUxpZ2h0IGFzIFJlY3RBcmVhTGlnaHROYXRpdmV9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7TGlnaHRDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTGlnaHRDb21wb25lbnQnO1xuXG5jbGFzcyBBcmVhTGlnaHQgZXh0ZW5kcyBMaWdodENvbXBvbmVudCB7XG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5MaWdodENvbXBvbmVudC5kZWZhdWx0cyxcblxuICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICBpbnRlbnNpdHk6IDEsXG4gICAgd2lkdGg6IDEwLFxuICAgIGhlaWdodDogMTBcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgQXJlYUxpZ2h0LmRlZmF1bHRzKTtcbiAgfVxuXG4gIGJ1aWxkKHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe2xpZ2h0OiBuZXcgUmVjdEFyZWFMaWdodE5hdGl2ZShcbiAgICAgIHBhcmFtcy5jb2xvcixcbiAgICAgIHBhcmFtcy5pbnRlbnNpdHksXG4gICAgICBwYXJhbXMud2lkdGgsXG4gICAgICBwYXJhbXMuaGVpZ2h0XG4gICAgKX0pLmxpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIEFyZWFMaWdodFxufTtcbiIsIi8qKiBAbW9kdWxlIGNvbXBvbmVudHMvbGlnaHRzICovXG5leHBvcnQgKiBmcm9tICcuL0FtYmllbnRMaWdodCc7XG5leHBvcnQgKiBmcm9tICcuL0RpcmVjdGlvbmFsTGlnaHQnO1xuZXhwb3J0ICogZnJvbSAnLi9IZW1pc3BoZXJlTGlnaHQnO1xuZXhwb3J0ICogZnJvbSAnLi9Qb2ludExpZ2h0JztcbmV4cG9ydCAqIGZyb20gJy4vU3BvdExpZ2h0JztcbmV4cG9ydCAqIGZyb20gJy4vQXJlYUxpZ2h0JztcbiIsImltcG9ydCB7Q3ViZUNhbWVyYSBhcyBDdWJlQ2FtZXJhTmF0aXZlfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge0NhbWVyYUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9DYW1lcmFDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBDdWJlQ2FtZXJhXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9jYW1lcmFzXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyA2IGNhbWVyYXMgdGhhdCByZW5kZXIgdG8gYSBXZWJHTFJlbmRlclRhcmdldEN1YmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9jYW1lcmFzXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5DYW1lcmFDb21wb25lbnRcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZXMgYSBDdWJlQ2FtZXJhIGFuZCBzZXQgaXQgYXMgYXBwJ3MgY2FtZXJhPC9jYXB0aW9uPlxuICogY29uc3QgY2FtZXJhID0gbmV3IEN1YmVDYW1lcmEoe1xuICogICBjYW1lcmE6IHtcbiAqICAgICBjdWJlUmVzb2x1dGlvbjogMjU2XG4gKiAgIH0sXG4gKlxuICogICBwb3NpdGlvbjoge1xuICogICAgIHg6IDAsXG4gKiAgICAgeTogMTAwLFxuICogICAgIHo6IDBcbiAqICAgfVxuICogfSk7XG4gKlxuICogYXBwLmNhbWVyYSA9IGNhbWVyYTtcbiAqL1xuY2xhc3MgQ3ViZUNhbWVyYSBleHRlbmRzIENhbWVyYUNvbXBvbmVudCB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvY2FtZXJhcy5DdWJlQ2FtZXJhI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGNhbWVyYToge1xuICAgKiAgICAgbmVhcjogMSxcbiAgICogICAgIGZhcjogMTAwMCxcbiAgICogICAgIGN1YmVSZXNvbHV0aW9uOiAxMjhcbiAgICogICB9XG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5DYW1lcmFDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBuZWFyOiAxLFxuICAgIGZhcjogMTAwMCxcbiAgICBjdWJlUmVzb2x1dGlvbjogMTI4XG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIEN1YmVDYW1lcmEuZGVmYXVsdHMpO1xuICB9XG5cbiAgYnVpbGQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7Y2FtZXJhOiBuZXcgQ3ViZUNhbWVyYU5hdGl2ZShcbiAgICAgIHBhcmFtcy5uZWFyLFxuICAgICAgcGFyYW1zLmZhcixcbiAgICAgIHBhcmFtcy5jdWJlUmVzb2x1dGlvblxuICAgICl9KS5jYW1lcmE7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgQ3ViZUNhbWVyYVxufTtcbiIsImltcG9ydCB7T3J0aG9ncmFwaGljQ2FtZXJhIGFzIE9ydGhvZ3JhcGhpY0NhbWVyYU5hdGl2ZX0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHtDYW1lcmFDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvQ2FtZXJhQ29tcG9uZW50JztcbmltcG9ydCB7c3lzdGVtfSBmcm9tICcuLi8uLi9wb2x5ZmlsbCc7XG5cbi8qKlxuICogQGNsYXNzIE9ydGhvZ3JhcGhpY0NhbWVyYVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvY2FtZXJhc1xuICogQGRlc2NyaXB0aW9uIENhbWVyYSB3aXRoIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgb2JqZWN0LlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL2NhbWVyYXNcbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLkNhbWVyYUNvbXBvbmVudFxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGFuIE9ydGhvZ3JhcGhpY0NhbWVyYSBhbmQgc2V0IGl0IGFzIGFwcCdzIGNhbWVyYTwvY2FwdGlvbj5cbiAqIGNvbnN0IGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoe1xuICogICBjYW1lcmE6IHtcbiAqICAgICBmYXI6IDEwMDAwXG4gKiAgIH0sXG4gKlxuICogICBwb3NpdGlvbjoge1xuICogICAgIHk6IDUwXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGFwcC5jYW1lcmEgPSBjYW1lcmE7XG4gKi9cbmNsYXNzIE9ydGhvZ3JhcGhpY0NhbWVyYSBleHRlbmRzIENhbWVyYUNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL2NhbWVyYXMuT3J0aG9ncmFwaGljQ2FtZXJhI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIG5lYXI6IDEsXG4gICAqICAgZmFyOiAxMDAwLFxuICAgKiAgIGxlZnQ6IHN5c3RlbS53aW5kb3cuaW5uZXJXaWR0aCAvIC0yLFxuICAgKiAgIHJpZ2h0OiBzeXN0ZW0ud2luZG93LmlubmVyV2lkdGggLyAyLFxuICAgKiAgIHRvcDogc3lzdGVtLndpbmRvdy5pbm5lckhlaWdodCAvIDIsXG4gICAqICAgYm90dG9tOiBzeXN0ZW0ud2luZG93LmlubmVySGVpZ2h0IC8gLTJcbiAgICogfTwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLkNhbWVyYUNvbXBvbmVudC5kZWZhdWx0cyxcblxuICAgIG5lYXI6IDEsXG4gICAgZmFyOiAxMDAwLFxuICAgIGxlZnQ6IHN5c3RlbS53aW5kb3cuaW5uZXJXaWR0aCAvIC0yLFxuICAgIHJpZ2h0OiBzeXN0ZW0ud2luZG93LmlubmVyV2lkdGggLyAyLFxuICAgIHRvcDogc3lzdGVtLndpbmRvdy5pbm5lckhlaWdodCAvIDIsXG4gICAgYm90dG9tOiBzeXN0ZW0ud2luZG93LmlubmVySGVpZ2h0IC8gLTJcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgT3J0aG9ncmFwaGljQ2FtZXJhLmRlZmF1bHRzKTtcbiAgfVxuXG4gIGJ1aWxkKHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe2NhbWVyYTogbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYU5hdGl2ZShcbiAgICAgIHBhcmFtcy5sZWZ0LFxuICAgICAgcGFyYW1zLnJpZ2h0LFxuICAgICAgcGFyYW1zLnRvcCxcbiAgICAgIHBhcmFtcy5ib3R0b20sXG4gICAgICBwYXJhbXMubmVhcixcbiAgICAgIHBhcmFtcy5mYXJcbiAgICApfSkuY2FtZXJhO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIE9ydGhvZ3JhcGhpY0NhbWVyYVxufTtcbiIsImltcG9ydCB7UGVyc3BlY3RpdmVDYW1lcmEgYXMgUGVyc3BlY3RpdmVDYW1lcmFOYXRpdmV9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7Q2FtZXJhQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL0NhbWVyYUNvbXBvbmVudCc7XG5pbXBvcnQge3N5c3RlbX0gZnJvbSAnLi4vLi4vcG9seWZpbGwnO1xuXG4vKipcbiAqIEBjbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYVxuICogQGRlc2NyaXB0aW9uIENhbWVyYSB3aXRoIHBlcnNwZWN0aXZlIHByb2plY3Rpb24uXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9jYW1lcmFzXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1ldGVycyBvYmplY3QuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvY2FtZXJhc1xuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuQ2FtZXJhQ29tcG9uZW50XG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGUgYW4gUGVyc3BlY3RpdmVDYW1lcmEgYW5kIHNldCBpdCBhcyBhcHAncyBjYW1lcmE8L2NhcHRpb24+XG4gKiBjb25zdCBjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoe1xuICogICBmb3Y6IDc1LFxuICogICBhc3BlY3Q6IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LFxuICpcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB4OiAwLFxuICogICAgIHk6IDEwMCxcbiAqICAgICB6OiAwXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGFwcC5jYW1lcmEgPSBjYW1lcmE7XG4gKi9cbmNsYXNzIFBlcnNwZWN0aXZlQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvY2FtZXJhcy5QZXJzcGVjdGl2ZUNhbWVyYSNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBuZWFyOiAxLFxuICAgKiAgIGZhcjogMTAwMCxcbiAgICogICBmb3Y6IDc1LFxuICAgKiAgIGFzcGVjdDogc3lzdGVtLndpbmRvdy5pbm5lcldpZHRoIC8gc3lzdGVtLndpbmRvdy5pbm5lckhlaWdodFxuICAgKiB9PC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uQ2FtZXJhQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgbmVhcjogMSxcbiAgICBmYXI6IDEwMDAsXG4gICAgZm92OiA3NSxcbiAgICBhc3BlY3Q6IHN5c3RlbS53aW5kb3cuaW5uZXJXaWR0aCAvIHN5c3RlbS53aW5kb3cuaW5uZXJIZWlnaHRcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgUGVyc3BlY3RpdmVDYW1lcmEuZGVmYXVsdHMpO1xuICB9XG5cbiAgYnVpbGQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7Y2FtZXJhOiBuZXcgUGVyc3BlY3RpdmVDYW1lcmFOYXRpdmUoXG4gICAgICBwYXJhbXMuZm92LFxuICAgICAgcGFyYW1zLmFzcGVjdCxcbiAgICAgIHBhcmFtcy5uZWFyLFxuICAgICAgcGFyYW1zLmZhclxuICAgICl9KS5jYW1lcmE7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgUGVyc3BlY3RpdmVDYW1lcmFcbn07XG4iLCIvKiogQG1vZHVsZSBjb21wb25lbnRzL2NhbWVyYXMgKi9cbmV4cG9ydCAqIGZyb20gJy4vQ3ViZUNhbWVyYSc7XG5leHBvcnQgKiBmcm9tICcuL09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5leHBvcnQgKiBmcm9tICcuL1BlcnNwZWN0aXZlQ2FtZXJhJztcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIEJveEJ1ZmZlckdlb21ldHJ5LFxuICBCb3hHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgQm94XG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBBcyB0b2xkIG9uIENvbXBvbmVudCBkZWZpbml0aW9uLCB3aGlsZSB5b3UgY2FuIHBhc3MgYW55IG9mIHRoZSBpbmhlcml0ZWQgcGFyYW1zIGZvciB0aGlzIGNvbXBvbmVudCBjb25zdHJ1Y3Rpb24sIHlvdSB3aWxsIG5lZWQgdG9cbiAqIHBhc3Mgc3BlY2lmaWMgcGFyYW1ldGVycyB0byBidWlsZCB0aGlzIG1lc2ggYXMgYSBnZW9tZXRyeSBvYmplY3QuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI0JveEdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBCb3gsIGFuZCBhZGRpbmcgdG8gYXBwPC9jYXB0aW9uPlxuICogIG5ldyBCb3goe1xuICogICAgZ2VvbWV0cnk6IHtcbiAqICAgICAgd2lkdGg6IDIsXG4gKiAgICAgIGhlaWdodDogMixcbiAqICAgICAgZGVwdGg6IDJcbiAqICAgIH0sXG4gKlxuICogICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgIGNvbG9yOiAweGZmZmZmZlxuICogICAgfSksXG4gKlxuICogICAgcG9zaXRpb246IFs1MCwgNjAsIDcwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgQm94IGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkJveCNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgd2lkdGg6IDEsXG4gICAqICAgICBoZWlnaHQ6IDEsXG4gICAqICAgICBkZXB0aDogMSxcbiAgICogICAgIHdpZHRoU2VnbWVudHM6IDEsXG4gICAqICAgICBoZWlnaHRTZWdtZW50czogMSxcbiAgICogICAgIGRlcHRoU2VnbWVudHM6IDFcbiAgICogICB9XG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMSxcbiAgICAgIGRlcHRoOiAxLFxuICAgICAgd2lkdGhTZWdtZW50czogMSxcbiAgICAgIGhlaWdodFNlZ21lbnRzOiAxLFxuICAgICAgZGVwdGhTZWdtZW50czogMVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkJveCNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCBnZW9tZXRyeTogWyd3aWR0aCcsICdoZWlnaHQnLCAnZGVwdGgnLCAnd2lkdGhTZWdtZW50cycsICdoZWlnaHRTZWdtZW50cycsICdkZXB0aFNlZ2VtZW50cyddXG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ3dpZHRoJywgJ2hlaWdodCcsICdkZXB0aCcsICd3aWR0aFNlZ21lbnRzJywgJ2hlaWdodFNlZ21lbnRzJywgJ2RlcHRoU2VnZW1lbnRzJ11cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgQm94LmRlZmF1bHRzLCBCb3guaW5zdHJ1Y3Rpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuQm94XG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgKHBhcmFtcy5idWZmZXIgPyBCb3hCdWZmZXJHZW9tZXRyeSA6IEJveEdlb21ldHJ5KShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS53aWR0aCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5oZWlnaHQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuZGVwdGgsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkud2lkdGhTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5oZWlnaHRTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5kZXB0aFNlZ21lbnRzXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBCb3hcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBDaXJjbGVCdWZmZXJHZW9tZXRyeSxcbiAgQ2lyY2xlR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIENpcmNsZVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gQXMgdG9sZCBvbiBDb21wb25lbnQgZGVmaW5pdGlvbiwgd2hpbGUgeW91IGNhbiBwYXNzIGFueSBvZiB0aGUgaW5oZXJpdGVkIHBhcmFtcyBmb3IgdGhpcyBjb21wb25lbnQgY29uc3RydWN0aW9uLCB5b3Ugd2lsbCBuZWVkIHRvXG4gKiBwYXNzIHNwZWNpZmljIHBhcmFtZXRlcnMgdG8gYnVpbGQgdGhpcyBtZXNoIGFzIGEgZ2VvbWV0cnkgb2JqZWN0LlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNDaXJjbGVHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgQ2lyY2xlLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqICBuZXcgQ2lyY2xlKHtcbiAqICAgIGdlb21ldHJ5OiB7XG4gKiAgICAgIHJhZGl1czogNCxcbiAqICAgICAgc2VnbWVudHM6IDE2XG4gKiAgICB9LFxuICpcbiAqICAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgIH0pLFxuICpcbiAqICAgIHBvc2l0aW9uOiBbNTAsIDYwLCA3MF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIENpcmNsZSBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5DaXJjbGUjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1czogNTAsXG4gICAqICAgICBzZWdtZW50czogOCxcbiAgICogICAgIHRoZXRhU3RhcnQ6IDAsXG4gICAqICAgICB0aGV0YUxlbmd0aDogTWF0aC5QSSAqIDJcbiAgICogICB9XG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogNTAsXG4gICAgICBzZWdtZW50czogOCxcbiAgICAgIHRoZXRhU3RhcnQ6IDAsXG4gICAgICB0aGV0YUxlbmd0aDogTWF0aC5QSSAqIDJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5DaXJjbGUjaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgZ2VvbWV0cnk6IFsncmFkaXVzJywgJ3NlZ21lbnRzJywgJ3RoZXRhU3RhcnQnLCAndGhldGFMZW5ndGgnXVxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWydyYWRpdXMnLCAnc2VnbWVudHMnLCAndGhldGFTdGFydCcsICd0aGV0YUxlbmd0aCddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIENpcmNsZS5kZWZhdWx0cywgQ2lyY2xlLmluc3RydWN0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkNpcmNsZVxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IChwYXJhbXMuYnVmZmVyID8gQ2lyY2xlQnVmZmVyR2VvbWV0cnkgOiBDaXJjbGVHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnNlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnRoZXRhU3RhcnQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIENpcmNsZVxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIENvbmVCdWZmZXJHZW9tZXRyeSxcbiAgQ29uZUdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBDb25lXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBBIGN5bGluZGVyIGlzIG9uZSBvZiB0aGUgbW9zdCBiYXNpYyBjdXJ2aWxpbmVhciBnZW9tZXRyaWMgc2hhcGVzLCB0aGUgc3VyZmFjZSBmb3JtZWQgYnkgdGhlIHBvaW50cyBhdCBhIGZpeGVkIGRpc3RhbmNlIGZyb20gYSBnaXZlbiBzdHJhaWdodCBsaW5lLCB0aGUgYXhpcyBvZiB0aGUgY3lsaW5kZXIuIDxici8+PGJyLz5cbiAqIFRoZSBzb2xpZCBlbmNsb3NlZCBieSB0aGlzIHN1cmZhY2UgYW5kIGJ5IHR3byBwbGFuZXMgcGVycGVuZGljdWxhciB0byB0aGUgYXhpcyBpcyBhbHNvIGNhbGxlZCBhIGN5bGluZGVyLjxici8+XG4gKiBUaGUgc3VyZmFjZSBhcmVhIGFuZCB0aGUgdm9sdW1lIG9mIGEgY3lsaW5kZXIgaGF2ZSBiZWVuIGtub3duIHNpbmNlIGRlZXAgYW50aXF1aXR5LlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNDb25lR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIENvbmUsIGFuZCBhZGRpbmcgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IENvbmUoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1c1RvcDogMixcbiAqICAgICByYWRpdXNCb3R0b206IDQsXG4gKiAgICAgaGVpZ2h0OiA1XG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3M6IFswLCAxMDAsIDBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBDb25lIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkNvbmUjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1czogMjAsXG4gICAqICAgICBoZWlnaHQ6IDEwMCxcbiAgICogICAgIHJhZGl1c1NlZ21lbnRzOiAzMixcbiAgICogICAgIGhlaWdodFNlZ21lbnRzOiAxLFxuICAgKiAgICAgb3BlbkVuZGVkOiBmYWxzZSxcbiAgICogICAgIHRoZXRhU3RhcnQ6IDAsXG4gICAqICAgICB0aGV0YUxlbmd0aDogTWF0aC5QSSAqIDJcbiAgICogICB9XG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogMjAsXG4gICAgICBoZWlnaHQ6IDEwMCxcbiAgICAgIHJhZGl1c1NlZ21lbnRzOiAzMixcbiAgICAgIGhlaWdodFNlZ21lbnRzOiAxLFxuICAgICAgb3BlbkVuZGVkOiBmYWxzZSxcbiAgICAgIHRoZXRhU3RhcnQ6IDAsXG4gICAgICB0aGV0YUxlbmd0aDogTWF0aC5QSSAqIDJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Db25lI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIGdlb21ldHJ5OiBbXG4gICAqICAgJ3JhZGl1cycsXG4gICAqICAgJ2hlaWdodCcsXG4gICAqICAgJ3JhZGl1c1NlZ21lbnRzJyxcbiAgICogICAnaGVpZ2h0U2VnbWVudHMnLFxuICAgKiAgICdvcGVuRW5kZWQnLFxuICAgKiAgICd0aGV0YVN0YXJ0JyxcbiAgICogICAndGhldGFMZW5ndGgnXG4gICAqIF1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbXG4gICAgICAncmFkaXVzJyxcbiAgICAgICdoZWlnaHQnLFxuICAgICAgJ3JhZGl1c1NlZ21lbnRzJyxcbiAgICAgICdoZWlnaHRTZWdtZW50cycsXG4gICAgICAnb3BlbkVuZGVkJyxcbiAgICAgICd0aGV0YVN0YXJ0JyxcbiAgICAgICd0aGV0YUxlbmd0aCdcbiAgICBdXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIENvbmUuZGVmYXVsdHMsIENvbmUuaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkNvbmVcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyAocGFyYW1zLmJ1ZmZlciA/IENvbmVCdWZmZXJHZW9tZXRyeSA6IENvbmVHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmhlaWdodCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpdXNTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5oZWlnaHRTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5vcGVuRW5kZWQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudGhldGFTdGFydCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS50aGV0YUxlbmd0aFxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgQ29uZVxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIEN5bGluZGVyQnVmZmVyR2VvbWV0cnksXG4gIEN5bGluZGVyR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIEN5bGluZGVyXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBBIGN5bGluZGVyIGlzIG9uZSBvZiB0aGUgbW9zdCBiYXNpYyBjdXJ2aWxpbmVhciBnZW9tZXRyaWMgc2hhcGVzLCB0aGUgc3VyZmFjZSBmb3JtZWQgYnkgdGhlIHBvaW50cyBhdCBhIGZpeGVkIGRpc3RhbmNlIGZyb20gYSBnaXZlbiBzdHJhaWdodCBsaW5lLCB0aGUgYXhpcyBvZiB0aGUgY3lsaW5kZXIuIDxici8+PGJyLz5cbiAqIFRoZSBzb2xpZCBlbmNsb3NlZCBieSB0aGlzIHN1cmZhY2UgYW5kIGJ5IHR3byBwbGFuZXMgcGVycGVuZGljdWxhciB0byB0aGUgYXhpcyBpcyBhbHNvIGNhbGxlZCBhIGN5bGluZGVyLjxici8+XG4gKiBUaGUgc3VyZmFjZSBhcmVhIGFuZCB0aGUgdm9sdW1lIG9mIGEgY3lsaW5kZXIgaGF2ZSBiZWVuIGtub3duIHNpbmNlIGRlZXAgYW50aXF1aXR5LlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNDeWxpbmRlckdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBDeWxpbmRlciwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgQ3lsaW5kZXIoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1c1RvcDogMixcbiAqICAgICByYWRpdXNCb3R0b206IDQsXG4gKiAgICAgaGVpZ2h0OiA1XG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3M6IFswLCAxMDAsIDBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBDeWxpbmRlciBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5DeWxpbmRlciNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgcmFkaXVzVG9wOiAyMCxcbiAgICogICAgIHJhZGl1c0JvdHRvbTogMjAsXG4gICAqICAgICBoZWlnaHQ6IDEwMCxcbiAgICogICAgIHJhZGl1c1NlZ21lbnRzOiAzMixcbiAgICogICAgIGhlaWdodFNlZ21lbnRzOiAxLFxuICAgKiAgICAgb3BlbkVuZGVkOiBmYWxzZSxcbiAgICogICAgIHRoZXRhU3RhcnQ6IDAsXG4gICAqICAgICB0aGV0YUxlbmd0aDogTWF0aC5QSSAqIDJcbiAgICogICB9XG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXNUb3A6IDAsXG4gICAgICByYWRpdXNCb3R0b206IDEsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICByYWRpdXNTZWdtZW50czogMzIsXG4gICAgICBoZWlnaHRTZWdtZW50czogMSxcbiAgICAgIG9wZW5FbmRlZDogZmFsc2UsXG4gICAgICB0aGV0YVN0YXJ0OiAwLFxuICAgICAgdGhldGFMZW5ndGg6IE1hdGguUEkgKiAyXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuQ3lsaW5kZXIjaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICogZ2VvbWV0cnk6IFtcbiAgICogICAncmFkaXVzVG9wJyxcbiAgICogICAncmFkaXVzQm90dG9tJyxcbiAgICogICAnaGVpZ2h0JyxcbiAgICogICAncmFkaXVzU2VnbWVudHMnLFxuICAgKiAgICdoZWlnaHRTZWdtZW50cycsXG4gICAqICAgJ29wZW5FbmRlZCcsXG4gICAqICAgJ3RoZXRhU3RhcnQnLFxuICAgKiAgICd0aGV0YUxlbmd0aCdcbiAgICogXVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFtcbiAgICAgICdyYWRpdXNUb3AnLFxuICAgICAgJ3JhZGl1c0JvdHRvbScsXG4gICAgICAnaGVpZ2h0JyxcbiAgICAgICdyYWRpdXNTZWdtZW50cycsXG4gICAgICAnaGVpZ2h0U2VnbWVudHMnLFxuICAgICAgJ29wZW5FbmRlZCcsXG4gICAgICAndGhldGFTdGFydCcsXG4gICAgICAndGhldGFMZW5ndGgnXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBDeWxpbmRlci5kZWZhdWx0cywgQ3lsaW5kZXIuaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkN5bGluZGVyXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgKHBhcmFtcy5idWZmZXIgPyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5IDogQ3lsaW5kZXJHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzVG9wLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1c0JvdHRvbSxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5oZWlnaHQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaGVpZ2h0U2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkub3BlbkVuZGVkLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnRoZXRhU3RhcnQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIEN5bGluZGVyXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnksXG4gIERvZGVjYWhlZHJvbkdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBEb2RlY2FoZWRyb25cbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIEluIGdlb21ldHJ5LCBhIGRvZGVjYWhlZHJvbiBpcyBhbnkgcG9seWhlZHJvbiB3aXRoIHR3ZWx2ZSBmbGF0IGZhY2VzLiA8YnIvPjxici8+XG4gKiBUaGUgbW9zdCBmYW1pbGlhciBkb2RlY2FoZWRyb24gaXMgdGhlIHJlZ3VsYXIgZG9kZWNhaGVkcm9uLCB3aGljaCBpcyBhIFBsYXRvbmljIHNvbGlkLiA8YnIvPlxuICogVGhlcmUgYXJlIGFsc28gdGhyZWUgcmVndWxhciBzdGFyIGRvZGVjYWhlZHJhLCB3aGljaCBhcmUgY29uc3RydWN0ZWQgYXMgc3RlbGxhdGlvbnMgb2YgdGhlIGNvbnZleCBmb3JtLiA8YnIvPlxuICogQWxsIG9mIHRoZXNlIGhhdmUgaWNvc2FoZWRyYWwgc3ltbWV0cnksIG9yZGVyIDEyMC5cbiAqIERvZGVjYWhlZHJvbiBjcmVhdGVzIERvZGVjYWhlZHJvbiBvYmplY3QgYnkgaXQncyByYWRpdXMgYW5kIGRldGFpbC5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjRG9kZWNhaGVkcm9uR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIERvZGVjYWhlZHJvbiwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgRG9kZWNhaGVkcm9uKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXM6IDJcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgeTogMTBcbiAqICAgfVxuICAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIERvZGVjYWhlZHJvbiBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuRG9kZWNhaGVkcm9uI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICogZ2VvbWV0cnk6IHtcbiAgICogICByYWRpdXM6IDEsXG4gICAqICAgZGV0YWlsOiAwXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgcmFkaXVzOiAxLFxuICAgICAgZGV0YWlsOiAwXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuRG9kZWNhaGVkcm9uI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIGdlb21ldHJ5OiBbJ3JhZGl1cycsICdkZXRhaWwnXVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFsncmFkaXVzJywgJ2RldGFpbCddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIERvZGVjYWhlZHJvbi5kZWZhdWx0cywgRG9kZWNhaGVkcm9uLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Eb2RlY2FoZWRyb25cbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IChwYXJhbXMuYnVmZmVyID8gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkgOiBEb2RlY2FoZWRyb25HZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmRldGFpbFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgRG9kZWNhaGVkcm9uXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgQnVmZmVyR2VvbWV0cnksXG4gIEV4dHJ1ZGVHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgRXh0cnVkZVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gRXh0cnVkZSBnZW9tZXRyeSBtZWFucyB0aGF0IHlvdSBjYW4gY3JlYXRlIGEgM0QgbWVzaCBmcm9tIGFueSAyRCBzaGFwZSB1c2luZyB0aHJlZS5qcyBnZW9tZXRyeSBiYXNlZCBvbiA8YSBocmVmPSdodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9tYXRoL1ZlY3RvcjInPlRIUkVFLlZlY3RvcjIuPC9hPiA8YnIvPlxuICogU3VjaCBpbXBsZW1lbnRhdGlvbiB3aWxsIGhlbHAgeW91IHRvIG1ha2Ugdm9sdW1lZCBzaGFwZXMgdGhhdCBoYXZlIHRoZWlyIG93biBkZXB0aCBhbmQgY2FuIGJlIHNlZW4gZnJvbSBhbGwgYW5nZWxzLjxici8+PGJyLz5cbiAqIFlvdSBjYW4gYWxzbyBmaW5kIHNvbWUgaW50ZXJlc3RpbmcgZXhhbXBsZXMgbWFkZSB1c2luZyA8YSBocmVmPSd0aHJlZWpzLm9yZyc+dGhyZWUuanM8L2E+IHdoaWNoIGlzIGEgY29yZSBvZiB3aHMuanMsIHN1Y2ggYXM6XG4gKiAtIDxhIGhyZWY9J2h0dHA6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy93ZWJnbF9nZW9tZXRyeV9leHRydWRlX3NoYXBlcy5odG1sJz5XZWJnbCBnZW9tZXRyeSBleHRydWRlPC9hPlxuICogLSA8YSBocmVmPSdodHRwOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvd2ViZ2xfZ2VvbWV0cnlfZXh0cnVkZV9zaGFwZXMyLmh0bWwnPkV4dHJ1ZGUgc2hhcGVzIGZyb20gZ2VvZGF0YTwvYT5cbiAqIC0gPGEgaHJlZj0naHR0cDovL3RocmVlanMub3JnL2V4YW1wbGVzL3dlYmdsX2dlb21ldHJ5X2V4dHJ1ZGVfc3BsaW5lcy5odG1sJz5FeHRydWRlIHNwbGluZXM8L2E+XG4gKlxuICogU3VjaCBleGFtcGxlcyBjYW4gYmUgZWFzaWx5IGltcGxlbWVudGVkIHVzaW5nIHdoaXRlc3Rvcm0uanMgb3IgaXQncyBwbHVnaW5zLiBVc2UgYEV4dHJ1ZGVgIGNsYXNzIHdpdGggPGEgaHJlZj0naHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZXh0cmFzL2NvcmUvU2hhcGUnPlRIUkVFLlNoYXBlPC9hPiB0byBnZXQgZXh0cnVkZSBlZmZlY3Qgb2Ygc2hhcGUgZGVmaW5lZCBieSAyRCB2ZWN0b3JzLlxuICogVGhpcyBjbGFzcyBpcyBzaW1pbGFyIHRvIDxhIGhyZWY9J2h0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5Jz5USFJFRS5FeHRydWRlR2VvbWV0cnk8L2E+LFxuICogYnV0IGl0IGFsc28gY29udGFpbnMgYWxsIHByb3BlcnRpZXMsIGFwcGxpZWQgYnkgYFNoYXBlYCwgc3VjaCBhcyBtYXRlcmlhbCwgbWFzcyBhbmQgdmVjdG9ycyBsaWtlIHBvc2l0aW9uIChwb3MpIGFuZCByb3RhdGlvbiAocm90KS5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjRXh0cnVkZUdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBzaGFwZSwgdGhlbiBhbiBFeHRydWRlIGZyb20gaXQ8L2NhcHRpb24+XG4gKiBjb25zdCBzaGFwZSA9IG5ldyBUSFJFRS5TaGFwZShbXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IyKC00LC00KSxcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjIoLTIsMCksXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IyKC00LDQpLFxuICogICBuZXcgVEhSRUUuVmVjdG9yMigwLDIpLFxuICogICBuZXcgVEhSRUUuVmVjdG9yMig0LDQpLFxuICogICBuZXcgVEhSRUUuVmVjdG9yMigyLDApLFxuICogICBuZXcgVEhSRUUuVmVjdG9yMig0LC00KSxcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjIoMCwtMilcbiAqIF0pO1xuICpcbiAqIGNvbnN0IGV4dHJ1ZGUgPSBuZXcgRXh0cnVkZSh7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgc2hhcGVzOiBzaGFwZSxcbiAqICAgICBvcHRpb25zOiB7XG4gKiAgICAgICBiZXZlbEVuYWJsZWQ6IGZhbHNlLFxuICogICAgICAgYmV2ZWxTaXplOiAwLFxuICogICAgICAgYW1vdW50OiAyXG4gKiAgICAgfVxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IFswLCAxMDAsIDBdXG4gKiB9KTtcbiAqXG4gKiBleHRydWRlLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIEV4dHJ1ZGUgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkV4dHJ1ZGUjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHNoYXBlczogW10sXG4gICAqICAgICBvcHRpb25zOiB7fVxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICBzaGFwZXM6IFtdLFxuICAgICAgb3B0aW9uczoge31cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5FeHRydWRlI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeTogWydzaGFwZXMnLCAnb3B0aW9ucyddXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ3NoYXBlcycsICdvcHRpb25zJ11cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgRXh0cnVkZS5kZWZhdWx0cywgRXh0cnVkZS5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuRXh0cnVkZVxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEV4dHJ1ZGVHZW9tZXRyeShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5zaGFwZXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkub3B0aW9uc1xuICAgICk7XG5cbiAgICByZXR1cm4gcGFyYW1zLmJ1ZmZlciA/IG5ldyBCdWZmZXJHZW9tZXRyeSgpLmZyb21HZW9tZXRyeShnZW9tZXRyeSkgOiBnZW9tZXRyeTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBFeHRydWRlXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSxcbiAgSWNvc2FoZWRyb25HZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgSWNvc2FoZWRyb25cbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIEluIGdlb21ldHJ5LCBhbiBpY29zYWhlZHJvbiBpcyBhIHBvbHloZWRyb24gd2l0aCAyMCBmYWNlcy48YnIvPlxuICogVGhlcmUgYXJlIG1hbnkga2luZHMgb2YgaWNvc2FoZWRyYSwgd2l0aCBzb21lIGJlaW5nIG1vcmUgc3ltbWV0cmljYWwgdGhhbiBvdGhlcnMuIFRoZSBtb3N0IHdlbGwga25vd24gaXMgdGhlIFBsYXRvbmljLCBjb252ZXggcmVndWxhciBpY29zYWhlZHJvbi48YnIvPlxuICogYEljb3NhaGVkcm9uYCBjcmVhdGVzIGFuIEljb3NhaGVkcm9uIG9iamVjdCBieSBpdHMgcmFkaXVzIGFuZCBkZXRhaWwuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI0ljb3NhaGVkcm9uR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIEljb3NhaGVkcm9uLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBJY29zYWhlZHJvbih7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgcmFkaXVzOiAyLFxuICogICAgIGRldGFpbDogMVxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IFswLCAxMDAsIDBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBJY29zYWhlZHJvbiBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuSWNvc2FoZWRyb24jZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1czogMSxcbiAgICogICAgIGRldGFpbDogMFxuICAgKiAgIH1cbiAgICogfTwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogMSxcbiAgICAgIGRldGFpbDogMFxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkljb3NhaGVkcm9uI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IHtnZW9tZXRyeTogWydyYWRpdXMnLCAnZGV0YWlsJ119XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ3JhZGl1cycsICdkZXRhaWwnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBJY29zYWhlZHJvbi5kZWZhdWx0cywgSWNvc2FoZWRyb24uaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkljb3NhaGVkcm9uXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkgOiBJY29zYWhlZHJvbkdlb21ldHJ5KShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpdXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuZGV0YWlsXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBJY29zYWhlZHJvblxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIExhdGhlQnVmZmVyR2VvbWV0cnksXG4gIExhdGhlR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIExhdGhlXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBBIGBMYXRoZUdlb21ldHJ5YCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBzaGFwZXMgZnJvbSBhIHNtb290aCBjdXJ2ZS5cbiAqIFRoaXMgY3VydmUgaXMgZGVmaW5lZCBieSBhIG51bWJlciBvZiBwb2ludHMgKGFsc28gY2FsbGVkIGtub3RzKSBhbmQgaXMgbW9zdCBvZnRlbiBjYWxsZWQgYSBzcGxpbmUuIFRoaXMgc3BsaW5lIGlzIHJvdGF0ZWQgYXJvdW5kIGEgZml4ZWQgcG9pbnQgYW5kIHJlc3VsdHMgaW4gdmFzZS0gYW5kIGJlbGwtbGlrZSBzaGFwZXMuPGJyLz48YnIvPlxuICogSW4gM0QgY29tcHV0ZXIgZ3JhcGhpY3MsIGEgbGF0aGVkIG9iamVjdCBpcyBhIDNEIG1vZGVsIHdob3NlIHZlcnRleCBnZW9tZXRyeSBpcyBwcm9kdWNlZCBieSByb3RhdGluZyB0aGUgcG9pbnRzIG9mIGEgc3BsaW5lIG9yIG90aGVyIHBvaW50IHNldCBhcm91bmQgYSBmaXhlZCBheGlzLlxuICogVGhlIGxhdGhpbmcgbWF5IGJlIHBhcnRpYWw7IHRoZSBhbW91bnQgb2Ygcm90YXRpb24gaXMgbm90IG5lY2Vzc2FyaWx5IGEgZnVsbCAzNjAgZGVncmVlcy5cbiAqIFRoZSBwb2ludCBzZXQgcHJvdmlkaW5nIHRoZSBpbml0aWFsIHNvdXJjZSBkYXRhIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGEgY3Jvc3Mgc2VjdGlvbiB0aHJvdWdoIHRoZSBvYmplY3QgYWxvbmcgYSBwbGFuZSBjb250YWluaW5nIGl0cyBheGlzIG9mIHJhZGlhbCBzeW1tZXRyeS4gPGJyLz48YnIvPlxuICogVGhlIDxhIGhyZWY9J2h0dHA6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjTGF0aGVHZW9tZXRyeSc+Zm9sbG93aW5nIGV4YW1wbGU8L2E+IHNob3dzIGEgZ2VvbWV0cnkgd2hpY2ggY2FuIGJlIGdlbmVyYXRlZCB1c2luZyBgTGF0aGVgIGNsYXNzLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNMYXRoZUdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBMYXRoLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIGNvbnN0IHBvaW50cyA9IFtdO1xuICpcbiAqIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICogICBwb2ludHMucHVzaChcbiAqICAgICBuZXcgVEhSRUUuVmVjdG9yMihcbiAqICAgICAgIChNYXRoLnNpbihpICogMC43KSAqIDE1ICsgNTApIC8gMTAsXG4gKiAgICAgICAoaSAtIDUpICogMC4yXG4gKiAgICAgKVxuICogICApO1xuICogfVxuICpcbiAqIGNvbnN0IGxhdGhlID0gbmV3IExhdGhlKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICBwb2ludHM6IHBvaW50c1xuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IFswLCA1MCwgMTBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBMYXRoZSBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuTGF0aGUjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHBvaW50czogW11cbiAgICogICB9XG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgcG9pbnRzOiBbXVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkxhdGhlI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+e1xuICAgKiAgIGdlb21ldHJ5OiBbJ3BvaW50cyddXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ3BvaW50cyddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIExhdGhlLmRlZmF1bHRzLCBMYXRoZS5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuTGF0aGVcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IChwYXJhbXMuYnVmZmVyID8gTGF0aGVCdWZmZXJHZW9tZXRyeSA6IExhdGhlR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnBvaW50c1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgTGF0aGVcbn07XG4iLCJpbXBvcnQge1xuICBMaW5lIGFzIExpbmVOYXRpdmUsXG4gIEJ1ZmZlckdlb21ldHJ5LFxuICBHZW9tZXRyeSxcbiAgQnVmZmVyQXR0cmlidXRlLFxuICBMaW5lQ3VydmUzLFxuICBWZWN0b3IzXG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBMaW5lXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBMaW5lIGNvbXBvbmVudCBpcyBnZW5lcmF0ZWQgZnJvbSBhIGN1cnZlL2xpbmUgYW5kIGFtb3VudCBvZiB2ZWN0b3JzIHRoYXQgc2hvdWxkIGJlIHVzZWQgKHBvaW50cykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBMaW5lLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBMaW5lKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICBjdXJ2ZTogbmV3IFRIUkVFLkxpbmVDdXJ2ZTMobmV3IFRIUkVFLlZlY3RvcjMoMTAsIDEwLCAwKSwgbmV3IFRIUkVFLlZlY3RvcjMoMTAsIDMwLCAwKSlcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgTGluZSBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuTGluZSNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBjdXJ2ZTogbmV3IExpbmVDdXJ2ZTMobmV3IFZlY3RvcjMoMCwgMCwgMCksIG5ldyBWZWN0b3IzKDEwLCAwLCAwKSksXG4gICAqICAgcG9pbnRzOiA1MFxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBjdXJ2ZTogbnVsbCxcbiAgICBwb2ludHM6IDUwXG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5MaW5lI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+e1xuICAgKiAgIGdlb21ldHJ5OiBbJ2N1cnZlJywgJ3BvaW50cyddXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ2N1cnZlJywgJ3BvaW50cyddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zLCBMaW5lLmRlZmF1bHRzLCBMaW5lLmluc3RydWN0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkxpbmVcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTGluZU5hdGl2ZShnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHBhcmFtcy5idWZmZXIgPyBuZXcgQnVmZmVyR2VvbWV0cnkoKSA6IG5ldyBHZW9tZXRyeSgpO1xuXG4gICAgaWYgKHBhcmFtcy5idWZmZXIpIHtcbiAgICAgIGNvbnN0IHBwID0gcGFyYW1zLmN1cnZlLmdldFBvaW50cyhwYXJhbXMucG9pbnRzKTtcbiAgICAgIGNvbnN0IHZlcnRzID0gbmV3IEZsb2F0MzJBcnJheShwcC5sZW5ndGggKiAzKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IHBwLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGkzID0gaSAqIDM7XG5cbiAgICAgICAgdmVydHNbaTNdID0gcHBbaV0ueDtcbiAgICAgICAgdmVydHNbaTMgKyAxXSA9IHBwW2ldLnk7XG4gICAgICAgIHZlcnRzW2kzICsgMl0gPSBwcFtpXS56O1xuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0cywgMykpO1xuICAgIH0gZWxzZSBnZW9tZXRyeS52ZXJ0aWNlcyA9IHBhcmFtcy5jdXJ2ZS5nZXRQb2ludHMocGFyYW1zLnBvaW50cyk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgTGluZVxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIEpTT05Mb2FkZXJcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIEltcG9ydGVyXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBJbXBvcnRlciBpcyBhIGxvYWRlciBmb3IgbWVzaGVzIGFuZCBhbnkgb3RoZXIgZGF0YSB0byB5b3VyIHNjZW5lXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBJbXBvcnRlciwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgSW1wb3J0ZXIoe1xuICogICBsb2FkZXI6IG5ldyBUSFJFRS5PQkpMb2FkZXIoKSxcbiAqXG4gKiAgIHBhcnNlcihnZW9tZXRyeSwgbWF0ZXJpYWwpIHsgLy8gZGF0YSBmcm9tIGxvYWRlclxuICogICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpOyAvLyBzaG91bGQgcmV0dXJuIHlvdXIgLm5hdGl2ZSAobWVzaCBpbiB0aGlzIGNhc2UpXG4gKiAgIH0sXG4gKlxuICogICBwb3NpdGlvbjogWzAsIDEwMCwgMF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIEltcG9ydGVyIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkltcG9ydGVyI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIHVybDogJycsXG4gICAqICAgbG9hZGVyOiBuZXcgSlNPTkxvYWRlcigpLFxuICAgKlxuICAgKiAgIG9uTG9hZCgpIHt9LFxuICAgKiAgIG9uUHJvZ3Jlc3MoKSB7fSxcbiAgICogICBvbkVycm9yKCkge30sXG4gICAqXG4gICAqICAgdGV4dHVyZVBhdGg6IG51bGwsXG4gICAqICAgdXNlQ3VzdG9tTWF0ZXJpYWw6IGZhbHNlLFxuICAgKlxuICAgKiAgIHBhcnNlcihnZW9tZXRyeSwgbWF0ZXJpYWxzKSB7XG4gICAqICAgICByZXR1cm4gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFscyk7XG4gICAqICAgfVxuICAgKiB9PC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcblxuICAgIHVybDogJycsXG4gICAgbG9hZGVyOiBuZXcgSlNPTkxvYWRlcigpLFxuXG4gICAgb25Mb2FkKCkge30sXG4gICAgb25Qcm9ncmVzcygpIHt9LFxuICAgIC8vIFRPRE8gYWRkIG9uQ29tcGxldGU/XG4gICAgb25FcnJvcigpIHt9LFxuXG4gICAgdGV4dHVyZVBhdGg6IG51bGwsXG4gICAgdXNlQ3VzdG9tTWF0ZXJpYWw6IGZhbHNlLFxuXG4gICAgcGFyc2VyKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuICAgICAgY29uc3Qge2dlb20sIG1hdH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtnZW9tOiBnZW9tZXRyeSwgbWF0OiBtYXRlcmlhbH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICAgIG1lc2g6IG5ldyBNZXNoKGdlb20sIG1hdClcbiAgICAgIH0pLm1lc2g7XG4gICAgfVxuICB9O1xuXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnNcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBmaWx0ZXJcbiAgICogQGRlc2NyaXB0aW9uIERlZmF1bHQgdmFsdWVzIGZvciBmaWx0ZXJcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1RIUkVFLk1lc2h9IG9iamVjdCBJbnN0YW5jZSBmb3IgaXRlcmF0aW5nIHRocm91Z2ggaXQncyBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyIEZ1bmN0aW9uIHdpdGggY2hpbGQgYXMgYXJndW1lbnQsIHNob3VsZCByZXR1cm4gYSBib29sZWFuIHdoZXRoZXIgaW5jbHVkZSB0aGUgY2hpbGQgb3Igbm90LlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBvYmplY3Qgd2l0aCBjaGlsZHJlblxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkltcG9ydGVyXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlJlbW92aW5nIHVubmVjZXNzYXJ5IGxpZ2h0cyBmcm9tIGNoaWxkcmVuPC9jYXB0aW9uPlxuICAgKiBuZXcgSW1wb3J0ZXIoe1xuICAgKiAgIGxvYWRlcjogbmV3IFRIUkVFLk9CSkxvYWRlcigpLFxuICAgKlxuICAgKiAgIHBhcnNlKGdyb3VwKSB7IC8vIGRhdGEgZnJvbSBsb2FkZXJcbiAgICogICAgIHJldHVybiBJbXBvcnRlci5maWx0ZXIoZ3JvdXAsIGNoaWxkID0+ICFjaGlsZC5pc0xpZ2h0KTsgLy8gcmVtb3ZlIGxpZ2h0c1xuICAgKiAgIH0sXG4gICAqXG4gICAqICAgcG9zaXRpb246IFswLCAxMDAsIDBdXG4gICAqIH0pLmFkZFRvKGFwcCk7XG4gICAqL1xuICBzdGF0aWMgZmlsdGVyKG9iamVjdCwgZmlsdGVyKSB7XG4gICAgY29uc3QgcHJvY2Vzc0ZpbHRlciA9IG9iamVjdCA9PiB7XG4gICAgICBvYmplY3QuY2hpbGRyZW4uZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChlbC5jaGlsZHJlbikgcHJvY2Vzc0ZpbHRlcihlbCk7XG4gICAgICAgIGlmICghZmlsdGVyKGVsKSkgb2JqZWN0LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb2Nlc3NGaWx0ZXIob2JqZWN0KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBJbXBvcnRlci5kZWZhdWx0cywgSW1wb3J0ZXIuaW5zdHJ1Y3Rpb25zLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkltcG9ydGVyXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmIChwYXJhbXMudGV4dHVyZVBhdGgpIHBhcmFtcy5sb2FkZXIuc2V0VGV4dHVyZVBhdGgocGFyYW1zLnRleHR1cmVQYXRoKTtcblxuICAgICAgcGFyYW1zLmxvYWRlci5sb2FkKHBhcmFtcy51cmwsICguLi5kYXRhKSA9PiB7IC8vIGdlb21ldHJ5LCBtYXRlcmlhbHNcbiAgICAgICAgcGFyYW1zLm9uTG9hZCguLi5kYXRhKTtcblxuICAgICAgICBjb25zdCBvYmplY3QgPSBwYXJhbXMucGFyc2VyLmFwcGx5KHRoaXMsIGRhdGEpO1xuICAgICAgICBpZiAocGFyYW1zLm1hdGVyaWFsKSBvYmplY3QubWF0ZXJpYWwgPSBwYXJhbXMubWF0ZXJpYWw7XG5cbiAgICAgICAgcmVzb2x2ZShvYmplY3QpO1xuICAgICAgfSwgcGFyYW1zLm9uUHJvZ3Jlc3MsIHBhcmFtcy5vbkVycm9yKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBJbXBvcnRlclxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSxcbiAgT2N0YWhlZHJvbkdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBPY3RhaGVkcm9uXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBJbiBnZW9tZXRyeSwgYW4gb2N0YWhlZHJvbiBpcyBhIHBvbHloZWRyb24gd2l0aCBlaWdodCBmYWNlcy5cbiAqIEEgcmVndWxhciBvY3RhaGVkcm9uIGlzIGEgUGxhdG9uaWMgc29saWQgY29tcG9zZWQgb2YgZWlnaHQgZXF1aWxhdGVyYWwgdHJpYW5nbGVzLCBmb3VyIG9mIHdoaWNoIG1lZXQgYXQgZWFjaCB2ZXJ0ZXguXG4gKiA8YnIvPjxici8+XG4gKiBgT2N0YWhlZHJvbmAgY3JlYXRlcyBhbiBPY3RhaGVkcm9uIG9iamVjdCBieSBpdHMgYHJhZGl1c2AgYW5kIGBkZXRhaWxgLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNPY3RhaGVkcm9uR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhbiBPY3RhaGVkcm9uLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBPY3RhaGVkcm9uKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXM6IDIsXG4gKiAgICAgZGV0YWlsOiAxXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjogWzAsIDEwMCwgMF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIE9jdGFoZWRyb24gZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLk9jdGFoZWRyb24jZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1czogMSxcbiAgICogICAgIGRldGFpbDogMFxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXM6IDEsXG4gICAgICBkZXRhaWw6IDBcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgT2N0YWhlZHJvbi5kZWZhdWx0cywgT2N0YWhlZHJvbi5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuT2N0YWhlZHJvblxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgKHBhcmFtcy5idWZmZXIgPyBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkgOiBPY3RhaGVkcm9uR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5kZXRhaWxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIE9jdGFoZWRyb25cbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnksXG4gIFBhcmFtZXRyaWNHZW9tZXRyeSxcbiAgVmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgUGFyYW1ldHJpY1xuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gYFBhcmFtZXRyaWNgIGdlbmVyYXRlcyBhIGdlb21ldHJ5IHJlcHJlc2VudGluZyBhIDxhIGhyZWY9J2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcmFtZXRyaWNfc3VyZmFjZSc+UGFyYW1ldHJpYyBzdXJmYWNlPC9hPlxuICogPGJyLz48YnIvPlxuICogSXQgaXMgdXN1YWxseSB1c2VkIHRvIGRldmVsb3AgZGlmZmVyZW50IGtpbmRzIG9mIGhpZ2hmaWVsZHMgb3IgdmlzdWFsaXplIGEgPGEgaHJlZj0naHR0cHM6Ly9zdGVta29za2kuZ2l0aHViLmlvL1RocmVlLmpzL0dyYXBodWx1cy1GdW5jdGlvbi5odG1sJz5tYXRoIGZ1bmN0aW9uPC9hPi5cbiAqIDxici8+XG4gKiAtIDxhIGhyZWY9J2h0dHA6Ly9tYXRoLmh3cy5lZHUvZ3JhcGhpY3Nib29rL3NvdXJjZS90aHJlZWpzL2N1cnZlcy1hbmQtc3VyZmFjZXMuaHRtbCc+UGFyYW1ldHJpYyBzdXJmYWNlPC9hPlxuICogLSA8YSBocmVmPSdodHRwczovL3N0ZW1rb3NraS5naXRodWIuaW8vVGhyZWUuanMvR3JhcGh1bHVzLVN1cmZhY2UuaHRtbCc+XCJHcmFwaHVsdXNcIjwvYT5cbiAqIDxici8+PGJyLz5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjUGFyYW1ldHJpY0dlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSBjcmVhdGluZyBhbiBoZWlnaHRmaWVsZC1saWtlIGdlb21ldHJ5LiBgdWAgYW5kIGB2YCBhcmUgbGlrZSBgeGAgYW5kIGB5YCBpbiBzaGFwZSwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgYWx3YXlzIGZyb20gYDBgIHRvIGAxYC5cbiAqIFdlIHVzZSB0aGVtIGluIGBUSFJFRS5WZWN0b3IzYCBsaWtlIGB4YCBhbmQgYHpgIGFuZCBgTWF0aC5yYW5kb20oKSAqIDVgIGZvciBgeWAuPC9jYXB0aW9uPlxuICogY29uc3QgY3JlYXRlUGFyYW1ldHJpYyA9ICh1LCB2KSA9PiB7XG4gKiAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyh1ICogMzAsIE1hdGgucmFuZG9tKCkgKiA1LCB2ICogMzApO1xuICogfVxuICpcbiAqIG5ldyBQYXJhbWV0cmljKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICBmdW5jOiBjcmVhdGVQYXJhbWV0cmljXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZixcbiAqICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IFswLCAxMDAsIC0xMDBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBQYXJhbWV0cmljIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5QYXJhbWV0cmljI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICBmdW5jOiAodSwgdikgPT4gbmV3IFZlY3RvcjModSwgdiwgMCksXG4gICAqICAgICBzbGljZXM6IDEwLFxuICAgKiAgICAgdGFja3M6IDEwXG4gICAqICAgfVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIGZ1bmM6ICh1LCB2KSA9PiBuZXcgVmVjdG9yMyh1LCB2LCAwKSxcbiAgICAgIHNsaWNlczogMTAsXG4gICAgICBzdGFja3M6IDEwXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFBhcmFtZXRyaWMuZGVmYXVsdHMsIFBhcmFtZXRyaWMuaW5zdHJ1Y3Rpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUGFyYW1ldHJpY1xuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgKHBhcmFtcy5idWZmZXIgPyBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkgOiBQYXJhbWV0cmljR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmZ1bmMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuc2xpY2VzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnN0YWNrc1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgUGFyYW1ldHJpY1xufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFBsYW5lQnVmZmVyR2VvbWV0cnksXG4gIFBsYW5lR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIFBsYW5lXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBgUGxhbmVgIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHBsYW5lcyBnaXZlbiBzb21lIGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNQbGFuZUdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBQbGFuZSwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgUGxhbmUoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHdpZHRoOiAyMCxcbiAqICAgICBoZWlnaHQ6IDMwXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSlcbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFBsYW5lIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5QbGFuZSNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgd2lkdGg6IDEwLFxuICAgKiAgICAgaGVpZ2h0OiAxMCxcbiAgICogICAgIHdTZWdtZW50czogMSxcbiAgICogICAgIGhTZWdtZW50czogMVxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB3aWR0aDogMTAsXG4gICAgICBoZWlnaHQ6IDEwLFxuICAgICAgd1NlZ21lbnRzOiAxLFxuICAgICAgaFNlZ21lbnRzOiAxXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUGxhbmUjaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiBbJ3dpZHRoJywgJ2hlaWdodCcsICd3U2VnbWVudHMnLCAnaFNlZ21lbnRzJ11cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3dTZWdtZW50cycsICdoU2VnbWVudHMnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBQbGFuZS5kZWZhdWx0cywgUGxhbmUuaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlBsYW5lXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgKHBhcmFtcy5idWZmZXIgPyBQbGFuZUJ1ZmZlckdlb21ldHJ5IDogUGxhbmVHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkud2lkdGgsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaGVpZ2h0LFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LndTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5oU2VnbWVudHNcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFBsYW5lXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxuICBQb2x5aGVkcm9uR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbmNvbnN0IFt2ZXJ0aWNlc09mQ3ViZSwgaW5kaWNlc09mRmFjZXNdID0gW1xuICBbXG4gICAgLTEsIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIC0xLFxuICAgIC0xLCAtMSwgMSwgMSwgLTEsIDEsIDEsIDEsIDEsIC0xLCAxLCAxXG4gIF0sXG4gIFtcbiAgICAyLCAxLCAwLCAwLCAzLCAyLFxuICAgIDAsIDQsIDcsIDcsIDMsIDAsXG4gICAgMCwgMSwgNSwgNSwgNCwgMCxcbiAgICAxLCAyLCA2LCA2LCA1LCAxLFxuICAgIDIsIDMsIDcsIDcsIDYsIDIsXG4gICAgNCwgNSwgNiwgNiwgNywgNFxuICBdXG5dO1xuXG4vKipcbiAqIEBjbGFzcyBQb2x5aGVkcm9uXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBJbiBlbGVtZW50YXJ5IGdlb21ldHJ5LCBhIHBvbHloZWRyb24gaXMgYSBzb2xpZCBpbiB0aHJlZSBkaW1lbnNpb25zIHdpdGggZmxhdCBwb2x5Z29uYWwgZmFjZXMsIHN0cmFpZ2h0IGVkZ2VzIGFuZCBzaGFycCBjb3JuZXJzIG9yIHZlcnRpY2VzLlxuICogPGJyLz48YnIvPlxuICogYFBvbHloZWRyb25gIGNyZWF0ZXMgYSBQb2x5aGVkcm9uIGJ5IGl0cyBgcmFkaXVzYCBhbmQgYGRldGFpbGAuXG4gKiA8YnIvPjxici8+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYW4gUG9seWhlZHJvbiwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgUG9seWhlZHJvbih7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgcmFkaXVzOiAyLFxuICogICAgIGRldGFpbDogMVxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IFswLCAxMDAsIDBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBQb2x5aGVkcm9uIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIHN0YXRpYyB2ZXJ0aWNlc09mQ3ViZSA9IHZlcnRpY2VzT2ZDdWJlO1xuICBzdGF0aWMgaW5kaWNlc09mRmFjZXMgPSBpbmRpY2VzT2ZGYWNlcztcblxuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUG9seWhlZHJvbiNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgdmVydGljZXNPZkN1YmU6IFtcbiAgICogICAgICAgLTEsIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIC0xLFxuICAgKiAgICAgICAtMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAxLCAxLCAtMSwgMSwgMVxuICAgKiAgICAgXSxcbiAgICpcbiAgICogICAgIGluZGljZXNPZkZhY2VzOiBbXG4gICAqICAgICAgIDIsIDEsIDAsIDAsIDMsIDIsXG4gICAqICAgICAgIDAsIDQsIDcsIDcsIDMsIDAsXG4gICAqICAgICAgIDAsIDEsIDUsIDUsIDQsIDAsXG4gICAqICAgICAgIDEsIDIsIDYsIDYsIDUsIDEsXG4gICAqICAgICAgIDIsIDMsIDcsIDcsIDYsIDIsXG4gICAqICAgICAgIDQsIDUsIDYsIDYsIDcsIDRcbiAgICogICAgIF0sXG4gICAqXG4gICAqICAgICByYWRpdXM6IDYsXG4gICAqICAgICBkZXRhaWw6IDJcbiAgICogICB9XG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgdmVydGljZXNPZkN1YmUsXG4gICAgICBpbmRpY2VzT2ZGYWNlcyxcbiAgICAgIHJhZGl1czogNixcbiAgICAgIGRldGFpbDogMlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlBvbHloZWRyb24jaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiBbJ3ZlcnRpY2VzT2ZDdWJlJywgJ2luZGljZXNPZkZhY2VzJywgJ3JhZGl1cycsICdkZXRhaWwnXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWyd2ZXJ0aWNlc09mQ3ViZScsICdpbmRpY2VzT2ZGYWNlcycsICdyYWRpdXMnLCAnZGV0YWlsJ11cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgUG9seWhlZHJvbi5kZWZhdWx0cywgUG9seWhlZHJvbi5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUG9seWhlZHJvblxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgKHBhcmFtcy5idWZmZXIgPyBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkgOiBQb2x5aGVkcm9uR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnZlcnRpY2VzT2ZDdWJlLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmluZGljZXNPZkZhY2VzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5kZXRhaWxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFBvbHloZWRyb25cbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBSaW5nR2VvbWV0cnksXG4gIFJpbmdCdWZmZXJHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgUmluZ1xuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gUmluZyBjbGFzcyBjcmVhdGVzIGEgY2lyY2xlIG9yIGp1c3QgMkQgVG9ydXMuIERvZXMgbm90IHN1cHBvcnQgcGh5c2ljcy5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjUmluZ0dlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBSaW5nLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBSaW5nKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICBpbm5lclJhZGl1czogNSxcbiAqICAgICBvdXRlclJhZGl1czogMlxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmYsXG4gKiAgICAgc2lkZSBUSFJFRS5Eb3VibGVTaWRlXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IFswLCA4LCAwXSxcbiAqXG4gKiAgIHJvdGF0aW9uOiB7XG4gKiAgICAgeDogTWF0aC5QSS80XG4gKiAgIH1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFJpbmcgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlJpbmcjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIGlubmVyUmFkaXVzOiAwLFxuICAgKiAgICAgb3V0ZXJSYWRpdXM6IDUwLFxuICAgKiAgICAgdGhldGFTZWdtZW50czogOCxcbiAgICogICAgIHBoaVNlZ21lbnRzOiA4LFxuICAgKiAgICAgdGhldGFTdGFydDogMCxcbiAgICogICAgIHRoZXRhTGVuZ3RoOiBNYXRoLlBJICogMlxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgIG91dGVyUmFkaXVzOiA1MCxcbiAgICAgIHRoZXRhU2VnbWVudHM6IDgsXG4gICAgICBwaGlTZWdtZW50czogOCxcbiAgICAgIHRoZXRhU3RhcnQ6IDAsXG4gICAgICB0aGV0YUxlbmd0aDogTWF0aC5QSSAqIDJcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5SaW5nI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeTogW1xuICAgKiAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICogICAgICdvdXRlclJhZGl1cycsXG4gICAqICAgICAndGhldGFTZWdtZW50cycsXG4gICAqICAgICAncGhpU2VnbWVudHMnLFxuICAgKiAgICAgJ3RoZXRhU3RhcnQnLFxuICAgKiAgICAgJ3RoZXRhTGVuZ3RoJ1xuICAgKiAgIF1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeTogW1xuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAndGhldGFTZWdtZW50cycsXG4gICAgICAncGhpU2VnbWVudHMnLFxuICAgICAgJ3RoZXRhU3RhcnQnLFxuICAgICAgJ3RoZXRhTGVuZ3RoJ1xuICAgIF1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgUmluZy5kZWZhdWx0cywgUmluZy5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUmluZ1xuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgKHBhcmFtcy5idWZmZXIgPyBSaW5nQnVmZmVyR2VvbWV0cnkgOiBSaW5nR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmlubmVyUmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5Lm91dGVyUmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnRoZXRhU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucGhpU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudGhldGFTdGFydCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS50aGV0YUxlbmd0aFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgUmluZ1xufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFNoYXBlQnVmZmVyR2VvbWV0cnksXG4gIFNoYXBlR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIFNoYXBlXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBTaGFwZSBpcyBhIHVuaXZlcnNhbCBjbGFzcy4gSXQgYWxsb3dzIHlvdSB0byBjcmVhdGUgZGlmZmVyZW50IDJEIHNoYXBlcyBpbiAzRCBzY2VuZS48YnIvPlxuICogVW5mb3J0dW5hdGVseSwgbm90IGFsbCBvZiB0aGVtIHN1cHBvcnQgcGh5c2ljcywgYW4gYWx0ZXJuYXRpdmUgaXMgdG8gbWFrZSBhIHNpbWlsYXIgM0Qgb2JqZWN0IGFuZCBzY2FsZSBpdHMgd2lkdGggZG93biB0byBuZWFyIHplcm8uXG4gKiA8YnIvPjxici8+XG4gKiBgU2hhcGVgIGNvbnNpc3RzIG9mIHNoYXBlcyB0aGF0IGFyZSBpbiBpdHMgc2hhcGVzIHBhcmFtZXRlci5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjU2hhcGVHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgcGxhbmUgbG9va2luZyBTaGFwZSBmcm9tIGEgVEhSRUUuU2hhcGUsIGFuZCBhZGRpbmcgaXQgdG8gYXBwPC9jYXB0aW9uPlxuICogY29uc3QgcmVjdFdpZHRoID0gMTAsXG4gKiByZWN0TGVuZ3RoID0gNTtcbiAqXG4gKiBjb25zdCByZWN0U2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAqIHJlY3RTaGFwZS5tb3ZlVG8oMCwwKTtcbiAqIHJlY3RTaGFwZS5saW5lVG8oMCwgcmVjdFdpZHRoKTtcbiAqIHJlY3RTaGFwZS5saW5lVG8ocmVjdExlbmd0aCwgcmVjdFdpZHRoKTtcbiAqIHJlY3RTaGFwZS5saW5lVG8ocmVjdExlbmd0aCwgMCk7XG4gKiByZWN0U2hhcGUubGluZVRvKDAsIDApO1xuICpcbiAqIGNvbnN0IHBsYW5lID0gbmV3IFNoYXBlKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICBzaGFwZTogcmVjdFNoYXBlXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSlcbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFNoYXBlIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5TaGFwZSNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgc2hhcGVzOiBbXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHNoYXBlczogW11cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5TaGFwZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFsnc2hhcGVzJ11cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFsnc2hhcGVzJ11cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgU2hhcGUuZGVmYXVsdHMsIFNoYXBlLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5TaGFwZVxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgKHBhcmFtcy5idWZmZXIgPyBTaGFwZUJ1ZmZlckdlb21ldHJ5IDogU2hhcGVHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuc2hhcGVzXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBTaGFwZVxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFNwaGVyZUJ1ZmZlckdlb21ldHJ5LFxuICBTcGhlcmVHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgU3BoZXJlXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBTcGhlcmUgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgc3BoZXJlIG9iamVjdHMgYnkgaXRzIHJhZGl1cyBwcm9wZXJ0eSBhbmQgb3RoZXIgdmFsdWVzIHRoYXQgZGV0ZXJtaW5lcyBpdHMgZGV0YWxpdHkuXG4gKiA8YnIvPjxici8+XG4gKiBJdCBpcyBzaW1pbGFyIHRvIFRIUkVFLlNwaGVyZUdlb21ldHJ5LCBidXQgaXQgYWxzbyBjb250YWlucyBhbGwgYFNoYXBlYCBwcm9wZXJ0aWVzLCBzdWNoIGFzIG1hdGVyaWFsLCBtYXNzIGFuZCB2ZWN0b3JzIGxpa2UgcG9zaXRpb24gKHBvcykgYW5kIHJvdGF0aW9uIChyb3QpLlxuICogPGJyLz48YnIvPlxuICogVGhlbiBpdCBjcmVhdGVzIGFuIGBUaHJlZS5qcyBtZXNoYCBvciBhIGBQaHlzaWpzIG1lc2hgLCB0aGF0IGlzIHNpbWlsYXIgdG8gYFRocmVlLmpzIG1lc2hgLCBidXQgaXQgYWxzbyB0YWtlIGludG8gY29uc2lkZXJhdGlvbiBjb2xsaXNpb24gY2FsY3VsYXRpb25zLlxuICogVGhpcyBtZXNoIGlzIGEgY29tYmluYXRpb24gb2YgYFRocmVlLmpzIGdlb21ldHJ5YCBhbmQgYFBoeXNpanMgbWF0ZXJpYWxgIChUaGUgc2FtZSBhcyBpbiB0aHJlZS5qcywgYnV0IHdpdGggZnJpY3Rpb24gYW5kIHJlc3RpdHV0aW9uKS5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjU3BoZXJlR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIFNwaGVyZSwgYW5kIGFkZGluZyBpdCB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgU3BoZXJlKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXM6IDJcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgeTogMTAwXG4gKiAgIH1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFNwaGVyZSBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuU3BoZXJlI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICByYWRpdXM6IDEsXG4gICAqICAgICB3aWR0aFNlZ21lbnRzOiA4LFxuICAgKiAgICAgaGVpZ2h0U2VnbWVudHM6IDZcbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXM6IDEsXG4gICAgICB3aWR0aFNlZ21lbnRzOiA4LFxuICAgICAgaGVpZ2h0U2VnbWVudHM6IDZcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5TcGhlcmUjaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiBbJ3JhZGl1cycsICd3aWR0aFNlZ21lbnRzJywgJ2hlaWdodFNlZ21lbnRzJ11cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFsncmFkaXVzJywgJ3dpZHRoU2VnbWVudHMnLCAnaGVpZ2h0U2VnbWVudHMnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBTcGhlcmUuZGVmYXVsdHMsIFNwaGVyZS5pbnN0cnVjdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5TcGhlcmVcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyAocGFyYW1zLmJ1ZmZlciA/IFNwaGVyZUJ1ZmZlckdlb21ldHJ5IDogU3BoZXJlR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS53aWR0aFNlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmhlaWdodFNlZ21lbnRzXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBTcGhlcmVcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxuICBUZXRyYWhlZHJvbkdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBUZXRyYWhlZHJvblxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gSW4gZ2VvbWV0cnksIGEgdGV0cmFoZWRyb24gaXMgYSBwb2x5aGVkcm9uIGNvbXBvc2VkIG9mIGZvdXIgdHJpYW5ndWxhciBmYWNlcywgc2l4IHN0cmFpZ2h0IGVkZ2VzLCBhbmQgZm91ciB2ZXJ0ZXggY29ybmVycy5cbiAqIFRoZSB0ZXRyYWhlZHJvbiBpcyB0aGUgc2ltcGxlc3Qgb2YgYWxsIHRoZSBvcmRpbmFyeSBjb252ZXggcG9seWhlZHJhIGFuZCB0aGUgb25seSBvbmUgdGhhdCBoYXMgZmV3ZXIgdGhhbiA1IGZhY2VzLlxuICogPGJyLz48YnIvPlxuICogYFRldHJhaGVkcm9uYCBjcmVhdGVzIGEgVGV0cmFoZWRyb24gb2JqZWN0IGJ5IGl0cyBgcmFkaXVzYCBhbmQgYGRldGFpbGBcbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjVGV0cmFoZWRyb25HZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgVGV0cmFoZWRyb24sIGFuZCBhZGRpbmcgaXQgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IFRldHJhaGVkcm9uKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXM6IDIsXG4gKiAgICAgZGV0YWlsOiAxXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjoge1xuICogICAgIHg6IDAsXG4gKiAgICAgeTogMTAwLFxuICogICAgIHo6IDBcbiAqICAgfVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgVGV0cmFoZWRyb24gZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRldHJhaGVkcm9uI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICByYWRpdXM6IDEsXG4gICAqICAgICBkZXRhaWw6IDBcbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXM6IDEsXG4gICAgICBkZXRhaWw6IDBcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5UZXRyYWhlZHJvbiNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFsncmFkaXVzJywgJ2RldGFpbCddXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ3JhZGl1cycsICdkZXRhaWwnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBUZXRyYWhlZHJvbi5kZWZhdWx0cywgVGV0cmFoZWRyb24uaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRldHJhaGVkcm9uXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkgOiBUZXRyYWhlZHJvbkdlb21ldHJ5KShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpdXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuZGV0YWlsXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBUZXRyYWhlZHJvblxufTtcbiIsImltcG9ydCB7XG4gIEZvbnQsXG4gIE1lc2gsXG4gIFRleHRHZW9tZXRyeSxcbiAgRm9udExvYWRlclxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgVGV4dFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gVGV4dCBjbGFzcyBpcyBtYWRlIGZvciBjcmVhdGluZyAzRCB0ZXh0IG9iamVjdHMuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI1RleHRHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogPGJyLz48YnIvPlxuICogUGh5c2ljcyB0ZXh0IG9iamVjdCBjYW4gYmUgY29udmV4IG9yIGNvbmNhdmUuIEJ5IGRlZmF1bHQgaXQncyBjb252ZXggYnV0IHlvdSBjYW4gYWxzbyBzd2l0Y2ggdG8gY29uY2F2ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIFRleHQsIGFuZCBhZGRpbmcgaXQgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IFRleHQoe1xuICogICAgIHRleHQ6ICdTb21lIHRleHQnLFxuICogICAgIHBhcmFtZXRlcnM6IHtcbiAqICAgICAgIGZvbnQ6ICdwYXRoL3RvL2ZvbnQudHlwZWZhY2UuanMnLFxuICogICAgICAgc2l6ZTogMjAsXG4gKiAgICAgICBoZWlnaHQ6IDUsXG4gKiAgICAgICBjdXJ2ZVNlZ21lbnRzOiA2XG4gKiAgICAgfVxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB4OiAtNDAsXG4gKiAgICAgeTogMjAsXG4gKiAgICAgejogMFxuICogICB9XG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5UZXh0I2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIHRleHQ6ICdIZWxsbyBXb3JsZCEnLFxuICAgKiAgIGZvbnQ6IG51bGwsXG4gICAqXG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHNpemU6IDEyLFxuICAgKiAgICAgaGVpZ2h0OiA1MCxcbiAgICogICAgIGN1cnZlU2VnbWVudHM6IDEyLFxuICAgKiAgICAgZm9udDogbmV3IEZvbnQoKSxcbiAgICogICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXG4gICAqICAgICBiZXZlbFRoaWNrbmVzczogMTAsXG4gICAqICAgICBiZXZlbFNpemU6IDhcbiAgICogICB9XG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICB0ZXh0OiAnSGVsbG8gV29ybGQhJyxcbiAgICBmb250OiBudWxsLFxuXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHNpemU6IDEyLFxuICAgICAgaGVpZ2h0OiA1MCxcbiAgICAgIGN1cnZlU2VnbWVudHM6IDEyLFxuICAgICAgZm9udDogbmV3IEZvbnQoKSxcbiAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXG4gICAgICBiZXZlbFRoaWNrbmVzczogMTAsXG4gICAgICBiZXZlbFNpemU6IDhcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9uc1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IEZvbnRMb2FkZXJcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVGV4dCNsb2FkZXJcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCBuZXcgRm9udExvYWRlcigpXG4gICAqL1xuICBzdGF0aWMgbG9hZGVyID0gbmV3IEZvbnRMb2FkZXIoKTtcblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzdGF0aWNcbiAgICogQGRlc2NyaXB0aW9uIGxvYWQoKSBwcmVsb2FkcyBhIEZvbnQgb2JqZWN0IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB3aXRoIGl0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHRvIHRoZSBmb250XG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgZm9udFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRleHRcbiAgICovXG4gIHN0YXRpYyBsb2FkKHBhdGgsIGxvYWRlciA9IFRleHQubG9hZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9hZGVyLmxvYWQocGF0aCwgcmVzb2x2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgVGV4dC5kZWZhdWx0cywgVGV4dC5pbnN0cnVjdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGlzIGNhbGxlZCBhcyBwYXJ0IG9mIHRoZSBsaWZlY3ljbGUgdG8gY3JlYXRlIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5UZXh0XG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIChwYXJhbXMuZm9udCBpbnN0YW5jZW9mIFByb21pc2UgPyBwYXJhbXMuZm9udCA6IFByb21pc2UucmVzb2x2ZShwYXJhbXMuZm9udCkpXG4gICAgICAudGhlbihmb250ID0+IHtcbiAgICAgICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgICAgICBnZW9tZXRyeTogbmV3IFRleHRHZW9tZXRyeShcbiAgICAgICAgICAgIHBhcmFtcy50ZXh0LFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgcGFyYW1zLmdlb21ldHJ5LFxuICAgICAgICAgICAgICB7Zm9udH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuXG4gICAgICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgICAgICB9KTtcblxuICAgICAgICByZXNvbHZlKFxuICAgICAgICAgIHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgICAgICAgbWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKVxuICAgICAgICAgIH0pLm1lc2hcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc3VwZXIud2FpdChwcm9taXNlKTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFRleHRcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBUb3J1c0dlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBUb3J1c1xuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gVG9ydXMgY2xhc3MgbWFrZXMgYSB0b3J1cyBmaWd1cmUuIEEgZG9udXQgaXMgYSB0b3J1cy5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL2luZGV4Lmh0bWwjYXBpL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgVG9ydXMsIGFuZCBhZGRpbmcgaXQgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IFRvcnVzKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXM6IDUsXG4gKiAgICAgdHViZTogMlxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB5OiAzNVxuICogICB9XG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBUb3J1cyBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVG9ydXMjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1czogMTAwLFxuICAgKiAgICAgdHViZTogNDAsXG4gICAqICAgICByYWRpYWxTZWdtZW50czogOCxcbiAgICogICAgIHR1YnVsYXJTZWdtZW50czogNixcbiAgICogICAgIGFyYzogTWF0aC5QSSAqIDJcbiAgICogICB9XG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgcmFkaXVzOiAxMDAsXG4gICAgICB0dWJlOiA0MCxcbiAgICAgIHJhZGlhbFNlZ21lbnRzOiA4LFxuICAgICAgdHVidWxhclNlZ21lbnRzOiA2LFxuICAgICAgYXJjOiBNYXRoLlBJICogMlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRvcnVzI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeTogW1xuICAgKiAgICAgJ3JhZGl1cycsXG4gICAqICAgICAndHViZScsXG4gICAqICAgICAncmFkaWFsU2VnbWVudHMnLFxuICAgKiAgICAgJ3R1YnVsYXJTZWdtZW50cycsXG4gICAqICAgICAnYXJjJ1xuICAgKiAgIF1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFtcbiAgICAgICdyYWRpdXMnLFxuICAgICAgJ3R1YmUnLFxuICAgICAgJ3JhZGlhbFNlZ21lbnRzJyxcbiAgICAgICd0dWJ1bGFyU2VnbWVudHMnLFxuICAgICAgJ2FyYydcbiAgICBdXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFRvcnVzLmRlZmF1bHRzLCBUb3J1cy5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVG9ydXNcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFRvcnVzR2VvbWV0cnkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnR1YmUsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaWFsU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudHVidWxhclNlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmFyY1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgVG9ydXNcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSxcbiAgVG9ydXNLbm90R2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIFRvcnVza25vdFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gVG9ydXNrbm90IGNsYXNzIG1ha2VzIGEgdG9ydXNrbm90IGZpZ3VyZS4gSXQncyBsaWtlIGEgY3Jvb2tlZCBkb251dCwgdmVyeSBjcm9va2VkLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNUb3J1c0tub3RHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgVG9ydXNrbm90LCBhbmQgYWRkaW5nIGl0IHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBUb3J1c2tub3Qoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1czo1LFxuICogICAgIHR1YmU6IDJcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvczoge1xuICogICAgIHk6IDEwMFxuICogICB9XG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBUb3J1c2tub3QgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRvcnVza25vdCNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgcmFkaXVzOiAxMDAsXG4gICAqICAgICB0dWJlOiA0MCxcbiAgICogICAgIHJhZGlhbFNlZ21lbnRzOiA2NCxcbiAgICogICAgIHR1YnVsYXJTZWdtZW50czogOCxcbiAgICogICAgIHA6IDIsXG4gICAqICAgICBxOiAzXG4gICAqICAgfVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogMTAwLFxuICAgICAgdHViZTogNDAsXG4gICAgICByYWRpYWxTZWdtZW50czogNjQsXG4gICAgICB0dWJ1bGFyU2VnbWVudHM6IDgsXG4gICAgICBwOiAyLFxuICAgICAgcTogM1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRvcnVza25vdCNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFtcbiAgICogICAgICdyYWRpdXMnLFxuICAgKiAgICAgJ3R1YmUnLFxuICAgKiAgICAgJ3JhZGlhbFNlZ21lbnRzJyxcbiAgICogICAgICd0dWJ1bGFyU2VnbWVudHMnLFxuICAgKiAgICAgJ3AnLFxuICAgKiAgICAgJ3EnXG4gICAqICAgXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogW1xuICAgICAgJ3JhZGl1cycsXG4gICAgICAndHViZScsXG4gICAgICAncmFkaWFsU2VnbWVudHMnLFxuICAgICAgJ3R1YnVsYXJTZWdtZW50cycsXG4gICAgICAncCcsXG4gICAgICAncSdcbiAgICBdXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFRvcnVza25vdC5kZWZhdWx0cywgVG9ydXNrbm90Lmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Ub3J1c2tub3RcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBHQ29uc3RydWN0ID0gcGFyYW1zLmJ1ZmZlciA/IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5IDogVG9ydXNLbm90R2VvbWV0cnk7XG5cbiAgICByZXR1cm4gbmV3IEdDb25zdHJ1Y3QoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnR1YmUsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaWFsU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudHVidWxhclNlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnAsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgVG9ydXNrbm90XG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgTGluZUN1cnZlMyxcbiAgVmVjdG9yMyxcbiAgVHViZUJ1ZmZlckdlb21ldHJ5LFxuICBUdWJlR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIFR1YmVcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIFR1YmUgY2xhc3MgbWFrZXMgYSB0dWJlIHRoYXQgZXh0cnVkZXMgYWxvbmcgYSAzZCBjdXJ2ZS5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL2luZGV4Lmh0bWwjYXBpL2dlb21ldHJpZXMvVHViZUdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBUdWJlIGZyb20gYSB0aHJlZS5qcyBDdXJ2ZSwgYW5kIGFkZGluZyBpdCB0byBhcHA8L2NhcHRpb24+XG4gKiBjb25zdCBDdXN0b21TaW5DdXJ2ZSA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcbiAqICAgZnVuY3Rpb24gKHNjYWxlKSB7IC8vIGN1c3RvbSBjdXJ2ZSBjb25zdHJ1Y3RvclxuICogICAgIHRoaXMuc2NhbGUgPSAoc2NhbGUgPT09IHVuZGVmaW5lZCkgPyAxIDogc2NhbGU7XG4gKiAgIH0sXG4gKlxuICogICBmdW5jdGlvbiAodCkgeyAvLyBnZXRQb2ludDogdCBpcyBiZXR3ZWVuIDAtMVxuICogICAgIGNvbnN0IHR4ID0gdCAqIDMgLSAxLjUsXG4gKiAgICAgdHkgPSBNYXRoLnNpbiggMiAqIE1hdGguUEkgKiB0ICksXG4gKiAgICAgdHogPSAwO1xuICpcbiAqICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjModHgsIHR5LCB0eikubXVsdGlwbHlTY2FsYXIodGhpcy5zY2FsZSk7XG4gKiAgIH1cbiAqICk7XG4gKlxuICogY29uc3QgcGF0aCA9IG5ldyBDdXN0b21TaW5DdXJ2ZSgxMCk7XG4gKlxuICogbmV3IFR1YmUoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHBhdGg6IHBhdGhcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgVHViZSBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVHViZSNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgcGF0aDogbmV3IFRIUkVFLkxpbmVDdXJ2ZTMobmV3IFZlY3RvcjMoMCwgMCwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpKSxcbiAgICogICAgIHNlZ21lbnRzOiAyMCxcbiAgICogICAgIHJhZGl1czogMixcbiAgICogICAgIHJhZGl1c1NlZ21lbnRzOiA4LFxuICAgKiAgICAgY2xvc2VkOiBmYWxzZVxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICBwYXRoOiBuZXcgTGluZUN1cnZlMyhuZXcgVmVjdG9yMygwLCAwLCAwKSwgbmV3IFZlY3RvcjMoMCwgMCwgMSkpLFxuICAgICAgc2VnbWVudHM6IDIwLFxuICAgICAgcmFkaXVzOiAyLFxuICAgICAgcmFkaXVzU2VnbWVudHM6IDgsXG4gICAgICBjbG9zZWQ6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVHViZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFtcbiAgICogICAgICdwYXRoJyxcbiAgICogICAgICdzZWdtZW50cycsXG4gICAqICAgICAncmFkaXVzJyxcbiAgICogICAgICdyYWRpdXNTZWdtZW50cycsXG4gICAqICAgICAnY2xvc2VkJ1xuICAgKiAgIF1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFtcbiAgICAgICdwYXRoJyxcbiAgICAgICdzZWdtZW50cycsXG4gICAgICAncmFkaXVzJyxcbiAgICAgICdyYWRpdXNTZWdtZW50cycsXG4gICAgICAnY2xvc2VkJ1xuICAgIF1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgVHViZS5kZWZhdWx0cywgVHViZS5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVHViZVxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IChwYXJhbXMuYnVmZmVyID8gVHViZUJ1ZmZlckdlb21ldHJ5IDogVHViZUdlb21ldHJ5KShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5wYXRoLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnNlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpdXNTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5jbG9zZWRcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFR1YmVcbn07XG4iLCJpbXBvcnQge09iamVjdDNEfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9Db21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBHcm91cFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gU29tZXRpbWVzIHlvdSBuZWVkIHRvIG1ha2UgZ3JvdXBzIG9mIG9iamVjdHMgKGl0J3Mgbm90IGNvbnZlbmllbnRseSB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIGVhY2ggb2JqZWN0IHdoZW4gY2FuIG1ha2UganVzdCBvbmUgdG8gYSBncm91cCkuPGJyLz5cbiAqIEluIFRocmVlLmpzIHlvdSBtYWtlIGl0IHVzaW5nIGBUSFJFRS5PYmplY3QzRGAgYW5kIGl0J3MgY2hpbGRyZW4uIDxici8+PGJyLz5cbiAqIEluIHdocy5qcyB3ZSBoYXZlIGBHcm91cGBcbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFwcHJvYWNoIDIgLSBBZGRpbmcgb2JqZWN0cyB0byBhbiBlbXB0eSBncm91cDwvY2FwdGlvbj5cbiAqIGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcbiAqIGNvbnN0IGJveCA9IG5ldyBCb3goKTtcbiAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKCk7XG4gKlxuICogc3BoZXJlLmFkZFRvKGdyb3VwKTtcbiAqIGJveC5hZGRUbyhncm91cCk7XG4qIEBleGFtcGxlIDxjYXB0aW9uPkFwcHJvYWNoIDIgLSBNYWtpbmcgYSBncm91cCBmcm9tIG9iamVjdHM8L2NhcHRpb24+XG4gKiBjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gKiBjb25zdCBib3ggPSBuZXcgQm94KCk7XG4gKiBjb25zdCBncm91cCA9IG5ldyBHcm91cChib3gsIHNwaGVyZSk7XG4gKiAvLyBPUjogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoW2JveCwgc3BoZXJlXSk7XG4gKi9cbmNsYXNzIEdyb3VwIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLm9iamVjdHMpIHtcbiAgICBzdXBlcih7fSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9iaiA9IG9iamVjdHNbaV07XG5cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBDb21wb25lbnQpIG9iai5hZGRUbyh0aGlzKTtcbiAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE9iamVjdDNEKSB0aGlzLm5hdGl2ZS5hZGQob2JqKTtcbiAgICB9XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdDNEKCk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgR3JvdXBcbn07XG4iLCIvKiogQG1vZHVsZSBjb21wb25lbnRzL21lc2hlcyAqL1xuZXhwb3J0ICogZnJvbSAnLi9Cb3gnO1xuZXhwb3J0ICogZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0ICogZnJvbSAnLi9Db25lJztcbmV4cG9ydCAqIGZyb20gJy4vQ3lsaW5kZXInO1xuZXhwb3J0ICogZnJvbSAnLi9Eb2RlY2FoZWRyb24nO1xuZXhwb3J0ICogZnJvbSAnLi9FeHRydWRlJztcbmV4cG9ydCAqIGZyb20gJy4vSWNvc2FoZWRyb24nO1xuZXhwb3J0ICogZnJvbSAnLi9MYXRoZSc7XG5leHBvcnQgKiBmcm9tICcuL0xpbmUnO1xuZXhwb3J0ICogZnJvbSAnLi9JbXBvcnRlcic7XG5leHBvcnQgKiBmcm9tICcuL09jdGFoZWRyb24nO1xuZXhwb3J0ICogZnJvbSAnLi9QYXJhbWV0cmljJztcbmV4cG9ydCAqIGZyb20gJy4vUGxhbmUnO1xuZXhwb3J0ICogZnJvbSAnLi9Qb2x5aGVkcm9uJztcbmV4cG9ydCAqIGZyb20gJy4vUmluZyc7XG5leHBvcnQgKiBmcm9tICcuL1NoYXBlJztcbmV4cG9ydCAqIGZyb20gJy4vU3BoZXJlJztcbmV4cG9ydCAqIGZyb20gJy4vVGV0cmFoZWRyb24nO1xuZXhwb3J0ICogZnJvbSAnLi9UZXh0JztcbmV4cG9ydCAqIGZyb20gJy4vVG9ydXMnO1xuZXhwb3J0ICogZnJvbSAnLi9Ub3J1c2tub3QnO1xuZXhwb3J0ICogZnJvbSAnLi9UdWJlJztcbmV4cG9ydCAqIGZyb20gJy4vR3JvdXAnO1xuIiwiLyoqXG4gKiBAY2xhc3MgRWxlbWVudE1vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRhaW5lcj1kb2N1bWVudC5ib2R5XSBjb250YWluZXIgaXMgdGhlIERPTSBvYmplY3QgdG8gd2hpY2ggYXBwbGljYXRpb24ncyBjYW52YXMgd2lsbCBiZSBhZGRlZCB0by5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHBcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGFuIGVsZW1lbnQgbW9kdWxlLCBwYXNzaW5nIGl0IHRvIHRoZSBBcHA8L2NhcHRpb24+XG4gKiBuZXcgQXBwKFtcbiAqICAgbmV3IEVsZW1lbnRNb2R1bGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKVxuICogXSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBFbGVtZW50TW9kdWxlIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyID0gZG9jdW1lbnQuYm9keSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbmVyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0VsZW1lbnRNb2R1bGUgbm93IGFjY2VwdHMgb25seSBhcmd1bWVudCB3aGljaCBpcyBhIERPTSBvYmplY3QsIG5vdCBhIHBhcmFtcyBvYmplY3QuJyk7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lci5jb250YWluZXI7XG4gICAgfSBlbHNlIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgdGhpcy5jcmVhdGVFbGVtZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjcmVhdGVFbGVtZW50XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIGNhbnZhcyBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlc2l6ZU1vZHVsZVxuICAgKi9cbiAgY3JlYXRlRWxlbWVudCgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gJ3docy1hcHAnO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICdpbmhlcml0JztcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2luaGVyaXQnO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLnNldCgnZWxlbWVudCcsIHRoaXMuZWxlbWVudCk7XG4gICAgbWFuYWdlci5zZXQoJ2NvbnRhaW5lcicsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuXG4gIGludGVncmF0ZShzZWxmKSB7XG4gICAgc2VsZi5jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbGVtZW50KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgV2ViR0xSZW5kZXJlcixcbiAgVmVjdG9yMlxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TG9vcH0gZnJvbSAnLi4vLi4vY29yZS9Mb29wJztcblxuLyoqXG4gKiBAY2xhc3MgUmVuZGVyaW5nTW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlcy9hcHBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXVxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcFxuICogQGV4YW1wbGUgPGNhcHRpb24+IENyZWF0aW5nIGEgcmVuZGVyaW5nIG1vZHVsZSBhbmQgcGFzc2luZyBpdCB0byBBcHAncyBtb2R1bGVzPC9jYXB0aW9uPlxuICogbmV3IEFwcChbXG4gKiAgIG5ldyBFbGVtZW50TW9kdWxlKCksXG4gKiAgIG5ldyBTY2VuZU1vZHVsZSgpLFxuICogICBuZXcgRGVmaW5lTW9kdWxlKCdjYW1lcmEnLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoe1xuICogICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLCA2LCAxOCksXG4gKiAgICAgZmFyOiAxMDAwMFxuICogICB9KSksXG4gKiAgIG5ldyBSZW5kZXJpbmdNb2R1bGUoe1xuICogICAgIGJnQ29sb3I6IDB4MTYyMTI5LFxuICpcbiAqICAgICByZW5kZXJlcjoge1xuICogICAgICAgYW50aWFsaWFzOiB0cnVlXG4gKiAgICAgfVxuICogICB9LCB7c2hhZG93OiB0cnVlfSlcbiAqIF0pO1xuICovXG5leHBvcnQgY2xhc3MgUmVuZGVyaW5nTW9kdWxlIHtcbiAgLyoqXG4gICAqIGFkZGl0aW9uYWxcbiAgICogQGRlc2NyaXB0aW9uIGNvbGxlY3Rpb24gb2YgYWRkaXRpb25hbCBzY3JpcHRzXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29yZS5BcHAjYWRkaXRpb25hbFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgYWRkaXRpb25hbCA9IHtcbiAgICBzaGFkb3cocmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZW5hYmxlZFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vZHVsZTpjb3JlLkFwcCNlbmFibGVkXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGVuYWJsZWQgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9LCBhZGRpdGlvbmFsKSB7XG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuXG4gICAgICByZXNvbHV0aW9uOiBuZXcgVmVjdG9yMigxLCAxKSxcbiAgICAgIHBpeGVsUmF0aW86IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuXG4gICAgICBiZ0NvbG9yOiAweDAwMDAwMCxcbiAgICAgIGJnT3BhY2l0eTogMSxcblxuICAgICAgcmVuZGVyZXI6IHt9LFxuICAgICAgZml4KCkge31cbiAgICB9LCBwYXJhbXMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgYmdDb2xvcixcbiAgICAgIGJnT3BhY2l0eSxcbiAgICAgIHJlbmRlcmVyLFxuICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGZpeFxuICAgIH0gPSB0aGlzLnBhcmFtcztcblxuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgdGhpcy5lZmZlY3RzID0gW107XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoXG4gICAgICBiZ0NvbG9yLFxuICAgICAgYmdPcGFjaXR5XG4gICAgKTtcblxuICAgIGlmIChwaXhlbFJhdGlvKSB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbyk7XG5cbiAgICB0aGlzLnNldFNpemUoXG4gICAgICBOdW1iZXIod2lkdGggKiByZXNvbHV0aW9uLngpLnRvRml4ZWQoKSxcbiAgICAgIE51bWJlcihoZWlnaHQgKiByZXNvbHV0aW9uLnkpLnRvRml4ZWQoKVxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhZGRpdGlvbmFsKVxuICAgICAgaWYgKGFkZGl0aW9uYWxba2V5XSkgdGhpcy5hcHBseUFkZGl0aW9uYWwoa2V5KTtcblxuICAgIGZpeCh0aGlzLnJlbmRlcmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFwcGx5QWRkaXRpb25hbFxuICAgKiBAZGVzY3JpcHRpb24gQXBwbHkgYWRkaXRpb25hbCBzY3JpcHQgZnJvbSBSZW5kZXJpbmdNb2R1bGUuYWRkaXRpb25hbFxuICAgKiBAcGFyYW0ge1N0aXJuZ30gbmFtZSBTY3JpcHQgbmFtZVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlbmRlcmluZ01vZHVsZVxuICAgKi9cbiAgYXBwbHlBZGRpdGlvbmFsKG5hbWUpIHtcbiAgICBSZW5kZXJpbmdNb2R1bGUuYWRkaXRpb25hbFtuYW1lXS5hcHBseSh0aGlzLCBbdGhpcy5yZW5kZXJlcl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW50ZWdyYXRlUmVuZGVyZXJcbiAgICogQGRlc2NyaXB0aW9uIEludGVncmF0ZSByZW5kZXJlclxuICAgKiBAcGFyYW0ge05vZGVFbGVtZW50fSBlbGVtZW50IERPTSBvYmplY3RcbiAgICogQHBhcmFtIHtUSFJFRS5TY2VuZX0gc2NlbmUgdXNlZCBzY2VuZVxuICAgKiBAcGFyYW0ge1RIUkVFLkNhbWVyYX0gY2FtZXJhIHVzZWQgY2FtZXJhXG4gICAqIEByZXR1cm4ge0xvb3B9IHJlbmRlckxvb3BcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5SZW5kZXJpbmdNb2R1bGVcbiAgICovXG4gIGludGVncmF0ZVJlbmRlcmVyKGVsZW1lbnQsIHNjZW5lLCBjYW1lcmEpIHtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5hdHRhY2hUb0NhbnZhcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBuZXcgTG9vcCgoKSA9PiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZWZmZWN0XG4gICAqIEBkZXNjcmlwdGlvbiBBZGQgdGhyZWUuanMgZWZmZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3QgdGhyZWUuanMgZWZmZWN0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVmZmVjdExvb3AgdXBkYXRlIGZ1bmN0aW9uIGZvciBlZmZlY3RcbiAgICogQHJldHVybiB7dGhpc31cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5SZW5kZXJpbmdNb2R1bGVcbiAgICovXG4gIGVmZmVjdChlZmZlY3QsIGVmZmVjdExvb3AgPSAoKSA9PiB7XG4gICAgZWZmZWN0LnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH0pIHtcbiAgICB0aGlzLnJlbmRlckxvb3Auc3RvcCgpO1xuXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVuZGVyZXIuZ2V0U2l6ZSgpO1xuICAgIGVmZmVjdC5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgIGNvbnN0IGxvb3AgPSBuZXcgTG9vcChlZmZlY3RMb29wKTtcblxuICAgIHRoaXMuZWZmZWN0cy5wdXNoKGxvb3ApO1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIGxvb3Auc3RhcnQodGhpcy5hcHApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRTaXplXG4gICAqIEBkZXNjcmlwdGlvbiBVcGRhdGUgcmVuZGVyIHRhcmdldCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlbmRlcmluZ01vZHVsZVxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGF0dGFjaFRvQ2FudmFzXG4gICAqIEBkZXNjcmlwdGlvbiBBdHRhY2ggcmVuZGVyZXIuZG9tRWxlbWVudCB0byBlbGVtZW50XG4gICAqIEBwYXJhbSB7Tm9kZUVsZW1lbnR9IGVsZW1lbnQgRE9NIG9iamVjdFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlbmRlcmluZ01vZHVsZVxuICAgKi9cbiAgYXR0YWNoVG9DYW52YXMoZWxlbWVudCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudDtcblxuICAgIC8vIGF0dGFjaCB0byBuZXcgcGFyZW50IHdvcmxkIGRvbVxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHN0b3BcbiAgICogQGRlc2NyaXB0aW9uIFN0b3BzIHJlbmRlckxvb3AgYW5kIGVmZmVjdCBsb29wc1xuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlbmRlcmluZ01vZHVsZVxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlckxvb3Auc3RvcCgpO1xuICAgIHRoaXMuZWZmZWN0cy5mb3JFYWNoKGxvb3AgPT4gbG9vcC5zdG9wKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGxheVxuICAgKiBAZGVzY3JpcHRpb24gUmVzdW1lcyByZW5kZXJMb29wIGFuZCBlZmZlY3QgbG9vcHNcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5SZW5kZXJpbmdNb2R1bGVcbiAgICovXG4gIHBsYXkoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlckxvb3Auc3RhcnQoKTtcbiAgICB0aGlzLmVmZmVjdHMuZm9yRWFjaChsb29wID0+IGxvb3Auc3RhcnQoKSk7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLmRlZmluZSgncmVuZGVyaW5nJyk7XG4gICAgbWFuYWdlci5zZXQoJ3JlbmRlcmVyJywgdGhpcy5yZW5kZXJlcik7XG5cbiAgICB0aGlzLmFwcCA9IG1hbmFnZXIuaGFuZGxlcjtcblxuICAgIHRoaXMucmVuZGVyTG9vcCA9IHRoaXMuaW50ZWdyYXRlUmVuZGVyZXIoXG4gICAgICBtYW5hZ2VyLmdldCgnZWxlbWVudCcpLFxuICAgICAgbWFuYWdlci5nZXQoJ3NjZW5lJyksXG4gICAgICBtYW5hZ2VyLmdldCgnY2FtZXJhJykubmF0aXZlXG4gICAgKTtcblxuICAgIG1hbmFnZXIudXBkYXRlKHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQgPT4ge1xuICAgICAgICB0aGlzLmF0dGFjaFRvQ2FudmFzKGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIHNjZW5lOiBzY2VuZSA9PiB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgIH0sXG4gICAgICBjYW1lcmE6IGNhbWVyYSA9PiB7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhLm5hdGl2ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGludGVncmF0ZShzZWxmKSB7XG4gICAgc2VsZi5yZW5kZXJMb29wLnN0YXJ0KHRoaXMpO1xuICAgIHNlbGYuZWZmZWN0cy5mb3JFYWNoKGxvb3AgPT4gbG9vcC5zdGFydCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAqIEBkZXNjcmlwdGlvbiBEaXNwb3NlIHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVuZGVyaW5nTW9kdWxlXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMucmVuZGVyZXIuZm9yY2VDb250ZXh0TG9zcygpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBTY2VuZVxufSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogQGNsYXNzIFNjZW5lTW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlcy9hcHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpbGxTY2VuZUJlUmVwbGFjZWQ9ZmFsc2VdIHdpbGxTY2VuZUJlUmVwbGFjZWQgc2hvdWxkIGJlIHRydWUgb25seSBpZiB5b3UgYXJlIGdvaW5nIHRvIG92ZXJ3cml0ZSBzY2VuZSBkZXBlbmRlbmN5IGV2ZW4gd2l0aG91dCB0aGUgdXNlIG9mIGRlZmF1bHQgb25lLlxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcFxuICovXG5leHBvcnQgY2xhc3MgU2NlbmVNb2R1bGUge1xuICBjb25zdHJ1Y3Rvcih3aWxsU2NlbmVCZVJlcGxhY2VkID0gZmFsc2UpIHtcbiAgICB0aGlzLnNjZW5lID0gd2lsbFNjZW5lQmVSZXBsYWNlZCA/IG51bGwgOiBuZXcgU2NlbmUoKTtcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuc2V0KCdzY2VuZScsIHRoaXMuc2NlbmUpO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBvYmplY3QuZGVmZXIoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHtuYXRpdmV9ID0gb2JqZWN0O1xuICAgICAgICAgIGlmICghbmF0aXZlKSByZWplY3QoKTtcblxuICAgICAgICAgIGNvbnN0IGFkZFByb21pc2UgPSB0aGlzLmFwcGx5QnJpZGdlKHtvbkFkZDogb2JqZWN0fSkub25BZGQ7XG5cbiAgICAgICAgICBjb25zdCByZXNvbHZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHNlbGYuc2NlbmUuYWRkKG5hdGl2ZSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2gob2JqZWN0KTtcblxuICAgICAgICAgICAgcmVzb2x2ZShvYmplY3QpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoYWRkUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICBhZGRQcm9taXNlLnRoZW4ocmVzb2x2ZXIpO1xuICAgICAgICAgIGVsc2UgcmVzb2x2ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAgIHNlbGYuc2NlbmUucmVtb3ZlKG9iamVjdC5uYXRpdmUpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFNjZW5lID0gZnVuY3Rpb24gKHNjZW5lKSB7XG4gICAgICBzZWxmLnNjZW5lID0gc2NlbmU7XG4gICAgICB0aGlzLm1hbmFnZXIuc2V0KCdzY2VuZScsIHNjZW5lKTtcbiAgICB9O1xuICB9XG59XG4iLCIvLyBpbXBvcnQge2FkZFJlc2l6ZUxpc3RlbmVyfSBmcm9tICdkZXRlY3QtZWxlbWVudC1yZXNpemUnO1xuXG4vKipcbiAqIEBjbGFzcyBSZXNpemVNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXM9e2F1dG86IHRydWV9XSAtIElmIGF1dG8gaXMgc2V0IHRvIHRydWUgLSByZXNpemUgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiBjb250YWluZXIgcmVzaXplc1xuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcFxuICovXG5leHBvcnQgY2xhc3MgUmVzaXplTW9kdWxlIHtcbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYXV0bzogdHJ1ZVxuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcyA9IFt0aGlzLnNldFNpemUuYmluZCh0aGlzKV07XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIHNldFNpemVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHNldHMgdGhlIHByb3ZpZGVkIHdpZHRoICYgaGVpZ2h0IHRvIHRoZSByZW5kZXJlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MV0gLSBUaGUgcHJvbWlzZSB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byBhIHF1ZXVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0xXSAtIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBhbGwgcHJvbWlzZXMgY29tcGxldGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlc2l6ZU1vZHVsZVxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCA9IDEsIGhlaWdodCA9IDEpIHtcbiAgICB0aGlzLmNhbWVyYS5uYXRpdmUuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEubmF0aXZlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIGlmICh0aGlzLnJlbmRlcmluZykgdGhpcy5yZW5kZXJpbmcuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBUcmlnZ2VycyByZXNpemUgd2hlbiBjYWxsZWQuIHdpZHRoICYgaGVpZ2h0IGFyZSBkZXRlcm1pbmVkIGF1dG9tYXRpY2FsbHlcbiAgICogVGhpcyBpbnZva2VzIGVhY2ggY2FsbGJhY2tzIHdpdGggdGhlIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IGFzIHBhcmFtc1xuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlc2l6ZU1vZHVsZVxuICAgKi9cbiAgdHJpZ2dlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgb2Zmc2V0V2lkdGgsXG4gICAgICAgIG9mZnNldEhlaWdodFxuICAgICAgfSxcbiAgICAgIHJlc29sdXRpb25cbiAgICB9ID0gdGhpcztcblxuICAgIGNvbnN0IHdpZHRoID0gTnVtYmVyKG9mZnNldFdpZHRoICogcmVzb2x1dGlvbi54KS50b0ZpeGVkKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTnVtYmVyKG9mZnNldEhlaWdodCAqIHJlc29sdXRpb24ueSkudG9GaXhlZCgpO1xuXG4gICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICBjYih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFkZEF1dG9yZXNpemVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBTZXRzIG1vZHVsZSB0byBhdXRvcmVzaXplLCB0aGlzIGFkZHMgYW4gZXZlbnQgbGlzdGVuZSBvbiB3aW5kb3cgcmVzaXplIHRvIHRyaWdnZXIgdGhlIHJlc2l6ZVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlc2l6ZU1vZHVsZVxuICAgKi9cbiAgYWRkQXV0b3Jlc2l6ZSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuYXV0bykgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFkZENhbGxiYWNrXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQWRkcyBhIGNhbGwgYmFjayBmdW5jdGlvbiB0byB0aGUgZXhpc3RpbmcgY2FsbGJhY2tzIGxpc3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYWRkXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVzaXplTW9kdWxlXG4gICAqL1xuICBhZGRDYWxsYmFjayhmdW5jKSB7XG4gICAgdGhpcy5jYWxsYmFja3MucHVzaChmdW5jKTtcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuZGVmaW5lKCdyZXNpemUnKTtcblxuICAgIHRoaXMucmVuZGVyaW5nID0gbWFuYWdlci5nZXQoJ3JlbmRlcmVyJyk7XG4gICAgdGhpcy5jYW1lcmEgPSBtYW5hZ2VyLmdldCgnY2FtZXJhJyk7XG5cbiAgICB0aGlzLmdldFJlc29sdXRpb24gPSAoKSA9PiBtYW5hZ2VyLnVzZSgncmVuZGVyaW5nJykucGFyYW1zLnJlc29sdXRpb247XG4gICAgdGhpcy5nZXRDb250YWluZXIgPSAoKSA9PiBtYW5hZ2VyLmdldCgnY29udGFpbmVyJyk7XG5cbiAgICBtYW5hZ2VyLnVwZGF0ZSh7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lciA9PiB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRBdXRvcmVzaXplKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdFByZXZpb3VzTHVtO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHRDdXJyZW50THVtO1xcclxcbnVuaWZvcm0gZmxvYXQgbWluTHVtaW5hbmNlO1xcclxcbnVuaWZvcm0gZmxvYXQgZGVsdGE7XFxyXFxudW5pZm9ybSBmbG9hdCB0YXU7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgcHJldmlvdXNMdW0gPSB0ZXh0dXJlMkQodFByZXZpb3VzTHVtLCB2VXYsIE1JUF9MRVZFTF8xWDEpLnI7XFxyXFxuXFx0ZmxvYXQgY3VycmVudEx1bSA9IHRleHR1cmUyRCh0Q3VycmVudEx1bSwgdlV2LCBNSVBfTEVWRUxfMVgxKS5yO1xcclxcblxcclxcblxcdHByZXZpb3VzTHVtID0gbWF4KG1pbkx1bWluYW5jZSwgcHJldmlvdXNMdW0pO1xcclxcblxcdGN1cnJlbnRMdW0gPSBtYXgobWluTHVtaW5hbmNlLCBjdXJyZW50THVtKTtcXHJcXG5cXHJcXG5cXHQvLyBBZGFwdCB0aGUgbHVtaW5hbmNlIHVzaW5nIFBhdHRhbmFpaydzIHRlY2huaXF1ZS5cXHJcXG5cXHRmbG9hdCBhZGFwdGVkTHVtID0gcHJldmlvdXNMdW0gKyAoY3VycmVudEx1bSAtIHByZXZpb3VzTHVtKSAqICgxLjAgLSBleHAoLWRlbHRhICogdGF1KSk7XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yLnIgPSBhZGFwdGVkTHVtO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhZGFwdGl2ZSBsdW1pbm9zaXR5IHNoYWRlciBtYXRlcmlhbC5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYWRhcHRpdmUgbHVtaW5vc2l0eSBtYXRlcmlhbC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJBZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0ZGVmaW5lczoge1xyXG5cclxuXHRcdFx0XHRNSVBfTEVWRUxfMVgxOiBcIjAuMFwiXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dFByZXZpb3VzTHVtOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0Q3VycmVudEx1bTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0bWluTHVtaW5hbmNlOiBuZXcgVW5pZm9ybSgwLjAxKSxcclxuXHRcdFx0XHRkZWx0YTogbmV3IFVuaWZvcm0oMC4wKSxcclxuXHRcdFx0XHR0YXU6IG5ldyBVbmlmb3JtKDEuMClcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHREZXB0aDtcXHJcXG5cXHJcXG51bmlmb3JtIGZsb2F0IGZvY3VzO1xcclxcbnVuaWZvcm0gZmxvYXQgYXNwZWN0O1xcclxcbnVuaWZvcm0gZmxvYXQgYXBlcnR1cmU7XFxyXFxudW5pZm9ybSBmbG9hdCBtYXhCbHVyO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxuI2lmbmRlZiBVU0VfTE9HREVQVEhCVUZcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8cGFja2luZz5cXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7XFxyXFxuXFx0dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgcmVhZERlcHRoKHNhbXBsZXIyRCBkZXB0aFNhbXBsZXIsIHZlYzIgY29vcmQpIHtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmcmFnQ29vcmRaID0gdGV4dHVyZTJEKGRlcHRoU2FtcGxlciwgY29vcmQpLng7XFxyXFxuXFx0XFx0ZmxvYXQgdmlld1ogPSBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihmcmFnQ29vcmRaLCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIpO1xcclxcblxcclxcblxcdFxcdHJldHVybiB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osIGNhbWVyYU5lYXIsIGNhbWVyYUZhcik7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIGFzcGVjdENvcnJlY3Rpb24gPSB2ZWMyKDEuMCwgYXNwZWN0KTtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZGVwdGggPSB0ZXh0dXJlMkQodERlcHRoLCB2VXYpLng7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBkZXB0aCA9IHJlYWREZXB0aCh0RGVwdGgsIHZVdik7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0ZmxvYXQgZmFjdG9yID0gZGVwdGggLSBmb2N1cztcXHJcXG5cXHJcXG5cXHR2ZWMyIGRvZkJsdXIgPSB2ZWMyKGNsYW1wKGZhY3RvciAqIGFwZXJ0dXJlLCAtbWF4Qmx1ciwgbWF4Qmx1cikpO1xcclxcblxcclxcblxcdHZlYzIgZG9mYmx1cjkgPSBkb2ZCbHVyICogMC45O1xcclxcblxcdHZlYzIgZG9mYmx1cjcgPSBkb2ZCbHVyICogMC43O1xcclxcblxcdHZlYzIgZG9mYmx1cjQgPSBkb2ZCbHVyICogMC40O1xcclxcblxcclxcblxcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxyXFxuXFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoIDAuMCwgICAwLjQgKSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4xNSwgIDAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjI5LCAgMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoLTAuMzcsICAwLjE1KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC40MCwgIDAuMCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjM3LCAtMC4xNSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoIDAuMjksIC0wLjI5KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4xNSwgLTAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjAsICAtMC40ICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoLTAuMTUsICAwLjM3KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4yOSwgIDAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjM3LCAgMC4xNSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoLTAuNCwgICAwLjAgKSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4zNywgLTAuMTUpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjI5LCAtMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoIDAuMTUsIC0wLjM3KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4xNSwgIDAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4zNywgIDAuMTUpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4zNywgLTAuMTUpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4xNSwgLTAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4xNSwgIDAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4zNywgIDAuMTUpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4zNywgLTAuMTUpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4xNSwgLTAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyOSk7XFxyXFxuXFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4yOSwgIDAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC40MCwgIDAuMCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4yOSwgLTAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4wLCAgLTAuNCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4yOSwgIDAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC40LCAgIDAuMCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4yOSwgLTAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4wLCAgIDAuNCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNyk7XFxyXFxuXFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4yOSwgIDAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC40LCAgIDAuMCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4yOSwgLTAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4wLCAgLTAuNCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4yOSwgIDAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC40LCAgIDAuMCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4yOSwgLTAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4wLCAgIDAuNCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZibHVyNCk7XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gY29sb3IgLyA0MS4wO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBEZXB0aCBvZiBGaWVsZCBzaGFkZXIgKEJva2VoKS5cclxuICpcclxuICogT3JpZ2luYWwgc2hhZGVyIGNvZGUgYnkgTWFydGlucyBVcGl0aXM6XHJcbiAqICBodHRwOi8vYXJ0bWFydGluc2guYmxvZ3Nwb3QuY29tLzIwMTAvMDIvZ2xzbC1sZW5zLWJsdXItZmlsdGVyLXdpdGgtYm9rZWguaHRtbFxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBCb2tlaE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gW2NhbWVyYV0gLSBBIGNhbWVyYS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzPTEuMF0gLSBGb2N1cyBkaXN0YW5jZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXBlcnR1cmU9MC4wMjVdIC0gQ2FtZXJhIGFwZXJ0dXJlIHNjYWxlLiBCaWdnZXIgdmFsdWVzIGZvciBzaGFsbG93ZXIgZGVwdGggb2YgZmllbGQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEJsdXI9MS4wXSAtIE1heGltdW0gYmx1ciBzdHJlbmd0aC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoY2FtZXJhID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0aWYob3B0aW9ucy5mb2N1cyA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuZm9jdXMgPSAxLjA7IH1cclxuXHRcdGlmKG9wdGlvbnMuYXBlcnR1cmUgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLmFwZXJ0dXJlID0gMC4wMjU7IH1cclxuXHRcdGlmKG9wdGlvbnMubWF4Qmx1ciA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMubWF4Qmx1ciA9IDEuMDsgfVxyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiQm9rZWhNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0Y2FtZXJhTmVhcjogbmV3IFVuaWZvcm0oMC4xKSxcclxuXHRcdFx0XHRjYW1lcmFGYXI6IG5ldyBVbmlmb3JtKDIwMDApLFxyXG5cdFx0XHRcdGFzcGVjdDogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHREZXB0aDogbmV3IFVuaWZvcm0obnVsbCksXHJcblxyXG5cdFx0XHRcdGZvY3VzOiBuZXcgVW5pZm9ybShvcHRpb25zLmZvY3VzKSxcclxuXHRcdFx0XHRhcGVydHVyZTogbmV3IFVuaWZvcm0ob3B0aW9ucy5hcGVydHVyZSksXHJcblx0XHRcdFx0bWF4Qmx1cjogbmV3IFVuaWZvcm0ob3B0aW9ucy5tYXhCbHVyKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmKGNhbWVyYSAhPT0gbnVsbCkgeyB0aGlzLmFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTsgfVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkb3B0cyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxyXG5cdCAqL1xyXG5cclxuXHRhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy5jYW1lcmFGYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy5hc3BlY3QudmFsdWUgPSBjYW1lcmEuYXNwZWN0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3IyLCBWZWN0b3IzIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdERlcHRoO1xcclxcblxcclxcbnVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxyXFxudW5pZm9ybSB2ZWMyIGhhbGZUZXhlbFNpemU7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBjYW1lcmFOZWFyO1xcclxcbnVuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO1xcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgZm9jYWxMZW5ndGg7XFxyXFxudW5pZm9ybSBmbG9hdCBmb2NhbFN0b3A7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBtYXhCbHVyO1xcclxcbnVuaWZvcm0gdmVjMyBsdW1pbmFuY2VDb2VmZmljaWVudHM7XFxyXFxudW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VUaHJlc2hvbGQ7XFxyXFxudW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VHYWluO1xcclxcbnVuaWZvcm0gZmxvYXQgYmlhcztcXHJcXG51bmlmb3JtIGZsb2F0IGZyaW5nZTtcXHJcXG51bmlmb3JtIGZsb2F0IGRpdGhlclN0cmVuZ3RoO1xcclxcblxcclxcbiNpZmRlZiBTSEFERVJfRk9DVVNcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHZlYzIgZm9jdXNDb29yZHM7XFxyXFxuXFxyXFxuI2Vsc2VcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGZvY2FsRGVwdGg7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG4jaWZuZGVmIFVTRV9MT0dERVBUSEJVRlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxwYWNraW5nPlxcclxcblxcclxcblxcdGZsb2F0IHJlYWREZXB0aChzYW1wbGVyMkQgZGVwdGhTYW1wbGVyLCB2ZWMyIGNvb3JkKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZnJhZ0Nvb3JkWiA9IHRleHR1cmUyRChkZXB0aFNhbXBsZXIsIGNvb3JkKS54O1xcclxcblxcdFxcdGZsb2F0IHZpZXdaID0gcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZnJhZ0Nvb3JkWiwgY2FtZXJhTmVhciwgY2FtZXJhRmFyKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWZkZWYgUEVOVEFHT05cXHJcXG5cXHJcXG5cXHRmbG9hdCBwZW50YSh2ZWMyIGNvb3Jkcykge1xcclxcblxcclxcblxcdFxcdGNvbnN0IHZlYzQgSFMwID0gdmVjNCggMS4wLCAgICAgICAgICAwLjAsICAgICAgICAgMC4wLCAxLjApO1xcclxcblxcdFxcdGNvbnN0IHZlYzQgSFMxID0gdmVjNCggMC4zMDkwMTY5OTQsICAwLjk1MTA1NjUxNiwgMC4wLCAxLjApO1xcclxcblxcdFxcdGNvbnN0IHZlYzQgSFMyID0gdmVjNCgtMC44MDkwMTY5OTQsICAwLjU4Nzc4NTI1MiwgMC4wLCAxLjApO1xcclxcblxcdFxcdGNvbnN0IHZlYzQgSFMzID0gdmVjNCgtMC44MDkwMTY5OTQsIC0wLjU4Nzc4NTI1MiwgMC4wLCAxLjApO1xcclxcblxcdFxcdGNvbnN0IHZlYzQgSFM0ID0gdmVjNCggMC4zMDkwMTY5OTQsIC0wLjk1MTA1NjUxNiwgMC4wLCAxLjApO1xcclxcblxcdFxcdGNvbnN0IHZlYzQgSFM1ID0gdmVjNCggMC4wLCAgICAgICAgICAwLjAsICAgICAgICAgMS4wLCAxLjApO1xcclxcblxcclxcblxcdFxcdGNvbnN0IHZlYzQgT05FID0gdmVjNCgxLjApO1xcclxcblxcclxcblxcdFxcdGNvbnN0IGZsb2F0IFBfRkVBVEhFUiA9IDAuNDtcXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBOX0ZFQVRIRVIgPSAtUF9GRUFUSEVSO1xcclxcblxcclxcblxcdFxcdGZsb2F0IGluT3JPdXQgPSAtNC4wO1xcclxcblxcclxcblxcdFxcdHZlYzQgUCA9IHZlYzQoY29vcmRzLCB2ZWMyKFJJTkdTX0ZMT0FUIC0gMS4zKSk7XFxyXFxuXFxyXFxuXFx0XFx0dmVjNCBkaXN0ID0gdmVjNChcXHJcXG5cXHRcXHRcXHRkb3QoUCwgSFMwKSxcXHJcXG5cXHRcXHRcXHRkb3QoUCwgSFMxKSxcXHJcXG5cXHRcXHRcXHRkb3QoUCwgSFMyKSxcXHJcXG5cXHRcXHRcXHRkb3QoUCwgSFMzKVxcclxcblxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0ZGlzdCA9IHNtb290aHN0ZXAoTl9GRUFUSEVSLCBQX0ZFQVRIRVIsIGRpc3QpO1xcclxcblxcclxcblxcdFxcdGluT3JPdXQgKz0gZG90KGRpc3QsIE9ORSk7XFxyXFxuXFxyXFxuXFx0XFx0ZGlzdC54ID0gZG90KFAsIEhTNCk7XFxyXFxuXFx0XFx0ZGlzdC55ID0gSFM1LncgLSBhYnMoUC56KTtcXHJcXG5cXHJcXG5cXHRcXHRkaXN0ID0gc21vb3Roc3RlcChOX0ZFQVRIRVIsIFBfRkVBVEhFUiwgZGlzdCk7XFxyXFxuXFx0XFx0aW5Pck91dCArPSBkaXN0Lng7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGNsYW1wKGluT3JPdXQsIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuI2lmZGVmIFNIT1dfRk9DVVNcXHJcXG5cXHJcXG5cXHR2ZWMzIGRlYnVnRm9jdXModmVjMyBjLCBmbG9hdCBibHVyLCBmbG9hdCBkZXB0aCkge1xcclxcblxcclxcblxcdFxcdGZsb2F0IGVkZ2UgPSAwLjAwMiAqIGRlcHRoO1xcclxcblxcdFxcdGZsb2F0IG0gPSBjbGFtcChzbW9vdGhzdGVwKDAuMCwgZWRnZSwgYmx1ciksIDAuMCwgMS4wKTtcXHJcXG5cXHRcXHRmbG9hdCBlID0gY2xhbXAoc21vb3Roc3RlcCgxLjAgLSBlZGdlLCAxLjAsIGJsdXIpLCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuXFx0XFx0YyA9IG1peChjLCB2ZWMzKDEuMCwgMC41LCAwLjApLCAoMS4wIC0gbSkgKiAwLjYpO1xcclxcblxcdFxcdGMgPSBtaXgoYywgdmVjMygwLjAsIDAuNSwgMS4wKSwgKCgxLjAgLSBlKSAtICgxLjAgLSBtKSkgKiAwLjIpO1xcclxcblxcclxcblxcdFxcdHJldHVybiBjO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWZkZWYgVklHTkVUVEVcXHJcXG5cXHJcXG5cXHRmbG9hdCB2aWduZXR0ZSgpIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdCB2ZWMyIENFTlRFUiA9IHZlYzIoMC41KTtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBWSUdORVRURV9PVVQgPSAxLjM7XFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgVklHTkVUVEVfSU4gPSAwLjA7XFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgVklHTkVUVEVfRkFERSA9IDIyLjA7IFxcclxcblxcclxcblxcdFxcdGZsb2F0IGQgPSBkaXN0YW5jZSh2VXYsIENFTlRFUik7XFxyXFxuXFx0XFx0ZCA9IHNtb290aHN0ZXAoVklHTkVUVEVfT1VUICsgKGZvY2FsU3RvcCAvIFZJR05FVFRFX0ZBREUpLCBWSUdORVRURV9JTiArIChmb2NhbFN0b3AgLyBWSUdORVRURV9GQURFKSwgZCk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGNsYW1wKGQsIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudmVjMiByYW5kKHZlYzIgY29vcmQpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIG5vaXNlO1xcclxcblxcclxcblxcdCNpZmRlZiBOT0lTRVxcclxcblxcclxcblxcdFxcdGNvbnN0IGZsb2F0IGEgPSAxMi45ODk4O1xcclxcblxcdFxcdGNvbnN0IGZsb2F0IGIgPSA3OC4yMzM7XFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgYyA9IDQzNzU4LjU0NTM7XFxyXFxuXFxyXFxuXFx0XFx0bm9pc2UueCA9IGNsYW1wKGZyYWN0KHNpbihtb2QoZG90KGNvb3JkLCB2ZWMyKGEsIGIpKSwgMy4xNCkpICogYyksIDAuMCwgMS4wKSAqIDIuMCAtIDEuMDtcXHJcXG5cXHRcXHRub2lzZS55ID0gY2xhbXAoZnJhY3Qoc2luKG1vZChkb3QoY29vcmQsIHZlYzIoYSwgYikgKiAyLjApLCAzLjE0KSkgKiBjKSwgMC4wLCAxLjApICogMi4wIC0gMS4wO1xcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0bm9pc2UueCA9ICgoZnJhY3QoMS4wIC0gY29vcmQucyAqIGhhbGZUZXhlbFNpemUueCkgKiAwLjI1KSArIChmcmFjdChjb29yZC50ICogaGFsZlRleGVsU2l6ZS55KSAqIDAuNzUpKSAqIDIuMCAtIDEuMDtcXHJcXG5cXHRcXHRub2lzZS55ID0gKChmcmFjdCgxLjAgLSBjb29yZC5zICogaGFsZlRleGVsU2l6ZS54KSAqIDAuNzUpICsgKGZyYWN0KGNvb3JkLnQgKiBoYWxmVGV4ZWxTaXplLnkpICogMC4yNSkpICogMi4wIC0gMS4wO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdHJldHVybiBub2lzZTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxudmVjMyBwcm9jZXNzVGV4ZWwodmVjMiBjb29yZHMsIGZsb2F0IGJsdXIpIHtcXHJcXG5cXHJcXG5cXHR2ZWMzIGM7XFxyXFxuXFx0Yy5yID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZHMgKyB2ZWMyKDAuMCwgMS4wKSAqIHRleGVsU2l6ZSAqIGZyaW5nZSAqIGJsdXIpLnI7XFxyXFxuXFx0Yy5nID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZHMgKyB2ZWMyKC0wLjg2NiwgLTAuNSkgKiB0ZXhlbFNpemUgKiBmcmluZ2UgKiBibHVyKS5nO1xcclxcblxcdGMuYiA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmRzICsgdmVjMigwLjg2NiwgLTAuNSkgKiB0ZXhlbFNpemUgKiBmcmluZ2UgKiBibHVyKS5iO1xcclxcblxcclxcblxcdC8vIENhbGN1bGF0ZSB0aGUgbHVtaW5hbmNlIG9mIHRoZSBjb25zdHJ1Y3RlZCBjb2xvdXIuXFxyXFxuXFx0ZmxvYXQgbHVtaW5hbmNlID0gZG90KGMsIGx1bWluYW5jZUNvZWZmaWNpZW50cyk7XFxyXFxuXFx0ZmxvYXQgdGhyZXNob2xkID0gbWF4KChsdW1pbmFuY2UgLSBsdW1pbmFuY2VUaHJlc2hvbGQpICogbHVtaW5hbmNlR2FpbiwgMC4wKTtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gYyArIG1peCh2ZWMzKDAuMCksIGMsIHRocmVzaG9sZCAqIGJsdXIpO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBsaW5lYXJpemUoZmxvYXQgZGVwdGgpIHtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gLWNhbWVyYUZhciAqIGNhbWVyYU5lYXIgLyAoZGVwdGggKiAoY2FtZXJhRmFyIC0gY2FtZXJhTmVhcikgLSBjYW1lcmFGYXIpO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBnYXRoZXIoZmxvYXQgaSwgZmxvYXQgaiwgZmxvYXQgcmluZ1NhbXBsZXMsIGlub3V0IHZlYzMgY29sb3IsIGZsb2F0IHcsIGZsb2F0IGgsIGZsb2F0IGJsdXIpIHtcXHJcXG5cXHJcXG5cXHRjb25zdCBmbG9hdCBUV09fUEkgPSA2LjI4MzE4NTMxO1xcclxcblxcclxcblxcdGZsb2F0IHN0ZXAgPSBUV09fUEkgLyByaW5nU2FtcGxlcztcXHJcXG5cXHRmbG9hdCBwdyA9IGNvcyhqICogc3RlcCkgKiBpO1xcclxcblxcdGZsb2F0IHBoID0gc2luKGogKiBzdGVwKSAqIGk7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFBFTlRBR09OXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgcCA9IHBlbnRhKHZlYzIocHcsIHBoKSk7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBwID0gMS4wO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdGNvbG9yICs9IHByb2Nlc3NUZXhlbCh2VXYgKyB2ZWMyKHB3ICogdywgcGggKiBoKSwgYmx1cikgKiBtaXgoMS4wLCBpIC8gUklOR1NfRkxPQVQsIGJpYXMpICogcDtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gbWl4KDEuMCwgaSAvIFJJTkdTX0ZMT0FULCBiaWFzKSAqIHA7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZGVwdGggPSBsaW5lYXJpemUodGV4dHVyZTJEKHREZXB0aCwgdlV2KS54KTtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdGZsb2F0IGRlcHRoID0gbGluZWFyaXplKHJlYWREZXB0aCh0RGVwdGgsIHZVdikpO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZmRlZiBTSEFERVJfRk9DVVNcXHJcXG5cXHJcXG5cXHRcXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxyXFxuXFxyXFxuXFx0XFx0XFx0ZmxvYXQgZkRlcHRoID0gbGluZWFyaXplKHRleHR1cmUyRCh0RGVwdGgsIGZvY3VzQ29vcmRzKS54KTtcXHJcXG5cXHJcXG5cXHRcXHQjZWxzZVxcclxcblxcclxcblxcdFxcdFxcdGZsb2F0IGZEZXB0aCA9IGxpbmVhcml6ZShyZWFkRGVwdGgodERlcHRoLCBmb2N1c0Nvb3JkcykpO1xcclxcblxcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZkRlcHRoID0gZm9jYWxEZXB0aDtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaWZkZWYgTUFOVUFMX0RPRlxcclxcblxcclxcblxcdFxcdGNvbnN0IGZsb2F0IG5Eb0ZTdGFydCA9IDEuMDsgXFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgbkRvRkRpc3QgPSAyLjA7XFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgZkRvRlN0YXJ0ID0gMS4wO1xcclxcblxcdFxcdGNvbnN0IGZsb2F0IGZEb0ZEaXN0ID0gMy4wO1xcclxcblxcclxcblxcdFxcdGZsb2F0IGZvY2FsUGxhbmUgPSBkZXB0aCAtIGZEZXB0aDtcXHJcXG5cXHRcXHRmbG9hdCBmYXJEb0YgPSAoZm9jYWxQbGFuZSAtIGZEb0ZTdGFydCkgLyBmRG9GRGlzdDtcXHJcXG5cXHRcXHRmbG9hdCBuZWFyRG9GID0gKC1mb2NhbFBsYW5lIC0gbkRvRlN0YXJ0KSAvIG5Eb0ZEaXN0O1xcclxcblxcclxcblxcdFxcdGZsb2F0IGJsdXIgPSAoZm9jYWxQbGFuZSA+IDAuMCkgPyBmYXJEb0YgOiBuZWFyRG9GO1xcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgQ0lSQ0xFX09GX0NPTkZVU0lPTiA9IDAuMDM7IC8vIDM1bW0gZmlsbSA9IDAuMDNtbSBDb0MuXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZm9jYWxQbGFuZU1NID0gZkRlcHRoICogMTAwMC4wO1xcclxcblxcdFxcdGZsb2F0IGRlcHRoTU0gPSBkZXB0aCAqIDEwMDAuMDtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmb2NhbFBsYW5lID0gKGRlcHRoTU0gKiBmb2NhbExlbmd0aCkgLyAoZGVwdGhNTSAtIGZvY2FsTGVuZ3RoKTtcXHJcXG5cXHRcXHRmbG9hdCBmYXJEb0YgPSAoZm9jYWxQbGFuZU1NICogZm9jYWxMZW5ndGgpIC8gKGZvY2FsUGxhbmVNTSAtIGZvY2FsTGVuZ3RoKTtcXHJcXG5cXHRcXHRmbG9hdCBuZWFyRG9GID0gKGZvY2FsUGxhbmVNTSAtIGZvY2FsTGVuZ3RoKSAvIChmb2NhbFBsYW5lTU0gKiBmb2NhbFN0b3AgKiBDSVJDTEVfT0ZfQ09ORlVTSU9OKTtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBibHVyID0gYWJzKGZvY2FsUGxhbmUgLSBmYXJEb0YpICogbmVhckRvRjtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRibHVyID0gY2xhbXAoYmx1ciwgMC4wLCAxLjApO1xcclxcblxcclxcblxcdC8vIERpdGhlcmluZy5cXHJcXG5cXHR2ZWMyIG5vaXNlID0gcmFuZCh2VXYpICogZGl0aGVyU3RyZW5ndGggKiBibHVyO1xcclxcblxcclxcblxcdGZsb2F0IGJsdXJGYWN0b3JYID0gdGV4ZWxTaXplLnggKiBibHVyICogbWF4Qmx1ciArIG5vaXNlLng7XFxyXFxuXFx0ZmxvYXQgYmx1ckZhY3RvclkgPSB0ZXhlbFNpemUueSAqIGJsdXIgKiBtYXhCbHVyICsgbm9pc2UueTtcXHJcXG5cXHJcXG5cXHRjb25zdCBpbnQgTUFYX1JJTkdfU0FNUExFUyA9IFJJTkdTX0lOVCAqIFNBTVBMRVNfSU5UO1xcclxcblxcclxcblxcdC8vIENhbGN1bGF0aW9uIG9mIGZpbmFsIGNvbG9yLlxcclxcblxcdHZlYzQgY29sb3I7XFxyXFxuXFxyXFxuXFx0aWYoYmx1ciA8IDAuMDUpIHtcXHJcXG5cXHJcXG5cXHRcXHRjb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXHJcXG5cXHJcXG5cXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdGNvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcclxcblxcclxcblxcdFxcdGZsb2F0IHMgPSAxLjA7XFxyXFxuXFx0XFx0aW50IHJpbmdTYW1wbGVzO1xcclxcblxcclxcblxcdFxcdGZvcihpbnQgaSA9IDE7IGkgPD0gUklOR1NfSU5UOyArK2kpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyaW5nU2FtcGxlcyA9IGkgKiBTQU1QTEVTX0lOVDtcXHJcXG5cXHJcXG5cXHRcXHRcXHQvLyBDb25zdGFudCBsb29wLlxcclxcblxcdFxcdFxcdGZvcihpbnQgaiA9IDA7IGogPCBNQVhfUklOR19TQU1QTEVTOyArK2opIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBCcmVhayBlYXJsaWVyLlxcclxcblxcdFxcdFxcdFxcdGlmKGogPj0gcmluZ1NhbXBsZXMpIHsgYnJlYWs7IH1cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHRzICs9IGdhdGhlcihmbG9hdChpKSwgZmxvYXQoaiksIGZsb2F0KHJpbmdTYW1wbGVzKSwgY29sb3IucmdiLCBibHVyRmFjdG9yWCwgYmx1ckZhY3RvclksIGJsdXIpO1xcclxcblxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Y29sb3IucmdiIC89IHM7IC8vIERpdmlkZSBieSBzYW1wbGUgY291bnQuXFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdCNpZmRlZiBTSE9XX0ZPQ1VTXFxyXFxuXFxyXFxuXFx0XFx0Y29sb3IucmdiID0gZGVidWdGb2N1cyhjb2xvci5yZ2IsIGJsdXIsIGRlcHRoKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaWZkZWYgVklHTkVUVEVcXHJcXG5cXHJcXG5cXHRcXHRjb2xvci5yZ2IgKj0gdmlnbmV0dGUoKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogRGVwdGggb2YgRmllbGQgc2hhZGVyIHZlcnNpb24gMi40LlxyXG4gKlxyXG4gKiBPcmlnaW5hbCBzaGFkZXIgY29kZSBieSBNYXJ0aW5zIFVwaXRpczpcclxuICogIGh0dHA6Ly9ibGVuZGVyYXJ0aXN0cy5vcmcvZm9ydW0vc2hvd3RocmVhZC5waHA/MjM3NDg4LUdMU0wtZGVwdGgtb2YtZmllbGQtd2l0aC1ib2tlaC12Mi00LSh1cGRhdGUpXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEJva2VoMk1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoMiBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IFtjYW1lcmFdIC0gVGhlIG1haW4gY2FtZXJhLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy50ZXhlbFNpemVdIC0gVGhlIGFic29sdXRlIHNjcmVlbiB0ZXhlbCBzaXplLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2hvd0ZvY3VzPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGZvY3VzIHBvaW50IHNob3VsZCBiZSBoaWdobGlnaHRlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hbnVhbERvRj1mYWxzZV0gLSBFbmFibGVzIG1hbnVhbCBkZXB0aCBvZiBmaWVsZCBibHVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmlnbmV0dGU9ZmFsc2VdIC0gRW5hYmxlcyBhIHZpZ25ldHRlIGVmZmVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBlbnRhZ29uPWZhbHNlXSAtIEVuYWJsZSB0byB1c2UgYSBwZW50YWdvbmFsIHNoYXBlIHRvIHNjYWxlIGdhdGhlcmVkIHRleGVscy5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNoYWRlckZvY3VzPXRydWVdIC0gRGlzYWJsZSBpZiB5b3UgY29tcHV0ZSB5b3VyIG93biBmb2NhbERlcHRoIChpbiBtZXRyZXMhKS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vaXNlPXRydWVdIC0gRGlzYWJsZSBpZiB5b3UgZG9uJ3Qgd2FudCBub2lzZSBwYXR0ZXJucyBmb3IgZGl0aGVyaW5nLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihjYW1lcmEgPSBudWxsLCBvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRpZihvcHRpb25zLnJpbmdzID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5yaW5ncyA9IDM7IH1cclxuXHRcdGlmKG9wdGlvbnMuc2FtcGxlcyA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuc2FtcGxlcyA9IDI7IH1cclxuXHRcdGlmKG9wdGlvbnMuc2hvd0ZvY3VzID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5zaG93Rm9jdXMgPSBmYWxzZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5zaG93Rm9jdXMgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnNob3dGb2N1cyA9IGZhbHNlOyB9XHJcblx0XHRpZihvcHRpb25zLm1hbnVhbERvRiA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMubWFudWFsRG9GID0gZmFsc2U7IH1cclxuXHRcdGlmKG9wdGlvbnMudmlnbmV0dGUgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnZpZ25ldHRlID0gZmFsc2U7IH1cclxuXHRcdGlmKG9wdGlvbnMucGVudGFnb24gPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnBlbnRhZ29uID0gZmFsc2U7IH1cclxuXHRcdGlmKG9wdGlvbnMuc2hhZGVyRm9jdXMgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnNoYWRlckZvY3VzID0gdHJ1ZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5ub2lzZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMubm9pc2UgPSB0cnVlOyB9XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJCb2tlaDJNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0ZGVmaW5lczoge1xyXG5cclxuXHRcdFx0XHRSSU5HU19JTlQ6IG9wdGlvbnMucmluZ3MudG9GaXhlZCgwKSxcclxuXHRcdFx0XHRSSU5HU19GTE9BVDogb3B0aW9ucy5yaW5ncy50b0ZpeGVkKDEpLFxyXG5cdFx0XHRcdFNBTVBMRVNfSU5UOiBvcHRpb25zLnNhbXBsZXMudG9GaXhlZCgwKSxcclxuXHRcdFx0XHRTQU1QTEVTX0ZMT0FUOiBvcHRpb25zLnNhbXBsZXMudG9GaXhlZCgxKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0RGVwdGg6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cclxuXHRcdFx0XHR0ZXhlbFNpemU6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IyKCkpLFxyXG5cdFx0XHRcdGhhbGZUZXhlbFNpemU6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IyKCkpLFxyXG5cclxuXHRcdFx0XHRjYW1lcmFOZWFyOiBuZXcgVW5pZm9ybSgwLjEpLFxyXG5cdFx0XHRcdGNhbWVyYUZhcjogbmV3IFVuaWZvcm0oMjAwMCksXHJcblxyXG5cdFx0XHRcdGZvY2FsTGVuZ3RoOiBuZXcgVW5pZm9ybSgyNC4wKSxcclxuXHRcdFx0XHRmb2NhbFN0b3A6IG5ldyBVbmlmb3JtKDAuOSksXHJcblxyXG5cdFx0XHRcdG1heEJsdXI6IG5ldyBVbmlmb3JtKDEuMCksXHJcblx0XHRcdFx0bHVtaW5hbmNlVGhyZXNob2xkOiBuZXcgVW5pZm9ybSgwLjUpLFxyXG5cdFx0XHRcdGx1bWluYW5jZUdhaW46IG5ldyBVbmlmb3JtKDIuMCksXHJcblx0XHRcdFx0bHVtaW5hbmNlQ29lZmZpY2llbnRzOiBuZXcgVW5pZm9ybShuZXcgVmVjdG9yMygwLjIxMjYsIDAuNzE1MiwgMC4wNzIyKSksXHJcblx0XHRcdFx0YmlhczogbmV3IFVuaWZvcm0oMC41KSxcclxuXHRcdFx0XHRmcmluZ2U6IG5ldyBVbmlmb3JtKDAuNyksXHJcblx0XHRcdFx0ZGl0aGVyU3RyZW5ndGg6IG5ldyBVbmlmb3JtKDAuMDAwMSksXHJcblxyXG5cdFx0XHRcdGZvY3VzQ29vcmRzOiBuZXcgVW5pZm9ybShuZXcgVmVjdG9yMigwLjUsIDAuNSkpLFxyXG5cdFx0XHRcdGZvY2FsRGVwdGg6IG5ldyBVbmlmb3JtKDEuMClcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZihvcHRpb25zLnNob3dGb2N1cykgeyB0aGlzLmRlZmluZXMuU0hPV19GT0NVUyA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLm1hbnVhbERvRikgeyB0aGlzLmRlZmluZXMuTUFOVUFMX0RPRiA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLnZpZ25ldHRlKSB7IHRoaXMuZGVmaW5lcy5WSUdORVRURSA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLnBlbnRhZ29uKSB7IHRoaXMuZGVmaW5lcy5QRU5UQUdPTiA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLnNoYWRlckZvY3VzKSB7IHRoaXMuZGVmaW5lcy5TSEFERVJfRk9DVVMgPSBcIjFcIjsgfVxyXG5cdFx0aWYob3B0aW9ucy5ub2lzZSkgeyB0aGlzLmRlZmluZXMuTk9JU0UgPSBcIjFcIjsgfVxyXG5cclxuXHRcdGlmKG9wdGlvbnMudGV4ZWxTaXplICE9PSB1bmRlZmluZWQpIHsgdGhpcy5zZXRUZXhlbFNpemUob3B0aW9ucy50ZXhlbFNpemUueCwgb3B0aW9ucy50ZXhlbFNpemUueSk7IH1cclxuXHRcdGlmKGNhbWVyYSAhPT0gbnVsbCkgeyB0aGlzLmFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTsgfVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHRleGVsIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB0ZXhlbCBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFRleGVsU2l6ZSh4LCB5KSB7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHgsIHkpO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy5oYWxmVGV4ZWxTaXplLnZhbHVlLnNldCh4LCB5KS5tdWx0aXBseVNjYWxhcigwLjUpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkb3B0cyB0aGUgbmVhciBhbmQgZmFyIHBsYW5lIGFuZCB0aGUgZm9jYWwgbGVuZ3RoIG9mIHRoZSBnaXZlbiBjYW1lcmEuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuXHJcblx0ICovXHJcblxyXG5cdGFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKSB7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XHJcblx0XHR0aGlzLnVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XHJcblx0XHR0aGlzLnVuaWZvcm1zLmZvY2FsTGVuZ3RoLnZhbHVlID0gY2FtZXJhLmdldEZvY2FsTGVuZ3RoKCk7IC8vIHVuaXQ6IG1tLlxyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTE7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTI7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5MTtcXHJcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHkyO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzQgdGV4ZWwxID0gb3BhY2l0eTEgKiB0ZXh0dXJlMkQodGV4dHVyZTEsIHZVdik7XFxyXFxuXFx0dmVjNCB0ZXhlbDIgPSBvcGFjaXR5MiAqIHRleHR1cmUyRCh0ZXh0dXJlMiwgdlV2KTtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgU0NSRUVOX01PREVcXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIGludlRleGVsMSA9IHZlYzMoMS4wKSAtIHRleGVsMS5yZ2I7XFxyXFxuXFx0XFx0dmVjMyBpbnZUZXhlbDIgPSB2ZWMzKDEuMCkgLSB0ZXhlbDIucmdiO1xcclxcblxcclxcblxcdFxcdHZlYzQgY29sb3IgPSB2ZWM0KFxcclxcblxcdFxcdFxcdHZlYzMoMS4wKSAtIGludlRleGVsMSAqIGludlRleGVsMixcXHJcXG5cXHRcXHRcXHR0ZXhlbDEuYSArIHRleGVsMi5hXFxyXFxuXFx0XFx0KTtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdHZlYzQgY29sb3IgPSB0ZXhlbDEgKyB0ZXhlbDI7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWF0ZXJpYWwgZm9yIGNvbWJpbmluZyB0d28gdGV4dHVyZXMuXHJcbiAqXHJcbiAqIFRoaXMgbWF0ZXJpYWwgc3VwcG9ydHMgdGhlIHR3byBibGVuZCBtb2RlcyBBZGQgYW5kIFNjcmVlbi5cclxuICpcclxuICogSW4gU2NyZWVuIG1vZGUsIHRoZSB0d28gdGV4dHVyZXMgYXJlIGVmZmVjdGl2ZWx5IHByb2plY3RlZCBvbiBhIHdoaXRlIHNjcmVlblxyXG4gKiBzaW11bHRhbmVvdXNseS4gSW4gQWRkIG1vZGUsIHRoZSB0ZXh0dXJlcyBhcmUgc2ltcGx5IGFkZGVkIHRvZ2V0aGVyIHdoaWNoXHJcbiAqIG9mdGVuIHByb2R1Y2VzIHVuZGVzaXJlZCwgd2FzaGVkIG91dCByZXN1bHRzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBDb21iaW5lTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY29tYmluZSBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NjcmVlbk1vZGU9ZmFsc2VdIC0gV2hldGhlciB0aGUgc2NyZWVuIGJsZW5kIG1vZGUgc2hvdWxkIGJlIHVzZWQuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHNjcmVlbk1vZGUgPSBmYWxzZSkge1xyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiQ29tYmluZU1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlMTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dGV4dHVyZTI6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cclxuXHRcdFx0XHRvcGFjaXR5MTogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHRcdFx0XHRvcGFjaXR5MjogbmV3IFVuaWZvcm0oMS4wKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmKHNjcmVlbk1vZGUpIHsgdGhpcy5kZWZpbmVzLlNDUkVFTl9NT0RFID0gXCIxXCI7IH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSwgVmVjdG9yMiB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXYwO1xcclxcbnZhcnlpbmcgdmVjMiB2VXYxO1xcclxcbnZhcnlpbmcgdmVjMiB2VXYyO1xcclxcbnZhcnlpbmcgdmVjMiB2VXYzO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQvLyBTYW1wbGUgdG9wIGxlZnQgdGV4ZWwuXFxyXFxuXFx0dmVjNCBzdW0gPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdjApO1xcclxcblxcclxcblxcdC8vIFNhbXBsZSB0b3AgcmlnaHQgdGV4ZWwuXFxyXFxuXFx0c3VtICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2MSk7XFxyXFxuXFxyXFxuXFx0Ly8gU2FtcGxlIGJvdHRvbSByaWdodCB0ZXhlbC5cXHJcXG5cXHRzdW0gKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYyKTtcXHJcXG5cXHJcXG5cXHQvLyBTYW1wbGUgYm90dG9tIGxlZnQgdGV4ZWwuXFxyXFxuXFx0c3VtICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2Myk7XFxyXFxuXFxyXFxuXFx0Ly8gQ29tcHV0ZSB0aGUgYXZlcmFnZS5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBzdW0gKiAwLjI1O1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcclxcbnVuaWZvcm0gdmVjMiBoYWxmVGV4ZWxTaXplO1xcclxcbnVuaWZvcm0gZmxvYXQga2VybmVsO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXYwO1xcclxcbnZhcnlpbmcgdmVjMiB2VXYxO1xcclxcbnZhcnlpbmcgdmVjMiB2VXYyO1xcclxcbnZhcnlpbmcgdmVjMiB2VXYzO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIGRVdiA9ICh0ZXhlbFNpemUgKiB2ZWMyKGtlcm5lbCkpICsgaGFsZlRleGVsU2l6ZTtcXHJcXG5cXHJcXG5cXHR2VXYwID0gdmVjMih1di54IC0gZFV2LngsIHV2LnkgKyBkVXYueSk7XFxyXFxuXFx0dlV2MSA9IHZlYzIodXYueCArIGRVdi54LCB1di55ICsgZFV2LnkpO1xcclxcblxcdHZVdjIgPSB2ZWMyKHV2LnggKyBkVXYueCwgdXYueSAtIGRVdi55KTtcXHJcXG5cXHR2VXYzID0gdmVjMih1di54IC0gZFV2LngsIHV2LnkgLSBkVXYueSk7XFxyXFxuXFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQW4gb3B0aW1pc2VkIGNvbnZvbHV0aW9uIHNoYWRlciBtYXRlcmlhbC5cclxuICpcclxuICogQmFzZWQgb24gdGhlIEdEQzIwMDMgUHJlc2VudGF0aW9uIGJ5IE1hc2FraSBLYXdhc2UsIEJ1bmthc2hhIEdhbWVzOlxyXG4gKiAgRnJhbWUgQnVmZmVyIFBvc3Rwcm9jZXNzaW5nIEVmZmVjdHMgaW4gRE9VQkxFLVMuVC5FLkEuTCAoV3JlY2tsZXNzKVxyXG4gKiBhbmQgYW4gYXJ0aWNsZSBieSBGaWxpcCBTdHJ1Z2FyLCBJbnRlbDpcclxuICogIEFuIGludmVzdGlnYXRpb24gb2YgZmFzdCByZWFsLXRpbWUgR1BVLWJhc2VkIGltYWdlIGJsdXIgYWxnb3JpdGhtc1xyXG4gKlxyXG4gKiBGdXJ0aGVyIG1vZGlmaWVkIGFjY29yZGluZyB0byBBcHBsZSdzXHJcbiAqIFtCZXN0IFByYWN0aWNlcyBmb3IgU2hhZGVyc10oaHR0cHM6Ly9nb28uZ2wvbG1Sb001KS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQ29udm9sdXRpb25NYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb252b2x1dGlvbiBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3RleGVsU2l6ZV0gLSBUaGUgYWJzb2x1dGUgc2NyZWVuIHRleGVsIHNpemUuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyKCkpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkNvbnZvbHV0aW9uTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0ZXhlbFNpemU6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IyKCkpLFxyXG5cdFx0XHRcdGhhbGZUZXhlbFNpemU6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IyKCkpLFxyXG5cdFx0XHRcdGtlcm5lbDogbmV3IFVuaWZvcm0oMC4wKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuc2V0VGV4ZWxTaXplKHRleGVsU2l6ZS54LCB0ZXhlbFNpemUueSk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY3VycmVudCBrZXJuZWwgc2l6ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7S2VybmVsU2l6ZX1cclxuXHRcdCAqIEBkZWZhdWx0IEtlcm5lbFNpemUuTEFSR0VcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMua2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTEFSR0U7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUga2VybmVsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBUaGUga2VybmVsLlxyXG5cdCAqL1xyXG5cclxuXHRnZXRLZXJuZWwoKSB7IHJldHVybiBrZXJuZWxQcmVzZXRzW3RoaXMua2VybmVsU2l6ZV07IH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHRleGVsIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHRleGVsIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0VGV4ZWxTaXplKHgsIHkpIHtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XHJcblx0XHR0aGlzLnVuaWZvcm1zLmhhbGZUZXhlbFNpemUudmFsdWUuc2V0KHgsIHkpLm11bHRpcGx5U2NhbGFyKDAuNSk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgS2F3YXNlIGJsdXIga2VybmVsIHByZXNldHMuXHJcbiAqXHJcbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXlbXX1cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5jb25zdCBrZXJuZWxQcmVzZXRzID0gW1xyXG5cdG5ldyBGbG9hdDMyQXJyYXkoWzAuMCwgMC4wXSksXHJcblx0bmV3IEZsb2F0MzJBcnJheShbMC4wLCAxLjAsIDEuMF0pLFxyXG5cdG5ldyBGbG9hdDMyQXJyYXkoWzAuMCwgMS4wLCAxLjAsIDIuMF0pLFxyXG5cdG5ldyBGbG9hdDMyQXJyYXkoWzAuMCwgMS4wLCAyLjAsIDIuMCwgMy4wXSksXHJcblx0bmV3IEZsb2F0MzJBcnJheShbMC4wLCAxLjAsIDIuMCwgMy4wLCA0LjAsIDQuMCwgNS4wXSksXHJcblx0bmV3IEZsb2F0MzJBcnJheShbMC4wLCAxLjAsIDIuMCwgMy4wLCA0LjAsIDUuMCwgNy4wLCA4LjAsIDkuMCwgMTAuMF0pXHJcbl07XHJcblxyXG4vKipcclxuICogQSBrZXJuZWwgc2l6ZSBlbnVtZXJhdGlvbi5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFZFUllfU01BTEwgLSBBIHZlcnkgc21hbGwga2VybmVsIHRoYXQgbWF0Y2hlcyBhIDd4NyBHYXVzcyBibHVyIGtlcm5lbC5cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFNNQUxMIC0gQSBzbWFsbCBrZXJuZWwgdGhhdCBtYXRjaGVzIGEgMTV4MTUgR2F1c3MgYmx1ciBrZXJuZWwuXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBNRURJVU0gLSBBIG1lZGl1bSBzaXplZCBrZXJuZWwgdGhhdCBtYXRjaGVzIGEgMjN4MjMgR2F1c3MgYmx1ciBrZXJuZWwuXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMQVJHRSAtIEEgbGFyZ2Uga2VybmVsIHRoYXQgbWF0Y2hlcyBhIDM1eDM1IEdhdXNzIGJsdXIga2VybmVsLlxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gVkVSWV9MQVJHRSAtIEEgdmVyeSBsYXJnZSBrZXJuZWwgdGhhdCBtYXRjaGVzIGEgNjN4NjMgR2F1c3MgYmx1ciBrZXJuZWwuXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBIVUdFIC0gQSBodWdlIGtlcm5lbCB0aGF0IG1hdGNoZXMgYSAxMjd4MTI3IEdhdXNzIGJsdXIga2VybmVsLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjb25zdCBLZXJuZWxTaXplID0ge1xyXG5cclxuXHRWRVJZX1NNQUxMOiAwLFxyXG5cdFNNQUxMOiAxLFxyXG5cdE1FRElVTTogMixcclxuXHRMQVJHRTogMyxcclxuXHRWRVJZX0xBUkdFOiA0LFxyXG5cdEhVR0U6IDVcclxuXHJcbn07XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gb3BhY2l0eSAqIHRleGVsO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIHNpbXBsZSBjb3B5IHNoYWRlciBtYXRlcmlhbC5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQ29weU1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvcHkgbWF0ZXJpYWwuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiQ29weU1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0b3BhY2l0eTogbmV3IFVuaWZvcm0oMS4wKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERlcHRoO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxuI2lmbmRlZiBVU0VfTE9HREVQVEhCVUZcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8cGFja2luZz5cXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7XFxyXFxuXFx0dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgcmVhZERlcHRoKHNhbXBsZXIyRCBkZXB0aFNhbXBsZXIsIHZlYzIgY29vcmQpIHtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmcmFnQ29vcmRaID0gdGV4dHVyZTJEKGRlcHRoU2FtcGxlciwgY29vcmQpLng7XFxyXFxuXFx0XFx0ZmxvYXQgdmlld1ogPSBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihmcmFnQ29vcmRaLCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIpO1xcclxcblxcclxcblxcdFxcdHJldHVybiB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osIGNhbWVyYU5lYXIsIGNhbWVyYUZhcik7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZGVwdGggPSB0ZXh0dXJlMkQodERlcHRoLCB2VXYpLng7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBkZXB0aCA9IHJlYWREZXB0aCh0RGVwdGgsIHZVdik7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChkZXB0aCwgZGVwdGgsIGRlcHRoLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIGRlcHRoIHNoYWRlciBtYXRlcmlhbC5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRGVwdGhNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IFtjYW1lcmFdIC0gQSBjYW1lcmEuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKGNhbWVyYSA9IG51bGwpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkRlcHRoTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtKDAuMSksXHJcblx0XHRcdFx0Y2FtZXJhRmFyOiBuZXcgVW5pZm9ybSgyMDAwKSxcclxuXHJcblx0XHRcdFx0dERlcHRoOiBuZXcgVW5pZm9ybShudWxsKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmKGNhbWVyYSAhPT0gbnVsbCkgeyB0aGlzLmFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTsgfVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkb3B0cyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxyXG5cdCAqL1xyXG5cclxuXHRhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy5jYW1lcmFGYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3I0IH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBhbmdsZTtcXHJcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcclxcbnVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxudmFyeWluZyB2ZWMyIHZVdlBhdHRlcm47XFxyXFxuXFxyXFxuZmxvYXQgcGF0dGVybigpIHtcXHJcXG5cXHJcXG5cXHRmbG9hdCBzID0gc2luKGFuZ2xlKTtcXHJcXG5cXHRmbG9hdCBjID0gY29zKGFuZ2xlKTtcXHJcXG5cXHJcXG5cXHR2ZWMyIHBvaW50ID0gdmVjMihjICogdlV2UGF0dGVybi54IC0gcyAqIHZVdlBhdHRlcm4ueSwgcyAqIHZVdlBhdHRlcm4ueCArIGMgKiB2VXZQYXR0ZXJuLnkpICogc2NhbGU7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIChzaW4ocG9pbnQueCkgKiBzaW4ocG9pbnQueSkpICogNC4wO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXHJcXG5cXHR2ZWMzIGNvbG9yID0gdGV4ZWwucmdiO1xcclxcblxcclxcblxcdCNpZmRlZiBBVkVSQUdFXFxyXFxuXFxyXFxuXFx0XFx0Y29sb3IgPSB2ZWMzKChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRjb2xvciA9IHZlYzMoY29sb3IgKiAxMC4wIC0gNS4wICsgcGF0dGVybigpKTtcXHJcXG5cXHRjb2xvciA9IHRleGVsLnJnYiArIChjb2xvciAtIHRleGVsLnJnYikgKiBpbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgdGV4ZWwuYSk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG52YXJ5aW5nIHZlYzIgdlV2UGF0dGVybjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0dlV2UGF0dGVybiA9IHV2ICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgZG90IHNjcmVlbiBzaGFkZXIgbWF0ZXJpYWwuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIERvdFNjcmVlbk1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGRvdCBzY3JlZW4gbWF0ZXJpYWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFthdmVyYWdlPWZhbHNlXSAtIFdoZXRoZXIgdGhlIHNoYWRlciBzaG91bGQgb3V0cHV0IHRoZSBjb2xvdXIgYXZlcmFnZSAoYmxhY2sgYW5kIHdoaXRlKS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoYXZlcmFnZSA9IGZhbHNlKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJEb3RTY3JlZW5NYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cclxuXHRcdFx0XHRhbmdsZTogbmV3IFVuaWZvcm0oMS41NyksXHJcblx0XHRcdFx0c2NhbGU6IG5ldyBVbmlmb3JtKDEuMCksXHJcblx0XHRcdFx0aW50ZW5zaXR5OiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cclxuXHRcdFx0XHRvZmZzZXRSZXBlYXQ6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3I0KDAuNSwgMC41LCAxLjAsIDEuMCkpXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYoYXZlcmFnZSkgeyB0aGlzLmRlZmluZXMuQVZFUkFHRSA9IFwiMVwiOyB9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0sIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG4jaWZkZWYgTk9JU0VcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IG5vaXNlSW50ZW5zaXR5O1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZmRlZiBTQ0FOTElORVNcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IHNjYW5saW5lSW50ZW5zaXR5O1xcclxcblxcdHVuaWZvcm0gZmxvYXQgc2NhbmxpbmVDb3VudDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWZkZWYgR1JFWVNDQUxFXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSB2ZWMzIGx1bWluYW5jZUNvZWZmaWNpZW50cztcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGdyZXlzY2FsZUludGVuc2l0eTtcXHJcXG5cXHJcXG4jZWxpZiBkZWZpbmVkKFNFUElBKVxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgc2VwaWFJbnRlbnNpdHk7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuI2lmZGVmIFZJR05FVFRFXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBmbG9hdCB2aWduZXR0ZU9mZnNldDtcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IHZpZ25ldHRlRGFya25lc3M7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XFxyXFxuXFx0dmVjMyBjb2xvciA9IHRleGVsLnJnYjtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgU0NSRUVOX01PREVcXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIGludkNvbG9yO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZmRlZiBOT0lTRVxcclxcblxcclxcblxcdFxcdGZsb2F0IHggPSB2VXYueCAqIHZVdi55ICogdGltZSAqIDEwMDAuMDtcXHJcXG5cXHRcXHR4ID0gbW9kKHgsIDEzLjApICogbW9kKHgsIDEyMy4wKTtcXHJcXG5cXHRcXHR4ID0gbW9kKHgsIDAuMDEpO1xcclxcblxcclxcblxcdFxcdHZlYzMgbm9pc2UgPSB0ZXhlbC5yZ2IgKiBjbGFtcCgwLjEgKyB4ICogMTAwLjAsIDAuMCwgMS4wKSAqIG5vaXNlSW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBTQ1JFRU5fTU9ERVxcclxcblxcclxcblxcdFxcdFxcdGludkNvbG9yID0gdmVjMygxLjApIC0gY29sb3I7XFxyXFxuXFx0XFx0XFx0dmVjMyBpbnZOb2lzZSA9IHZlYzMoMS4wKSAtIG5vaXNlO1xcclxcblxcclxcblxcdFxcdFxcdGNvbG9yID0gdmVjMygxLjApIC0gaW52Q29sb3IgKiBpbnZOb2lzZTtcXHJcXG5cXHJcXG5cXHRcXHQjZWxzZVxcclxcblxcclxcblxcdFxcdFxcdGNvbG9yICs9IG5vaXNlO1xcclxcblxcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZmRlZiBTQ0FOTElORVNcXHJcXG5cXHJcXG5cXHRcXHR2ZWMyIHNsID0gdmVjMihzaW4odlV2LnkgKiBzY2FubGluZUNvdW50KSwgY29zKHZVdi55ICogc2NhbmxpbmVDb3VudCkpO1xcclxcblxcdFxcdHZlYzMgc2NhbmxpbmVzID0gdGV4ZWwucmdiICogdmVjMyhzbC54LCBzbC55LCBzbC54KSAqIHNjYW5saW5lSW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBTQ1JFRU5fTU9ERVxcclxcblxcclxcblxcdFxcdFxcdGludkNvbG9yID0gdmVjMygxLjApIC0gY29sb3I7XFxyXFxuXFx0XFx0XFx0dmVjMyBpbnZTY2FubGluZXMgPSB2ZWMzKDEuMCkgLSBzY2FubGluZXM7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29sb3IgPSB2ZWMzKDEuMCkgLSBpbnZDb2xvciAqIGludlNjYW5saW5lcztcXHJcXG5cXHJcXG5cXHRcXHQjZWxzZVxcclxcblxcclxcblxcdFxcdFxcdGNvbG9yICs9IHNjYW5saW5lcztcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaWZkZWYgR1JFWVNDQUxFXFxyXFxuXFxyXFxuXFx0XFx0Y29sb3IgPSBtaXgoY29sb3IsIHZlYzMoZG90KGNvbG9yLCBsdW1pbmFuY2VDb2VmZmljaWVudHMpKSwgZ3JleXNjYWxlSW50ZW5zaXR5KTtcXHJcXG5cXHJcXG5cXHQjZWxpZiBkZWZpbmVkKFNFUElBKVxcclxcblxcclxcblxcdFxcdHZlYzMgYyA9IGNvbG9yLnJnYjtcXHJcXG5cXHJcXG5cXHRcXHRjb2xvci5yID0gZG90KGMsIHZlYzMoMS4wIC0gMC42MDcgKiBzZXBpYUludGVuc2l0eSwgMC43NjkgKiBzZXBpYUludGVuc2l0eSwgMC4xODkgKiBzZXBpYUludGVuc2l0eSkpO1xcclxcblxcdFxcdGNvbG9yLmcgPSBkb3QoYywgdmVjMygwLjM0OSAqIHNlcGlhSW50ZW5zaXR5LCAxLjAgLSAwLjMxNCAqIHNlcGlhSW50ZW5zaXR5LCAwLjE2OCAqIHNlcGlhSW50ZW5zaXR5KSk7XFxyXFxuXFx0XFx0Y29sb3IuYiA9IGRvdChjLCB2ZWMzKDAuMjcyICogc2VwaWFJbnRlbnNpdHksIDAuNTM0ICogc2VwaWFJbnRlbnNpdHksIDEuMCAtIDAuODY5ICogc2VwaWFJbnRlbnNpdHkpKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaWZkZWYgVklHTkVUVEVcXHJcXG5cXHJcXG5cXHRcXHRjb25zdCB2ZWMyIGNlbnRlciA9IHZlYzIoMC41KTtcXHJcXG5cXHJcXG5cXHRcXHQjaWZkZWYgRVNLSUxcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWMyIHV2ID0gKHZVdiAtIGNlbnRlcikgKiB2ZWMyKHZpZ25ldHRlT2Zmc2V0KTtcXHJcXG5cXHRcXHRcXHRjb2xvciA9IG1peChjb2xvci5yZ2IsIHZlYzMoMS4wIC0gdmlnbmV0dGVEYXJrbmVzcyksIGRvdCh1diwgdXYpKTtcXHJcXG5cXHJcXG5cXHRcXHQjZWxzZVxcclxcblxcclxcblxcdFxcdFxcdGZsb2F0IGRpc3QgPSBkaXN0YW5jZSh2VXYsIGNlbnRlcik7XFxyXFxuXFx0XFx0XFx0Y29sb3IgKj0gc21vb3Roc3RlcCgwLjgsIHZpZ25ldHRlT2Zmc2V0ICogMC43OTksIGRpc3QgKiAodmlnbmV0dGVEYXJrbmVzcyArIHZpZ25ldHRlT2Zmc2V0KSk7XFxyXFxuXFxyXFxuXFx0XFx0I2VuZGlmXFx0XFx0XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjbGFtcChjb2xvciwgMC4wLCAxLjApLCB0ZXhlbC5hKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBjaW5lbWF0aWMgc2hhZGVyIHRoYXQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBlZmZlY3RzOlxyXG4gKiAgLSBGaWxtIEdyYWluXHJcbiAqICAtIFNjYW5saW5lc1xyXG4gKiAgLSBWaWduZXR0ZVxyXG4gKiAgLSBHcmV5c2NhbGVcclxuICogIC0gU2VwaWFcclxuICpcclxuICogT3JpZ2luYWwgc2NhbmxpbmVzIGFsZ29yaXRobSBieSBQYXQgXCJIYXd0aG9ybmVcIiBTaGVhcm9uLlxyXG4gKiAgaHR0cDovL3d3dy50cnVldmlzaW9uM2QuY29tL2ZvcnVtcy9zaG93Y2FzZS9zdGF0aWNub2lzZV9jb2xvcmJsYWNrd2hpdGVfc2NhbmxpbmVfc2hhZGVycy10MTg2OTguMC5odG1sXHJcbiAqXHJcbiAqIE9wdGltaXNlZCBzY2FubGluZXMgYW5kIG5vaXNlIHdpdGggaW50ZW5zaXR5IHNjYWxpbmcgYnkgR2VvcmcgXCJMZXZpYXRoYW5cIlxyXG4gKiBTdGVpbnJvaGRlci4gVGhpcyB2ZXJzaW9uIHdhcyBwcm92aWRlZCB1bmRlciBhIENyZWF0aXZlIENvbW1vbnMgQXR0cmlidXRpb25cclxuICogMy4wIExpY2Vuc2U6IGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzMuMC5cclxuICpcclxuICogVGhlIHNlcGlhIGVmZmVjdCBpcyBiYXNlZCBvbjpcclxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzXHJcbiAqXHJcbiAqIFRoZSB2aWduZXR0ZSBjb2RlIGlzIGJhc2VkIG9uIFBhaW50RWZmZWN0IHBvc3Rwcm9jZXNzIGZyb20gcm8ubWU6XHJcbiAqICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvMy1kcmVhbXMtb2YtYmxhY2svc291cmNlL2Jyb3dzZS9kZXBsb3kvanMvZWZmZWN0cy9QYWludEVmZmVjdC5qc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBGaWxtTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZmlsbSBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy4gRGlzYWJsZWQgZWZmZWN0cyB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgc2hhZGVyIGFuZCBoYXZlIG5vIG5lZ2F0aXZlIGltcGFjdCBvbiBwZXJmb3JtYW5jZS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmdyZXlzY2FsZT1mYWxzZV0gLSBFbmFibGUgZ3JleXNjYWxlIGVmZmVjdC4gR3JleXNjYWxlIGFuZCBzZXBpYSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VwaWE9ZmFsc2VdIC0gRW5hYmxlIHNlcGlhIGVmZmVjdC4gR3JleXNjYWxlIGFuZCBzZXBpYSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmlnbmV0dGU9ZmFsc2VdIC0gQXBwbHkgdmlnbmV0dGUgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZXNraWw9ZmFsc2VdIC0gVXNlIEVza2lsJ3MgdmlnbmV0dGUgYXBwcm9hY2guIFRoZSBkZWZhdWx0IGxvb2tzIGR1c3R5IHdoaWxlIEVza2lsIGxvb2tzIGJ1cm5lZCBvdXQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zY3JlZW5Nb2RlPXRydWVdIC0gV2hldGhlciB0aGUgc2NyZWVuIGJsZW5kIG1vZGUgc2hvdWxkIGJlIHVzZWQgZm9yIG5vaXNlIGFuZCBzY2FubGluZXMuIEJvdGggb2YgdGhlc2UgZWZmZWN0cyBhcmUgY29tcHV0ZWQgaW5kZXBlbmRlbnRseS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vaXNlPXRydWVdIC0gU2hvdyBub2lzZS1iYXNlZCBmaWxtIGdyYWluLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2NhbmxpbmVzPXRydWVdIC0gU2hvdyBzY2FubGluZXMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm5vaXNlSW50ZW5zaXR5PTAuNV0gLSBUaGUgbm9pc2UgaW50ZW5zaXR5LiAwLjAgdG8gMS4wLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FubGluZUludGVuc2l0eT0wLjA1XSAtIFRoZSBzY2FubGluZSBpbnRlbnNpdHkuIDAuMCB0byAxLjAuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdyZXlzY2FsZUludGVuc2l0eT0xLjBdIC0gVGhlIGludGVuc2l0eSBvZiB0aGUgZ3JleXNjYWxlIGVmZmVjdC4gMC4wIHRvIDEuMC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2VwaWFJbnRlbnNpdHk9MS4wXSAtIFRoZSBpbnRlbnNpdHkgb2YgdGhlIHNlcGlhIGVmZmVjdC4gMC4wIHRvIDEuMC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlnbmV0dGVPZmZzZXQ9MS4wXSAtIFRoZSBvZmZzZXQgb2YgdGhlIHZpZ25ldHRlIGVmZmVjdC4gMC4wIHRvIDEuMC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlnbmV0dGVEYXJrbmVzcz0xLjBdIC0gVGhlIGRhcmtuZXNzIG9mIHRoZSB2aWduZXR0ZSBlZmZlY3QuIDAuMCB0byAxLjAuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdGlmKG9wdGlvbnMuc2NyZWVuTW9kZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuc2NyZWVuTW9kZSA9IHRydWU7IH1cclxuXHRcdGlmKG9wdGlvbnMubm9pc2UgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLm5vaXNlID0gdHJ1ZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5zY2FubGluZXMgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnNjYW5saW5lcyA9IHRydWU7IH1cclxuXHJcblx0XHRpZihvcHRpb25zLmdyZXlzY2FsZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuZ3JleXNjYWxlID0gZmFsc2U7IH1cclxuXHRcdGlmKG9wdGlvbnMuc2VwaWEgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnNlcGlhID0gZmFsc2U7IH1cclxuXHRcdGlmKG9wdGlvbnMudmlnbmV0dGUgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnZpZ25ldHRlID0gZmFsc2U7IH1cclxuXHRcdGlmKG9wdGlvbnMuZXNraWwgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLmVza2lsID0gZmFsc2U7IH1cclxuXHJcblx0XHRpZihvcHRpb25zLm5vaXNlSW50ZW5zaXR5ID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5ub2lzZUludGVuc2l0eSA9IDAuNTsgfVxyXG5cdFx0aWYob3B0aW9ucy5zY2FubGluZUludGVuc2l0eSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuc2NhbmxpbmVJbnRlbnNpdHkgPSAwLjA1OyB9XHJcblx0XHRpZihvcHRpb25zLmdyZXlzY2FsZUludGVuc2l0eSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuZ3JleXNjYWxlSW50ZW5zaXR5ID0gMS4wOyB9XHJcblx0XHRpZihvcHRpb25zLnNlcGlhSW50ZW5zaXR5ID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5zZXBpYUludGVuc2l0eSA9IDEuMDsgfVxyXG5cclxuXHRcdGlmKG9wdGlvbnMudmlnbmV0dGVPZmZzZXQgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnZpZ25ldHRlT2Zmc2V0ID0gMS4wOyB9XHJcblx0XHRpZihvcHRpb25zLnZpZ25ldHRlRGFya25lc3MgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnZpZ25ldHRlRGFya25lc3MgPSAxLjA7IH1cclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkZpbG1NYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRpbWU6IG5ldyBVbmlmb3JtKDAuMCksXHJcblxyXG5cdFx0XHRcdG5vaXNlSW50ZW5zaXR5OiBuZXcgVW5pZm9ybShvcHRpb25zLm5vaXNlSW50ZW5zaXR5KSxcclxuXHRcdFx0XHRzY2FubGluZUludGVuc2l0eTogbmV3IFVuaWZvcm0ob3B0aW9ucy5zY2FubGluZUludGVuc2l0eSksXHJcblx0XHRcdFx0c2NhbmxpbmVDb3VudDogbmV3IFVuaWZvcm0oMC4wKSxcclxuXHJcblx0XHRcdFx0bHVtaW5hbmNlQ29lZmZpY2llbnRzOiBuZXcgVW5pZm9ybShuZXcgVmVjdG9yMygwLjIxMjYsIDAuNzE1MiwgMC4wNzIyKSksXHJcblx0XHRcdFx0Z3JleXNjYWxlSW50ZW5zaXR5OiBuZXcgVW5pZm9ybShvcHRpb25zLmdyZXlzY2FsZUludGVuc2l0eSksXHJcblx0XHRcdFx0c2VwaWFJbnRlbnNpdHk6IG5ldyBVbmlmb3JtKG9wdGlvbnMuc2VwaWFJbnRlbnNpdHkpLFxyXG5cclxuXHRcdFx0XHR2aWduZXR0ZU9mZnNldDogbmV3IFVuaWZvcm0ob3B0aW9ucy52aWduZXR0ZU9mZnNldCksXHJcblx0XHRcdFx0dmlnbmV0dGVEYXJrbmVzczogbmV3IFVuaWZvcm0ob3B0aW9ucy52aWduZXR0ZURhcmtuZXNzKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmKG9wdGlvbnMuZ3JleXNjYWxlKSB7IHRoaXMuZGVmaW5lcy5HUkVZU0NBTEUgPSBcIjFcIjsgfVxyXG5cdFx0aWYob3B0aW9ucy5zZXBpYSkgeyB0aGlzLmRlZmluZXMuU0VQSUEgPSBcIjFcIjsgfVxyXG5cdFx0aWYob3B0aW9ucy52aWduZXR0ZSkgeyB0aGlzLmRlZmluZXMuVklHTkVUVEUgPSBcIjFcIjsgfVxyXG5cdFx0aWYob3B0aW9ucy5lc2tpbCkgeyB0aGlzLmRlZmluZXMuRVNLSUwgPSBcIjFcIjsgfVxyXG5cclxuXHRcdGlmKG9wdGlvbnMuc2NyZWVuTW9kZSkgeyB0aGlzLmRlZmluZXMuU0NSRUVOX01PREUgPSBcIjFcIjsgfVxyXG5cdFx0aWYob3B0aW9ucy5ub2lzZSkgeyB0aGlzLmRlZmluZXMuTk9JU0UgPSBcIjFcIjsgfVxyXG5cdFx0aWYob3B0aW9ucy5zY2FubGluZXMpIHsgdGhpcy5kZWZpbmVzLlNDQU5MSU5FUyA9IFwiMVwiOyB9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0gfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB0UGVydHVyYjtcXHJcXG5cXHJcXG51bmlmb3JtIGJvb2wgYWN0aXZlO1xcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgYW1vdW50O1xcclxcbnVuaWZvcm0gZmxvYXQgYW5nbGU7XFxyXFxudW5pZm9ybSBmbG9hdCBzZWVkO1xcclxcbnVuaWZvcm0gZmxvYXQgc2VlZFg7XFxyXFxudW5pZm9ybSBmbG9hdCBzZWVkWTtcXHJcXG51bmlmb3JtIGZsb2F0IGRpc3RvcnRpb25YO1xcclxcbnVuaWZvcm0gZmxvYXQgZGlzdG9ydGlvblk7XFxyXFxudW5pZm9ybSBmbG9hdCBjb2xTO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxuZmxvYXQgcmFuZCh2ZWMyIHRjKSB7XFxyXFxuXFxyXFxuXFx0Y29uc3QgZmxvYXQgYSA9IDEyLjk4OTg7XFxyXFxuXFx0Y29uc3QgZmxvYXQgYiA9IDc4LjIzMztcXHJcXG5cXHRjb25zdCBmbG9hdCBjID0gNDM3NTguNTQ1MztcXHJcXG5cXHJcXG5cXHRmbG9hdCBkdCA9IGRvdCh0YywgdmVjMihhLCBiKSk7XFxyXFxuXFx0ZmxvYXQgc24gPSBtb2QoZHQsIDMuMTQpO1xcclxcblxcclxcblxcdHJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIGNvb3JkID0gdlV2O1xcclxcblxcclxcblxcdGZsb2F0IHhzLCB5cztcXHJcXG5cXHR2ZWM0IG5vcm1hbDtcXHJcXG5cXHJcXG5cXHR2ZWMyIG9mZnNldDtcXHJcXG5cXHR2ZWM0IGNyLCBjZ2EsIGNiO1xcclxcblxcdHZlYzQgc25vdywgY29sb3I7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgc3gsIHN5O1xcclxcblxcclxcblxcdGlmKGFjdGl2ZSkge1xcclxcblxcclxcblxcdFxcdHhzID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnggLyAwLjUpO1xcclxcblxcdFxcdHlzID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnkgLyAwLjUpO1xcclxcblxcclxcblxcdFxcdG5vcm1hbCA9IHRleHR1cmUyRCh0UGVydHVyYiwgY29vcmQgKiBzZWVkICogc2VlZCk7XFxyXFxuXFxyXFxuXFx0XFx0aWYoY29vcmQueSA8IGRpc3RvcnRpb25YICsgY29sUyAmJiBjb29yZC55ID4gZGlzdG9ydGlvblggLSBjb2xTICogc2VlZCkge1xcclxcblxcclxcblxcdFxcdFxcdHN4ID0gY2xhbXAoY2VpbChzZWVkWCksIDAuMCwgMS4wKTtcXHJcXG5cXHRcXHRcXHRjb29yZC55ID0gc3ggKiAoMS4wIC0gKGNvb3JkLnkgKyBkaXN0b3J0aW9uWSkpICsgKDEuMCAtIHN4KSAqIGRpc3RvcnRpb25ZO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZihjb29yZC54IDwgZGlzdG9ydGlvblkgKyBjb2xTICYmIGNvb3JkLnggPiBkaXN0b3J0aW9uWSAtIGNvbFMgKiBzZWVkKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3kgPSBjbGFtcChjZWlsKHNlZWRZKSwgMC4wLCAxLjApO1xcclxcblxcdFxcdFxcdGNvb3JkLnggPSBzeSAqIGRpc3RvcnRpb25YICsgKDEuMCAtIHN5KSAqICgxLjAgLSAoY29vcmQueCArIGRpc3RvcnRpb25YKSk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGNvb3JkLnggKz0gbm9ybWFsLnggKiBzZWVkWCAqIChzZWVkIC8gNS4wKTtcXHJcXG5cXHRcXHRjb29yZC55ICs9IG5vcm1hbC55ICogc2VlZFkgKiAoc2VlZCAvIDUuMCk7XFxyXFxuXFxyXFxuXFx0XFx0b2Zmc2V0ID0gYW1vdW50ICogdmVjMihjb3MoYW5nbGUpLCBzaW4oYW5nbGUpKTtcXHJcXG5cXHJcXG5cXHRcXHRjciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmQgKyBvZmZzZXQpO1xcclxcblxcdFxcdGNnYSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmQpO1xcclxcblxcdFxcdGNiID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZCAtIG9mZnNldCk7XFxyXFxuXFxyXFxuXFx0XFx0Y29sb3IgPSB2ZWM0KGNyLnIsIGNnYS5nLCBjYi5iLCBjZ2EuYSk7XFxyXFxuXFx0XFx0c25vdyA9IDIwMC4wICogYW1vdW50ICogdmVjNChyYW5kKHZlYzIoeHMgKiBzZWVkLCB5cyAqIHNlZWQgKiA1MC4wKSkgKiAwLjIpO1xcclxcblxcdFxcdGNvbG9yICs9IHNub3c7XFxyXFxuXFxyXFxuXFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRjb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gY29sb3I7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgZ2xpdGNoIHNoYWRlciBtYXRlcmlhbC5cclxuICpcclxuICogUmVmZXJlbmNlOlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL3N0YWZmYW50YW4vdW5pdHlnbGl0Y2hcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgR2xpdGNoTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ2xpdGNoIG1hdGVyaWFsLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkdsaXRjaE1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dFBlcnR1cmI6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cclxuXHRcdFx0XHRhY3RpdmU6IG5ldyBVbmlmb3JtKDEpLFxyXG5cclxuXHRcdFx0XHRhbW91bnQ6IG5ldyBVbmlmb3JtKDAuOCksXHJcblx0XHRcdFx0YW5nbGU6IG5ldyBVbmlmb3JtKDAuMDIpLFxyXG5cdFx0XHRcdHNlZWQ6IG5ldyBVbmlmb3JtKDAuMDIpLFxyXG5cdFx0XHRcdHNlZWRYOiBuZXcgVW5pZm9ybSgwLjAyKSxcclxuXHRcdFx0XHRzZWVkWTogbmV3IFVuaWZvcm0oMC4wMiksXHJcblx0XHRcdFx0ZGlzdG9ydGlvblg6IG5ldyBVbmlmb3JtKDAuNSksXHJcblx0XHRcdFx0ZGlzdG9ydGlvblk6IG5ldyBVbmlmb3JtKDAuNiksXHJcblx0XHRcdFx0Y29sUzogbmV3IFVuaWZvcm0oMC4wNSlcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gdmVjMyBsaWdodFBvc2l0aW9uO1xcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgZXhwb3N1cmU7XFxyXFxudW5pZm9ybSBmbG9hdCBkZWNheTtcXHJcXG51bmlmb3JtIGZsb2F0IGRlbnNpdHk7XFxyXFxudW5pZm9ybSBmbG9hdCB3ZWlnaHQ7XFxyXFxudW5pZm9ybSBmbG9hdCBjbGFtcE1heDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIHRleENvb3JkID0gdlV2O1xcclxcblxcclxcblxcdC8vIENhbGN1bGF0ZSB2ZWN0b3IgZnJvbSBwaXhlbCB0byBsaWdodCBzb3VyY2UgaW4gc2NyZWVuIHNwYWNlLlxcclxcblxcdHZlYzIgZGVsdGFUZXhDb29yZCA9IHRleENvb3JkIC0gbGlnaHRQb3NpdGlvbi5zdDtcXHJcXG5cXHRkZWx0YVRleENvb3JkICo9IDEuMCAvIE5VTV9TQU1QTEVTX0ZMT0FUICogZGVuc2l0eTtcXHJcXG5cXHJcXG5cXHQvLyBBIGRlY3JlYXNpbmcgaWxsdW1pbmF0aW9uIGZhY3Rvci5cXHJcXG5cXHRmbG9hdCBpbGx1bWluYXRpb25EZWNheSA9IDEuMDtcXHJcXG5cXHJcXG5cXHR2ZWM0IHNhbXBsZTtcXHJcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcclxcblxcclxcblxcdC8vIEVzdGltYXRlIHRoZSBwcm9iYWJpbGl0eSBvZiBvY2NsdXNpb24gYXQgZWFjaCBwaXhlbCBieSBzdW1taW5nIHNhbXBsZXMgYWxvbmcgYSByYXkgdG8gdGhlIGxpZ2h0IHNvdXJjZS5cXHJcXG5cXHRmb3IoaW50IGkgPSAwOyBpIDwgTlVNX1NBTVBMRVNfSU5UOyArK2kpIHtcXHJcXG5cXHJcXG5cXHRcXHR0ZXhDb29yZCAtPSBkZWx0YVRleENvb3JkO1xcclxcblxcdFxcdHNhbXBsZSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdGV4Q29vcmQpO1xcclxcblxcclxcblxcdFxcdC8vIEFwcGx5IHNhbXBsZSBhdHRlbnVhdGlvbiBzY2FsZS9kZWNheSBmYWN0b3JzLlxcclxcblxcdFxcdHNhbXBsZSAqPSBpbGx1bWluYXRpb25EZWNheSAqIHdlaWdodDtcXHJcXG5cXHJcXG5cXHRcXHRjb2xvciArPSBzYW1wbGU7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gVXBkYXRlIGV4cG9uZW50aWFsIGRlY2F5IGZhY3Rvci5cXHJcXG5cXHRcXHRpbGx1bWluYXRpb25EZWNheSAqPSBkZWNheTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gY2xhbXAoY29sb3IgKiBleHBvc3VyZSwgMC4wLCBjbGFtcE1heCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgY3JlcHVzY3VsYXIgcmF5cyBzaGFkZXIgbWF0ZXJpYWwuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqXHJcbiAqIFRoaWJhdXQgRGVzcG91bGFpbiwgMjAxMjpcclxuICogIFsoV2ViR0wpIFZvbHVtZXRyaWMgTGlnaHQgQXBwcm94aW1hdGlvbiBpbiBUaHJlZS5qc10oXHJcbiAqICBodHRwOi8vYmtjb3JlLmNvbS9ibG9nLzNkL3dlYmdsLXRocmVlLWpzLXZvbHVtZXRyaWMtbGlnaHQtZ29kcmF5cy5odG1sKVxyXG4gKlxyXG4gKiBOdmlkaWEsIEdQVSBHZW1zIDMsIDIwMDg6XHJcbiAqICBbQ2hhcHRlciAxMy4gVm9sdW1ldHJpYyBMaWdodCBTY2F0dGVyaW5nIGFzIGEgUG9zdC1Qcm9jZXNzXShcclxuICogIGh0dHBzOi8vZGV2ZWxvcGVyLm52aWRpYS5jb20vZ3B1Z2Vtcy9HUFVHZW1zMy9ncHVnZW1zM19jaDEzLmh0bWwpXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEdvZFJheXNNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBnb2QgcmF5cyBtYXRlcmlhbC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJHb2RSYXlzTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdGRlZmluZXM6IHtcclxuXHJcblx0XHRcdFx0TlVNX1NBTVBMRVNfRkxPQVQ6IFwiNjAuMFwiLFxyXG5cdFx0XHRcdE5VTV9TQU1QTEVTX0lOVDogXCI2MFwiXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdGxpZ2h0UG9zaXRpb246IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cclxuXHRcdFx0XHRleHBvc3VyZTogbmV3IFVuaWZvcm0oMC42KSxcclxuXHRcdFx0XHRkZWNheTogbmV3IFVuaWZvcm0oMC45MyksXHJcblx0XHRcdFx0ZGVuc2l0eTogbmV3IFVuaWZvcm0oMC45NiksXHJcblx0XHRcdFx0d2VpZ2h0OiBuZXcgVW5pZm9ybSgwLjQpLFxyXG5cdFx0XHRcdGNsYW1wTWF4OiBuZXcgVW5pZm9ybSgxLjApXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0sIFZlY3RvcjIsIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIGZsb2F0IGRpc3RpbmN0aW9uO1xcclxcbnVuaWZvcm0gdmVjMiByYW5nZTtcXHJcXG51bmlmb3JtIHZlYzMgbHVtaW5hbmNlQ29lZmZpY2llbnRzO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XFxyXFxuXFx0ZmxvYXQgdiA9IGRvdCh0ZXhlbC5yZ2IsIGx1bWluYW5jZUNvZWZmaWNpZW50cyk7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFJBTkdFXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgbG93ID0gc3RlcChyYW5nZS54LCB2KTtcXHJcXG5cXHRcXHRmbG9hdCBoaWdoID0gc3RlcCh2LCByYW5nZS55KTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBBcHBseSB0aGUgbWFzay5cXHJcXG5cXHRcXHR2ICo9IGxvdyAqIGhpZ2g7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0diA9IHBvdyhhYnModiksIGRpc3RpbmN0aW9uKTtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgQ09MT1JcXHJcXG5cXHJcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHRleGVsLnJnYiAqIHYsIHRleGVsLmEpO1xcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2LCB2LCB2LCB0ZXhlbC5hKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBsdW1pbm9zaXR5IHNoYWRlciBtYXRlcmlhbC5cclxuICpcclxuICogVGhpcyBzaGFkZXIgcHJvZHVjZXMgYSBncmV5c2NhbGUgbHVtaW5hbmNlIG1hcCB0aGF0IGRlc2NyaWJlcyB0aGUgYWJzb2x1dGVcclxuICogYW1vdW50IG9mIGxpZ2h0IGVtaXR0ZWQgYnkgYSBzY2VuZS4gSXQgY2FuIGFsc28gYmUgY29uZmlndXJlZCB0byBvdXRwdXRcclxuICogY29sb3VycyB0aGF0IGFyZSBzY2FsZWQgd2l0aCB0aGVpciByZXNwZWN0aXZlIGx1bWluYW5jZSB2YWx1ZS4gQWRkaXRpb25hbGx5LFxyXG4gKiBhIHJhbmdlIG1heSBiZSBwcm92aWRlZCB0byBtYXNrIG91dCB1bmRlc2lyZWQgdGV4ZWxzLlxyXG4gKlxyXG4gKiBUaGUgYWxwaGEgY2hhbm5lbCB3aWxsIHJlbWFpbiB1bmFmZmVjdGVkIGluIGFsbCBjYXNlcy5cclxuICpcclxuICogT24gbHVtaW5hbmNlIGNvZWZmaWNpZW50czpcclxuICogIGh0dHA6Ly93d3cucG95bnRvbi5jb20vbm90ZXMvY29sb3VyX2FuZF9nYW1tYS9Db2xvckZBUS5odG1sI1JURlRvQzlcclxuICpcclxuICogQ29lZmZpY2llbnRzIGZvciBkaWZmZXJlbnQgY29sb3VyIHNwYWNlczpcclxuICogIGh0dHBzOi8vaHN0by5vcmcvZ2V0cHJvL2hhYnIvcG9zdF9pbWFnZXMvMmFiLzY5ZC8wODQvMmFiNjlkMDg0ZjlhNTk3ZTAzMjYyNGJjZDc0ZDU3YTcucG5nXHJcbiAqXHJcbiAqIEx1bWluYW5jZSByYW5nZSByZWZlcmVuY2U6XHJcbiAqICBodHRwczovL2N5Y2xpbmc3NC5jb20vMjAwNy8wNS8yMy95b3VyLWZpcnN0LXNoYWRlci8jLlZ0eTlGZmtyTDRaXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEx1bWlub3NpdHlNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsdW1pbm9zaXR5IG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbY29sb3I9ZmFsc2VdIC0gRGVmaW5lcyB3aGV0aGVyIHRoZSBzaGFkZXIgc2hvdWxkIG91dHB1dCBjb2xvdXJzIHNjYWxlZCB3aXRoIHRoZWlyIGx1bWluYW5jZSB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtyYW5nZV0gLSBJZiBwcm92aWRlZCwgdGhlIHNoYWRlciB3aWxsIG1hc2sgb3V0IHRleGVscyB0aGF0IGFyZW4ndCBpbiB0aGUgc3BlY2lmaWVkIGx1bWluYW5jZSByYW5nZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoY29sb3IgPSBmYWxzZSwgcmFuZ2UgPSBudWxsKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJMdW1pbm9zaXR5TWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHRkaXN0aW5jdGlvbjogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHRcdFx0XHRyYW5nZTogbmV3IFVuaWZvcm0oKHJhbmdlICE9PSBudWxsKSA/IHJhbmdlIDogbmV3IFZlY3RvcjIoKSksXHJcblx0XHRcdFx0bHVtaW5hbmNlQ29lZmZpY2llbnRzOiBuZXcgVW5pZm9ybShuZXcgVmVjdG9yMygwLjIxMjYsIDAuNzE1MiwgMC4wNzIyKSlcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYoY29sb3IpIHsgdGhpcy5kZWZpbmVzLkNPTE9SID0gXCIxXCI7IH1cclxuXHRcdGlmKHJhbmdlICE9PSBudWxsKSB7IHRoaXMuZGVmaW5lcy5SQU5HRSA9IFwiMVwiOyB9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0sIFZlY3RvcjIgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIGZsb2F0IGdyYW51bGFyaXR5O1xcclxcbnVuaWZvcm0gZmxvYXQgZHg7XFxyXFxudW5pZm9ybSBmbG9hdCBkeTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWM0IHRleGVsO1xcclxcblxcclxcblxcdGlmKGdyYW51bGFyaXR5ID4gMC4wKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMiBjb29yZCA9IHZlYzIoXFxyXFxuXFx0XFx0XFx0ZHggKiAoZmxvb3IodlV2LnggLyBkeCkgKyAwLjUpLFxcclxcblxcdFxcdFxcdGR5ICogKGZsb29yKHZVdi55IC8gZHkpICsgMC41KVxcclxcblxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0dGV4ZWwgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIGNvb3JkKTtcXHJcXG5cXHJcXG5cXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdHRleGVsID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSB0ZXhlbDtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBwaXhlbGF0aW9uIHNoYWRlciBtYXRlcmlhbC5cclxuICpcclxuICogT3JpZ2luYWwgc2hhZGVyIGNvZGUgYnkgUm9iZXJ0IENhc2Fub3ZhOlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL3JvYmVydGNhc2Fub3ZhL3BpeGVsYXRlLXNoYWRlclxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQaXhlbGF0aW9uTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcGl4ZWxhdGlvbiBtYXRlcmlhbC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJQaXhlbGF0aW9uTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHRncmFudWxhcml0eTogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHRcdFx0XHRyZXNvbHV0aW9uOiBuZXcgVW5pZm9ybShuZXcgVmVjdG9yMigxLjAsIDEuMCkpLFxyXG5cdFx0XHRcdGR4OiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cdFx0XHRcdGR5OiBuZXcgVW5pZm9ybSgxLjApXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHBpeGVsIGdyYW51bGFyaXR5LlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0Z2V0IGdyYW51bGFyaXR5KCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5ncmFudWxhcml0eS52YWx1ZTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBBIGhpZ2hlciB2YWx1ZSB5aWVsZHMgY29hcnNlciB2aXN1YWxzLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0c2V0IGdyYW51bGFyaXR5KHgpIHtcclxuXHJcblx0XHRjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XHJcblx0XHRjb25zdCByZXNvbHV0aW9uID0gdW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZTtcclxuXHJcblx0XHR1bmlmb3Jtcy5ncmFudWxhcml0eS52YWx1ZSA9IHg7XHJcblx0XHR1bmlmb3Jtcy5keC52YWx1ZSA9IHggLyByZXNvbHV0aW9uLng7XHJcblx0XHR1bmlmb3Jtcy5keS52YWx1ZSA9IHggLyByZXNvbHV0aW9uLnk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgcmVzb2x1dGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0UmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldCh3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdHRoaXMuZ3JhbnVsYXJpdHkgPSB0aGlzLmdyYW51bGFyaXR5O1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcclxcbnVuaWZvcm0gZmxvYXQgYXNwZWN0O1xcclxcbnVuaWZvcm0gZmxvYXQgd2F2ZVNpemU7XFxyXFxudW5pZm9ybSBmbG9hdCByYWRpdXM7XFxyXFxudW5pZm9ybSBmbG9hdCBtYXhSYWRpdXM7XFxyXFxudW5pZm9ybSBmbG9hdCBhbXBsaXR1ZGU7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG52YXJ5aW5nIGZsb2F0IHZTaXplO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIGFzcGVjdENvcnJlY3Rpb24gPSB2ZWMyKGFzcGVjdCwgMS4wKTtcXHJcXG5cXHJcXG5cXHR2ZWMyIGRpZmZlcmVuY2UgPSB2VXYgKiBhc3BlY3RDb3JyZWN0aW9uIC0gY2VudGVyICogYXNwZWN0Q29ycmVjdGlvbjtcXHJcXG5cXHRmbG9hdCBkaXN0YW5jZSA9IHNxcnQoZG90KGRpZmZlcmVuY2UsIGRpZmZlcmVuY2UpKSAqIHZTaXplO1xcclxcblxcclxcblxcdHZlYzIgZGlzcGxhY2VtZW50ID0gdmVjMigwLjApO1xcclxcblxcclxcblxcdGlmKGRpc3RhbmNlID4gcmFkaXVzKSB7XFxyXFxuXFxyXFxuXFx0XFx0aWYoZGlzdGFuY2UgPCByYWRpdXMgKyB3YXZlU2l6ZSkge1xcclxcblxcclxcblxcdFxcdFxcdGZsb2F0IGFuZ2xlID0gKGRpc3RhbmNlIC0gcmFkaXVzKSAqIFBJMiAvIHdhdmVTaXplO1xcclxcblxcdFxcdFxcdGZsb2F0IGNvc1NpbiA9ICgxLjAgLSBjb3MoYW5nbGUpKSAqIDAuNTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmbG9hdCBleHRlbnQgPSBtYXhSYWRpdXMgKyB3YXZlU2l6ZTtcXHJcXG5cXHRcXHRcXHRmbG9hdCBkZWNheSA9IG1heChleHRlbnQgLSBkaXN0YW5jZSAqIGRpc3RhbmNlLCAwLjApIC8gZXh0ZW50O1xcclxcblxcclxcblxcdFxcdFxcdGRpc3BsYWNlbWVudCA9ICgoY29zU2luICogYW1wbGl0dWRlICogZGlmZmVyZW5jZSkgLyBkaXN0YW5jZSkgKiBkZWNheTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2IC0gZGlzcGxhY2VtZW50KTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidW5pZm9ybSBmbG9hdCBzaXplO1xcclxcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxyXFxudW5pZm9ybSBmbG9hdCBjYW1lcmFEaXN0YW5jZTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcbnZhcnlpbmcgZmxvYXQgdlNpemU7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdHZTaXplID0gKDAuMSAqIGNhbWVyYURpc3RhbmNlKSAvIHNpemU7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBzaG9jayB3YXZlIHNoYWRlciBtYXRlcmlhbC5cclxuICpcclxuICogQmFzZWQgb24gYSBHaXN0IGJ5IEplYW4tUGhpbGlwcGUgU2FyZGE6XHJcbiAqICBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qcHNhcmRhLzMzY2VhNjdhOWYyZWNiMGEwZWRhXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFNob2NrV2F2ZU1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNob2NrIHdhdmUgbWF0ZXJpYWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndhdmVTaXplPTAuMl0gLSBUaGUgd2F2ZSBzaXplLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbXBsaXR1ZGU9MC4wNV0gLSBUaGUgZGlzdG9ydGlvbiBhbXBsaXR1ZGUuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdGlmKG9wdGlvbnMubWF4UmFkaXVzID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5tYXhSYWRpdXMgPSAxLjA7IH1cclxuXHRcdGlmKG9wdGlvbnMud2F2ZVNpemUgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLndhdmVTaXplID0gMC4yOyB9XHJcblx0XHRpZihvcHRpb25zLmFtcGxpdHVkZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuYW1wbGl0dWRlID0gMC4wNTsgfVxyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiU2hvY2tXYXZlTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHJcblx0XHRcdFx0Y2VudGVyOiBuZXcgVW5pZm9ybShuZXcgVmVjdG9yMigwLjUsIDAuNSkpLFxyXG5cdFx0XHRcdGFzcGVjdDogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHRcdFx0XHRjYW1lcmFEaXN0YW5jZTogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHJcblx0XHRcdFx0c2l6ZTogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHRcdFx0XHRyYWRpdXM6IG5ldyBVbmlmb3JtKC1vcHRpb25zLndhdmVTaXplKSxcclxuXHRcdFx0XHRtYXhSYWRpdXM6IG5ldyBVbmlmb3JtKG9wdGlvbnMubWF4UmFkaXVzKSxcclxuXHRcdFx0XHR3YXZlU2l6ZTogbmV3IFVuaWZvcm0ob3B0aW9ucy53YXZlU2l6ZSksXHJcblx0XHRcdFx0YW1wbGl0dWRlOiBuZXcgVW5pZm9ybShvcHRpb25zLmFtcGxpdHVkZSlcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSwgVmVjdG9yMiB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHRXZWlnaHRzO1xcclxcblxcclxcbnVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG52YXJ5aW5nIHZlYzQgdk9mZnNldDtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0Ly8gRmV0Y2ggdGhlIGJsZW5kaW5nIHdlaWdodHMgZm9yIGN1cnJlbnQgcGl4ZWwuXFxyXFxuXFx0dmVjNCBhO1xcclxcblxcdGEueHogPSB0ZXh0dXJlMkQodFdlaWdodHMsIHZVdikueHo7XFxyXFxuXFx0YS55ID0gdGV4dHVyZTJEKHRXZWlnaHRzLCB2T2Zmc2V0Lnp3KS5nO1xcclxcblxcdGEudyA9IHRleHR1cmUyRCh0V2VpZ2h0cywgdk9mZnNldC54eSkuYTtcXHJcXG5cXHJcXG5cXHR2ZWM0IGNvbG9yO1xcclxcblxcclxcblxcdC8vIENoZWNrIGlmIHRoZXJlIGlzIGFueSBibGVuZGluZyB3ZWlnaHQgd2l0aCBhIHZhbHVlIGdyZWF0ZXIgdGhhbiAwLjAuXFxyXFxuXFx0aWYoZG90KGEsIHZlYzQoMS4wKSkgPCAxZS01KSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29sb3IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiwgMC4wKTtcXHJcXG5cXHJcXG5cXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdC8qIFVwIHRvIGZvdXIgbGluZXMgY2FuIGJlIGNyb3NzaW5nIGEgcGl4ZWwgKG9uZSB0aHJvdWdoIGVhY2ggZWRnZSkuIFdlIGZhdm9yXFxyXFxuXFx0XFx0ICogYmxlbmRpbmcgYnkgY2hvb3NpbmcgdGhlIGxpbmUgd2l0aCB0aGUgbWF4aW11bSB3ZWlnaHQgZm9yIGVhY2ggZGlyZWN0aW9uLlxcclxcblxcdFxcdCAqL1xcclxcblxcclxcblxcdFxcdHZlYzIgb2Zmc2V0O1xcclxcblxcdFxcdG9mZnNldC54ID0gYS5hID4gYS5iID8gYS5hIDogLWEuYjsgLy8gTGVmdCB2cy4gcmlnaHQuXFxyXFxuXFx0XFx0b2Zmc2V0LnkgPSBhLmcgPiBhLnIgPyAtYS5nIDogYS5yOyAvLyBUb3AgdnMuIGJvdHRvbSAoY2hhbmdlZCBzaWducykuXFxyXFxuXFxyXFxuXFx0XFx0Ly8gVGhlbiB3ZSBnbyBpbiB0aGUgZGlyZWN0aW9uIHRoYXQgaGFzIHRoZSBtYXhpbXVtIHdlaWdodCAoaG9yaXpvbnRhbCB2cy4gdmVydGljYWwpLlxcclxcblxcdFxcdGlmKGFicyhvZmZzZXQueCkgPiBhYnMob2Zmc2V0LnkpKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0b2Zmc2V0LnkgPSAwLjA7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRvZmZzZXQueCA9IDAuMDtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmV0Y2ggdGhlIG9wcG9zaXRlIGNvbG9yIGFuZCBsZXJwIGJ5IGhhbmQuXFxyXFxuXFx0XFx0Y29sb3IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiwgMC4wKTtcXHJcXG5cXHRcXHR2ZWMyIGNvb3JkID0gdlV2ICsgc2lnbihvZmZzZXQpICogdGV4ZWxTaXplO1xcclxcblxcdFxcdHZlYzQgb3Bwb3NpdGVDb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmQsIDAuMCk7XFxyXFxuXFx0XFx0ZmxvYXQgcyA9IGFicyhvZmZzZXQueCkgPiBhYnMob2Zmc2V0LnkpID8gYWJzKG9mZnNldC54KSA6IGFicyhvZmZzZXQueSk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gR2FtbWEgY29ycmVjdGlvbi5cXHJcXG5cXHRcXHRjb2xvci5yZ2IgPSBwb3coYWJzKGNvbG9yLnJnYiksIHZlYzMoMi4yKSk7XFxyXFxuXFx0XFx0b3Bwb3NpdGVDb2xvci5yZ2IgPSBwb3coYWJzKG9wcG9zaXRlQ29sb3IucmdiKSwgdmVjMygyLjIpKTtcXHJcXG5cXHRcXHRjb2xvciA9IG1peChjb2xvciwgb3Bwb3NpdGVDb2xvciwgcyk7XFxyXFxuXFx0XFx0Y29sb3IucmdiID0gcG93KGFicyhjb2xvci5yZ2IpLCB2ZWMzKDEuMCAvIDIuMikpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcbnZhcnlpbmcgdmVjNCB2T2Zmc2V0O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHJcXG5cXHR2T2Zmc2V0ID0gdXYueHl4eSArIHRleGVsU2l6ZS54eXh5ICogdmVjNCgxLjAsIDAuMCwgMC4wLCAtMS4wKTsgLy8gQ2hhbmdlZCBzaWduIGluIFcgY29tcG9uZW50LlxcclxcblxcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIFN1YnBpeGVsIE1vcnBob2xvZ2ljYWwgQW50aWFsaWFzaW5nLlxyXG4gKlxyXG4gKiBUaGlzIG1hdGVyaWFsIGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBmaW5hbCBhbnRpYWxpYXNpbmcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFNNQUFCbGVuZE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFNNQUEgYmxlbmQgbWF0ZXJpYWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIGFic29sdXRlIHNjcmVlbiB0ZXhlbCBzaXplLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih0ZXhlbFNpemUgPSBuZXcgVmVjdG9yMigpKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJTTUFBQmxlbmRNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRXZWlnaHRzOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0ZXhlbFNpemU6IG5ldyBVbmlmb3JtKHRleGVsU2l6ZSlcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSwgVmVjdG9yMiB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxudmFyeWluZyB2ZWM0IHZPZmZzZXRbM107XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdGNvbnN0IHZlYzIgVEhSRVNIT0xEID0gdmVjMihFREdFX1RIUkVTSE9MRCk7XFxyXFxuXFxyXFxuXFx0Ly8gQ2FsY3VsYXRlIGNvbG9yIGRlbHRhcy5cXHJcXG5cXHR2ZWM0IGRlbHRhO1xcclxcblxcdHZlYzMgYyA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KS5yZ2I7XFxyXFxuXFxyXFxuXFx0dmVjMyBjTGVmdCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdk9mZnNldFswXS54eSkucmdiO1xcclxcblxcdHZlYzMgdCA9IGFicyhjIC0gY0xlZnQpO1xcclxcblxcdGRlbHRhLnggPSBtYXgobWF4KHQuciwgdC5nKSwgdC5iKTtcXHJcXG5cXHJcXG5cXHR2ZWMzIGNUb3AgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZPZmZzZXRbMF0uencpLnJnYjtcXHJcXG5cXHR0ID0gYWJzKGMgLSBjVG9wKTtcXHJcXG5cXHRkZWx0YS55ID0gbWF4KG1heCh0LnIsIHQuZyksIHQuYik7XFxyXFxuXFxyXFxuXFx0Ly8gV2UgZG8gdGhlIHVzdWFsIHRocmVzaG9sZC5cXHJcXG5cXHR2ZWMyIGVkZ2VzID0gc3RlcChUSFJFU0hPTEQsIGRlbHRhLnh5KTtcXHJcXG5cXHJcXG5cXHQvLyBUaGVuIGRpc2NhcmQgaWYgdGhlcmUgaXMgbm8gZWRnZS5cXHJcXG5cXHRpZihkb3QoZWRnZXMsIHZlYzIoMS4wKSkgPT0gMC4wKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZGlzY2FyZDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gQ2FsY3VsYXRlIHJpZ2h0IGFuZCBib3R0b20gZGVsdGFzLlxcclxcblxcdHZlYzMgY1JpZ2h0ID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2T2Zmc2V0WzFdLnh5KS5yZ2I7XFxyXFxuXFx0dCA9IGFicyhjIC0gY1JpZ2h0KTtcXHJcXG5cXHRkZWx0YS56ID0gbWF4KG1heCh0LnIsIHQuZyksIHQuYik7XFxyXFxuXFxyXFxuXFx0dmVjMyBjQm90dG9tICA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdk9mZnNldFsxXS56dykucmdiO1xcclxcblxcdHQgPSBhYnMoYyAtIGNCb3R0b20pO1xcclxcblxcdGRlbHRhLncgPSBtYXgobWF4KHQuciwgdC5nKSwgdC5iKTtcXHJcXG5cXHJcXG5cXHQvLyBDYWxjdWxhdGUgdGhlIG1heGltdW0gZGVsdGEgaW4gdGhlIGRpcmVjdCBuZWlnaGJvcmhvb2QuXFxyXFxuXFx0ZmxvYXQgbWF4RGVsdGEgPSBtYXgobWF4KG1heChkZWx0YS54LCBkZWx0YS55KSwgZGVsdGEueiksIGRlbHRhLncpO1xcclxcblxcclxcblxcdC8vIENhbGN1bGF0ZSBsZWZ0LWxlZnQgYW5kIHRvcC10b3AgZGVsdGFzLlxcclxcblxcdHZlYzMgY0xlZnRMZWZ0ICA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdk9mZnNldFsyXS54eSkucmdiO1xcclxcblxcdHQgPSBhYnMoYyAtIGNMZWZ0TGVmdCk7XFxyXFxuXFx0ZGVsdGEueiA9IG1heChtYXgodC5yLCB0LmcpLCB0LmIpO1xcclxcblxcclxcblxcdHZlYzMgY1RvcFRvcCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdk9mZnNldFsyXS56dykucmdiO1xcclxcblxcdHQgPSBhYnMoYyAtIGNUb3BUb3ApO1xcclxcblxcdGRlbHRhLncgPSBtYXgobWF4KHQuciwgdC5nKSwgdC5iKTtcXHJcXG5cXHJcXG5cXHQvLyBDYWxjdWxhdGUgdGhlIGZpbmFsIG1heGltdW0gZGVsdGEuXFxyXFxuXFx0bWF4RGVsdGEgPSBtYXgobWF4KG1heERlbHRhLCBkZWx0YS56KSwgZGVsdGEudyk7XFxyXFxuXFxyXFxuXFx0Ly8gTG9jYWwgY29udHJhc3QgYWRhcHRhdGlvbiBpbiBhY3Rpb24uXFxyXFxuXFx0ZWRnZXMueHkgKj0gc3RlcCgwLjUgKiBtYXhEZWx0YSwgZGVsdGEueHkpO1xcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoZWRnZXMsIDAuMCwgMC4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcbnZhcnlpbmcgdmVjNCB2T2Zmc2V0WzNdO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHJcXG5cXHR2T2Zmc2V0WzBdID0gdXYueHl4eSArIHRleGVsU2l6ZS54eXh5ICogdmVjNCgtMS4wLCAwLjAsIDAuMCwgMS4wKTsgLy8gQ2hhbmdlZCBzaWduIGluIFcgY29tcG9uZW50LlxcclxcblxcdHZPZmZzZXRbMV0gPSB1di54eXh5ICsgdGV4ZWxTaXplLnh5eHkgKiB2ZWM0KDEuMCwgMC4wLCAwLjAsIC0xLjApOyAvLyBDaGFuZ2VkIHNpZ24gaW4gVyBjb21wb25lbnQuXFxyXFxuXFx0dk9mZnNldFsyXSA9IHV2Lnh5eHkgKyB0ZXhlbFNpemUueHl4eSAqIHZlYzQoLTIuMCwgMC4wLCAwLjAsIDIuMCk7IC8vIENoYW5nZWQgc2lnbiBpbiBXIGNvbXBvbmVudC5cXHJcXG5cXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBTdWJwaXhlbCBNb3JwaG9sb2dpY2FsIEFudGlhbGlhc2luZy5cclxuICpcclxuICogVGhpcyBtYXRlcmlhbCBkZXRlY3RzIGVkZ2VzIGluIGEgY29sb3IgdGV4dHVyZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgU01BQUNvbG9yRWRnZXNNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIGNvbG9yIGVkZ2VzIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbdGV4ZWxTaXplXSAtIFRoZSBhYnNvbHV0ZSBzY3JlZW4gdGV4ZWwgc2l6ZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjIoKSkge1xyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiU01BQUNvbG9yRWRnZXNNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0ZGVmaW5lczoge1xyXG5cclxuXHRcdFx0XHRFREdFX1RIUkVTSE9MRDogXCIwLjFcIlxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0ZXhlbFNpemU6IG5ldyBVbmlmb3JtKHRleGVsU2l6ZSlcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBS0FBQUFJd0NBSUFBQUNPVlBjUUFBQ0Jla2xFUVZSNDJ1MzlXNHhsV1hybmgvM1dXdnVjaUl6TXJLeHJWOC8wcldiWTArU1FGS2NiNG93SWtTSUZDalk5QUMxQlQvTFlCb3pSaStFWCtjVis4SU1zWUFhQ3dSY0J3anpNaXcyakFXdGd3QzhXUjVROG1ERkhaTE5IVGFyWkdyTEpKbGx0MVcycUtyc3VtWldaY1R2bjdMM1c1NGUxdnJYWDN2dWNpTFBQT1JGUjFYRTJFb21vckIwblZ1ei8vcjcxcmUveS8xZU12YjRDYjNOMTF4Vi9QUC8ydjRVQkF3SkcvN0g4dXJ4Ni8yNS9HZjhPNWh5cE1RMEVFRVF3QXFMZm9OL1orOTdmL1NXKy9OdmNnUWs0c0dCSks2SDdONFBGVkwrSytlME4xMXlOZmtLdndVZHdkbFVBWFBISEwzOG9hMTVmL2kvNDZJaDZTdU1TUG1MQVlBd3lSS243ZGZNR0g5N2phTUZCWUNKVWdvdElDMllBZHUrTHlXOXZ2dWJ4QVA4a0FMOEgva29BdU9LUDMrcTYreEduZDVrZFlDZUVDbkdJSlZpd0dKTUFrUUtmRHZCM1daeGpMS0doOFZTQ0N6aHdFV0JwTWM1L2tCYmphd1Q0SG53SmZocitwUEJJdTd1dStPT1RvOXZzbXRRY25pTUJHa0tGZDRqRFdNU0NSVXBMakpZTkprTStJUnpRK1BRdkllQU1UckJTMkxFaWFpUjliLzVQdVQ2QXAvQWNmQUZPNFkzZEEzREZINy9WUytNOGs0YmFFQVFmTUk0UWZiVkRER0lSZzdHS2FJWTUycUFqVEFnVHZHQkFQR0lJZ2hPQ1lBVXJHRk5nekE3UTNRaGdDd2Z3QW53ZTV2RGVqZ0c0NG8vZmJtMUM1WmxZUXZRREFSUEFJUUd4Q1dCTSt3V2wzN1pRRVNiNGdJbWV4R01Eb3VoR0x4MUNzdDBTYWE0YjRBcU80SGs0Z3hvKzNESEFWL254MjdwM0p6aVBNMnBWZ29paWE1TWRFekNHVUxwcklON2dFRWVRNUlReEVCQkJRbnhoc0RiNWF1R21BQVljSE1BOWVBQXo4UEJvbDgveGlqOStDNERqbGltNGdKaldjd1pCaENCZ01JSVl4R0FWSWtIM1p0Y0J1TGR0UkZNV3NQR29ZOXJOK0hvQmppOVZCWWR3RDJaUWc0Y25PN09TcS96NHJVNUtLZHdWYkZBak5vakNRelRsQ0xQRlN4dGFtd2gyak1VY0VnZzJXbS82WGdFcklCaEJja1F0R04zQ3piVmFjRVJnQ25mZ0xzd2hudnFmN1F5QXEvejRyUlptMVlnbFlFM2FmZkdJVGFac2RJZTJGbU1JcG5PQ2FwMjVJNmp0MmtDd0NXMEQxdUFEOXNaY3ROR1hjUUlIQ2tJTkRRZ2M3OGFDcit6anR3M0JVL2lqZHB3M3poQ3djYU9Od0J2ZGVTMllaS2tKTkpzTVBmMkpLRXZDMjhSWHh4STBBU0p5elFDakNFUXJPNFE3c0ZBckV6alpoYUZjNGNkdisvSkZkS1VMTTRweDBEZlVCSTJoSXN5MDZCcUxoR1RRRVZkYmZBSVpYWU1QZXNxNlZvQ0hJQ3pVeWp3SW5PNFk0MTEvL0xZTHM2VERhOXd2ZzJDQzJyRWxnQW5wVEJ6aVRoeGFMMjJNWWh6ZmtnaHo2R0FzMlZIYmJkTTkxVlp1MU1FRXB1cE1Nd0t5VlRiNWlqOSt1NFZKRy81RWdFTU1tRkYwMWNGYWkzaXNSYktiemIrWWFVL01RYkFtMlhTTW9VUEFtdlp6YnVLWVJJRkFwYnRscmZGdVVHZDZ2cTJoWE5uSDc4WkxoL2lGaHNRRzNUNEQxaWI3azVDQzZ2WTBEQ2J0cm9oZ0xFSUNsWGlHdGwxMHpjMENuRUdJaGhhdExCdmE3TlA1OFR2dzBxRTh5V2hBUkxROGg0K0FoUVNQK0k0RjV4b1UrVmlsR1JKczZ3blM3cnV0aS80S3ZBWS9DZmRncWpzTXk0cGY4Zm9kUU84L2dudVgzZi8zeGkzb20xL2g3VEhyK2NvM3g5M1BQOStGQlVmYk5VamNqRW1oY3JrVCs4SzdtbDdWMTBKbzA1bXBJRUZ5MU5tQ0pXeDlTSUtLdCtFakFMNEV6OEVCVk9CNmhhdnVUL3JCeVB2SFhLKzl6VWNmY2JiMjU0KzlmeWRKa25ZblJyMW9HZmRhaUFncHh1MVJ4L1JlazhLSVNmdHgzTCtEZnNMV0FBTm44SHZ3MC9BRmVBR085REZWM2M2RCtDY1diTDhEajllN2YrVDFrOEFadi9kNytQWFdNL1orVnZkQ3JJdnVBS08wOVJwRUVRSk0wQ2k2K0I0eGhUV3I0Y1pOT3Zoa3RhYncwdGEwclNKbXF6M1l3NS9BS1h3ZW5vZDdjQWhUbUJTUEtmNkpCZHZIOElQMTdoOTVwWHF3NTAvK0JGbmo4OGZldjROY2h5YUs0N09QaGh0SThSRlN2QWZEU05oMENrMHAyZ0x4R2tpYjVOSmovSldDcjkwRVdRSnZ3QnpPNEFIY2d6dHdBRk4xZXZIUFVWR3dmWE9OKzBkZWJUMVllR09OOVl5OS82M1grT2d1aXdtaEloUWhEN2w0c01xbEczRDg2U3VjM3FXWjRyV2pJMVg3dTBZdHc2eDNySU1lSU9QRHByZmUyWHpOZ3lqNlBhaGhCak80QzNlNnB1RGdYcmRnKy81bDk0OHZGM2Jxd1pldForejlSeDl6ZElZNXBJblBLNE5rMHQrbDUyeGRLMkI0NVFkODduTThmc0Q1RWZVaEljSmNFUnc0UmRxcUg3WWRlNVY3bTF2aE5tdGVka3o2RUR6VU1GLzJqSllXYkMrNGZ6ekEvWSsvOFBQSDNqOWRjQkFQSVJQOEpMWGQ1QnBBdTAzYXppT0wzVlZIWnp6M0NYV0RQV2QrU0gyQW54SXFRb1RacG85Q2tjNkhJckZiQWJ6Tm1sY2c4QWc4TkZEREFoYkp2VEJaWGJDOTRQN3Q2OEVYZnY2bysyMWdVdFBFVFU3YmJrTHh2TktSRkcyK0tYenZ0T2JvblBQNHJCdnNnbWFLajQwNERsc2hGb2xlMUdsZmgwMmZFN2JZUjdkWjgyb1Rld0lCR24xTWQ2Q0c2WVVGMjZYMzc2b2V2T0x6eDk1dmhVbWdibEk2TEJad1RDRFk3dk1xMG9wNVdWWGdzT2JPWEorMXgzcWFCbDlqMUZlTHhiaFU5dzFGK1dpYmE2czFYL1RCejFMblVmdVlEaTRyMkM2OWYxZjE0QldmUCtwK1cyR0ZLdUM5cGhjRUxNWVJSTHVyOURFWlRVZEVIK2lFcVdkYU03WDRXT29QR0krWllEMit3Y1EreStpb0hVWjlkVERiQXJ6eG1pL2JKSTlCTkQwWW5kNmxCZHZlL2J1dEJ3OCtmL1Q5RDNBQmEzQUc4VzNWUFg0aEJpbitiajhkTU1tU3BwNXBnN2ZKNnhyQkZFMldRUUVXblY4UWczRmJBV3pZZk0xclJFRW5tdmtOMm8xK2FjRzJkLzl1NjhHRHp4OTF2M21BamIxemtwcVQyMU9pcFBLTzBiOVRPNVcwblRkT21BUW0wVE9idHMzYUJLZ3dBUnRvUERpQ1QwZ0hnd25iQXJ6eG10Y0xjMDhIZ0YxYXNOMEM0TXMvZnZENUkrN1BoZnF5WEUvYjdSYmJyR3lSUVJUOUFSWmN3QVVtZ2RvejBlaEo5Rm43UUFoVWpoREFRU3cwYlYzVDNXYk5hNTlqem1pUDZHc1diR1hEWDJ5dGp5OCtmOVQ5N2ZpQlBxOVllTGRCbXl1aXpaSGFxWElUblhpTVVFRVZjSjdLNGozQkZQdXJ0QjRiaXhXOHdUcHdlTDhEQzk1c3pXTU9xdWNGWUdzV2JHVTdwM1R4eHhlZlArcitvVFZrdHhZMHY1aGJxM0tpT0tZblk4ZGRKVlNCeHVNTVZmZk5ieHdJT0VSU2hzdDczSFo3OERackhwbUptSDNLNnNHejBmZTNVVWowZXlSclNDR1RUYytyalZOb0d6TlN2MDVzckF4VUJoOElocUNoaVFnVk5JSUJIM0FWUG5yc25YUVpiTFRtOGFtbXY4ZVZYbi92V3BhVGVtNUlYUmx0K1UvTEEyMXpoU2I5Y3llNmpjT2ZDbk93aElBWVhBTVZUVU5WMFFoVmhhOXhqZ0EyN09ESmJMYm1pdHQzdFJOODBscUc2Ti9raGdvdDRaVmxPeU80V05nM09JTXpoSVpRcFVFSGllZzJpbTZGOTFoQjNJMnR1YnFsNkJZTk45SGo1UzdHMEcydGFoc2xCV0tEbk9pSXZ1QUVEemFrRFFLRE5GUVQ2Z2JuOEUyeTRCQnViTTIzMFlJcEJuRGJNYSt5M2R4MG4xUzBCdHVHNjJsQ0NYd2NZMEY3MlQxVlJSM3QyT05jc21EamJtek50OVJGczJMTzJoUU55YjAyMkppc2FJOHJBV3V3NEhJM0Z1QUloWmRPR0ljZGpMSnZ2T2JxbHBxdldUSm5uUWJ5aS8xTTlPOFV4V2hCcy8vSDQySTBxMVliL1hQR09OemNtbStyaTE3Mm1IS3ZaQnBIa0phTkp6NnY5anhxaWtsRGozVTRDQTJ1Z3BBYVlNV3FOWHNkWGJtSk5kOWVnQ25KRXNwaFhOTStNbkszbTBGQ0o1UzFrbUpwYTNEZ1BWYm5RblBHV0lEc3BXOW96YmNPNEsvOUxrZmFRTzJLSHVxbGZGWFNiZE56Y0Vjd29xTkVGRTl6Y0lYdTkvNm4veW0vQkMvQzNhSkx6RUtQdVlWbGJGbmZoWjhrY1d4VjNkYnY0YktsMjg1NjZ3RCs4QzUzYXc0OWxUQUJwOVBXYnNCK2tuZmMvTGkzZVZpemY1dnYveG12blBLZzVpaHdLRXdscmNIcXVjdVZjVk94RXY4YUgzN0UzWnFwWnlwVXVsckhFdElXS1VyK3R4SGcrb2paREdsd25xbWtHbHpjVmkxZExpTlNKaUhqZmJSTk9Qd0tweDlUVmRUbjNLMDVEQng0cHNJazRFaThhQ2tKYWhSZ2ZmazRZbkVYZTA3VDRIMlJSMXUyN0U2d2ZRc0JEb2ZVZ2pGVUZud0MyQWlWdEErMDVKMnpwaURLMk9hMGM1Zm1BZWNOMWlKem1wcUZaeHFZQkNZaEZUQ3NVTkVtVW5JY1o2YUVBNXJRVmhFeXdHNnc3SFNXMDJYZk9vQmxRbWp3dWxPRlFBZzY2U3ZKYmxyVEVYMVl0SjN1RzE1VC9CSDFPZk9RZXVSOGcvYzBnZHBUNWZ4MlNLYnM5RWZIVEtkTThBMUdhSlJITFZJd2hjR3l5ZFpzYmlmQUZWS2w1RU1LTlUySHJ5byswNkJlVGdxbnh6WWpUaFZ5U0Rpa2J0SlBpZWNvNzVsWWZLQUpPTUVaQlRqb0lUdVdIWFhaVmhjVURJUzJocGlYSFY5S3U0dTQ0Yk41T1lMRE9rSm84dyt4SlNNYmhCUkhFZEVzOUpaVUNrUXJQTUF2YUh5TGt4Z2tFSHhpTmt4L3gyWUIwbUdzUThFVVdqL3N0VzVZTGh0UzVTTXUrL1lCYk5QRENrR1RVeWJOOGtyUkxCR1BsWmtWT0EwaithMStya3lRS1dHYVBIUExaT2tKaGlvUVluVloyaFMzelZ4TXRnQzQ2S3VSd2JKTmQ5blYyUEhnYjM2RjE5NGVjZi9ZZXUydkFGZTVubS9iUkJGcm5ZNEJhdUU4RVJtWlJGVW4wazhoYmZ0aVZZU0tNRW1lMmRKQ0pTQ0dZQWxOcWg4N2JYT1BkVWtHeTI0UDZkMWxsMjFNQnFxeDQ4RnZ2OFpISDhIWkZZN2ovdUFxMXhNSlVGcUNTVWxKUG1OYklpTnNtd3VNcy9xOUNNdHNac0ZPNlNwcnpDUzFaN1FMOHhDUUNsRWVscGpUZHVETXNtV0Q4UzFQVDE1MkJ0dm1JR3ZVZURBL3lSbjgzdS94MC80cXhvUEhqeCtQWFk5cHFYOWJnTXZoL056OWtwUDRwT2UxL2ZZZjNheFVpTWRITGxQcFpDTmpndE5GQWhjSEVEeFR1bU5PTmhIckJkdVcrdk95WSsrNzBXV25QWGo5OGVBNGtPdC9tai81RTA1bDkrTzRvOGVQeDY3SEZxeUMrcVNTbnlzZWxxalpHYVZLMlRhZGJGTFBXQVE0TkJoSHFEQ0NWN09UcG8zNEFsU1N5bFB0SWRkMkFKWmx5ellRckRKNWxjV0dOY2VEODBDdW5QTEdHenNmRCs3d1JiOTVOZXZKSTVkb2NRM3RnQ3lyNWJHbnlhUFJsbXdOc0ZFTFZpT094OWxvZWJHTnEybW9ET0twSExWUDVhbDJjeW1XSGJrZnpHWEw3a2ZSbDQ0SDl3WnkzM3R2dCtQQi9YbmY5M2Urbmg1WmxVMTh3Q2lSVWE5bTdraWI5TFl1T2sraHVkUU5ieHdtMEFRcWJmbG9pbWFCMmxNNWZDaGV4K3lsTXd1VGJmbVhRdG1XbGVuWmxqYmRYVEx1T3hqSS9mRERIWTRIang4L0hyc2UwelhmUEZ4YlVOMWtLcVNDQ1NrNTBtMEFqdHgzdWI5WEhCS0hYRVNiOGlPNkUrcUd5dEY0bk8wT0czU1h6YkpsaHhCbkt0S3lsME53eWJqdllDRDMwYU1kamdlUEh6OGV1NTZTVlRCYmd4Sk1saVEzT2F1d2cwUUh4WEUyRXovRUlSZUxkUWo0Mkd6YjRDTFMwWUpEOXhVeDdic2kwdkppNW1VYlcxUXpMMGgwUEZrMTdydGlJUGZKazUyTUI0OGZQeDY3bnBKSnd5ckJhMlJDQ1FSVGJHWlNQQ3hUUE9pTkQ0RzJwWXlPUTRoNGpJTklKaDV3RlUxTkZadCtJc1o1OUxTbkRxQmpaMmF3Yk9rdSt5SW51bkxjZDhWQTdyTm5PeGtQSGo5K1BHWTlCME1XSkpOb3pPSm1sZ2x2RE1YREVvemRoUVdiZ3MvVTZvQmFuR3pMcmRTTk5uWkZqT2ttYmk1Yk50MWxYN0pMTGhuM3ZYQWc5L2g0eS9IZzhlUEhJOWR6UU1Fa1dDZ2RSZll5a1lLbmtQN0Q0ckl1anN1amFLUEJzQjU0dkUyVFMwMGNjdkZZL1R0aDdKWGVxMWh6K3FnVnkwNHNBSmF3VHN2T2tuSGZDd2R5VDA2MkhBOGVQMzQ4WmowdmRvWEY0cGlsS2EyQlJPZWQrOWZ5dzlyV1JYZVRGWEVTTU9hbnZEWmZKdUphU1hvdVFkTWRESlp0ZWtaY0xMdkVlSzA0ZDhtNDc0VUR1YWVuVzQ0SGp4OC9YbnM5WVlxWnBzekdXQjNBTi80Vkh3K2s3V1NGdEozUWljdXFiL05sVm1nWFdzeGg1NzB4ZzJVd3hVdzNXZk82QjVuT3VPOGFBN2xuWnh1UEI0OGZQeDZ6bm0xaTRic2ZjYmFwdEYzek5UNzhlRlB0d2kxT2FDTk9xcDF4M3pVR2NzL1BOKytBR0QxK2ZNWHJTVm0yYmFUdFBoUGFoYlBoQTcxd0lIZDJiWHpSYTY5bkcrM0NyYVR0UGl2YWhWLzU1dFhXZzhmeVJZLzlBZHNZOFZiU2RwOFY3Y0tycmdkZk0vL3o2SUxRRnRKMm54SHR3bXVvQjQva2Y3NCtnTGVSdHZ2TWFCZGVTejM0K3ZpZngwWUcyMGpiZlRhMEM2K3RIcndlLy9ObU9HMEw4RWJTZHA4UjdjTHJyUWUvOTk2TythaTN1alFPc2twVE5VTGE3ak9qWFhqOTllQ2Q4bEh2b0Zpd3NiVGRaMGE3OFBycndUdmxvOTY2cEx1UnRCMmZGZTNDbTZvSFA5a05IL1cyRnJ5eHROMW5UTHZ3UnVyQk8rS2ozcFdYSGlkdHgyZEZ1L0JtNjhGYjgxSHZ5a3VQbHJiN0xHa1gzbXc5ZUdzKzZoMVk4TWJTZGplZ1hjZ3VRTGptZXZEcFRRTE14dEoyTjZOZHlCWnU5QWJyd1Z2d1VXK0xidGVVTFVwQ2RxbTBIVGVsWGJoTlBlOEc2OEdiOGxGdlZmWWZTTnV4dnJUZFRXb1hib3pBemRhRFp6Zmtvck9qMW94VnhsSU1scFNJbHBMcnQ4RDRoclFMMTd6K2MzaDZoVS93djRRL3V0cHM0K2JtKzZQL2hJY2YwSndRNW9RR1BCTDBlS1BUWUVYVFcrZUwvMkRLbjczSjlCVFhZQU5HNTdoejFjRU12aVZmLzR0ZjViLzZDNXBUUWtNSVdvQXE3aFRwT0pqdEFNNHB4S3U1dmc1dlhlVXJ0STA5L01vLzVIKzR6K01wNXhVTGg3Y0VtMlFiUlAydEZJS1I3V00zZlBmL2paM1NXQ3FMTTJsNE54SUQ1ekI3MkhRWHYzamovOG1MUjV4WE5BNXY4RWJGUUV6N1BwUmZsMStNQi9obEFONjVxZ0RuM3dUZ0gxM2hLN1Q1OWJtUCtOSXgxU0hIVTg0bkxPSVR0M2lWejhtTk8rbFByakdBbkJGcW1pb05uMW1UeWsxdGE0N1I2ZDRNclg3dGpybmpZVXBkVWJ2MnJWcjZZcFZmc0dHNThBRzhBaDlleVVOOENYNFdmZ1YrRzhMVldQREdiK1pkNGNVNTg0Q3RxU2JNS3hhdXhUZytkeW4vTGtWZ0ErSVI4S0h0ZWplRktSdFRtTExweE42bVlWTGpZeHdYZjV4MlZvZmlaY3AvbHdLazR3R09wWURub0laUGRnL0FBYndNZngwK2dlOWRnWnZZanVxS2U0SG5HbnlrWW81VHZKYkcwVmoxMkphZ1Jod0thNDRIOTVTaGtaYTVSeUxHR2RmWXZHN2F3MVRzRjZpYXBQQVMyOW1OUzNObXNUUVpDbWdUekZ3Z0wzdXBDVGd0QlRSd3ZHTUFLcmdMbjRldndpbjgrYWZKUmNmZis4aXpVR1VNNjNHT091QXMzdEprdzdKNGt5b05yZXFycE82Y1lMUWVGVWQ3VFRwcjVZT1RMYzlSVVVvZ1VPVkpRMUdZSmFGTEFXMG9UbUt5WVM0Nlpvb1A0UzRFT04zeFE1ekM4L0NYNENuTTRjMVBFOEFwZXhwb1l1enFsUDNkNFMzT0pQOFpESzdjS1dOYVRscW1nRGlpSHdsMVlzRTQxdzF6VDRpUlRtM0RCcXh2T1VzYk1LS0RhL0VIeGFndG50YTA3MmVqYzNET0loNW9qdmg4bDN0azFKRi9BVjZGVTZqaDNVOEh3RWF6TGdkQ0xZU1ErTVlpQUkybHRvbWt6dHRVYjBnR0hkU1VVZ3NJWWpUekxHM21PYlg0RkJSYVl0cERWTlpyaWg5VGdUZVlPQnhzRW5OMWdPQ1RNOEJzdy9pZU1jNzV3OWt1QVQ2QSsvQWlIR3ZOLytHbjRLUmtpdXpwTk5EWWhER0ZuZFdScEU2U1ZmbThVNWJ4blNnVlYyanJnNkpDS21uZXFleThWTUZncTIrQU0vaTRMNFJVYmZTaTI3bE5YWjdSN1c5UlRjcS9xOWZrNFh3M0FNUWQ0STVpZkFaejhGY1Z0bTlTQW9tL2R5TjRsY3pKUVcva0M0MlpySGdjQ29JZjFvVk1La1ZJdG1NQmk5Y09lTkhHTHFPWmsrUXFRbXJiYzVZbVlneEVMVVVOMzV6MmlvaHN0Z2ZMSUZtY01WN3M0Q0ZtSTc0TDkrRUZtR3NpK3RHbkFPRDRZazlnSXBvMDFZNGNBNDNCV0d5Z01kcjRZWmVrRzNPQklVWFhOdWt2SlM4dHFhMDZlK2xTREN0bnFxTUZ1NmhXSFhDRitXYVl0NjRtOVFCbU54aTdJb3k3RCtmYTF5SHcrRk1BY1B0N1N5c0ZMdG9HNFBYQWs3Sk9BM2FBeEJScVVpQWRVOVlwNWxLM0hMU1JGdE9pbTBzYThldUV0MDh4dktqWWp6ZUoyR1U3WWF3ZXhybktJOXRtb2JJbmpGWENld3B3cmlZOStSUjRhYWV6RmhNaEdDcHBLd29tMENocmdGbEt6eVBLa0dsVFcxWVFyRTlISnF1OGhLR2dNYzZoVmk1UVJxMFBaeE5mcllOZ0U2NHV0bVJ2NktLSFJweGY2VkRVYU92TlA1akNFeDVxMTg1TXkvN1JLejY5VVF1MmltNWs0L2Vvd25weFp4Tkx3aVoxQVpUTzJaaldqa1U5dWFCMkhGbjZRM3UwSmNzU3gvcVY5aFRFQXBSemVCTERKUVh4WW1UbnE3YmRMYTMrdXFGcnhMSjV3MVRlaG5OSHg1RUN2Q2gyZzJjM2hISDVZc2ZkYVNLZGR6dGZqUTZpbUtGR1N5RndsTHp4RUdQcDZyNUlldlZqazFBTXgzd01xaTFOeERWakxCaVBzOXRic0NrSVk1d2U1L01MMjJ6ckNTY0Z4bk50enNyOVdjYzNDbkQrcFlPKzRWWFhpREUwb2MvdlFRL2ZESzNvUEVTSk1ZWE5tSmEvRHVsb0paa2NUcGNZRThsSUg4RHo4REpNaXluTkM4Nk1iMmxOYWFxUC8rTDdmMmZjRS95UDcvTGRlOHhmZ1NPZE14dk9peFpmLzlwMytNNGhUMStGK3pBcHhnOVhmVXZZamM4cVgybGZPT3BLMmdOUnRCNGZscEZ1OUZUS0NwMlhKUmdYblg2b2xwMXp5WWpUS0pTa0dtTEUyTmpVcjFieEZNNEFlQUFIQlVGSWVTTHFYUitOdkgvTTlmT25mSHpPRDJ2Q1N5UUpLemZnc0NoK3lpL01tYzM1RjJmVXJ3N21pVzMzVzloQkQxdnB1VW9qRnBoSXl2ZzdhVGVveW1Ea0lrZVczWExIbWd1TXpiSUFKZWpONkI1TURyaGlwRTJ5NlNvRlJPL0FLL0FjSEhaSE5JZmlXckVlL0M2Y3IzZi95T3ZyUUtCK3pNTTU1L0dRZExEc1IraWZyNUZpdXUrL3krTTc4THpPRTVkc051WEMzUFl2WVdkOE5YdnBoTFNrSklhc3JsRDIvSE9xUStSamNSZGpLVEdXWWhoVlVtNHl4bHlpR1B1TXNaUjdzTUNIVUJlVHVOV0E3aWYraWZYZ2MvaG92ZnRIWHMvRFYrRnZ3ZStmOHNoek1pTWN3ZUZnQmx5My8vdndKZmc1QU40NDUwZm4xSGQxUm0xYUJMdTIyRHkzeTNIMitPcU1lbWtiR1o0am96Y0RqSmY2NTk2eE9McEMwZU1USGJLbnhMeEgyN3VaL2JNVEdzMmpPYU1PWTRtODdDZlF3RjBkdzUzb2ExazgwSlJ1ei9YZ1MrOGZYM045QWY0cVBJTWZ6S2dDcDRINVRER2U5R0dlRlB6U3NaejgwU2xQVHhYamd3Sm1DNDVuanpndDJ2YlE0YjRPQWRVSzQvdldoTzhkOHY2RUU4Zk1Vc2Zha1hiUHBGSmVMczJ1Yk0vcWRtL2xhM1dQOTF1V2h4WEhqb1doeVJVcTJpSi8rNW1BNzN6d0lJbytMb1ovU2d2SVJqQWQxSU12dm45OFBmZ092QUpmaGhtOHNjQUtWV0R1YVJhSzhhUTlmN3Z1UERINkJqNDdaWGF1N3JxWUo2Nm1URHdFRFU2bExiQ2pDSzBxVFh5bDVtbkRvZU5SeGFuajNGSmJha3NUazBmYVh4SHhMcnNzZ1BrV0I5TG5BL01GbGVYY0pvenpqd3NVdlVHMFgvUUN2ZTUxcWtNRFhwOW10Y3lPeTNyd0JmZHZWSks3RDYvQUNTemczUm9ydUlxNVVEZUVTZkVtVmNsRHhubmlVODJ2eE1MdGNlRDBoR1pXekJOUE1NL2pTUG5lMk9WYXRpVEtVcFk1dlk3Z2MwTGRVQVdlV001dEgrTzJJNjZBT1d3OXhUMkJ1eVJWTEdkb0RIVXNWUlhPby9jK1pkUlh2RmZueFd5SVY0dXBGTENsOWVBTDdoOFp2MFFIOFJ5OHBBMmNIelFwR2VzY3RWQTM3WnRrbEJUZ0hqeXZkU2VLWS9SWncva0pNazBZMjVjU05SV1NpZ1F0bFVMUFR3K2t6dUpQZVlFa1hqUVJwb0dab2JZc0xGNzlweWQxZE1SSEluYmdGVFpxTkxoRHFpSXNUTnBvZXgyV0xjeTAvWDZySGNkTU1RdkZTZDVkV0ErKzRQN3h2ODlkZUFDbm1yMzZ1R2xMNjliUkNMNkJTWnNTNmMwVFUyVEtLNWd0V0N6Z0FPT3dRY3VycWs5ajh3aHZ6aVpTTUxjcTVoYnV3QkVzWWpvcFVCa3F3MXlZQkdwTEE5N1NSRWxFbXg1TUNJbkJZNXZnTGs5NGlLcVNXbWhJR21rSjRCaTltNEw2NDVKNjhMeVk0d3NGWUJmVWc1ZmVQLzZnV1dtNThJRW1LUU04OWhxN0tzWk5hS3RQNVR4eHJVWlpWa05tTUp0amJLckd4TE5FYkhQSnhocXk3bEFtYkMzMlpxZUY2bFRha25SV2NZYUZwZkxVQmgvcndhUXljQ0NKbVcxNUtzdHY2alJIeUpGcnkyQzFhaGtrSVcwTE83NXM2MStvd3hLMXkzWHF3ZVg5bTVZTE0yRFBGZU9qbi9paXFDS0oreUtYRjh0NVlsL2tOc3FhU0NyeXhQcTV4V1RGSWFQOEtTVzBSWXhxdXBhVWYwUmNUTlNTZEpaR2NLWWRZQTZrZHRydG15QmNrZktYd3FrMHBIcFVIbHdXYWZmak5SQllGUFVEV2E4ZTNMdC9vMFIwQ2Rpc0tETTg5Y1gwcHZSSEVmTThjYTR0MHMyWHg0a2dvOTFNUFFKLzBjOU1RWXEwY284TUJoN2J6MWZpbzBVVUhMUjRhQUlPdk9tb1lPNmt3bEVWT0RTU1RsaVd0T3RINnNQa3J0Y3RGOVp0SjlHSWVyQnNrdmhkVlM1Y0ZOdjlzMUJVMEFiZFVnZEs0RkcrZFJuakZtRFR6bmlSTWRaTzFRaHpNSzM1NXZpZ2Jka3B6OVA2cWpVR0U1SjJxQWNYbXdKMjBjWlVpQUQweitwR014NnhrekprbUVmNDBIcjRxWmZWZzJYekY5WU95b1Y1Qmp6VmtVSm5nS2Y4bGdOWXdLRUNFSHJDTkRyV1p6TWxmbFMzeUJoci9JbnlvVWdCYy9sS1Q0cHhWcnJDNmcxWXdjY2VLM0JtTnhaY0F0ejNqNUVJcHFndWg5SDZ3YzAxMVlONzVjS0RMcEZEeHV3a3JQUW1Vd1c0S1RiajltWlR3QndMcTRhUU1VWmJIbTFyeWxKNDZkelIwZHVhMm4zUllDV1pzaUhST2V5d3lKR1I3bVhLbHByeXlDaW91WTU2c0ZrQldFbmtFQi9yYWVoL1N3NDE2MktldUF4TVFwRWt6eTVhbE1ZNXdhbU1zV0tLcnRXMldwRVdOblJlWldPTktXanJkc0taYXJwRmpxQ3NscTc3M1BMbUVoTTQ0OFBjMytGS3IxKzk0dnYvcmZ3NHRFY3UrbEtUQmU0a1pTZGlqQnJ5a3d2OXZiQ01QY0xRVHlnQmp6VmNrU0xQUlZHc2xxZHVud0o0b2VndEZPWWI0U3d4TmdXTENtRDdUOWtWalR2NVlEZ3BvMFhCbU4zNFovckVIcDBzZ3l6N2xuZ3NybTRsdk1tMk1yMXpOT0pZSjVjdXh1UXh3TUdKcS9UUDVlbWxiOGZzUUJadmlLNHQ4aEZMK3piaHRscHdhUlN4UVJXZmVFVGp1YXVQc2RHeHNCVmRPN25tUDR4dnpTb1QyOXBSbDdrR3F6K2syNkIzT3kwWU5WK1NYYmJRYXMxY3RDL0dhcnNrUmRGcEtjelZBRjFaWG5MY3BhTXV6VmU2bFoyZy8xbmRjdk9WZ1JHM3NkVUFZMWJLRDZhY2hpak1QZE14VjRtdUtWb3JTcGlESGl0dUg3clNUczduLzR5NURoUlhvNEZWQk40dk8vemJBY3hoRU56R2JIQ3pVLzk4TWN4NWU3YTMxa1dqdzlGQ2Uvek5lWXlRalpzV2IxdWM3VTMzcE40TWppNmhDTGhpdnFmYTlTczZ4TGcwMzFBZ2Zlc0EvbDk5bTlmZ3ZuYUY5Sm9FNmJZS21rR05LM2FQYkhCOTZ3MytEbnhGbTRoczBkckxzazdVOGtmL04vQ3Z3UU50bGxuYTByanE2MXNIOEw4MEhBdXZ3SDF0dkJ5MkNocVdTQ2FZVGFHTjE5c1R2bGZ6RkQ2bitpS1RidnRheWZyZmU5dWVXaDZHSkZveExkcjdWNzJhNVpwdkhjQ1BEem1hMHdUTzRFZ2JMeWVkeHN0TzgxbjU3TFlCT0J6eWZzT2hVS3NXMUoxQkI1dnIvdHo4UnlxT0Z5bFFQOVR2c3QySkFMc0M1bHNIOFB5UTQwRFY0QU56WWE0ZGVkTmlLTlIxcyt4Mnd3YlI3cTQvNGNUeHFFazRMV0RlYmZpc3VvMzZKWExpV0ZqT3RMcmxOV2gzSzFyUlM0eHZIY0RObEZuTm1XQkJBbDVTV2FMM29QT2ZudmJyNXBkalZuRWFlQkpTWWp1TEVreUxMc1doS2NjYWRtT3BoWmtPUGdWZGFsajJRcFNtZk9zQURoTVdFMlpCdTQrRUVKSTR3S1RBdUNvQzR4d1FiV1hCbHRweGJqa1hKdEt4eGFibzllN3R5aGxnYjZnTmxTYlVwTWgrbC9GYXF6Vndld0d1OEJXMVp4N3BUcFFESlVqYjh0c1VUVzYrR0RYYk1uM21MYlhsWEppR2RnZ3hGQW9VcnRQUzN3RTROazAyVVpHMk9PemxrN2ZSczdpOTVRQ0xvM0UwanRyam5NN1NSM3VTMXA0cXRTMm5KNU93dFFWSGdPdkFyTEJGaWpaVVY5UXRTbDhkQVk1ZDBFMGhNMHczSFMyRHBJZUI2bS9BMStIZmhKY0dVcTRzT3hIK3gzZjUrVk8rRHM5cllOSTd6UFhPWVdQcnRmOGJZTXg2ZnVPQVg1anpOUjBQZHN1T04rWDFmN0VFUnhNSkpvVTZHa1RFV0J2Vm9sVmxiNWxoM3RLQ2c2V3gxSWJhTURkSis5c1VDYzVLQzQ2aEtHQ2szSVZPUzRUQ3FkQk5mVXM3S2Q0aVhmMlJqblQvTEx5c0p5M1hEY0hMaC92ZGUzeDhEb0d2d2dzYTY3dkJrOTFHNVBlL0hiT2U3eHd5bTBOWGJ0aXV1RGtHTzJJSkRoOW9Rdko0Y1k0dmRvcUxEdW9IOVpsMkYvb2ZzZWtuOGxrdWhJbGhRY2ZmVXRTanl0RnlwKytwNk5pRTdScXgvbG9kZ0tWb2NlRXAvQ1A0RmZqcnF1WmFUdGoyQXZINUsveXdwbjdNMzRLL1Nzb1lEQWRJTjQ0OEkxLzAvd3ZlVzI4OVQxL2xYNXhCemM4TjVJYUhyMFhNT1FkSHNJa0R1SkZpZmoyMHBCbTVqendVdjllMkZod1JzdmhBYmFsQ0l1SXczYmhKaWhZM3A2blRGRklaZ2lTWWpmVGYzYVh1T2ptZUduNGJQb0d2d2wrQ0Z6VFJjekJJdUhCRWVJbUhjMzcvbEdmd1pSMGNYelZET3ZhS2ZOSHZ3ZStzdVo3NzFLL3kvWGNCbHNvTjk5NkpwQmhvRTJ0b1l4T3puTkVPUzVUSmM2SWQ1R0VYTGpyV28rTEVXR05wUERVNFdBd3NJUlJPdSsxdk0rMG9XMzd6L01CTjlrcUhuU0Fyd1BmZ0ZKN0NxL0FpM0llN2c3bmNtSTA5djhzanp3OW16T0FFWG9JSHhVUnVlYUFjZTVWODBmL0RPdXVad0hNOHZzTWI1d0J6T0ZXTTd3eW1UWFBBRXZtNHZjRnBaMnV0MFZaUmpraVAyTWxtTGQ2RElwYkdTaUhPamRuVUhOOTBoUlltaFRubXZoenAxaUtETmorYjd0NWhpNzlsV0d3UStITjlSc2ZGTXkwRlhiRXdoZnVjektnQ2J5eFl3Qm1jRmhodm8vN2E0NHYraTNYV2N3RFA4NlB6cEdRWWRXaDdjc1A1ZEJ2WjFqTnpkeEM4cEJHdXhxU1c1dnc0MG5CcGo1SmhNd3ZPek4wUldxRVJITXI0THYxa1dYODR4TFI4MzBHM2o2eXFaMWE4VXN0VGxXK3FKUE9aK3NaN3haUEtUSkxoaU5PQUZkNnRrK2pyVEgzMW5jTE94aWQ4K256UmIxMjhIaFVjcnUveTBXbjZpVDI1NFlQQzZGdFZTSU1vVzJzazcyN0FodlR0cldLWlR2Z3NtY2tmWFlaV2VOUlh4LzNZUTJPVXhMRHJiSHROMTFJd3JnWFQ2YzhkQVREd0xuaVl3eHpPNFJ6dVFxVEtTQzVnQW9mTVoxUUJLM3pRNEpXb2JGYmN2Sm04N0ZLKzZKWHJLYWhMbjU0bTNwK01jWHp6WXRQOFZGL1FwSnVoMU93aWVFbEVvSTFwUnhQUzA5RkJya3EydFdDVTU5K0hkaE50VElxS204RUJydzJSVE9FRHBHM0lLbzJZN21GZExtM1plVmpZd1Z3MTFvL296bmNlTXZlNENnTWZOeW0vdXRBL2QvSUxNUjdncFh6Unk5ZURzZ0xjZ2JzOE8yVmExTDB6eklkd0dHZW1UQnV3Uk9IZW9NU2hrVWM3UCtJU1kzS0g1WlplV3FPOG1GVHhRWWVYVE51enZ2SzVGR1BkUWZ1dTAwRHdZRlk5ZHloY3RFdCtPSkRkbnVjZnBteWh6VUp6ZnNKanIyOWw4UzBiWEJmd1JTOVpUMjZ0bU1JZFp1Y2NoNVpib016M05pbzNuSU9zWUhDR29EVDRrVUE5TWlYRXA5WHN1aTFTOHRoL2tiV0lyTUJ4REdMb2RXVVFJV2N2blh5KzlNMjN4UGlTTU9pUlBxTStZTVhrVU4zZ1hGclpKd1hHelVhTXBKZnlSUzlaVDBsUGU4VHBTY3VSbGJNSGVVbWxhS0RvTnV5NjJpV05UV05GWWpveEZ6dUpzOG9SK1JoUng3TzRTVk5TWHBhMFpKUTBLMUxBSERRK0Q5SWVwa01YcGNzcTVFVkN2Q2xCVUl6RGhEb3lLd0R3MUxjNTlHYlRlT1JpdnVndzFJY3VhRU9hR1dkTm0rUHM1ZlE3L3RtMERqTWVncTN5TTN2YjVqMTJxVUlkNVVaRDJveERTRVdPWk1TcUZsL1crNW95bldEYS9hSTA0dEpSUTJlVFh1c2c4NlNRVnUvbndTWXdwVzZ3TGpscUl6d0x1eEdJdm9BdnVsMFBTK1pOejAvYWtwL3BuaU8vOEpEbkd5YUNremJobDZZY3FtSy82OXByeFBxdHB4MitLbTlhbDlzakwrcndNZ0h3NGpFL0M4L0hRM20xdkJ1TDFmbGRiemQ4bU91ZVZKOTJzeXFkRVk0S0pqU0NkZTNtY1J3MlRBNnN6eGVkbit6d2haTXBzMFhycUVzaVVqbkMxaHcwVEVMQzJFazd1QUFkemNoZVh2MUJZTGFnc3B4cHpTQW9aWlVzSXpJcTM1TW5GUTlET3JsTkIzMGpxM0w0cGtoY2NLVUFBOC9vY3ZOMVJ6eDlReU90RVJzNENWc0pSSy9ERjcxa1BZcnhZc0dzbTZSTWg0Y3BzNWcxRE9tTTU0THkxaWkwSGQzWS9CTWs4VldGZ0JWbWhxcmtKQ1BCSEFvbHdaYVd6TFI5VmI3YmNXZFg5TnlVWUUrdUIyQktmdWFlQlVjakRsamJZVlk0RGR0c1ZXdnpSWmRXbnlVekRwak5sMUR1M2Fsb0FqVkpUTkRwY0lPVlZockhGRjY2bExmSkwxekpyOVBRMm5GSlNCYUtvRGUrc0F2THVmWlZIVnpZaDdXMGgvYzZBQVorN1R2ajZxOWo2OEcvY1RDUy8zbjF2TEtIWndOaStQK3BTMFdrWk5NQk1VbCtMREx1aUU0b21aeTcxcjNVRk13TkpWK1ZKL0dDNWl4VlVrQlN0c1Q0Z0dLaDBHbTRPeTNxdnE3TGJtcTI0blBkRHVEUjlkZVIxMVh6UDR2RnUzVFl6Zm5JeWlTVm1naXpVWUdxa0lYTmRLVFk5cGdiOUQySXg1dDArTkhrVnpDZFUwM3N1V2trVlpBb0NPTkNuMFQzNWdBZVczOGRlNDNtZjk3c01PcFN2ajRhYTFLWVVtNThVU0k3V3h4ZXMwM2JBWmRSems2VXRiek1hQ1E2SXhPMGR5N1grWHNqb0QxNmhwc0JlR3o5ZGZ6SGorUi9IcDhuQ3haUnFrRURUYUNLQ1N5d2ppYW9NSjFUSVRFOWVnN0pxbnE4SEw2Z0R3aVpiMHUwVjBSci9ybXZxanhLdWFMQ1g3WldYVHZBWSt1dm0zejhDUDduelZwbmdxckpwWkt3V25DVWpJdmlZVmxpcmxHT3pQTEkzU01WeXAvZWx2QlVqakRrTmhydHVmRkZFclE4cG1kU2xiSzE2dG9CSGx0L0hWOHVITVgvdkVHQUxrVjNSSlJFaVNsb3B4d2RNWE9aUExaK2l4K2tBSHBNS0lrOFV0RTF5Z3RxdXR0d3hOaHBocklaMUlCempHRjNJSUd4R2NCajZxOGJISkJHOFQ5dmRzb1dyVEZFdWViRVp1VnhoaENsSDZQNVpvODlPRzlmd0hOanROUVRwRDBURzlQSkxFWXF2RVk2Umx4eStaWkdmTDBBajYyL2JuUUNYcC8vZWVNNEt6ZlFWSmJnTVFiVWpsTUZJbTZUcGNmV2xaamU3TkJTVjZJc0VWbXVtV0liamlsb1V6UVg5T3pZZG84TDF3ancyUHJycGltT05mbWZOeXpLa2xyZ25Fa1N6VDVRV1lRVzQwWVNoeXpxc1JtTVhidlZ4S3RHdVl5TUthVTF1Z2VuTERtNUlseTRpVDE0ZlAxMU14K3hKdit6WjNNdm5mZEZxeFUzYTFXL0ZUQjRtM1Fmc3ljMVhVY2RWaERlVURaWFNGSEhMUWovWTVqdEM3WnFNMENYR3dCNGJQMTFpM0xoT3Z6UEd5Z1l0aVVCaXdRVi80d0ZPMG1hamlqR3NhZkh5Ukx1MHlHNnEzNWNMMXJPcFZ4cjJzNWNNMmpKWU1DZGMxMEFqNnEvYmxScFdKLy8rZG1tNXBzTWwwS0EyK0FGUng5ak1lMldiQzRqUXhuaWtkNERVOFR3VWpSVmFjZ2RsaG1yM2JwZGR6dUo5elhxcjJ4bnhKZnpQMjlSZXhkdGpEVlpxemtxYTZQeXZjb2pHcmZrWGlKOFNFdG1sL25Zc2tpY3YwaXZseGJxamVtd1VqTXc1ZXZkZzhmVVg5bk9pQy9sZjk0UTJpN01VUms5blcxTVNqNWo4ZUF5VjZ5NUNOMlM2cWJudzN2ZEExSXdxK1hPU0NsNjYzdWROM0l6TG5ydCt1czI1Y0kxK1o4M1NYUVVsZHFRcTBiNVhPVDE3YkdwTGQ2c3NOMVZNUGY4YytqRzhMM05lQ25NZEYrUmEzZlJhOWRmdDM5L0x1Wi8zdndIb0hycUdtUUZhZm1pUXc2ZXl6TXhTMDVLNGJMOXVBK1NLVVF6Q25TRGtxT0dva1h5SnZiZ0ovQkhJK3F2WTY5Ly80cmwyME5zbUsyb3UyZFRzeUlBTHYvOTEvOG4zUDJBYW83MVdGR2k4S0t2MWZSQzUrSjY3US81MDcvRS9TT3NocU41VHNtWUlqVnQra2NqQXg5OGl6LzRTYW9qYklWMXJleEU3L0MyOUhjWUQvRFg0YTByQk9GNVZUdTdvbXNiMTFML0FXY1ZsY1ZaSFNzcUd1WExMcDloYThJLy93M012K1Q0RXc3blRCc21nYXBvQ3JORk9iSWNONHBmL09iL21ydkhUR3FxZ0F1cEw4cVdqV1BTOW0vMzFqQWU0RGpBKzQrdUNvUW9UL3pPemxyTmQzcWQ0U2RwaEZ4c1V2WXdHV2JUV3RJU2Mzd05PV0gra0hCTWZjNmtwbXB3UGdIV3dxYVNVRzJaV1doZVlPR1FHYUhCK2VRL2tuNmIzcE9nTFYrT0RTbjk0d0R2cjhCdmI3MC9MTHVpUFBFcjhPR1ZXZkRtcjQ1UFp5Y2NFbXNWWFpHZTFwUk5YOVNVNStBVlFrTlRJVlBDSEYvakdteURDOWo0UjlMZldjUXZmaUVUbWdNTVVDTU4xdU5DYWtrd2Vac293ZFlvYmlNU2xuS0E5M3U3TnpUWGxTZmUrU1ZiZm5QUVhtZzlMcFlBUXhwd0V0T055RXlhdWVXTTRGUGpqeWpHM3VPYUZtQlRXRE5nQlhHRWlRcHNhV2huQXFJaWpCMDdEbHN5M2ZVR2VQOTg5eGJXa3lmK0ZGMlNORXRUMUUwZjREWVlWbHhGbGJhU01QSVJNay8zaU1VNXBNRTJTSVdKdmpja2NpZWJrUXVJUlJ5aFV2a0hnL2lVbGpHNWt6Vm9nNWhWN3ZJbEN1QnJtbGh2Z1BmTkhRTThsQ2YrRkVHc1liTUlCQzBxQzlhMHV1eTJ3TFhWYkxCYVA1a2pIb2tDUnhhcGtReXpJNFFFY3dnWUhSWkJwK1hFRlRxWEZ1TlZ6TXRqWExKZ1g0Z0FpZDI0SGp3YzROM2R0VlNlK05OaXdUcnpINFdWVU9sRG9iVXFyMUZ1QWdZbGxjOHBtem9WckVMUkhTSVc4VmlQeE55NHh3akJweVI1NUk2SjIyMHFRVFpZUjRndXZVSUNKaVNwcjlnRkZsZTRSY0YvT01CN0JSaVg4c1NmaHBOU08zbHZFWkNRZkxVVlRLVDc4RWsxTFJMaFdOK3lMeVRucDhxV1VaNDZiNnZ4ZFJHWGZIVnF4M2VJNzVZYUxhNGlOTmlLNE5PVzd3UFc2bGhiU09GOS9NOXF3OGUvYW9CM2QxNTZxVHp4cDhwWHg1QktBc1lTVE9JSWlQa3A2OEdtVHE3c1p0dnl6QlFhUkxOeElaK3Bhb3pIV29MRmVFeEloUkJyV2l0SENBSHJDRjcvdGhoRDhKaFl6ODR3ZzkzUVJWODh3THVMWTh6RjhzUTM2cUYxSjQ1NWJPbGduRUxmc2hLVnhZT1hLVnVLeDBqYWoyMnNjelRRcVBxdFYvWERncHN3bUdUV1dNU0R3M3NzeVV1bkxMclZQR2pZUnNINWdnSGVIU1dpVjhrVDMzeWNGU2ZNZ2tvT0s4YXBDeWUwSjZWVzZHT1l2ZmZnVTlSV3N1a0VpMmtVVjJubDRkT1lVelJpazlwN2JjQTRnZ2RKNTNMeEtjRWUxN0IxUjhlcUFkN2RPZXBWOHNUWGY1bGhlam9MODVoVWRoRGRrblB0S0hGaGxqT1QrYmRxMGh4Ym0zNXAybmM4K0phMUl3K3RKeWtncDBFV3VBQVpZd01Wd2FjNUt6WU1zbGh2Z0hkSFJyeEtudmhUWWNmS3N4VHh0VEVUa2pITzdycjN6am9WMjVsQVFIcnFwVjdiVGl5MmFYTW1VaFRCbktTOTFqaHRSM0dFb0Ywb0xuV2hXTm5ZZ3RjYzROMEZ4bGNnVDd5ejNUZ05JS2tzY3g5anRWMVpLcFdXK1ViMXRjMWVPdjV1Y2RncHgrRkp5OXBnYkxFN3hEeVhiL2YraExIVkdlaXRIT2k2QTd5Ym8zc0Y4c1M3dzdjZ2RrMG5KYU9uM2hMajN1eUQwWnA1cGF6RklVWFVwdVRUVTE4ZDFFUGtEb1g4U2ttV1RuVklvekVkYlRjWmpvcXhoTkhmMUpyU1MvQWN2SGpaL1NNSGhMLzdpNXorUE9zVFVoLzhCdk5mWU1UQThuK3lVL01sVFp4U0pEUlN0cXZFdUxRS1d3RGN0TVRRb2dVRHlRUm9UUUc1S2M2b1FSRTF5VjFqQ0E3cmk3amRaeUswc1lUUmpDUjBIbm5kK3k3bkh4TmdUVUxxdys4d2owbVFLeHBZdmhqbTl1U1V4ZytUVHk3czJHdExVR2N5d2hYU0taTjI3NUdzcWxjbFg5MEo2YlJJMWFvdXhtZ0w3UTBOZW41emlNODBTcU1JbzhjU09vKzhYcGxULzVESE5Xc1NVci82bExOL1FRM3JEeXpMcnVFVzVlbnBmN0txWm9TaEVkdXVTRk9WN0RMWDdZZStHbVhiNi9obk5OcUtzVlh1TURGcGI5WTllSDNDNk5HRXp1T3VJM2dwTUgvSTZlK3pEaUgxZlhpMTV0M3ZBMWN6c0x3czBUR0V0bVBFSmRpaUZQd2x3S2JnTEhBRms0UDZaeVBkeW1ZWUhHRTBkdXRzQ2hRQmwySmNCRmxyRWtZL041YlFlWFExOGdqdW51TWZNZnNCbHhKU3gzbmlPNDg1ZndPNGZHRDVULyszZlBRcWtuZVdWZHdudy8zYk1Qa1c5V2JxZytpQzc2NVprK3hjVDk4aWJLWmMyRWRnSGNMb0Y4Y1NPby9PYzhmUytPeUVVTEY0ZzRzSnFYVmNtZk1mc2M3QTh2MS95ZkdYbUw5STZGbjVwUndaaHNQdjBUeEZObEFmWkN2RytPb2hpODJVQzVmLzJJc0pvMGNUT205WXJEb0toRlBFVXIvTEJZVFVOaHQ5emVsSFhEcXdmUENJdzRvd3AzbU9jSVFjTHR0V1hGZTNWWi9qNUgzY0ljMEc2b1BiQ1IrNlkyeEYyRUM1Y0dVbTZ3S0M1dEdFemhzV3F3NWhOaWRVaUtYNWdGV0UxR1hoNC9RcGx3NHNWek9teDlReFU3OGczRUY2d25abEVONEZ6SjFRUFNMRVp6MUtmWEM3dmQ4c3NHZEliTlVZcFZ4NFVhcHlGVUh6Sm9UT28xTWNTa2VObjFNNU1EUWZzNHFRdWhoWDV2UVpGdzhzdXdXVGN5WVRnaW9JU2syWWRta2hlaEc0UGtFN3c1MWlueUFHR2FVK3VDWEFEYWJHekpSMWZuM2x3a3R5MGFzSW84Y1JPbTlWeTFnMHlEeHh0UHZIREFtcHUrUEtuTThJeDF3d3NHdzkxWUpxaHRlYVdnallCbW1RaWVibVNwd0tLekUxOWh4N2prelNXT202Nm9QYnpaOFlqNmt4VlNwWWpWQXV2THpZTUNSbzNvVFFlY09PampnaTNOUTRsOUs1L2hPR2hOVGRjV1ZPVHJsZ1lOa0VYSU5icENrQlJ5cWhwK0xkUkIzZzBPVTZyTWZXMkhQQ0ZGTVY5blNwK3VCMndvZXBkYkxCdUpReWF3L1pGeXNYcmxYd0h4STBiMExvdkVraU9wWEdBMUlqYWdmK0tVTkM2cktOYTliUW5MRnFZTmtFbk1jMXVKcmcydTY0RUxQQkhwa2dXYm13S3BKb0RoTXdOYmJHekFwN1lnMzF3UzJUNXJHdHppdDU5UHJLaGVzV0c1NTBDWnBIRXpwdjJOR1JheGxOamJNcXBtRUl6eWdKcVFmanlweWNzMnBnMmNTMlJZOXI4SFVxa3FkRWdLVFd0V1RLb1J2T0JQRFlCbHRqYTJTTzBSR2p5OVVIdHh3UmpBMTF1amJLRit0aTVjSVI5ZUNueFVnNm93aWR0eW9VNXRLNE5Mamk1UTNIQ3RpeUYySXFMR1lzSFZpT1hUWE9ZeHVjRHFHMEh5dHRxWUFLcVlvM0tUWTFla3lEWFJBbTJBV2g5Sm1zVmgvY2NnOVdKMkU4WWpHMjAxc1BxNVVMeHhYOG4zWExYdU1JbmJmdDJtazgwclJHakNHY3RKOC9HRmRtRVE5VWc0RmxFMWxsMVk3anRpcmFxbTVGZTA0VlY4bHZTVkJMOGhpUHJmRlZkOCs3UUgzUWJ1MmlwVFZpOGN2U0dpdmM5Y2o4eXZIMTFZTUhkTlNFUnR1T3NsTTk3ZmVZRk9QS3pHY3NJNHpXMFlHQWJUQU9heENueGRmaVlVbVZXc2x4aUlibENlQVlyOVZZUjFnTTdHbW9QcmlsdW5TeHhlVDNETi8yZUJROUgxMStuazFhZG42Vks3MSs1K0pmY3Q0L2VsMTAvN0tCWmZOcnlVdW5XU0NQeFBFQ2sxcmRPdjFXVlNyUW1wQytUbDQ2WUQzaWtRWWNwdW5TUWd6VkIyVkhGaHhIVkdLRGdNRVk1R0xsUW5QN0ZNRHp3N0lhY0FXbk82c0JyMTJ1K1hhblcyQU8wd1E4cGtubkZoc0w3S1lJcWhrRVBtRVhGa3dhTjVLUXBoYmtVbUc3MndndzdXU205UmlMOVFUOTI1aGtqaVZJSWhwaEZTOUhLSTYvOFFBamxwWHFnOVcyQzBhcHlhVkR3S1F3cndMWTNqNkFEUjEzWnlVTkJ5UVhIUXU2UlkwOUh1NnpNcVhSYU5aR1MvS0VKczBjSkVlOVZIMVFkdkJTSnY5aDA5ZWlSbXkwVjJ1SmNxSGNTaGNkdmJTTmc1ZnhrZW5rVnByWE05ckRWblgyNC95OU1WdG5jdmJLWTcwNmFuTmwzQVNsbDlhNDNVaWFjVnF1WEdodnE0czJGUDYyTkdLZlFMSVFZdTlxMVdtZE1mbVVyREd0OGVEUzBjWG96SC9mam1VSDZKcnV2bTUwaEJEU2FFVS8yUnUyTEVOL2RsMDA2VFNjL2c3dGZKRVJ4R01zZ0RVRXIxMDRwZldIOWxRYU4rTTRLV1Fqd1piVmMyclpWTkhzeUhhbDIzd1p0SXMySkpxdEljL1dMWFhSRkNwSmtmRTlqdldsZkZic05ROXBQNVpCUzB6S2g0UjBhTUZqMUlqVGNUbnZpMFp6MnJ0N05kdlFiMm1nYmp1MXBsc0g4TW1ibkVrN0tiSzBiK3dDMml5M2FYM3N6Vzh4ZVp2RHdFVDZoV1pZd3FUWFNTRyt3TUVUS3VtMERxL3EreDYyZ3QydWEycHBBbzMwOVRSazlUUGF6ZlYzcUw5SDh6N3VoR3FHcXhOVmcvRkt4MEhCbDlPVlVPUm44UThKeDlnRnR0R1FVRHIzdHpjWFg5eEdnTjBFcHpOOW1kWjNHQVR0UGhMK0NqeEZEbWtlRVU2eDU2a3FaUnVzTHpBTFhWcWtDTjd6TUVjcXdqbXl3RFE2T2h5VWUwWGFvMVFweW5jcmc2d0twOVhmV0RzYVpwbEVsdlEvYjNzZHdlZWdob3J3QkRsSHpnazFKbU1jL3dpRVJJQ1Z5MlZKRmRNakZ1TFFTcDNTMFczK3NuZ3Qybmp3TmdMc3NGR1ZRZEowdHUwS0g0a3kxTFc0eXJia3VhQTZJeTlvei9xRU1NWE1NRFd5SUhoc0F5RlpjMnBlVjloYzdraUt2ZlVMeENsOWlkZGZSSzFmOGtrOXF2YmRPb0J0T2c3WmtPWjVNc0dyU0hzb2tnTFhVcDl5ODhzbW5pd1d5dUZTSVJWbWpwbGdhM3lEOFVpajVRUzFaaU00VTNRdzVRbFNtMmJYakZlNmp6ekJGdHBnKy9ZQmJMQVdHN09QeW5OamxDdzY1ZnVrR05ka0pSZjd5TTFmT3hWemJ4T0pWb2NGb1lJYUd3SDIybUlRa3J2dTFFMm5HdWVieElnVzlVOVRTaXVrUEdVK0x0KytjM0RKUEtoeWhFRWJYQ1FMVXBhZTJleGlLeTZ0TVBlOW1EUkJGQ0VNVFdydHd4TjhxdnVHbnQ2TW9paEtXUzVOU3lCaGJIOFN0WG9BejhQTE9yUmdMdE9ULys0dmN1Kzd2RExucU52enRPcTdmbWQ4c01tWTlYem4xemo4RHE4K1hWZHUyTnYwSUl5U2dFZFFvM3hWSHBzM1E1aTNmTEZzVjRhaXF6QWlCaGJnTURFZDF1aDhxWlorbHdoamtnb2trT0l2NHhOSm15bmNkZlVVemdCNG9GTUJ0aXU3MVh1bXB6L1ArY2ZVUCtTbHdGRXh3V1c2MnI3YitMU1B4cXhuL2d2TVo1ejlDMTZ0MTVVYk5scStqYkdKdGNvN3A4d2JZbEw0YWxTeWZXZGV1dTBqN0pBM0pGTnVWQXd0c3Q3RjdGaFdCYlBGTktJVU9SbmRXdExyYUZMbU11N0tGVkRET3pxa2VhaU4zM1lBVy9yNzZ3UjRYRE4veU4xejdoZWpQYXUwNkVkZGtTLzZYVGhmY3oxZkkvNEs3MzZmTzQ4dmx4dDJQWEpZRmFlVWtGUzhVMTVYRTM0Mjh4ZHRuMmtjOEdRbGYxdmtJYU5SUm5PTXZMVFdyWmJFbEVIZUxXaTFvMGRsS1BBaDFNVmdiYlZxdVBKNStDcjhMVTUvSC8rSTJRbEhJVTJDbFhNOUc4djdScjdvYy9ob3pmVVVnc1BuYjNEK0krN1dGOGtOTzkyR1kwU052dXhpRSsyQnQ4cHJWSlRrekU2NHNmT3N0eHV3ZnhVVW95azhWamNUbHNxZTJxSVRTRm9TajZFcGQ0S3NUNkJaT1dtdGdFM2hCZmlyOEl6WkR3Z1Y0WlRadkQ4VnZQSEVSbzh2K3ZMMURBU0hUei9pOU9sS3VlSERqSzVSbngvSkIxVmIxaW9YZEJyYTE2ZG10N2RnaWsxMHlBL0Z3SlNWWTZYakEzb3k0U3FNMmZycURQUFNSTWV4OXFzM1hRdG9XeE1qNy9FcjhHV1lzWGdqYVZ6NE9ZdW1QMis5a2J4dm55LzZrdldzRUJ3K2ZjYjViSW5jOEFQZGhwT1NzMDF0RXFJa29pWmpiQXFLTXJ1TGJKWWRkSHVIRlJJeUpjYmRFZGJsMnNWTGF5U3lndW51dEJnOTZZMi9KaktSQ2R5SFYrQUVGdFR2SXBiS0lYT2Fta25ZU2lCNktWLzBKZXRaSVRnY2pqazVaZGFza0J0V084NlVGMGFwNm96R1hKazJXTmlSVWxDUEZpcjY2bHpkbS9TTFN1SzdFVWRQejhmMXoyOVNrcTZGMWZYZzgrNVVWUjZic3puY1A0VG40S1Vra2RKOFVGQ1kxelIxaThSbUwvcVFMM3JsZWk0VEhHN09PRGxuS2tvNG9JMDFrZDNDYU0wOElhMThrQzNHTm9WYU85aURoK2hXeFN5VFhGQUJYb2F1N1E2cTlPeFlnL09WRU13NmpkYnRTcko5Y0JjZXdHbWFabWcrYnZrVW5VVWFHcitaZm5NSDQ1SXZldmw2MWhNY1hzeFlMRlR1MWhUbTJ6VmlDcDd1MG81bCsyUFNVaDliRGo2RmdZeXB1ZkJEaHFLMitvWGtpdUhGSFIzemZqKzlQdEE4b1IweG5xWDhxbitzeDNiRk9EU2JiRjBYOEVVdldROGpCSWNqbzViUm1MT2xqRE50Y3FOdE9lNzU2aDNsMFZoS2E5aERkMmwxZXFtc25oME1OTVQvQ3FueDZCSW51bWhMVDhsdWxqelE1M1JpSmVBLzBkeGU1TkswbzJmQTErR0xYcjZlTlFXSE5VT0pzc1FhVFJsR3BMSEtMOWZEK0lyUXpUT01aUzlmTlFENEFuUk5WeHZUZGpDK2ZKZGNERFdRY3lCMDBCMHQ5QkR3VHhYZ2FBZnpEWi9EQlh6Um5mV01GUnd1TnFvY09tWDZPS05rWTYzaDVuL2ZGY0IyOE1jVkhxblhaVkkyN0swaTRyRExORTlsREtWL3JUK3VkVmJEOGRGRnUyR0daOG1PdDBrQVhjb1gzWmtJV1Z0dytNTmY1TmpSMkZiaXZST0htaFYxL3BqMmVndi9mTUdJT1dUSVdyVjNBdjhOOWltVjlJV21sMzZINmNVanFFV052OWFOYyt2ZWIyc0g0NlBSYUhTdU1CeHZ0Vyt0d3hjdHEweitRc0hodXg4UTdyQ1k0Q3Q4bHFzeDdjNlN5MGRsNVQ4OXJJZUV1WktvVmN0SWsxaE5wZmF2RVI2eXlIMVZ2bTNNYnNVSHk0YWI0aFdyL09aUGNzUkJwaG5hVjY1L1pjZFlQTk53c2pOL2RqbGY5TnFDdzlVNUV4Q1BjZGhLeFVnTFNtZlJPcExwNFdTVXI4b2pkd2JuY2J2Q2YrYS9ZelJhRWM2UU92WGNHTzI1NlRYYzVMYWI5UE92QitBV1k3UGlnV1lqemhpZmJvdnV1bnpSYXdzTzI0WnFRUUFxZ3VCdG1wbVBCN3lzWEpmeUREYVYvYVBHaWxsZ3oxTWRRZzR1NU1ZYUV0Qk5OSEZqa1JsU3BkNjVscDRoZDJBVlBUZmJWN0ZHcHlJT2ZtTmMvWFZzUGZnN3Z6YVMvM25rdkxMNTkzQU5Mdk11Uk1HcFFJaGlGN2tVRVc5UURwQVViVFdZQmNicDRXcGFjSEhZMWFhY3FReWpHWlM5SEkzeUNCVDlrVVpKaFZPRCt6VUR2RUg5ZGRSMTFmelBjVERRNVRsZ0IwS3dxZFhTYXZrOUJDMHBLcDBXbWN1b3dTdzA3VlhtWEM1Z3V6U2E0cDBVdlJ3MmxiRGlZVXgwRXhKSlJ6V3ppNkdtOGNuRWtmWFhzZGNHL00vakFKYTArYm1DZ2RtUTlDWWxObFNZWk9LaXhtUnNnaUZ4a3JtVzRsM0tkRkt2MURNOHRrNld4UFlKWmhVVXpjZDhLZHRncncvZ2tmWFhEVDcrYXZtZlZhazMycWh0a2c2TlZkVVM1d2drcnUxWXpJa1NkdVRXMUZEd1ZXVjNKUVZKVnVpZVRjMHk0aURwRndjNy9CdlNhbHZLZFFNOHN2NjYyY2V2ei8rOHNRVm5qVkFUMFcyd0xsbHcxSmlNaEpSeGdEakNqTFFzT3pTRlNnWnF4N2xBVzFKVzBlMDN5QUQzYXNDK0dEM05iUWhiZSttTjVHWEgxRjgzS0RPTTRuL2U1Skl1SDROcGRRQVJyRlBCVnB0VU5jamo0Y1ZNY0ZTUlRFMk5wUjFMRVliWU1tZldwWGdQOUtlamFQc0xVaHV2TENzVlh6bkFHOWRmeDlTUjF1ZC8zaFpkQ0xIYjFHTWRQcVJKZ3FEbW03Nm1IYnZPWER0aU8yUVBVY0tvL1RXa1EwaTJKRlhwQm9vN3ZpajFpMUxwM0FEQW8rcXZHM1Ywck0vL3ZGbm5URTRoeGQ1S2EvQ29yNVlFZHNMVkp5S3REZ1ZvSGd0VzExcFdTam9sUE5NbnJsclZqOUZ2MlFuNjB0d013S1BxcitOL3d2cjh6NXRaY0RzRHJ2MDZ0a3F5ekVTTTg1WWN2NlhCV0EyYmlybE5DWHJJNlZiRDJseDJMMHZRTzBRVlRWVkxINFNFNjdmZ3NmVlh2OG43c3o3Lzg1WjdjTXRiRTZmMDg4d1NhUjRrQ2tDbTEwczZwS2JKaGZxaVVOR0xxKzBnTFdDNmVVQVpGUG5MandxdEtkOEV3R3ZXWDU5dDdpUFc0WC9lQU4xc3ZnUlZTWTk5MFlaZzA2QkQxb2hMTXR5RlRJNHBLVEpzUzl4UkVxOUVPYVBXaU8yZ3BtczczOTd4Nm5RSmtiaCtGejJxL3JxUlJPWDYvTThiSnJxbFZXNGw2SkVwdEtlVUZ1TVlVYnRDUTdDSXR0cEdjNk1ZOTN4MXIxdmdBblJYdlk1Y3Z3V1BxYjl1V1FtK2xQOTVReGROTWVXaE9xMXgwRGI1NUM3R2NVdjJaVXVONm44aUt6c3ZPeGliQy8vWWZzOU5hOHIyUmx6MDJ2WFhEVDU3RlAvekppNjYvRUpTbXNKS2E4UXhub3FXM1ZMUStqWlZVdEp3SjhQTlgxTlFDd2ZOZ2RoaEhEOW9uN1BkUmRyZEdQRjI4ckpyMUYrM0xCZGV5dis4eVlmTG9NWWV0MXZYNHVwTkFqVnZ3T1VXbmxOWEpYbGt6azVJbDZrcWVvaUwwQzA3cW5vKy9DWUJYcS8rdXRsbnN6Ny9NenZ5MHRtSTR6bTRhZzIzUFJOM3QvQ1dyeW9VVkpHbSs1K0s4UkowVjhIYzg4L1hIVVgvSGZpQXE3dCtCSCt4NnY4dDQzOGVuV21kSndGQTZaSU5yaUxHS3YvOTVmOGxUOS9GbnlBMU5NVkV2UXlhWHV1K2d6MzZmL0RENzNFNHB3cXBMY3ZtL28wVmxlNzhuLy8rTC9OUHZvZWZwMXBUSnllNmU0QS9EMDgyRkVSYTUvb3BlSDl6cHZoMTNjTm0xOS80di9MRGU1eE1XVGk4STBUYTBxS2xLMjdBUy92My9yKy94LzJHTzlLMmM3a1ZNb25EcHE3Ly9qYzVQS0N4ZU5QcEZWemFScjAxd0Y4QzRQdTc2aFh1WDE4SDRMZHVUcjc5Z3V1RkQzbjVCSGZJK1pSRmhZOHcyOVRZaGJiTGkvYnZCZHFLRTRmVWdnMXBCS25WM0ZFYUNXT1d5QSttM1dwT1Jaci9qKzlUS0p0Vzh5QlRGMi9aRU9ESTkvUWF2SGtWZEdGcC9Qam40USt1NWhYYXBzUDVzT0grT1hYQTFMaUt1cUp4aU1OYmhUa2JkSlRDeTRsbEV0Nk5ucVJUNGRoZzFWM25iZHJtNmRZTWVjQTF5VE9MNFBXVEU5TDVWelBGbExCQ3ZsRzU4QWhlaG5ONHVIc0FZaW55SitBWi9Oa1Z2RUxiZk9CVXVPTzVzeUJJRXRpcUhVMWs5WGVJU1g1YnNpbXJrVVVobkdEeG91ck44U2dVc0NaVnRLeUdieUd6SFhkak9oc0F2T0Fzd1NSeUlCZGRSZEVaV1A2R1poTksveWp3ZXc5ZWhCbyszakVBRHU3QXkybjhtRGMrVFM3YXdVSGcwT016UjBMQUJocUxENGhKRWgvQkVHeUJkR2xTSm9YWVh0ciszSFM0aWp6VnBnaTBwYVdYdGRydUdUa25YQnorMTFxVDFRMmlueGFUelFDTzQ2UDNsZkxweVM0Zm91MlBIL1B1cHdaZ0N4TmhHbGo0SXZVdVdFc1RrcU1XbTZpNHhDU01jOU4xUkRRb0NWY3VHSXRKL01SV2VmYWlzKzNzeW5vd2kvZEVTZ0pqa2lsblduQlRHdlJXbWF3OG9SMTUyNTd0N0NIbUNmOEhPbjdjd0k4K05RQlhNQkVtQWE4UE1SZW1yTkNFaExHRWhEUUtjR1pXUzMxOUJYOVBGQkV3R1RiUkJoTGJEY2FWM2RyRmNEcWs1a0NUZDJKRjFXcDBIcmFxQng4VTB3d0JUbmJwQ2Fkd0JBL2dUSC9DRHJjQ3M5M0xWOEUwWWxtbWN5UVJRbmpCYThKRVNtR1VmSWpLLzdma2FESnBtRDJRcHRGTlZKVTFiYnRJQWpqV1FpemVwT0twdFJqYnpSOUthZzZ4Wm1NTExqSE90Y0xUM1R4OW8vMEVjVFQxWE4zRTQ1dTI0QWl3RXlwREpYaWhLalF4akxwckV3Y21SS2NsYUROWkNWcXIvVjhtWVd5RkFEYnVzaVk1aHZnRm9VMnZpbzQ5UmdKTG41T3NSZVJGTjZ0YWJlZXRpaXkwVjdLRkhUM0h5Wkx4NDkxdTk1c240SzFRUVNQS005aE5UMHdNVnZBV2J6RFNWZHJLdzR6UmpaTXlKSUhrZnExVkFWQ0RsL2JVaE5LbEdxMHpHcjA1K1lBY2VYVlBDdHRWazBvcWpWd01QdCtCQmVmeDR5UHRHVmtVc3FZM0NIRFBpQ001bmd1cFV3Q2Ria3BkOGtiUHJDV0hoa210SUtMRWV0RjI0OTllUzFqWmxJUEdZbmxjUFhlTTJLRDl2TFMwYlcza3RZTnFVbGxwS0xuNVpyc3hsSXp4dkR1NWVIeHpHTGN0a1pMRVk0UGdTT2cySVVWVmNVT056VURCRXBSYU1vWE5tVWMwdEZaclRacXVpTHlLeHJTbTNEdklXOUZpbCtBa2hYdTVQaEVQeDltVU53cXlwRHZaV2RLbGhJSlFZN3ZuMk9zbm1CZU9XbllaMG0xaXdiYncxVTYwYnk1b200N2lIUlY2Zk9nempNZi9EQVpybFA0MFo3c3l4cExLMGxKMGdxYUFLMWMyS1FLdTd0YWJUWGtMRnowc0NmdHV3WCsrTXlOZU5uNjhrNUJ1cTIzWVFoVWgwU05USmExaW9RMHA0blVHMnkwWGlsRjFKcU9EcWRJbWxvUFM0QnAxMTFERVdUMGpKalZ2OTV1WDlCQlY3ZUIzYlVXY3UwYWNTVk0yM1laZGQ4UjhVYlFVeEo5d2R1M29NdWhkdDkyOU1FK21oNkpYSjhkaTJSeGJUaTZUYnJEcXVxVjRhVUtSMml3VDZhWmJ5T3dFWE4zRFVzV3I4SG40RWh3TnlIdVhIaDcvcGRhVWp0Ujd2bkRoL2Q4Yzl4RC9zNWY1MDFlUTErQ3VEaUN2R2hrMUFOLzRUZjc0UmZ4UHdEM3RvTGFyUjB6TnRzblB6bVM2NEtJUms4NjFkTVdDVThBcmFzRzlUOUgwWkJwc0RHbmp0QU9NMisvTHVJYjJpSVVHWE5nbDVabUtEL1R3OFRsYUF1aWhhRlA1eXJ3MTh2NHgxODk4eklkUCtEREFYMWJNM0dBTXZQZ1JQL2NKbjN6Q1cwMTNucmhIa3JJVHl2WXV3T1VrY0h1S2xSU1c1QzZyeklkWTRwcG5GN0o4YUFKYlFlcGdiSllCakNZOXVzR1hES1F4cTdSWmZoOWVnNWQxVUhNVkFUUmFELzRCSEs5My8xaUFnWVovK2pxUG44RG40VUV4bVdycGEzK1pPSzZNdk0zYmp3Znp4TldBMmRoczgrNTFYSFNQSmlhQWhHU3BXZXZFczV4SExYY0VHRlhZaUNPTnlTSDNmUFdxOTNKSXNCaVNXdld5YzNDQU4rRWNYb1Q3ckNTQU5sb1BQb2EzMXJ0LzVQVUEvZ3A4US9qREQzaHlyanpsUjhWa2FuZk92QjFYUHVidDE3dnp4QWZkU1ZiRDFwekFuZmd5RjN5Y2FkT1RPVFhocEVVb0xDMUhaeU5HVzNkdG1qZVhncjJyNTZKTm1Sd2ROTldhUVZCZGRkNnJoNE1odmlFQjlFRlJELzdSR3ZlUHZDYndBTDRNeC9ENk01NDFoSE80RDNlN2c2UGFmZGNaVnc2ODl6N05HVHdvNW9tN0E4c1BoY2NUNnFLY2w5TkpsOWFNLzlrWCtlNTlIaDF5UHFHdUNDWnh1SVRjc21OYUo1RjdkMHE2SjNINDhUTzEvK001NzA4NXEyaWNkdTJVK1czNkxkbGx6OUFnaXY0WUdsam9FTjkwOEV6dkRPckJGOTgvdnRKd0NDL0JGMkFHNzV4eEVtam1NSWNqeGJqb2F4cU9LMy80aFBPWnpoTVBCcFlQRzQ0Q00wZFRWbTFMakx0VVdXVnoxQmNmOHRFeDB6czhPMkEyWVZIUnhLWU9peS9hT1ZvQWFNdTBpN3VidTQzbmpqbWQ0aWJNSFUxc0lESGFRTktyWk5EL0ZaWWRrNTRvQ1hldGpxN0U3SVZsOWVBTDd0K29IbndYWHRMeDQ0Y3p6b1JGSEJ6dFlWd3RIMWQrTk9Na3VwWjVNVE0rZ1VtcTkwWCtCaDl6alJsbWFRK203WU1xVUwvdmVlbWNlY0F0T0oweXExSm5WbE4yN2RpMkUwK0tscDF0QUo0S1J3MWVNSTdhSmpzTzNSOGtQU0kzZlVGWG5JT2ZkUWU4NnNJSVZ0V0RMN2gvL09rNnZqOHZ3RGswOE5FY0k4eno3T2hCeStXd2FselplWjQrMFhuaVJmc3Q5cEFKcVFIREdMelZRMnBoZVpubnYxT1dod080My9BZ2N2QUVYRVZWcGE0ZGI5c0d2Tks4d2phRU5Ia2ZGUTRDaTVpN2RxblFsUG9MUXJIWFpEdk8zQklYWmJKT0JyT2FFYk1MNnNGTDc5OEk0RmhLaWhqSE1zUGpCVVpZQ01GcjZudmFBcnhxWFBuNGxDYStjSGZTYTJjUDI3ZzNaM3ppWVRScmNiUU5HTFFtR0YzRjNjQmR6enpYN0FJTHgwSUI5cmJ3bjlreDJHMUZXM0luaWMrWkxJc1Z2S1I4WndmajBsMWZrcW84TFdZMU0zSVgxNE9YM3I5UktUSU8rZDlYekFJOHFSUEdQbi80TkMybjZvNHJOOFhKODJUT0l2dVZBOHpMS1VIUkZnQkNldGxEWmxxUjFnTEtqUzM5eG9FN0J0OFV2QTZCeHVFRGpVM3RGc0VpamdBKzYxNXRtWmtYS3FpRUVOcmg0MWlMRERaTnE0cEtUV1IzTFpmbm9zODFMT3VOYTE1Y0Q5NTZ2TE1zSmQxcnFZcDUxZ0RVUXFNWW0yWHN4blVoRDJqZzFETTdTZXVKeHhncm1wZklTU1hWSUpJUzVxSkpTdkpQRVE0OURRVFZJYllXSjlRV2EvRTIrYy9vUEsxZHJtQzdXU2ZKUk5LQk81WWp2Y3A3R2MzZG1tSS9YaDFrRFRFdWlTbldxUWYzN2grZlRNaEduRGY2ZHNTOFNRZlFXbHFxd1hYR2xjL1BFWi9TQzVtdHpJVjBuQXNobFFkTS9MdlV0WXV0ckVaL1krRUFGdHExazI4elFoT3dMcjFBSWVBTnpoRjh0OXF6VGRaZjJxUktPNk1XRTlvaEJZd2liYk9tckZ0Tm1nM21jUyt0QjI4eHYydUtkL2FnWUN2T1ArR2tTYyswbHI3Ulh6eXVmTDdRYmtVcGpMakVXRkxxT0lrQUd1MkIwdE5sTzlFYXUyVzFxY09VdlZSZ0t6eXBLSVFaNUtJM3EwTUx6cVROUllxaVpPcW10cWxvSVJsbWtCSFZwSG1SWVY2L0hpeGJPNlVDNDdLT0ZKbm9NclZ5cjd3WXorU2xXNkdVYWdoWWJZMUk2a2t4QTJXMWZTSm9rVWRTaDJMUTFHQWltUkdtME1UK3V1NTdINWw3UWdPV3hFUnBPOW1vTFJQZ1R0cXVXQ2ZGbEdsSWpRYVJseTlvZG16TU9XWStJQk81dEI0c1cvMCtWV0dVaDMycVlrNzlFaWRXS3JqV3VpTHBpVk5HRldGUkpWa3R5ZVhXbWJnQkJ6Vmw4YW5QdVh5TkpsQkpPbEtMVGdBYmkvRVlIVkh4V2lEYVZSMDZHbkhRTnBKY1djSzJqSnRpQ2ZHMnNFSEx6dUk2NnNHck1LNDduUElJblBudTc5OTkzNWFPSzJjdm12dWJyRTM4WnpaanJFTENtWE0yaE03VWNwWEQyb0MzK0VDVnA3eHRJdXhwdEowalVyM3NCbUJTNDdUVnhsdkoxU3FiL0UwdUxkdkxqMGxMcjI5eXBkZC9lTVgzZjZscnhHbEt3S1F4RUd2dzBxSGJrYndyRjN1SEt3VkVOYklWMndaMTNrTkVGNnpEK3gyNGFMTk1mRFRDYkRQbkVpa1pGeVROdHR4V0JYRGFCdU04S3RJMnJtYU1kVVk3Y1hjVVBzdHFUR3ZCR1NyRldJcE5NZmJkZWE5OTBidkFPQzFZWDBxYmM2c21EUzFtUHhTSm9XNGZ3RVh2ak1taGxpakRScTZxYWxlNmFKRXVGR29wcFlEb0JFTFF6TEJ1aC9tWk54N2praW52MEV0blVwNTBsTzloYk5LNTdsWmFNQVd1V1I1WW85L2tZd2NZSTB0NGdXTTQ3VW1ubDNZbXBlQlBxU3lOcDNLN3MyRFNBUy8zOUtSdUVOMmJTNHh2b3dWM2RGUk14L1ZGY3AyWXA4dzJuVE85aENYdEhHMWtGMUw0S2xySnIyd0tmeXE3N1I3TUtwRkt6V2xZOVVraFl4eUhXVzZuQldQYXVkdkVBbDNDR2NOcFNYUFo2UjlCYkJ0SWw2Y0hMM2dJQmkrNDJDWVhxQ3gxZ2ZHV2U3QXAwaDNsdXlYZHQxTUt5NFlVVDl4U0YwMUcxNllFZFdzb3VXOW1nREhkM3ZleUE5N0grWWE0N1ptRWJxTVk3Mm9QenRDR3ZLMG9uTDQ0QXZnQzQ5c2FaS2tXUno0dmVXbGpFMUZIamJSSmFXdjZaS0t0bDg3NWg0Q3ppRkNaaEc1cng3dGVmc2wwYVJUMWJNSFpqbThkd0wvNnU3d0NSeXNhUWJsUW9HNXlBUU41enBhdE1OWS8reWY4eitHTGNIL1FuMGlYMlcyb0VmWFA0R3Z3UUh1SUw5QVlHbmFPM3pxQVg2OTQ2bmtncVpOblVoeDQzRElkUXRNRmVPUHJneS95M1lkODVIbEpXd2pMRmtVM2tGd3EyOHhQbnVQaE1XZVMrdERMVjlPdGxscTdwUUNmM3VYSkROOXdGRGlVVGdlZkhhaVliZGZpM2IzdTgraVk2VG56aGdlaEkxTFRlOGxjZDdzMXdKU3pLYmFoQ1J4S0t6dFRMWHN0R0FpdTNhNnJQdVFzNXBrOVRXQWFuNWYwQlptR2Y3WWx4enprL0E3UEFzNFFQUFBBSGVGUTJoYkZIc3psZ1p1S1pzSmNVbWJEQzQwc0VVNDAzY0VqY3pzdE9FeXBhK1l4ZXZMNFFCQzhvUllxV2RLNmI3c0syNXRmRStvRFpndE9RMkpnOFQ0MUhHY0JFNmZUV0huNEp0SGN1OVM3dVlnVTVLU0NrbC9tY25xKzUvWUJYT0VyNmxDVUN3T1RPTTF0YU9JOG1TeHgxTnNDWEJFbUxLYk1BZzVNa3diTG1wQmFGT1ByTlNsTzJIbkxpRXFXM3RIRXdkOEFlaVFMbW4rMmd4akMzazZBeFJFcXZLY0piVEV6bHBMaXc0ck5aSzZvSmRpZGJNTUdYOUZVTEtyMEFrVysycURFUEJOTm01UUF0MklrMm5mdE5XSGV0dWJvc0hMbzJuRzR2UUE3R2tjVkNnVkNnYURpeEhxbzlVVW4xQTZPc2hhcGFOUi9MUFJZRlY4c2lUMWNDdEpFMGsvM1d0YU5TdVVaWUtQbnNWSVcweFhXbk1VeHE1K0VuNEt2dy9NcVFtVlhuQVhqOVorOXpNOTh6TS9BZ3k3Ri9xcWoyTmg2N2I4SGpGblBQM2lCbi90a3BkendFSlgvd2hJY1FVWE9haWtlbGlDUkdVazd0aXdGMHJJdHdNRWhqa1ozMDloaWtGb1JBbUxUcEVYV3VIUzZ5K2FtL0tCL2ZNNTBhTEVoR25TTXdrcHh6T292NEgwQXZnb3Z3SjFpR3pETHRKbi85QlUrZkFJTmZ3VWU2RkhTTGh1ODN2aVYvKy9Ick9lUFgrU1RUMkI5dVdHYnJNSEhMbGRSQmxoUy9DSlFtY1J4SkZxWmljYTAxWGl4QVpzWWlIMXVvbFp4THJSL1NneFZJSmprcFFQNFBFOXNFNTlMS0xyN2tsdFNCb2dTNXR5c3p6SDhGdnc4L0FTOHJOT2cweFVTOWZJYUh3Yis2ZXQ4US9neXZLUmpmNU91c096R3g4ZXZBL0JQNElQMTF1Ti9ncmNhNU8wbGNzUExKNVlqd0k0UWtKQk9IYTBXZE1aWUd4UGJoMlcyblI5djNXeEVXcWdwL0czKzZWWmJSTFNBQVozQmhkaEFhVUwzM1ZVU3c5eWpFc3ZiYVE5dTRBL2dHWHdaWG9FSE91VTFHU2oyY2hmK01vK2Y4SWNmY0F4ZklLVm15dW5SYllRVm5vZXZ3Z2Z3M1RYWGN3Kyt4TnVQNGZoeXVlRVVOdHRFZHVSVmFEdHRkZG9QMGVTeExlMkxFTms2aXRZeGxyeEJOQllyTk5LU1FtZWFMY205YzhVc2FCNVd5TzY2NzV5eVFJQVdTRHBCVm9BL2d4bWN3RXZ3b0R2MG01OFVFN2dIbitmSk9hOC9Zd2FuOEVLUmZqc29wRjgzZUNnbFgvU2ZyN09lYVJvUWZ2dDFDR3ZJRGNjSDVCQ3Z3MXNXSXpSR0MvNjZ0MFZUY0xaUVp0bTZQbEFhc2JPSjlpd1d0VW83YmlrdFRTSVB4blIyNGp4UDFaS2FxcSsyUmNYTTlPckJBbS9BQXM3aERKNWJObUdiK0tJZndDczhhM2puakJyT0ZlTWpIU0NkYktyKzJ1T0xmbk9kOWVpQThIdnZ3d3E1NFZiUDJPcXdrQjQ4WXRjNFlFT2lIMnZUWHFvZGFiZldFT3pzbzRxeGRicUQ1TDZ0YnROUEVDcWJobkE3MDhEWkg0UU9KVVhxU2NtVWxrczdPdDZGQnVadzNuMm1FYmFVWDdrRHp4SE9PUWs4bktXTXpBenU2Wlo4c09GdzRSSys2UGN1WG85dEI0U2JNejU4QXBmS0RYZjNzempOSUliR3BENVRLVFJ4R2tFTUxqTGwrSzN3bFdYQnNDVXhJRFUramJPaXlzRVNxQXkxTUdVSnBYZ3diVFd6Tk9WRXppSVhackorVkl6dGwxUFVCeFRTbzBkd24yYk9tZkRSUEQzVFJUR2xmYkNKdk85S3Z1aEwxaE1IaEI5d1B1UFJMR0hjZE9XRzJ4YzBVKzViUXRBSlQwblJUZXdYTDFwZ2syK3JaQWRlV216M2p4QXFmTlFRZHpUbGJGOHVKNWVjRUlXdlRrZXZBSHB3ejd3NzhRdWpsRC9McjQ5MWJEOC8xdmhNMnlyVVFScldYTlFZNGZHaWxmY3RNV1lqTDcyVUwvcVM5ZWlBOEVtTjg4bmJOZG91citQQmJiQWpPaklhNGlCaGZGZzZyeGVLZEVHY0w2cDNFV1IxUXEyUWtoczJEcm5rUm5tTjl0RzJFQXFtZ1B3NmhvTDdPemE3QiszU0NyUjl0UmZ0a28rTHNmMkYvbWtUbmROMkxtenVNY0tUdWovbVgyKzRWYTNraTE2K25uSlkrUzdNZWZwa2lkeHduVis0d2tYSDhUS25YMHRzWXpZcDI5RE9Pb1NXMW5mN25UaDJha1lpV21jSk91VGlkU2FxRVNyVFlwd2pKSk5WR1FyK3JMSTdXc3FlckhXNktwL29NMnBLdVY3VDFRWTlnanFsWnA0MS9XZktwbDU2RlYvMGt2WFFGUnllUTgzeGFUdTVFOHA1ZE5QM2RVRjM0aWh5STNHU3BlQ3N5d1NoMjJaSmRXdG85d2luaHFpZmI3VlJ2Z2t0eHAxM3Z5anJTMEVqdnJSZlo2MnV5cWRkU1dhV1lsd1RQQXRKWjJvWjNqL1NnaS9taSs2dnB6ZXNmQWNXTkEwbjh4Vnl3OTBHVkZHdVpqVFhFUXkrNkdmTEdMTUxMNTIzZjVFME9teFZqRG9PdVJpSDkxUktVK3Z0b0N0SDdUZ212Qkx2dEZYV0xXMTVIOUdUZFZ3OG93NElsUkxlSEVDTjl5bTFlOUswSStDYm5oZ3Y0WXUrYUQySGFRSjgwWERxT3pTR0FWNCs0eUNxQnhyc0pBWDZaVElvWDM2UW52emhoenpNZkZXMmRaVkxPSmZvMHpiY2U1T3Z3WE1GYVo4MW1PbmxUVlhwRFpzUU51b1lXdmVrZXRLYjUrNkpPT3NnWCtOVG03SDQ5ZlVUbHgrV0x1V0w3cXhuT0ZoNEJ4cG1KeDBwMmdEekEvQlVBUnVTNnBoUitwVXNZN01NYm9BSHg1eE5zU1ZmVlpjWVN3cUNLcnFvbjd6TSs4ZWNDa2VTNG5tM3JJTnVhV3ZWTm5NUkkxSVJweFRxeDhQWlVaMEJyL1VFZHVvM0IzaE52bWdaZnM5Z1FQajh2SU94ZDJrbmRpcjNhd3ZKNkJMdm9VdU9mRldOWUIwTFIxT1FKb1V5U0tiOUlsT0J4NzRxMStBREMyRzZyT2RtRmRKY0Q4QmtmdWFsQStCZGpPT3pQOXVVaEdVRVgvVHdoWnNVZHV3UnI4d051WEt1ckNpeExCZ3BRSTBtRGJKcjlkSXFVdVYrOTJuZ2tKWjd4ZHVDazJ5WktiZldySDFWQmlUZzlWZHpzZ1JqVzNDVlhDdkF3RGQrYzF6OWRXdzkrQis4TUpML2VZMTVaUS9IcXZUd1Zkc1puNVdRc2dSUm5NYVdhZWN1M2pGdk1CRW1nZytGSkZac25TbDB6akI5T3FQWWFCRDdxbW9WeUltRnZ6aTQxdXNlc1YwanVsYUFSOWRmUjE1WHp2OXNFcnVSRHlrMW5iK1FhTFU2N1Q4ODVHVGxzNllnY1krVWlNYTI1TS9wd0dyYkNmemt2UjNlMGpqdHVhRnRud3VhZ0hUU2I1eTdib0JIMTE5SFhodndQNDg3akpMc0xKNFhuVWtIWDVzTGJTNjFkcGlBWFJvWlNDckZKK0VqcGVVM3B1VmZpdG5nWU5vNlBKckFpZ0trdG13anlRZFpwZnEzMG1tdHVsYUF4OVpmeDE1WHp2K2N5ZXVpQkZVczl6cThLcStYQjlhNFBWdnBoM0dWNEUzeThIRU5Kck41NUgxWDJwOFZ5cVNLd1Z1c0pES3pYT1p6cGxXZHpCVUZLOWUrQjQrdXY0Njh4dkkvYjV4dFNBa0JIUWFQdnRxV3psbFZ2RU94UGJ1aUU2K2oycHZqY0tzYnZJN3R4blJFcmdmSDdMZFhxanEwSW9rS3pnYTE0R3pRMjNTU2JDUXZPNnIrT3I3U01Jci9lZk9ra3FTZE1uajltQngyRFJzaVkyOVVqNitxSzlacnNzQ0thcHRSNkhLVVJkd1VZZVVXQTJrUHpWS1FPOGt1Mm5VM0FuaHMvWFdrQngzRi83d0p0Q1RUVElLZnR0aHVlMXR5OXh2TllMWS96bzVLU2JJdUtiWHBiRWRTeWVSeVlkQUl3S1kybmV5b2MzK2sxWFVhdWZZZ2EzVDlkYU1VeC9yOHoxczEwSVRrbklPMGt1b010K1RCOGpLMGxwYXlxcWpzSjJxdFhBWXdCVTkzMnppbmltZ21kNm1UUkRuUWZyODhxMzZOQUkrdHYyNEU4UHI4enh0YXNCcXgwK3hISDlIaGxyd3N4eE5VZktPSFFhWkJJVE5mMHVjY2o4R1hpVm1YQXVQRUFLU2ROLzRHTEhocy9YV2o5MmROL3VldE51Qk1uVlIrWFdEYzI1SkxqbzVNZzVJWklxMjI2dG1Dc2lwMnpabGlMMjEzWXJUbEwyaGNGanBDZHV5aW0zTTcvZUIxNnEvYmxRc3Y1WC9lc0RSYnRKZWFiTElvc1d5M3ljYXZ3TGh0eGRXemJNbUhpQlRpVmpKbzZsQ0xqWFpzaTdwOVBFUG5zcTZYNndkNGJQMTFpMHJENWZ6UG0vMEE2YnJySXNsbGVuWnMwbENKbFU0YWJha1I1OWVuWktyS2UzQlppaGJUeGx5WjJ6bDErZzB3dmdtQTE2Ni9iaHdEcmNuLzdEZHowZVdadUp2ZlNFU3VnNk56WnNveDNaMDRGSXh6MG1Vak13Vk9PVlRxMUNRMEFoZGJCR1ZkakcvQ2dzZlVYN2VzSmwzSy83eXRXSFJ2NjgzcHJhVy84aURPQ3FXTExocGxqRFkxWnB6Szc1UWlhWm9PVHBMS2w2MGF1SFMvOTdvQlhydit1bVU5K0ZMKzUrTnRMRmdqcVZMQ2RibWo3cFk1elBDUExPSE5Dd1hHT2NMcXVPaGk4Q21DV3ZiY3VPNzNYbU1VUGFiK3VnM0E2L0EvNzhCd2UwYmNTMit0Z0huNEo1cHlTMldiT2NrMEY1MVZxM0xjamhMdlo2N3AxQUJiYUwySDY3Ymc3OEJmaktpL2pyMytUL0FCVjNpbExtTlhUSTJTcHZ4V0J0dDYvWi8vRDB6L0ZYYUdiU0JneWx6bHNFR3ArNS8veHJkNC9hZTRkOERVVWpsc2xmSVlTM3QwNkhacHZmUXR2djBON0FIV3F0alAycFcwOFFEL0ZMeS8vZGEzOHZvOFBObEtIZjV5MzdEeGRmZS9vajRrVklnRnEza29MUmVTUjc2Vy9ieC8vbjlrOGpvblp4eldUQU5Wd0VuaURzZzg3c09TZC96Ny8vUHZNcDNqUWlwdEdWV0ZYMmNhZXp6QVh3Zmd0ellVdmJyMGlvenMzMmMzVWdlN3ZhckgrQ05FNmN2RVltemJQWjloTWFZRGRqSzRWMmllY2Y2RWNFYmRVRFZVQVJkYTJLek8vSnRDdURiTlFCL2lUZUwwRUcxSlNPMWpiWFMrbkx4dFBNRFB3MWZoNStFUHJnU0VLRS84R3J5NUE3M3VpODdBbXh3ZGF0eU1FQkNQTk9DU0tVZVJaMlA2TXliNU1SdmdDSG1BOXl3c01pZlUrQVlYY0I2WGE1R2liVUM1VFN5ZXJ4eWgwajZRZ0xWcGR5aGZBclJUVExxUWp3ZTRIT0Q5czkyRDRBcDU0b2RYQVBCV0xBd0IwMmlnRzVLa2MrcGlONGx2T0RJRkdBWmdUK0VPNFNpMXM3ZmpTUjd2Y1FFVFVrUm05TytNWHlvOU9ZaGZlNHh0OVNUUTJwY1pSTGF5Q1Y5MGI0RDNqUjBEWUFmeXhKK2V5d2cySUw3TlRNWG5hN1MvUnBRNjNKaFdFTThVNDFaeVFHandzVlMwUUJyRUtMdTh4d1pzYmk0d0xjQ1QrT0dpZFBJT0NlMVBpU2M5UXQrZ28rdllxQjdjRytCOWQ4Y0FEK1dKUHowQW0yZ3hYZ1U5SW5lT3FEcEFBWE9zT2x0VnVNenBkYWtKWHJkUEN6WGlOVlVwQ2VPb3M1Y3hucFFUMzlHK1hWTGhzMW9zUVZ2SktQWnlOcThIRHdkNGQ3cE5EdVdKUHhWWDdNU3pxVURVNmdmYWRLaU5sVUZUekxlRkhIRGx6TzRrcGE3YWlLaEJQR0t3T3F4c0JBbVlrT0lwaXB5WGNRU1BsUlRmK1RpaTBVM0VKR2Fac0RFUjJxb0IzaDJodTBxZStOTndVb29ZVTh5NW1JTGJKZTZPdVgrMkZUS3k3YmllVERBZW1hUXlRMENQdGhsalNXTyt4bUZESVlpRVNqTTV4S2Q2SWs1bHZMcTVHclEzYUNNTHZtQ0E5d293THVXSmI5eEY1OWhWVlA2TzBDckJpM1pqWlNOT3ZSeStJNmtsTlZSSllSQmFFemROK2ltaVVYUThpVkY4ZnNwK1c0Slh3N1dJU1c3ZkRoN2xwdFdrQ3daNGQ3UVRYeUJQZkpNWUs3U2lqakZwcEdubElWSkJKQllqN2VVd3RpUDFJQlhHSTFYQ3NqTnBiakVOVnBTQUoyaHEyTFR5d0VseTNoVVlhenQzMUo4dzIrYWlMeDNnM2ZvaFhpeFBmT01ZbTZ6Q0dzOUxWbzlNb1czTUNKRTdSNXUvV3NPSWpycUJvSFVPMGJKRTl2eEJwYmhzZDMrTmI0L3Z0UENaNG9aWUNpdE5lWXVDLzhVRHZEdnkwcXZraVcvY2dxTnFSeXpxU1phL3MwbXFOR2p0S09vVG0xNHpacFVhdWlRZ1ZmcXRRaVpqcTdRMjdKTmFTSzVFeFJjckdDWE8xRkpZaDZqUjZDRnFLN2JaZFFaNHQ4ZzByU2xQZlAxUmRCdHFhYTlkaXF0ekprUTlkdVNyeWkyYnJRWGJ4RHdiUlVwRk1CSGpSajgrTnQ3R0RLZ3ZwaDlva1c3TFg0N2d1MFNwR25uRlExUzFsWWxkT3NDN2hZdGVSNTc0WnVLczdFaTFsQnNmZHo3SVpveHp6Q1ZtbVZxYVN5U3pRYkJWQVdEZWsrTjRqaDlFLzRWcVpySmpQd2l2OUJDMVhjdk9XZ084Mjc1Q1Z5QlB2QXRUVmxESmZaa2FaR1U3TnBxQm9nQWoveEVIa2VBdUppaFdZQ3hHTjZlOCs5SnRTZWdGWEYxVHJoaExHUDFmYWszcGViZ1B6MTkyLzhnQjRkLzZXVDcrR2RZbnBIN2hIL0RKenpGaVlQbi92alcwU2dOcFROdVBJWm9BRVp2OHRsR3c0K1JMeHkrWmpuS2E1TmRGb0M3VWFXMGFkdW9Zc2U2K2JYZzFETGc2VWZSWXdtaEdFanFQdkY3NVU1NThTQU5yRWxLLytNZHBYdm1xQnBhWE9hL01UWmFhMURPY1NpTGF3OWowTk5Oc3QzYys2M2M3RUtUcGt2S0h6dTZiUGJQMFJrdUhBVmNiUlk4aWpQNDZNSWJRZWVUMW1oQSs1UFYvaW55RGRRaXBmOExUdk1YYnd2b0R5N0lydUROVlpLVGZWNENUU1JVWWR5YlVDbkdVN0tVVER4TGdDa25xVW01YUFXNi8xcDZlTXNPWXNwaEx6c0hyRTBZL1A1YlFlZHgxRi80eVBIbk1CMy9JT29UVTkrQkw4UGh0anVGS0JwWlhuWU5KeFR1disyWHFvbEtSMlVRZ0hoUzVub3Z1eFZ5U0poQk5SRjNTb0tLMVhaYmJYalZ3V055T2pscVdKanJXSkl5K1A1YlFlZHlsZE5TY1ArSFo2MXhLU0szanlyeitOaUhHMWhjT0xMLytQK1BERjJnT2tla0tHaU5XS2dKKzhaL3g4SXY0RGRRSHpjcFp5RjR2MTlJMjd3OS95UEdERlF2bUVwS3Rxdi9UTGlXTWZuNHNvZk1tOWVBSDhBbzB6emg3aDRzSnFZdHhaZDUvRDdoa1lQbmVEemw1aWRsek5IY0lCMGpWbFErOFVMencvbmM1L29qemwyanVFMGFwRDdMUm5KeGUwNGRNejJpT0NGTnRHRnBUdVhBNUFoY1RSbzhtZE40a3ozMG5WakVDNFlUWlF5NGdwQzdHbFRscmVQS2hHc0tLZ2VYcENZZU8wTUFkL0dIN3lLUVVsWFBMT2FzT0gzRm5TcGhqSHVEdkV1NGdCOGc2Nm9OYnRyNmVNYkZJQTRmSUJKa2dheW9Ycml3MlhFRFFQSnJRZVJPQWxZNmFlWU9jTWYrSVZZVFUzWEZsWnVmTUhpbkd5d2FXM1lMcE9iVkJBc2JqRjRRSk1zVlVTYXlqazR2b1BzSEpPUWZQV0RoQ2dEbm1EbDZYSVJlckQyNEhzR3R3ODZSTUhPTHZWU0hyS0JkZVZFMjZnS0I1TktIemFJd0xPbXJxQldKWVpETGhBU0cxNmMwVG4rQ2RSaFdEZ1dYbnFSWlVUblBJSHVNSlRmTFZwa29ZeTVDenlsSFZUR1pNVHdrR0FvMkhCbGtRcGxySlg2VSt1RjF3WnoydXdTMVNRMTJJcVdhUHVPNGJhWmFFRkJkdWtrc0pta2NUT20rWUpTdm9xUEZ6eEZBL1lVaEl2V3hjbVNkUFdUV3diQUtWcDZyeFR0UEZVWmZLSXdwem00SW9NZmFZUUxXZ21sRzVGTUUyZ2RCZ20rSjdKK3J0Uy9YQmJhVkxzUjdicFBRbnBNRmxvMmRvV2FWY2VIazkrTWt5Z3VaTkNKMUhlK2t1SFRXeVFBek5NNVlTVWcvR2xUazladW5Bc2cxcUVMVk9oVVNBSzBMQUJJSkhMS2JxYUViSFpMTDFWQTNWZ3FvaU9LWFlpUytIUnlhRUtnc2ZJcVg2NEhZV2JMUlh5L3FXb3lsSVY5Z3VkTDFPV0JOZ0JnVE5teEE2YjR0eERUNGdpM1JpN3hGU0x4dFhwbW1ZbnpBY1dEWmdZOGQ1MDNMRm9nejVzYm9uRGdrS2N4R3NXc0UxT0krcmNRdGxnQkJDU09LRDFtdHFZcElVOGNUdkJtQVQweVplK3pVemVZOTJmWWpUdEdpcFhMaHVSMGVQb0hrMG9mTldCWCtsbzhaN3BBWkRrOG1FdzVMN2RWeVpab0UvcFRld2JJNlNOYmlBTDV4ZXlnVzR4UFJ1TENHYmhjTzRSSWVUTUZZSEVKa1l5RU85SG1KZlhNREVqL0xhSDc4MXdISFpFdHFTUS82OVVuR3B6SDdMS0lBWkVEU1BKblRlc0pUVWErcndUZXBJOWRMSkVhd1lWK1prUm45ZytRaXJEOHZGOE1xMGpGUTI5anM2a0NTM0UxK2paSWhnUE5hbkhkSEZxRnZQSkxIcUZ3UXFiSUE0amhEeGNOc09DQ1FMRG9tYUwvZHI1bHlKYUpVNkZ4UEZqTzNKT2gza1ZNY1JPbzh1K0Mram8wNUdqTUYzUDMvRnVETG41eDJNMDR4WFVMUHdhUzZoQllraStNck1kWkpTZ1BIbGNCN25DUjViSjlLcjVBQ1VuOWprNWtpdmRkOHRrOTVTT0dydHF1OWxyMkloSzY1WnRFbDdaS3JwN0RycXdaZlJVU04xZWw3KzdOSnhaYnl3T0M4bmVOS1RjaDV2c1RFTU5zb0NDcUhCQ3FJUFJqSVBrbTBCanZGT0RHdHRvOTlyQ2wrZDN3bUhrVzBGUGRwWnRDN01NY1Z0R0ZRakpMWDViZFEyK3g5eXBkYzMxM3VqOHhsc3JmdUxnV1h6MWNSaFp2SllYMGlOVkJSY1ZjbUNYWnM2YUVmM1JRRjJXSS9UY0NiS21HVTNJT29ESkdEZER1YjAraFlja3Q2UGxHdTJCY3htaGJUZGova2xoY2NMR0pNY3FSak1KUDFqVzJFVHFMU1dKLzI5TUFvT1JsdUorNkxQZmZCWmJpNWdxaTVoNmNhdFFwbU9UNy9PRmY1VW9yUnBMekNxY01sdEJMaHdkMWFyZTNrenRyU3pYTzBMVWJYUlFjZExoL1JkU1orc3dSbTgxOVJFRHJ0cXpDNGVzNkd3NEpDS2xTbmpZVnBvMHhlcTMzUHJBRGJGTEwzUnVDbU9iVm1QTisyNGtmYStBb2pEdU00dW1LZTJRd0NmNkVOOTA2SHdqdWphaXREczVvMHMxeStrM2xnYlQyVzJpN0ZKZG53YkxYaEpVQnEvOWxpVGN0U21GQy8wT3FVaW5iMFFkZFRXYW10amJIUkZ1V0pKNk5wcVo4dk8zZlpKMzdEYisyR2thUFlMR0hzN1hUVGRpRlFKNjhTa1ZKRlZtWTZNY1I1VXljZmxOQ3NjY0hGYVY5Rk5iUjROdHRMeHc0cFE3d0pkMDY2WjBvaFZiemloYXhIVkV4ZC9heTA0b3hVS1d0K0FzZGlROU9VeVoya3J6TjE5SVpJd2FmU1RGZ0lCbk1WNzNBRGo3Vi9LOHUxTWFZMnNKcDJIV20wZjQxdHF3YWpFdmRIV09KczUxME1hQXFONGFvU2lQQ1h0TjJLU2k0NmRVeEhkYU1xdWFyODJPMXg1anFoREd2cW1vRTlMZnhjWTN6cUE3L3gzSEE2N3I5Wkc0TzZDdXh1MTIvK1RQK2VMUCtJK0hFcnFERENEVm1CRE80bGFydWpOZTd4OG9tMnJNdWcwTVgwckwxK0lXd2R3ZlIrcDFUTlR5Tm1WSjg1bGpXemJXdUd2OC9DN0hEL2l6amtITlpOWWxoWmNVT0tWektGVXhzeHhOL2theCs4elBXUFNGS3c4MHJKcjlUaXp5ajNvMWdFc2R3Z1dHb3hQZXpEZFoxVFNFTkUxZExkTnZ1S0wrSTg0bnhLZXNaZ3hYVkExVkExT2NMNDlkRmxwRlY1eUpNaHp5Q21OUSthNEJxdXNQSjJiQit4bzhWOXUzeDQ4VlZJRVBTL21jM0R2QWJYeW9ZcjZWZ0RmaDVkbzVoaEhPQ1hNcUJaVVBoV1liV1pFQ3dWSmxqTGdNVVdPQ0I0TVV1TWF4R05VUURWSTUwVFErUzNrRmdJY3UycUtrTlNIVm9NMFNIc2dvWnhQMmQ1SEg4Qjl3b09rNHg1YlBrS3RBSHVjWnNkeWtqeHVJcGJVclNJTGdyVDhHN0c1b0NXK0swOTkwbzdFM1Q2QWRXNFRpbEg1a0RqZHMrSDY0a1MwbXoyNGdydHdsekRIQkpxSThZSlFFeG90UHZvQzRKQnEwbEVqalFreUJaOG9IMkxuUnNRNEh1MVFzZ0RUSmJPOGZRRG5sbGl0a3h1VnNrb2lLYlJGOVZ3ek1EdnhIQWR3QjdtRDl5Q3BsaEhGRXlVV0h4M1d0d0NiU01NVENVQ2NFbVNHbGc0Z1RYa0hwWlhXUTdrcHpuSzNFbUNIaVhJbnFuZGtRanVuRzVreFRLRWVHeWU3ald6OWN5TVIybUdpRlExNUVOUkJUYkNwK0doODZ2QXlBU2RnbUpxMk1DNmhvQURRM0dvc1AwUUhibk1IanlCUXZRcWZoeS9CVWJlSGQ1V1kvRy85TEsvOEthOEpkN1VGZU5XRVp2elBiNDU4RG44REdMT2UzL3dHTC80eFArSFhsUnQrTTFQRTJpTGhSOHQrbGZneHN1aDdBZk8yQU9mK293V2hTWlJZUWJkNjIyaGJwS1dLdVUrWHV2TnpQME9zZVJEYSttT2JnREhKVVNjL3BLeDMxUWRLZmZRNU9JSnB0OEdXamxnVHdNYy93NU1QQ1IveWwxWEMyYTJZdXQ1NFN2T3RNZXY1NU9mNDVCT2F0OWFXRzI3cDJaVk9SUnZuRWsxaHFXTVZVbXFhN1MyWXR2bElwc3B1RjFwdDBzeXVaUzJOVjE0bVVpZENTZnpRemcrS3F2SVlDTWxqSXgyWUsyQU8zNGZYNEdXZHU1eGNJQWI4TXpUdytqL2x5V00rRHcvZ2pzNEdENmVoTmdBNDhrWC9BSTdYWE0vWEFONFdIcis5bnR5d3FvQ2FrQ3FtS1Awcm1RckpKRUVyRzJVcGcxSk9icjAxbEtReTRqc2tXYWxLWWZKL0VETE1wak5TSEZFVUFkZTJmbHRhRGdtck5hV1E5K0FBYjhJNXZLanozTDFuMUxyaUIvQlhrRy93d1I5eS9vUlg0TGxpb0hBNEx6UDJpbnpSeC9EV211dFJ3ZUZqZVAzdE5lU0dsYUUxRmRlME9TMTF5T3BtYklwMnUvakYxbjJSUlp2aUpNMHlCVDNJWmwySFdJbUtqUU94SXllVTMyNWIvcVd5VTlNb2oxbzA3dFMwRzdxSkRvR0hnNW04eWVDeE1vRUg4R1U0NXRuck5NODREMmwyOTdEUTl0MVlQN2praS83Um11dFJ3ZUVBNzcvSFdYT2gzSEN4a1JnbGREUWtBak5UTWwySWxvYzFxTjVKZkplZVRseVRSenhVUlRkbjFJeHYydUtqczEyQWJkRVdsQnRtVmRrMms3RkZ3ajA3UENaOVhBd1czZEcrOHhLek5GcjRFbndCWnB5OVF6aGgzakRYZWJCcFljcHVvNGZRNDR1K2ZEMWR3ZUVuSHpJN3YweHV1T0FMUlVWOHJYcEZ5ZlNUUVlraGQ3SUhtMDdqcHlobGtDbUkwQUxZcVBUcFV4WFMrejRqZ0RqMVBmbHZtejVlY3VJdHBJQnh5VEhwU1RHV2Q5ZzFBcGZEL2J2d1VoTDRuVDFFenFnWDdjeGZDY05tYjNtUEwvcWk5U3dUSEo0OW9qNVpMamNjYlRHM3BSbWxZaTZKQ0cwbVFyQXQxK2kyVVhUWjJkdjlJbFFwTjVuYU1ZdHZpYVhsVHJGcG9Nc2wzYk9BRkVhOHNxUGoyV0NNcngzWWp4OTlxRndPNTlBdy93Z3grSGxxTno4b1p2QTNleFJEdnVoTDFqTVFIUGFPSjArWHlBM2ZwMU9mTTNxT2JFVmRoeGp2eW54Tk1YUVY0K0dKeXZPRUZxZVFCYUliYk83aTYzcnB4Q2x0ZFpTaFBGeGtqTTJGUFZrbjNURytScDlwTzNsMlJ6RmVnR2Z4R0RISUFoOFN0ZVIwQzRIb3BYelJGNjFuaGVEdzZURk4wNUVidnE4TTNWS0twR2pqTzZyN25odWRURUdNdFlNOTJIVERhUjFGRE1YSjFlVGhzYktmeXd5b1d3cnpSU1hrYzUxZmxHM3ZJaWQ2MmgyOWJJY0ZiVEdoZlYrZmFhQitvaGo3ZFBOMEMyZTJsQzk2K1hvdUZCeWVuOUFzdW5MREpaOXo3TkV4aVVjME91b1lXNlVaa0l5eDJZVVIyejYvVGlSanlLTXg1R2JiakxIdkh1ZjdZbXRLZ2hmMzRMSmZ4NjNZZzh2cnZOMnpDN2xZMHgwdHZLZXpvNEhtR1lEVStHYWI2ZEZMK0tJNzYxbERjTmlmY2pMcnJyOUxXWkpjdEcxRmZVMXV3aG9RRTIyT2JqZGZrU3pZNjNDYlU1aHpzMjFXZVRkZEgyQmFMMTFHaTdsVmRseFAxbmt4cWhuS2hWWTZrblMzRVBnVkdnMUpwTjVjUC9oaXZ1ak9lbGhYY1BqOEhDL0x5STZNa3RlVmpsb2xCZE1tRjNhM0Ric3VBWWhMNDRkeHp0aFdTTjA2NXh4VWQ1NUxtZjB3UmJPWU9xSDA5L285V2JPMlZ0RmRhTWI0cUJndEZKb1QxU3FvTjh3UFhNb1hMYjNwMVBVRWh4Zm5uTHpHekJJMEt1N0Z4cktzTkpqLzhibi9IOGZQSVZPZDNyZnJrbFVCL0RPZU8rbmtnaGdTUHpybFB4bHVDTXRPbkRMNFltbDZkSzFyM3ZzZ014Z3RQT3JNRlVaYkVVYlRkSXppaTViZXE3Mkc0UEQwREtud2ptQlVMVVZGbXk4dCtrN2ZaM3BLYzBRNFVDNmpwVlJxUzlVbXY4Ynh3MzVmbFpWT1UxWDdxa2puaFpsc01iazI0cVE2SHo3UWN1TDZzREMwaUhIa2k5NlVoMlVkdm1nWm5qSXZFeHkyVGVKZE1EWk5TYmRaeUFIZS9ZZDF4c1FoSGlLempoN0d4UTR5cU1QYXl3UGtqTWFtdnFyWXBtTzdLbmFkK1pRQzVtc0N1QVBXVW94cnhWaHJHdjdhK0tMWEZoeU9OZFRNclo3a2UyM3FpTzQwWkpVeXpnWXlYNVh5TDBtVjdOaVV6RXM5bWp0Yk1OMGRFUnF3eUFKcGlnYWQwQjMvelJWN3M0UElmWFN1NllWL01LNytPclllL0p2ZkdNbi9QSEplMmZ5VWR0bkZyS1JOcFhWMFkyNTU5YVdQdC9HNEJsdmpUTXRYbFZJV0NuTnlBM1lRQkRtWUlvZEZ6NDFQdlhQU2E2cnE5bFdaYXdaNGRQMTE1SFhWL00vdG5Ga2tyQk9kemc2YVA0cElEK01ablRKMVN1dUI2aVpseWlveDRIVDJ5M1lCdGtVS1dvb2FjQlFVRFRwandhRHQ1cG9CSGwxL0hYbHR3UDg4N2xLS1h4TlVFeVBxcEdUeUE2OTlVcVkvbHQ5eUdkbFVLcmEwZkZXUyszNml5bFZXckF5ZDdVdzBDWk0wejd4S1RPZHV6bkxJakcySHg4Y0RQTGIrT3ZLNkJ2N24xRFljaTRDeFV1UnhyakJjMGJiNHZEM3JONVp6MzZudExiODNlVkpJQjhMaUl6Q21uNlNNUGpsWCt5TmxUanZJR2pzK1F6SFBmNjBBajYyL2pyekc4ajl2WU1GdG0xVm9SV0NKZG13N3o5TjB0K2M4Y3hacFBlSzRhVFJpY1MyNVFoclZ0VXA3VTU3OGNoazRxMDRXeDRZb1FTakZyeVVscGNRMUFieFovWFZNa25JVS8vT0dsN1E2ejlacHhpMCszeUZoU2tqVURwbkNJVWhMV1ZYMjNLUStMOXZLdkZLSTBaV0ZRZ2tETHZCb3lsckhOVm1hdzEwendDUHJyNXRsb2RmbmY5NEVXblEwbEZSV3k4cFc5TGJrTHN5VVZEYzJOU1RIR0R0bkQxdU10Y2hqYkNlYjFtcHhGUDBZYmNDbGh6ZEx1NmxmTzhCajZxK2JkVDJzei8rOFNaQ1Y3Vkl4dHQwRFVuOUw3cjRjTFlXRFNYbnNlRXBPR0Z1dHkwcWJPVmxTN05OenM1Rk9HSlVxUXBsMlE2NC95QnBaZjkwc3hiRSsvL1BHZFowMkhTaXBDYm1ENk5JdG1RNExrNVhVckdwRE1raGJNbTJaVmhlTllWK1ZiVVdUY3Y5OSsyTnlYMVZvYWZTdUMrQU42cTliRklNdjVYL2VhZ05XWFp4RWE5SmpsTXdOV2IwMGFrR1VrU29lcHAxL3lSdXVxSEdiVW4zVWRCU1R4QlU2U0VWa2x6V1JVa1BuZFZ2dzJQcnJwanZ4T3Z6UG13SGMwaHBtcTgybnBpN0dScm84ZFhwMEtYblVRbWhaYlJMN05FVnAxdXVabU80NXZ1ektzSHJrdFMzR0xXWE9EVmp3K3ZYWExZeDRIZjdualJQZDBpM2FvQUdYNlcyOUduYVY1WWR5RGo5VEZrYWtqZTdHSFl6RG9PYmZkZEh0T1Nwb2kyU216SkhyQjNoTS9YVURERWJ4UDIvb29zc3pjUmxlaFdYVXZ6SHY0VHBCVmt0SHF3ZW5Gbzh1TFZteTRES0xhNWQzUnRMcm1yTTNhTUZyMTE4M0U0c2V3Zis4NVZXZWcxYzVhZzI3Nk5ack05SUpWTmNtTEV2RE5hVjYyYXErMTRJQU9HRnNCdDk3M1JhOFh2MTFZelh3TmZtZnQ3Smcyb1MrWE95b0M4L2N3emk2NkRobWdrMzhrVW1QMUNVaVlXT1gxYnBEMnpXWHQyRkNwN3VxODcwM0FQQWE5ZGZOZHNjUi9NL2JaTEl5b3VWeHFKZmVXdkc5SmUrSlZja0hROStDSTlOV3h6K2JsWC9LWVl2TzVuMnRBUC92cmxaNys4L2g5eSs5cWVCL0hudDk2N2U1bWV2WDEwckFMRFdLLy9GYUFUNU1YZEJYZFAwQy9CQWVzNzkyYzQwSCtBaUFwMWUxb0g4SGdIOTRnL0x0dHgxZ3A2M29wMWV5b00vQnZ3NS9HLzd4RmJxSlBjQ1hubUJpd0RQYi9ZS080Rlg0T2p5Q2IyODlkYjIvTm9xaWN3NGk3TjZUVnRvejh0TndESCs4eC9pNkFlN2xtYVFWRU56SkZiM0RpL0JGZUF3eitJczlTamVReVNwUHFiTEZsTm15ejQ3ejVhL0FGK0FZRnZEbUhxaWJTWFRFem9UNEdjM09BTGFxQVA0S1BGVUo2bisxeCtyR0FNNlpkNzhiZ0owYThRTjRHVTYxNHZ4d0Q5ZTFBbXk2Q2Nza05yY3pMeDFKSXA2SEU1VVpEL0RCSHJGcjJvTmxnRzRPZHYyMjZCb2RvcnlqR0o5cTJUL0FSM3ZRcnNPQ1MwY3RYWmkzcnVMbGhwRkRKWWw0SG1ZdGpRQ1A5cmhkbjRzdXlTTEtEdDZ3TGNDNTJoOHhQbGNqanUxZm4reWh1dzRMWnNBR1V1bzJiNEZ4MlV3UXU3N3VxUkhYR3RnOTJhTjN0UUNiRmV4YzB1azkzdmhUWGJjdDZ5N011bEx5Y29VbGp4OG5nRE1CZzF0dkpqQWF6cEVtT3R4bHpjbHZqMXZRZjFUeDdRbFBEcEdwcWd0ZFNLei9kOS9oZHkxdlRmRkhTbUM5ZEdEWmJMaWV6ejdBYzgwMUhpckdac1dqeWRmWnlQdkhYTC9ZOE1qemc4QnhUWml1d0t6NEViOHNCRTl6em5zem1qdkZ3SEtQSVdVbndocWZWUmNkNENrMEs2YXRlNDhtMW9PZnJYMy95T3R2QXNKOHpzUEFNODlzam5kZG11THVEUGpYOUJ1L0w3eDd4cE16Rms2bld0eVFmUGcyNzhHbjRBZWt6MlpnT21VOWVKMzdSMTR2d0UvQkw4RzNhaWJDaVdNV1dEUTBadGtQTW5sY0dlQXUvQWcrOFp5ZWNVNUJQdXkySUxEK3NRcXlaaEFLbW43WFpkK2pJTVROOWVCTDd4OTV4VkxTWDRPbjhFY05sWERxbUJscVMxM2pHNExwbUdia0YvMENuT2kzSDhFVE9JWHptbm10YjBhMTZUenhqMXNVdlFDQmlYWkdEdG1CM0tBZWZQSDk0eGNVYS82dndSbjgwR09GeWpFWEZwYmE0QTFlOEtRZkZGKzI1OXR4NVhTNGVnWW44ZlFzTEdycUdySGJ6dHIrdUJ5VGFoV3VMMU5VR2JEcHNucndCZmVQUHdISElmOVg0Um5NNFoyQUJXZHhVQmxxUTJQd2h1RHhvUzB2dnFCMUp6UzBQNGgybkEvUWdUcnNKRm4rWTNBT2pzOUpGQzA3Q0dXWDFvTlgzVC95SE96Z0Rqd1BuMVBNM2c5Sms5bFpyTUVweG5sUG1CYmp5bzIrS0ZYUlU1MlRKTS8yQUxjWTU3UlV6ak9iYmpxeFZ3Kys0UDZSQU9mNThwY1ZzdzlEYWplM2h0cmlZcnBET29ucmUzQ3VkU2U2YmZrVEVnSEJIdURpeXU1TUNzYzdCSGhZRHg3ZVB4TGpxaWdYWnN3K2lqTUhGaHV3Qm10b1RQdE94T3JUdllKRG5DNzVkblViaGZ3dS9aVzlBZ1lkK3BlTDY4SEQrMGVtS3F1aVhIaFdqSmcvVXJrSll6dWlhTDNFOWFJL3l0ckN2QWQ0R2NZWk1Da1NReGZVZzN2M2o4YzRlOTBqNVpUUGR2bUpKR0huT0NJMm5IUzgwODFYMDEzcEh1QmxWMWdCMk1YMVlObVdMSHFxR04vVFdtRzB5NmNsSld0aHhOVWw0OHEzOEJpOHZ0TUt5enpwRmRTRGh4WjVXQkE1Wkx0OEp2Mzg5NURkdUJsZ2JQWUFqOEM0QjhoTzY4RkRrb2g1bHlkQzRGaVd2Qk9WcWpZZHFqaUx2OTJ0OHlQRGpyRGFpSGRVRDE1cWtTVVJTR21YSndPTVN4V0FYWXdyM3phQXVmSjY2bCs5NHZ2M0FPK3ZQY0Q3YXcvdy90b0R2TC8yQU8rdlBjRDdhdy93SHVEOXRRZDRmKzBCM2w5N2dQZlhIdUQ5dFFkNGYrMEIzbDk3Z0c4THdQOEcvQUw4Ty9BNU9DcTBZczJLSWR2L3FPSVhHLzRtdkZBTUYxNmdaRCsyWHZ1L0I4YXM1KzhiZmxsV3lnMHphTk81YmZYajZ2Zmhod0Q4Ni9BcTNOZlJTOXQ5V1BuaGZudkNJdy9DVDhHTGNGVE1ucG50ZEYvejlWK1BXYy92V29JSCtGTDNabnY1N1BpdGNkR1A0Ui9DMzRhdnc1ZmdSVlVJbkN3YnNuMXl5QThDOHptL0JIOE5Yb1huVkU2d1ZQamRlQ0kzOGtYLzMrQ3Q5ZGJ6MXBUbUhGUnUrSG00TzlDaDNjbHI5OW5lZ3hmd2orRVIvRFI4RVY2QjUrRHVRT25UZ1V3NXJua1krRmJOVTNnTlhoMG8vSllUdVdPdnlCZjlGdnpYNjYzSEgvSGVqTzhMd0FsOEhsNVlMVGQ4cTdzcUEzd2JqdUV4ZkFGZWdRZHdmeURvU2tXWThzd3pFZjZvNFF5ZXdlZmcrY0hOYnFNUXJ1U0wvdS9XV2MrRTVnN3ZubkVYZ0RtY0RlU0diL0Y0Y0JjQ2dUK0dHUnpEVTNoWllidXJBdDlURXRIZ2JNNkpveEorNk5NenpUY2Y2YzJieWN2MitLSy9mK2w2TEJ6dzVJd2ZxWkpoQTNNNDcycFdUL2FqS3huanY0QUZuTUVwbkJUUE5ENnMySjdxSGJQQXFjTUs3NFQybVo0VkdCOXVKQTQ2NUl0Ky9lTDFXS2hZT0Q3eEhPa3IxYWpLN2QwQzQra2U0SHk5cVhad3BnTHIrWm5tL3VORnc4eFFPU3k4SDlJempVcmQ5K0JJZmVuWWF5bGY5RnNYcjhmQkFhZG5QSUVEbmE4SUJjd2x4bnVBMC9XdjZHQVdQZDdkRElLak1kU1d1ZUFzQmo0TTdUT2QwNnFCYndEd0tyN29sZXV4TU9FY1R1RVpUSFd2RFlVTzdhSHFBZTBCYnErSEVGUnpPejdXVm9URFFrVmRzN0E0c0lJeGZDUWRDZWZGUm9JT0YvTkZMMW1QYWIvbnZPYWtTTC9RMWFGdE5wVWIvbkZPVlg2Z3p5Zy8xbklTeURmVWhzb2tJemFCUjlLeG04MHM1bUsrNlA1NmlsMWpYaWM3bmhReHN4U20zT3dCSGw0ZkZkTHFpNjRuRFFadnFFMmF0N2NXQXAvSVZ2ck42L0JGTDFtUGhZckdNQmZPaTRQeWp1U0dmNndCQmg3cC9GWlRnaENOV0dnTXpsQmJyTkpvUEpYMm1XNW13WmZ5UmZmWG83T0ZpNXBaY1M0cVpVcmxWaXB0clh0dytHUW95aERQUytBTmpjR0JOUmlMQ1FEUFpQTUh1aVpmZEZwUFNUY1F3d0tZZFJOcXBram03QUZlZVQwcEp6QUxnbzdnOFlZR3JNSFMwaW9jeStZVG0ydnlSVXZ2cFhDSXBRNXBlNjY2VEpyY3lnblNjVWYvcDBORHMvaUFJL25xREhDOFRtUVQ4eDNORjkxbDc2b0RkUUd3dTYxWjZFMEFCdjd1TzFkYmYvMzdabHYrWncvUGJoOGYxczRBdnVyNjY1Ny8rWVlCdnVyNjY1Ny8rWVlCdnVyNjY1Ny8rWVlCdnVyNjY1Ny8rYVlCdnVMNjY1Ny8rVk1BOEZYV1gvZjh6emNOOEJYWFgvZjh6emNOTUZkYmY5M3pQMzhLTFBpSzY2OTcvdWVidHVBcnJyL3UrWjl2R21DdXNQNjY1My8rMUZqd1ZkWmY5L3pQTjdvSFgzMzlkYy8vZk5NdStpcnJyM3YrNTArQmkrWnE2Njk3L3VlYkEvano4UHVkZjlodC9mV3Y1MTdKL1hVekFQOEMvQkFlWDlXQ0RyVXBaMy9kRU1CeGdQY2ZidFRWdnNZVjVZbjMydTAzQjNBYzRQM2I4SSt2eE5CS2VlTDlkUk1BbHdPODM5NTlxR083OHNUNzY5b0I3ZzN3L3ZHVllGektFKyt2NndWNE9NRDdGN3Rja0ZrbVQ3eS9yaEhncFFPOGIrNFk0Nlh5eFB2cnVnQmVOY0I3QlJpWDhzVDc2N29Bdm1DQTl3b0FIc29UNzYrckJKakxCbmgzdHhPdmtpZmVYMWRzd1pjTzhHNk43c1h5eFB2cjZpMzQwZ0hlM1RucVZmTEUrK3VLQWI1MGdIY1hMbnJYOHNSN2dOZFBScXd6d0x1N1kvRk81WW4zQUs5alhDTUdlSGRneER1Vko3NVZBSThsalA3UEFiMy9SZmpjWmZlUEhCQis3OWRwZnBIMUNhbk4zMGQrbVQxaDlHcUF4eEpHTTVMUWVlUTErVGIrRVFKckVsTGIzOFZIUTk0VFJxOTAwYU1JbzhjU09vKzhEcDhRZnNCOHpwcUUxTk8zT0k5WnJqMWg5RVY3OFBxRTBXTUpuVWRlVTZFK0pqeWsvaGJyRUZJZmVXYnZJZDhIOW9UUkZ3ZFpheEpHdnppVzBIbjBncVlCL3d5WjBQd1JseEpTVCtCT3c5bTc3QW1qMTRpaTF5R00vdHhZUXVkTjBxRHpHZTRFcWZBLzVHSkNhZ3NIY1BhRVBXSDBlc2VrU3dtalJ4TTZiNUpFY1o0d3c1MGlsdkFPRnhCU3g0eUxXK0EvWVU4WXZmWTUrQUxDNk5HRXpodG15Wm9GWm9hcndCTGVaeFVodFk0cmMzYktuakI2VEtKakZVSHpKb1RPb3pGMllCcHNqY3l4RGd6aFExWVJVc2U4K0o0d2Vud21heWxCODJoQzV3MHpvUlhVTlhhUkJtU01RVXFpV1NXa0xzYVZxYy9aRTBhUFRGVXVKV2dlVGVpOFNmTFpRZU14TmFaU0l6YklJNGFFMU5tcjEzUDJoTkhqYzlFOWd1WU5DWjAzMllsTndFU01MY1ppTFFIa0U0YUUxQkZnMHlBUjR6MWg5QWlBR1JBMGp5WjAzdHlJeFdNYWpNUFdCSXN4WUpDbmxJVFU1U2hpSFlkWjk0VFI0d0NtU3hnOWp0QjVLeVBHWXp5bUFZZXhXRU13QVBJc0FkWWRWNmFPYm1OUEdEMGFZTG9FemFNSm5UYzBZZ3MrWUR3MEdBdHF4QmprdVAzOGJNUldDSG43M3hOR2p6NzVQNzNXZW5DRUpuaHd5VmUzQUVlOFR0S2RKY1loQmw5N3d1aE5BT2JLNjZsdkQvOUo5TlM3NXYxN3d1aXRBTjVmZTREMzF4N2cvYlVIZUgvdEFkNWZlNEQzQU8rdlBjRDdhdy93L3RvRHZMLzJBTyt2UGNEN2F3L3cvdG9EdkFkNGYvMjRBQnpaOG8rS0xzU0xTK1B2L1RxVGIzUDRoS2xRclRHaCtmYklCVDBBeHF6bm5iK0wvVjJtYjNIa041TWIvbkVIZUs3ZDRJY0RsZDZsbURXL2lIOUUrQUgxTWRPdy9KbHUyVDF4Tm1ZOThzdjR3SG5EN0QzdU5IdTU0V1V1T3NCVGJRdXZCc1BUL1Vmek54R1l6d2tQOGMrWXozQytyL2k2RGN5UkwvclordXRSd1dINVBtZnZjdllFdDlqTERTL2JnMC9CNjREV0tyUU04QUw4RlB3UzliZVFDZTZFTUtOWllKb2wzN2pCTXkzNW90ZGF6MEJ3MkgvQzJTbWM3K1dHQjBIV0RFTEJtT0J5QTNyNVFPTm80VitEcHpSL2hGUzRVOHdNVzFQWE5CNFRPcVl6OXVyeFJWKytudFdDdy9VNTlUeTllYmRXYnJnZlJTOUFZS0tONjNab2taVnlncjhHWi9nZkloWlhJWFBzQWxOalBPTEJieTVjMWVPTHZtUTlsd2tPeTV4NlFWMWo1VFlxcFMwNUp0VWdVSFVwNXRvSEdzVmZuNE5YNFJuTUNlK0F4VHB3bUFwVFl4cU14d2ZDZUpHanBYelJGNjFuYmNIaFVCUHFXemU5c3Z3Y0hKK1M2TlBzY0tyRWp1Zzc4RHg4TGozVDhENFl4R0lkeG1KY3doaTM0ZnpaVXI3b2xldlpDdzV2a09ob0NscTV6QlBaQW55Z0QvVGw5RXpEaDZrbDNWaHNIWWNERWIraEN0SlN2dWlWNjlrTERtK1d5Y3JPVEFySG1CNS9WWXlQNmpPVmp3Z0dhd2syelFPYVRjYzFMK2FMWHJLZXZlRHdacWxLcnc4VTlZMXA2NnVLOGRFemRZd0JlVVFBWTdEYnlZTmV6QmZkV1E5N3dlRXRBS1lRZzJ4SklrdXZlQVQzZFllTEdIK1NocldOd1pnTjBiMllMN3F6bnIzZzhKWUFvNWJRQnppUGp4N0JQWjBkOVJDUXA0VVpibkZkekJkZG9yNFhITjRLWU1yQjJxSEZSSXp6Y0xBSFFaNXRoZTVvdnVpOTRQQ1dBUGVmYVlueElkelJ3ZEhDYnVSNEIrdGJpeTk2THppOEU0RDd6N1MwbUVQZCtlcU8zY1Q1M1owWThTVjgwWHZCNFowQURKaS9mN1gxMTNmKzdwNy8rVVlCdnVyNjY1Ny8rWVlCdnVyNjY1Ny8rYVlCdnVMNjY1Ny8rYVlCdnVMNjY1Ny8rYVlCdnVMNjY1Ny8rYVlCdnVMNjY1Ny8rVk1BOEZYV1gvZjh6NThPZ0sreS9ycm5mNzVSZ0xuYSt1dWUvL2xUQS9DVjFWLzMvTTgzN2FLdnZ2NjY1MysrVVF2bWF1dXZlLzduVHdmQVYxTi8zZk0vZnpyMjRDdXV2Kzc1bno4RkZueGw5ZGM5Ly9NT3IvOC9nbGl4d1J1VWZNNEFBQUFBU1VWT1JLNUNZSUk9XCI7XHJcbiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFSUFBQUFoQ0FBQUFBQklYeUxBQUFBQU9FbEVRVlJJeDJOZ0dBV2pZQlNNZ2xFd0VJQ1JFWVJnRkJaQnFEQ1NMQTJNR1BVSVZRRVRFOWlOVUFxTFI1Z0llb1FLUmd3WGp3QUFHbjRBdGFGZVlMRUFBQUFBU1VWT1JLNUNZSUk9XCI7XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5pbXBvcnQgYXJlYUltYWdlIGZyb20gXCIuL2ltYWdlcy9zbWFhL2FyZWFJbWFnZS5qc1wiO1xyXG5pbXBvcnQgc2VhcmNoSW1hZ2UgZnJvbSBcIi4vaW1hZ2VzL3NtYWEvc2VhcmNoSW1hZ2UuanNcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCIjZGVmaW5lIHNhbXBsZUxldmVsWmVyb09mZnNldCh0LCBjb29yZCwgb2Zmc2V0KSB0ZXh0dXJlMkQodCwgY29vcmQgKyBmbG9hdChvZmZzZXQpICogdGV4ZWxTaXplLCAwLjApXFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdEFyZWE7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdFNlYXJjaDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxudmFyeWluZyB2ZWM0IHZPZmZzZXRbM107XFxyXFxudmFyeWluZyB2ZWMyIHZQaXhDb29yZDtcXHJcXG5cXHJcXG52ZWMyIHJvdW5kKHZlYzIgeCkge1xcclxcblxcclxcblxcdHJldHVybiBzaWduKHgpICogZmxvb3IoYWJzKHgpICsgMC41KTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgc2VhcmNoTGVuZ3RoKHZlYzIgZSwgZmxvYXQgYmlhcywgZmxvYXQgc2NhbGUpIHtcXHJcXG5cXHJcXG5cXHQvLyBOb3QgcmVxdWlyZWQgaWYgdFNlYXJjaCBhY2Nlc3NlcyBhcmUgc2V0IHRvIHBvaW50LlxcclxcblxcdC8vIGNvbnN0IHZlYzIgU0VBUkNIX1RFWF9QSVhFTF9TSVpFID0gMS4wIC8gdmVjMig2Ni4wLCAzMy4wKTtcXHJcXG5cXHQvLyBlID0gdmVjMihiaWFzLCAwLjApICsgMC41ICogU0VBUkNIX1RFWF9QSVhFTF9TSVpFICsgZSAqIHZlYzIoc2NhbGUsIDEuMCkgKiB2ZWMyKDY0LjAsIDMyLjApICogU0VBUkNIX1RFWF9QSVhFTF9TSVpFO1xcclxcblxcclxcblxcdGUuciA9IGJpYXMgKyBlLnIgKiBzY2FsZTtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gMjU1LjAgKiB0ZXh0dXJlMkQodFNlYXJjaCwgZSwgMC4wKS5yO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBzZWFyY2hYTGVmdCh2ZWMyIHRleENvb3JkLCBmbG9hdCBlbmQpIHtcXHJcXG5cXHJcXG5cXHQvKiBAUFNFVURPX0dBVEhFUjRcXHJcXG5cXHQgKiBUaGlzIHRleENvb3JkIGhhcyBiZWVuIG9mZnNldCBieSAoLTAuMjUsIC0wLjEyNSkgaW4gdGhlIHZlcnRleCBzaGFkZXIgdG9cXHJcXG5cXHQgKiBzYW1wbGUgYmV0d2VlbiBlZGdlLCB0aHVzIGZldGNoaW5nIGZvdXIgZWRnZXMgaW4gYSByb3cuXFxyXFxuXFx0ICogU2FtcGxpbmcgd2l0aCBkaWZmZXJlbnQgb2Zmc2V0cyBpbiBlYWNoIGRpcmVjdGlvbiBhbGxvd3MgdG8gZGlzYW1iaWd1YXRlXFxyXFxuXFx0ICogd2hpY2ggZWRnZXMgYXJlIGFjdGl2ZSBmcm9tIHRoZSBmb3VyIGZldGNoZWQgb25lcy5cXHJcXG5cXHQgKi9cXHJcXG5cXHJcXG5cXHR2ZWMyIGUgPSB2ZWMyKDAuMCwgMS4wKTtcXHJcXG5cXHJcXG5cXHRmb3IoaW50IGkgPSAwOyBpIDwgU01BQV9NQVhfU0VBUkNIX1NURVBTX0lOVDsgKytpKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdGV4Q29vcmQsIDAuMCkucmc7XFxyXFxuXFx0XFx0dGV4Q29vcmQgLT0gdmVjMigyLjAsIDAuMCkgKiB0ZXhlbFNpemU7XFxyXFxuXFxyXFxuXFx0XFx0aWYoISh0ZXhDb29yZC54ID4gZW5kICYmIGUuZyA+IDAuODI4MSAmJiBlLnIgPT0gMC4wKSkgeyBicmVhazsgfVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBDb3JyZWN0IHRoZSBwcmV2aW91c2x5IGFwcGxpZWQgb2Zmc2V0ICgtMC4yNSwgLTAuMTI1KS5cXHJcXG5cXHR0ZXhDb29yZC54ICs9IDAuMjUgKiB0ZXhlbFNpemUueDtcXHJcXG5cXHJcXG5cXHQvLyBUaGUgc2VhcmNoZXMgYXJlIGJpYXNlZCBieSAxLCBzbyBhZGp1c3QgdGhlIGNvb3JkcyBhY2NvcmRpbmdseS5cXHJcXG5cXHR0ZXhDb29yZC54ICs9IHRleGVsU2l6ZS54O1xcclxcblxcclxcblxcdC8vIERpc2FtYmlndWF0ZSB0aGUgbGVuZ3RoIGFkZGVkIGJ5IHRoZSBsYXN0IHN0ZXAuXFxyXFxuXFx0dGV4Q29vcmQueCArPSAyLjAgKiB0ZXhlbFNpemUueDsgLy8gVW5kbyBsYXN0IHN0ZXAuXFxyXFxuXFx0dGV4Q29vcmQueCAtPSB0ZXhlbFNpemUueCAqIHNlYXJjaExlbmd0aChlLCAwLjAsIDAuNSk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIHRleENvb3JkLng7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbmZsb2F0IHNlYXJjaFhSaWdodCh2ZWMyIHRleENvb3JkLCBmbG9hdCBlbmQpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIGUgPSB2ZWMyKDAuMCwgMS4wKTtcXHJcXG5cXHJcXG5cXHRmb3IoaW50IGkgPSAwOyBpIDwgU01BQV9NQVhfU0VBUkNIX1NURVBTX0lOVDsgKytpKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdGV4Q29vcmQsIDAuMCkucmc7XFxyXFxuXFx0XFx0dGV4Q29vcmQgKz0gdmVjMigyLjAsIDAuMCkgKiB0ZXhlbFNpemU7XFxyXFxuXFxyXFxuXFx0XFx0aWYoISh0ZXhDb29yZC54IDwgZW5kICYmIGUuZyA+IDAuODI4MSAmJiBlLnIgPT0gMC4wKSkgeyBicmVhazsgfVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHR0ZXhDb29yZC54IC09IDAuMjUgKiB0ZXhlbFNpemUueDtcXHJcXG5cXHR0ZXhDb29yZC54IC09IHRleGVsU2l6ZS54O1xcclxcblxcdHRleENvb3JkLnggLT0gMi4wICogdGV4ZWxTaXplLng7XFxyXFxuXFx0dGV4Q29vcmQueCArPSB0ZXhlbFNpemUueCAqIHNlYXJjaExlbmd0aChlLCAwLjUsIDAuNSk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIHRleENvb3JkLng7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbmZsb2F0IHNlYXJjaFlVcCh2ZWMyIHRleENvb3JkLCBmbG9hdCBlbmQpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIGUgPSB2ZWMyKDEuMCwgMC4wKTtcXHJcXG5cXHJcXG5cXHRmb3IoaW50IGkgPSAwOyBpIDwgU01BQV9NQVhfU0VBUkNIX1NURVBTX0lOVDsgKytpKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdGV4Q29vcmQsIDAuMCkucmc7XFxyXFxuXFx0XFx0dGV4Q29vcmQgKz0gdmVjMigwLjAsIDIuMCkgKiB0ZXhlbFNpemU7IC8vIENoYW5nZWQgc2lnbi5cXHJcXG5cXHJcXG5cXHRcXHRpZighKHRleENvb3JkLnkgPiBlbmQgJiYgZS5yID4gMC44MjgxICYmIGUuZyA9PSAwLjApKSB7IGJyZWFrOyB9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdHRleENvb3JkLnkgLT0gMC4yNSAqIHRleGVsU2l6ZS55OyAvLyBDaGFuZ2VkIHNpZ24uXFxyXFxuXFx0dGV4Q29vcmQueSAtPSB0ZXhlbFNpemUueTsgLy8gQ2hhbmdlZCBzaWduLlxcclxcblxcdHRleENvb3JkLnkgLT0gMi4wICogdGV4ZWxTaXplLnk7IC8vIENoYW5nZWQgc2lnbi5cXHJcXG5cXHR0ZXhDb29yZC55ICs9IHRleGVsU2l6ZS55ICogc2VhcmNoTGVuZ3RoKGUuZ3IsIDAuMCwgMC41KTsgLy8gQ2hhbmdlZCBzaWduLlxcclxcblxcclxcblxcdHJldHVybiB0ZXhDb29yZC55O1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBzZWFyY2hZRG93bih2ZWMyIHRleENvb3JkLCBmbG9hdCBlbmQpIHtcXHJcXG5cXHJcXG5cXHR2ZWMyIGUgPSB2ZWMyKDEuMCwgMC4wKTtcXHJcXG5cXHJcXG5cXHRmb3IoaW50IGkgPSAwOyBpIDwgU01BQV9NQVhfU0VBUkNIX1NURVBTX0lOVDsgKytpICkge1xcclxcblxcclxcblxcdFxcdGUgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHRleENvb3JkLCAwLjApLnJnO1xcclxcblxcdFxcdHRleENvb3JkIC09IHZlYzIoMC4wLCAyLjApICogdGV4ZWxTaXplOyAvLyBDaGFuZ2VkIHNpZ24uXFxyXFxuXFxyXFxuXFx0XFx0aWYoISh0ZXhDb29yZC55IDwgZW5kICYmIGUuciA+IDAuODI4MSAmJiBlLmcgPT0gMC4wKSkgeyBicmVhazsgfVxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHR0ZXhDb29yZC55ICs9IDAuMjUgKiB0ZXhlbFNpemUueTsgLy8gQ2hhbmdlZCBzaWduLlxcclxcblxcdHRleENvb3JkLnkgKz0gdGV4ZWxTaXplLnk7IC8vIENoYW5nZWQgc2lnbi5cXHJcXG5cXHR0ZXhDb29yZC55ICs9IDIuMCAqIHRleGVsU2l6ZS55OyAvLyBDaGFuZ2VkIHNpZ24uXFxyXFxuXFx0dGV4Q29vcmQueSAtPSB0ZXhlbFNpemUueSAqIHNlYXJjaExlbmd0aChlLmdyLCAwLjUsIDAuNSk7IC8vIENoYW5nZWQgc2lnbi5cXHJcXG5cXHJcXG5cXHRyZXR1cm4gdGV4Q29vcmQueTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxudmVjMiBhcmVhKHZlYzIgZGlzdCwgZmxvYXQgZTEsIGZsb2F0IGUyLCBmbG9hdCBvZmZzZXQpIHtcXHJcXG5cXHJcXG5cXHQvLyBSb3VuZGluZyBwcmV2ZW50cyBwcmVjaXNpb24gZXJyb3JzIG9mIGJpbGluZWFyIGZpbHRlcmluZy5cXHJcXG5cXHR2ZWMyIHRleENvb3JkID0gU01BQV9BUkVBVEVYX01BWF9ESVNUQU5DRSAqIHJvdW5kKDQuMCAqIHZlYzIoZTEsIGUyKSkgKyBkaXN0O1xcclxcblxcclxcblxcdC8vIFNjYWxlIGFuZCBiaWFzIGZvciB0ZXhlbCBzcGFjZSB0cmFuc2xhdGlvbi5cXHJcXG5cXHR0ZXhDb29yZCA9IFNNQUFfQVJFQVRFWF9QSVhFTF9TSVpFICogdGV4Q29vcmQgKyAoMC41ICogU01BQV9BUkVBVEVYX1BJWEVMX1NJWkUpO1xcclxcblxcclxcblxcdC8vIE1vdmUgdG8gcHJvcGVyIHBsYWNlLCBhY2NvcmRpbmcgdG8gdGhlIHN1YnBpeGVsIG9mZnNldC5cXHJcXG5cXHR0ZXhDb29yZC55ICs9IFNNQUFfQVJFQVRFWF9TVUJURVhfU0laRSAqIG9mZnNldDtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gdGV4dHVyZTJEKHRBcmVhLCB0ZXhDb29yZCwgMC4wKS5yZztcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzQgd2VpZ2h0cyA9IHZlYzQoMC4wKTtcXHJcXG5cXHR2ZWM0IHN1YnNhbXBsZUluZGljZXMgPSB2ZWM0KDAuMCk7XFxyXFxuXFx0dmVjMiBlID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpLnJnO1xcclxcblxcclxcblxcdGlmKGUuZyA+IDAuMCkge1xcclxcblxcclxcblxcdFxcdC8vIEVkZ2UgYXQgbm9ydGguXFxyXFxuXFx0XFx0dmVjMiBkO1xcclxcblxcclxcblxcdFxcdC8vIEZpbmQgdGhlIGRpc3RhbmNlIHRvIHRoZSBsZWZ0LlxcclxcblxcdFxcdHZlYzIgY29vcmRzO1xcclxcblxcdFxcdGNvb3Jkcy54ID0gc2VhcmNoWExlZnQodk9mZnNldFswXS54eSwgdk9mZnNldFsyXS54KTtcXHJcXG5cXHRcXHRjb29yZHMueSA9IHZPZmZzZXRbMV0ueTsgLy8gdk9mZnNldFsxXS55ID0gdlV2LnkgLSAwLjI1ICogdGV4ZWxTaXplLnkgKEBDUk9TU0lOR19PRkZTRVQpXFxyXFxuXFx0XFx0ZC54ID0gY29vcmRzLng7XFxyXFxuXFxyXFxuXFx0XFx0LyogTm93IGZldGNoIHRoZSBsZWZ0IGNyb3NzaW5nIGVkZ2VzLCB0d28gYXQgYSB0aW1lIHVzaW5nIGJpbGluZWFyIGZpbHRlcmluZy5cXHJcXG5cXHRcXHRTYW1wbGluZyBhdCAtMC4yNSAoc2VlIEBDUk9TU0lOR19PRkZTRVQpIGVuYWJsZXMgdG8gZGlzY2VybiB3aGF0IHZhbHVlIGVhY2ggZWRnZSBoYXMuICovXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZTEgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIGNvb3JkcywgMC4wKS5yO1xcclxcblxcclxcblxcdFxcdC8vIEZpbmQgdGhlIGRpc3RhbmNlIHRvIHRoZSByaWdodC5cXHJcXG5cXHRcXHRjb29yZHMueCA9IHNlYXJjaFhSaWdodCh2T2Zmc2V0WzBdLnp3LCB2T2Zmc2V0WzJdLnkpO1xcclxcblxcdFxcdGQueSA9IGNvb3Jkcy54O1xcclxcblxcclxcblxcdFxcdC8vIFRyYW5zbGF0ZSBkaXN0YW5jZXMgdG8gcGl4ZWwgdW5pdHMgZm9yIGJldHRlciBpbnRlcmxlYXZlIGFyaXRobWV0aWMgYW5kIG1lbW9yeSBhY2Nlc3Nlcy5cXHJcXG5cXHRcXHRkID0gZCAvIHRleGVsU2l6ZS54IC0gdlBpeENvb3JkLng7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gVGhlIGFyZWEgYmVsb3cgbmVlZHMgYSBzcXJ0LCBhcyB0aGUgYXJlYXMgdGV4dHVyZSBpcyBjb21wcmVzc2VkIHF1YWRyYXRpY2FsbHkuXFxyXFxuXFx0XFx0dmVjMiBzcXJ0RCA9IHNxcnQoYWJzKGQpKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBGZXRjaCB0aGUgcmlnaHQgY3Jvc3NpbmcgZWRnZXMuXFxyXFxuXFx0XFx0Y29vcmRzLnkgLT0gdGV4ZWxTaXplLnk7IC8vIFdlYkdMIHBvcnQgbm90ZTogQWRkZWQuXFxyXFxuXFx0XFx0ZmxvYXQgZTIgPSBzYW1wbGVMZXZlbFplcm9PZmZzZXQodERpZmZ1c2UsIGNvb3JkcywgaXZlYzIoMSwgMCkpLnI7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gUGF0dGVybiByZWNvZ25pc2VkLCBub3cgZ2V0IHRoZSBhY3R1YWwgYXJlYS5cXHJcXG5cXHRcXHR3ZWlnaHRzLnJnID0gYXJlYShzcXJ0RCwgZTEsIGUyLCBzdWJzYW1wbGVJbmRpY2VzLnkpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRpZihlLnIgPiAwLjApIHtcXHJcXG5cXHJcXG5cXHRcXHQvLyBFZGdlIGF0IHdlc3QuXFxyXFxuXFx0XFx0dmVjMiBkO1xcclxcblxcclxcblxcdFxcdC8vIEZpbmQgdGhlIGRpc3RhbmNlIHRvIHRoZSB0b3AuXFxyXFxuXFx0XFx0dmVjMiBjb29yZHM7XFxyXFxuXFxyXFxuXFx0XFx0Y29vcmRzLnkgPSBzZWFyY2hZVXAodk9mZnNldFsxXS54eSwgdk9mZnNldFsyXS56KTtcXHJcXG5cXHRcXHRjb29yZHMueCA9IHZPZmZzZXRbMF0ueDsgLy8gdk9mZnNldFsxXS54ID0gdlV2LnggLSAwLjI1ICogdGV4ZWxTaXplLng7XFxyXFxuXFx0XFx0ZC54ID0gY29vcmRzLnk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmV0Y2ggdGhlIHRvcCBjcm9zc2luZyBlZGdlcy5cXHJcXG5cXHRcXHRmbG9hdCBlMSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmRzLCAwLjApLmc7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmluZCB0aGUgZGlzdGFuY2UgdG8gdGhlIGJvdHRvbS5cXHJcXG5cXHRcXHRjb29yZHMueSA9IHNlYXJjaFlEb3duKHZPZmZzZXRbMV0uencsIHZPZmZzZXRbMl0udyk7XFxyXFxuXFx0XFx0ZC55ID0gY29vcmRzLnk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRGlzdGFuY2VzIGluIHBpeGVsIHVuaXRzLlxcclxcblxcdFxcdGQgPSBkIC8gdGV4ZWxTaXplLnkgLSB2UGl4Q29vcmQueTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBUaGUgYXJlYSBiZWxvdyBuZWVkcyBhIHNxcnQsIGFzIHRoZSBhcmVhcyB0ZXh0dXJlIGlzIGNvbXByZXNzZWQgcXVhZHJhdGljYWxseS5cXHJcXG5cXHRcXHR2ZWMyIHNxcnREID0gc3FydChhYnMoZCkpO1xcclxcblxcclxcblxcdFxcdC8vIEZldGNoIHRoZSBib3R0b20gY3Jvc3NpbmcgZWRnZXMuXFxyXFxuXFx0XFx0Y29vcmRzLnkgLT0gdGV4ZWxTaXplLnk7IC8vIFdlYkdMIHBvcnQgbm90ZTogQWRkZWQuXFxyXFxuXFx0XFx0ZmxvYXQgZTIgPSBzYW1wbGVMZXZlbFplcm9PZmZzZXQodERpZmZ1c2UsIGNvb3JkcywgaXZlYzIoMCwgMSkpLmc7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gR2V0IHRoZSBhcmVhIGZvciB0aGlzIGRpcmVjdGlvbi5cXHJcXG5cXHRcXHR3ZWlnaHRzLmJhID0gYXJlYShzcXJ0RCwgZTEsIGUyLCBzdWJzYW1wbGVJbmRpY2VzLngpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSB3ZWlnaHRzO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxudmFyeWluZyB2ZWM0IHZPZmZzZXRbM107XFxyXFxudmFyeWluZyB2ZWMyIHZQaXhDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFxyXFxuXFx0dlBpeENvb3JkID0gdXYgLyB0ZXhlbFNpemU7XFxyXFxuXFxyXFxuXFx0Ly8gT2Zmc2V0cyBmb3IgdGhlIHNlYXJjaGVzIChzZWUgQFBTRVVET19HQVRIRVI0KS5cXHJcXG5cXHR2T2Zmc2V0WzBdID0gdXYueHl4eSArIHRleGVsU2l6ZS54eXh5ICogdmVjNCgtMC4yNSwgMC4xMjUsIDEuMjUsIDAuMTI1KTsgLy8gQ2hhbmdlZCBzaWduIGluIFkgYW5kIFcgY29tcG9uZW50cy5cXHJcXG5cXHR2T2Zmc2V0WzFdID0gdXYueHl4eSArIHRleGVsU2l6ZS54eXh5ICogdmVjNCgtMC4xMjUsIDAuMjUsIC0wLjEyNSwgLTEuMjUpOyAvL0NoYW5nZWQgc2lnbiBpbiBZIGFuZCBXIGNvbXBvbmVudHMuXFxyXFxuXFxyXFxuXFx0Ly8gVGhpcyBpbmRpY2F0ZXMgdGhlIGVuZHMgb2YgdGhlIGxvb3BzLlxcclxcblxcdHZPZmZzZXRbMl0gPSB2ZWM0KHZPZmZzZXRbMF0ueHosIHZPZmZzZXRbMV0ueXcpICsgdmVjNCgtMi4wLCAyLjAsIC0yLjAsIDIuMCkgKiB0ZXhlbFNpemUueHh5eSAqIFNNQUFfTUFYX1NFQVJDSF9TVEVQU19GTE9BVDtcXHJcXG5cXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBTdWJwaXhlbCBNb3JwaG9sb2dpY2FsIEFudGlhbGlhc2luZy5cclxuICpcclxuICogVGhpcyBtYXRlcmlhbCBjb21wdXRlcyB3ZWlnaHRzIGZvciBkZXRlY3RlZCBlZGdlcy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgU01BQVdlaWdodHNNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIHdlaWdodHMgbWF0ZXJpYWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIGFic29sdXRlIHNjcmVlbiB0ZXhlbCBzaXplLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih0ZXhlbFNpemUgPSBuZXcgVmVjdG9yMigpKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJTTUFBV2VpZ2h0c01hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHRkZWZpbmVzOiB7XHJcblxyXG5cdFx0XHRcdFNNQUFfTUFYX1NFQVJDSF9TVEVQU19JTlQ6IFwiOFwiLFxyXG5cdFx0XHRcdFNNQUFfTUFYX1NFQVJDSF9TVEVQU19GTE9BVDogXCI4LjBcIixcclxuXHJcblx0XHRcdFx0U01BQV9BUkVBVEVYX01BWF9ESVNUQU5DRTogXCIxNi4wXCIsXHJcblxyXG5cdFx0XHRcdFNNQUFfQVJFQVRFWF9QSVhFTF9TSVpFOiBcIigxLjAgLyB2ZWMyKDE2MC4wLCA1NjAuMCkpXCIsXHJcblx0XHRcdFx0U01BQV9BUkVBVEVYX1NVQlRFWF9TSVpFOiBcIigxLjAgLyA3LjApXCJcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dEFyZWE6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRTZWFyY2g6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRleGVsU2l6ZTogbmV3IFVuaWZvcm0odGV4ZWxTaXplKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGFyZWEgcGF0dGVybiByZWNvZ25pdGlvbiBpbWFnZS4gRW5jb2RlZCBhcyBiYXNlNjQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuYXJlYUltYWdlID0gYXJlYUltYWdlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNlYXJjaCBpbWFnZS4gRW5jb2RlZCBhcyBiYXNlNjQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuc2VhcmNoSW1hZ2UgPSBzZWFyY2hJbWFnZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSwgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gZmxvYXQgbWlkZGxlR3JleTtcXHJcXG51bmlmb3JtIGZsb2F0IG1heEx1bWluYW5jZTtcXHJcXG51bmlmb3JtIHZlYzMgbHVtaW5hbmNlQ29lZmZpY2llbnRzO1xcclxcblxcclxcbiNpZmRlZiBBREFQVEVEX0xVTUlOQU5DRVxcclxcblxcclxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGx1bWluYW5jZU1hcDtcXHJcXG5cXHJcXG4jZWxzZVxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgYXZlcmFnZUx1bWluYW5jZTtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZlYzMgdG9uZU1hcCh2ZWMzIGMpIHtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgQURBUFRFRF9MVU1JTkFOQ0VcXHJcXG5cXHJcXG5cXHRcXHQvLyBHZXQgdGhlIGNhbGN1bGF0ZWQgYXZlcmFnZSBsdW1pbmFuY2UgYnkgc2FtcGxpbmcgdGhlIGNlbnRlci5cXHJcXG5cXHRcXHRmbG9hdCBsdW1BdmcgPSB0ZXh0dXJlMkQobHVtaW5hbmNlTWFwLCB2ZWMyKDAuNSkpLnI7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBsdW1BdmcgPSBhdmVyYWdlTHVtaW5hbmNlO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdC8vIENhbGN1bGF0ZSB0aGUgbHVtaW5hbmNlIG9mIHRoZSBjdXJyZW50IHBpeGVsLlxcclxcblxcdGZsb2F0IGx1bVBpeGVsID0gZG90KGMsIGx1bWluYW5jZUNvZWZmaWNpZW50cyk7XFxyXFxuXFxyXFxuXFx0Ly8gQXBwbHkgdGhlIG1vZGlmaWVkIG9wZXJhdG9yIChSZWluaGFyZCBFcS4gNCkuXFxyXFxuXFx0ZmxvYXQgbHVtU2NhbGVkID0gKGx1bVBpeGVsICogbWlkZGxlR3JleSkgLyBsdW1Bdmc7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgbHVtQ29tcHJlc3NlZCA9IChsdW1TY2FsZWQgKiAoMS4wICsgKGx1bVNjYWxlZCAvIChtYXhMdW1pbmFuY2UgKiBtYXhMdW1pbmFuY2UpKSkpIC8gKDEuMCArIGx1bVNjYWxlZCk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIGx1bUNvbXByZXNzZWQgKiBjO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHRvbmVNYXAodGV4ZWwucmdiKSwgdGV4ZWwuYSk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEZ1bGwtc2NyZWVuIHRvbmUtbWFwcGluZyBzaGFkZXIgbWF0ZXJpYWwuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZTpcclxuICogIGh0dHA6Ly93d3cuY2lzLnJpdC5lZHUvcGVvcGxlL2ZhY3VsdHkvZmVyd2VyZGEvcHVibGljYXRpb25zL3NpZzAyX3BhcGVyLnBkZlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBUb25lTWFwcGluZ01hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHRvbmUgbWFwcGluZyBtYXRlcmlhbC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJUb25lTWFwcGluZ01hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0bHVtaW5hbmNlTWFwOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHRhdmVyYWdlTHVtaW5hbmNlOiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cdFx0XHRcdGx1bWluYW5jZUNvZWZmaWNpZW50czogbmV3IFVuaWZvcm0obmV3IFZlY3RvcjMoMC4yMTI2LCAwLjcxNTIsIDAuMDcyMikpLFxyXG5cdFx0XHRcdG1heEx1bWluYW5jZTogbmV3IFVuaWZvcm0oMTYuMCksXHJcblx0XHRcdFx0bWlkZGxlR3JleTogbmV3IFVuaWZvcm0oMC42KVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hhZGVyIG1hdGVyaWFscyB0aGF0IGFyZSB1c2VkIGluIHRoZSBwb3N0IHByb2Nlc3NpbmcgcGFzc2VzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIHBvc3Rwcm9jZXNzaW5nL21hdGVyaWFsc1xyXG4gKi9cclxuXHJcbmV4cG9ydCB7IEFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsIH0gZnJvbSBcIi4vQWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgQm9rZWhNYXRlcmlhbCB9IGZyb20gXCIuL0Jva2VoTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgQm9rZWgyTWF0ZXJpYWwgfSBmcm9tIFwiLi9Cb2tlaDJNYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBDb21iaW5lTWF0ZXJpYWwgfSBmcm9tIFwiLi9Db21iaW5lTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgQ29udm9sdXRpb25NYXRlcmlhbCwgS2VybmVsU2l6ZSB9IGZyb20gXCIuL0NvbnZvbHV0aW9uTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgQ29weU1hdGVyaWFsIH0gZnJvbSBcIi4vQ29weU1hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IERlcHRoTWF0ZXJpYWwgfSBmcm9tIFwiLi9EZXB0aE1hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IERvdFNjcmVlbk1hdGVyaWFsIH0gZnJvbSBcIi4vRG90U2NyZWVuTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgRmlsbU1hdGVyaWFsIH0gZnJvbSBcIi4vRmlsbU1hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IEdsaXRjaE1hdGVyaWFsIH0gZnJvbSBcIi4vR2xpdGNoTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgR29kUmF5c01hdGVyaWFsIH0gZnJvbSBcIi4vR29kUmF5c01hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IEx1bWlub3NpdHlNYXRlcmlhbCB9IGZyb20gXCIuL0x1bWlub3NpdHlNYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBQaXhlbGF0aW9uTWF0ZXJpYWwgfSBmcm9tIFwiLi9QaXhlbGF0aW9uTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgU2hvY2tXYXZlTWF0ZXJpYWwgfSBmcm9tIFwiLi9TaG9ja1dhdmVNYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBTTUFBQmxlbmRNYXRlcmlhbCB9IGZyb20gXCIuL1NNQUFCbGVuZE1hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IFNNQUFDb2xvckVkZ2VzTWF0ZXJpYWwgfSBmcm9tIFwiLi9TTUFBQ29sb3JFZGdlc01hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IFNNQUFXZWlnaHRzTWF0ZXJpYWwgfSBmcm9tIFwiLi9TTUFBV2VpZ2h0c01hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IFRvbmVNYXBwaW5nTWF0ZXJpYWwgfSBmcm9tIFwiLi9Ub25lTWFwcGluZ01hdGVyaWFsLmpzXCI7XHJcbiIsImltcG9ydCB7IFNjZW5lLCBNZXNoLCBPcnRob2dyYXBoaWNDYW1lcmEsIFBsYW5lQnVmZmVyR2VvbWV0cnkgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBwYXNzLlxyXG4gKlxyXG4gKiBQYXNzZXMgdGhhdCBkbyBub3QgcmVseSBvbiB0aGUgZGVwdGggYnVmZmVyIHNob3VsZCBleHBsaWNpdGx5IGRpc2FibGUgdGhlXHJcbiAqIGRlcHRoIHRlc3QgYW5kIGRlcHRoIHdyaXRlIGluIHRoZWlyIHJlc3BlY3RpdmUgc2hhZGVyIG1hdGVyaWFscy5cclxuICpcclxuICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIGEge0BsaW5rIFBhc3MjZGlzcG9zZX0gbWV0aG9kIHRoYXQgZnJlZXMgbWVtb3J5IG9uXHJcbiAqIGRlbWFuZC5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U2NlbmV9IFtzY2VuZV0gLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxyXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBbY2FtZXJhXSAtIFRoZSBjYW1lcmEuXHJcblx0ICogQHBhcmFtIHtNZXNofSBbcXVhZF0gLSBBIHF1YWQgdGhhdCBmaWxscyB0aGUgc2NyZWVuIHRvIHJlbmRlciAyRCBmaWx0ZXIgZWZmZWN0cy4gU2V0IHRoaXMgdG8gbnVsbCwgaWYgeW91IGRvbid0IG5lZWQgaXQgKHNlZSB7QGxpbmsgUmVuZGVyUGFzc30pLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdHNjZW5lID0gbmV3IFNjZW5lKCksXHJcblx0XHRjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMCwgMSksXHJcblx0XHRxdWFkID0gbmV3IE1lc2gobmV3IFBsYW5lQnVmZmVyR2VvbWV0cnkoMiwgMiksIG51bGwpXHJcblx0KSB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNjZW5lIHRvIHJlbmRlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2NlbmV9XHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAZGVmYXVsdCBuZXcgU2NlbmUoKVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGNhbWVyYS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q2FtZXJhfVxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQGRlZmF1bHQgbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAsIDEpXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcXVhZCBtZXNoIHRoYXQgZmlsbHMgdGhlIHNjcmVlbi5cclxuXHRcdCAqXHJcblx0XHQgKiBBc3NpZ24geW91ciBzaGFkZXIgbWF0ZXJpYWwgdG8gdGhpcyBtZXNoIVxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtNZXNofVxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQGRlZmF1bHQgbmV3IE1lc2gobmV3IFBsYW5lQnVmZmVyR2VvbWV0cnkoMiwgMiksIG51bGwpXHJcblx0XHQgKiBAZXhhbXBsZSB0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLm15TWF0ZXJpYWw7XHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnF1YWQgPSBxdWFkO1xyXG5cclxuXHRcdGlmKHRoaXMucXVhZCAhPT0gbnVsbCkge1xyXG5cclxuXHRcdFx0dGhpcy5xdWFkLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmKHRoaXMuc2NlbmUgIT09IG51bGwpIHtcclxuXHJcblx0XHRcdFx0dGhpcy5zY2VuZS5hZGQodGhpcy5xdWFkKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVhZCBhbmQgd3JpdGUgYnVmZmVycyBzaG91bGQgYmUgc3dhcHBlZCBhZnRlciB0aGlzXHJcblx0XHQgKiBwYXNzIGhhcyBmaW5pc2hlZCByZW5kZXJpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB0aGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyIHNvIHRoYXQgYVxyXG5cdFx0ICogZm9sbG93aW5nIHBhc3MgY2FuIGZpbmQgdGhlIHJlc3VsdCBpbiB0aGUgcmVhZCBidWZmZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEVuYWJsZWQgZmxhZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZW5kZXIgdG8gc2NyZWVuIGZsYWcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cclxuXHQgKlxyXG5cdCAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgbWV0aG9kIHRoYXQgbXVzdCBiZSBvdmVycmlkZGVuLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgbWV0aG9kIGlzIG5vdCBvdmVycmlkZGVuLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIEEgcmVhZCBidWZmZXIuIENvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBBIHdyaXRlIGJ1ZmZlci4gTm9ybWFsbHkgdXNlZCBhcyB0aGUgcmVuZGVyIHRhcmdldCB3aGVuIHRoZSByZWFkIGJ1ZmZlciBpcyB1c2VkIGFzIGlucHV0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFdIC0gVGhlIGRlbHRhIHRpbWUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbbWFza0FjdGl2ZV0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgdGVzdCBtYXNrIGlzIGFjdGl2ZSBvciBub3QuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIsIGRlbHRhLCBtYXNrQWN0aXZlKSB7XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyIG1ldGhvZCBub3QgaW1wbGVtZW50ZWQhXCIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBwYXNzIHdpdGggdGhlIHJlbmRlcmVyJ3Mgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gY2FzZSB5b3Ugd2FudCB0byBiZSBpbmZvcm1lZCBhYm91dCB0aGUgbWFpblxyXG5cdCAqIHJlbmRlciBzaXplLlxyXG5cdCAqXHJcblx0ICogVGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0gY2FsbHMgdGhpcyBtZXRob2QgYmVmb3JlIHRoaXMgcGFzcyBpc1xyXG5cdCAqIGluaXRpYWxpc2VkIGFuZCBldmVyeSB0aW1lIGl0cyBvd24gc2l6ZSBpcyB1cGRhdGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHJlbmRlcmVyJ3Mgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSByZW5kZXJlcidzIGhlaWdodC5cclxuXHQgKiBAZXhhbXBsZSB0aGlzLm15UmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge31cclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgaW5pdGlhbGlzYXRpb24gdGFza3MuXHJcblx0ICpcclxuXHQgKiBCeSBvdmVycmlkaW5nIHRoaXMgbWV0aG9kIHlvdSBnYWluIGFjY2VzcyB0byB0aGUgcmVuZGVyZXIuIFlvdSdsbCBhbHNvIGJlXHJcblx0ICogYWJsZSB0byBjb25maWd1cmUgeW91ciBjdXN0b20gcmVuZGVyIHRhcmdldHMgdG8gdXNlIHRoZSBhcHByb3ByaWF0ZSBmb3JtYXRcclxuXHQgKiAoUkdCIG9yIFJHQkEpLlxyXG5cdCAqXHJcblx0ICogVGhlIHByb3ZpZGVkIHJlbmRlcmVyIGNhbiBiZSB1c2VkIHRvIHdhcm0gdXAgc3BlY2lhbCBvZmYtc2NyZWVuIHJlbmRlclxyXG5cdCAqIHRhcmdldHMgYnkgcGVyZm9ybWluZyBhIHByZWxpbWluYXJ5IHJlbmRlciBvcGVyYXRpb24uXHJcblx0ICpcclxuXHQgKiBUaGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIHRoaXMgcGFzcyBpcyBhZGRlZCB0byBpdHNcclxuXHQgKiBxdWV1ZS5cclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGlzZVxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxyXG5cdCAqIEBleGFtcGxlIGlmKCFhbHBoYSkgeyB0aGlzLm15UmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0OyB9XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpc2UocmVuZGVyZXIsIGFscGhhKSB7fVxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhIHNoYWxsb3cgc2VhcmNoIGZvciBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIGEgZGlzcG9zZSBtZXRob2QgYW5kXHJcblx0ICogZGVsZXRlcyB0aGVtLiBUaGUgcGFzcyB3aWxsIGJlIGlub3BlcmF0aXZlIGFmdGVyIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQhXHJcblx0ICpcclxuXHQgKiBEaXNwb3NhYmxlIG9iamVjdHM6XHJcblx0ICogIC0gcmVuZGVyIHRhcmdldHNcclxuXHQgKiAgLSBtYXRlcmlhbHNcclxuXHQgKiAgLSB0ZXh0dXJlc1xyXG5cdCAqXHJcblx0ICogVGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0gY2FsbHMgdGhpcyBtZXRob2Qgd2hlbiBpdCBpcyBiZWluZyBkZXN0cm95ZWQuXHJcblx0ICogWW91IG1heSwgaG93ZXZlciwgdXNlIGl0IGluZGVwZW5kZW50bHkgdG8gZnJlZSBtZW1vcnkgd2hlbiB5b3UgYXJlIGNlcnRhaW5cclxuXHQgKiB0aGF0IHlvdSBkb24ndCBuZWVkIHRoaXMgcGFzcyBhbnltb3JlLlxyXG5cdCAqL1xyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcclxuXHJcblx0XHRsZXQga2V5O1xyXG5cclxuXHRcdGZvcihrZXkgb2Yga2V5cykge1xyXG5cclxuXHRcdFx0aWYodGhpc1trZXldICE9PSBudWxsICYmIHR5cGVvZiB0aGlzW2tleV0uZGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblxyXG5cdFx0XHRcdHRoaXNba2V5XS5kaXNwb3NlKCk7XHJcblx0XHRcdFx0dGhpc1trZXldID0gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgTGluZWFyRmlsdGVyLCBSR0JGb3JtYXQsIFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSBcInRocmVlXCI7XHJcbmltcG9ydCB7IENvbnZvbHV0aW9uTWF0ZXJpYWwsIEtlcm5lbFNpemUgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBibHVyIHBhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEJsdXJQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYmx1ciBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZW5kZXIgdGV4dHVyZSByZXNvbHV0aW9uIHNjYWxlLCByZWxhdGl2ZSB0byB0aGUgc2NyZWVuIHJlbmRlciBzaXplLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuTEFSR0VdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkJsdXJQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFggPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoMSwgMSwge1xyXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0bWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aEJ1ZmZlcjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WC50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0WFwiO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRYLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHNlY29uZCByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFkgPSB0aGlzLnJlbmRlclRhcmdldFguY2xvbmUoKTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFkudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldFlcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxyXG5cdFx0ICpcclxuXHRcdCAqIFlvdSBuZWVkIHRvIGNhbGwge0BsaW5rIEVmZmVjdENvbXBvc2VyI3NldFNpemV9IGFmdGVyIGNoYW5naW5nIHRoaXNcclxuXHRcdCAqIHZhbHVlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwLjVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVzb2x1dGlvblNjYWxlID0gKG9wdGlvbnMucmVzb2x1dGlvblNjYWxlICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGUgOiAwLjU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGNvbnZvbHV0aW9uIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q29udm9sdXRpb25NYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwgPSBuZXcgQ29udm9sdXRpb25NYXRlcmlhbCgpO1xyXG5cclxuXHRcdHRoaXMua2VybmVsU2l6ZSA9IG9wdGlvbnMua2VybmVsU2l6ZTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGFic29sdXRlIHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0WC53aWR0aDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYWJzb2x1dGUgaGVpZ2h0IG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLnJlbmRlclRhcmdldFguaGVpZ2h0OyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBrZXJuZWwgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtLZXJuZWxTaXplfVxyXG5cdCAqIEBkZWZhdWx0IEtlcm5lbFNpemUuTEFSR0VcclxuXHQgKi9cclxuXHJcblx0Z2V0IGtlcm5lbFNpemUoKSB7IHJldHVybiB0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwua2VybmVsU2l6ZTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7S2VybmVsU2l6ZX1cclxuXHQgKi9cclxuXHJcblx0c2V0IGtlcm5lbFNpemUoeCA9IEtlcm5lbFNpemUuTEFSR0UpIHsgdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLmtlcm5lbFNpemUgPSB4OyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEJsdXJzIHRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpIHtcclxuXHJcblx0XHRjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XHJcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRYID0gdGhpcy5yZW5kZXJUYXJnZXRYO1xyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0WSA9IHRoaXMucmVuZGVyVGFyZ2V0WTtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IHRoaXMuY29udm9sdXRpb25NYXRlcmlhbDtcclxuXHRcdGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XHJcblx0XHRjb25zdCBrZXJuZWwgPSBtYXRlcmlhbC5nZXRLZXJuZWwoKTtcclxuXHJcblx0XHRsZXQgbGFzdFJUID0gcmVhZEJ1ZmZlcjtcclxuXHRcdGxldCBkZXN0UlQ7XHJcblx0XHRsZXQgaSwgbDtcclxuXHJcblx0XHQvLyBBcHBseSB0aGUgbXVsdGktcGFzcyBibHVyLlxyXG5cdFx0Zm9yKGkgPSAwLCBsID0ga2VybmVsLmxlbmd0aCAtIDE7IGkgPCBsOyArK2kpIHtcclxuXHJcblx0XHRcdC8vIEFsdGVybmF0ZSBiZXR3ZWVuIHRhcmdldHMuXHJcblx0XHRcdGRlc3RSVCA9ICgoaSAlIDIpID09PSAwKSA/IHJlbmRlclRhcmdldFggOiByZW5kZXJUYXJnZXRZO1xyXG5cclxuXHRcdFx0dW5pZm9ybXMua2VybmVsLnZhbHVlID0ga2VybmVsW2ldO1xyXG5cdFx0XHR1bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IGxhc3RSVC50ZXh0dXJlO1xyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgZGVzdFJUKTtcclxuXHJcblx0XHRcdGxhc3RSVCA9IGRlc3RSVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dW5pZm9ybXMua2VybmVsLnZhbHVlID0ga2VybmVsW2ldO1xyXG5cdFx0dW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSBsYXN0UlQudGV4dHVyZTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGp1c3RzIHRoZSBmb3JtYXQgb2YgdGhlIHJlbmRlciB0YXJnZXRzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpc2UocmVuZGVyZXIsIGFscGhhKSB7XHJcblxyXG5cdFx0aWYoIWFscGhhKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldFgudGV4dHVyZS5mb3JtYXQgPSBSR0JGb3JtYXQ7XHJcblx0XHRcdHRoaXMucmVuZGVyVGFyZ2V0WS50ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3Iod2lkdGggKiB0aGlzLnJlc29sdXRpb25TY2FsZSkpO1xyXG5cdFx0aGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihoZWlnaHQgKiB0aGlzLnJlc29sdXRpb25TY2FsZSkpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRZLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0dGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLnNldFRleGVsU2l6ZSgxLjAgLyB3aWR0aCwgMS4wIC8gaGVpZ2h0KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIFJHQkZvcm1hdCwgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tIFwidGhyZWVcIjtcclxuaW1wb3J0IHsgQ29tYmluZU1hdGVyaWFsLCBLZXJuZWxTaXplLCBMdW1pbm9zaXR5TWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IEJsdXJQYXNzIH0gZnJvbSBcIi4vQmx1clBhc3MuanNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGJsb29tIHBhc3MuXHJcbiAqXHJcbiAqIFRoaXMgcGFzcyByZW5kZXJzIGEgc2NlbmUgd2l0aCBzdXBlcmltcG9zZWQgYmx1ciBieSB1dGlsaXNpbmcgdGhlIGZhc3QgS2F3YXNlXHJcbiAqIGNvbnZvbHV0aW9uIGFwcHJvYWNoLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBCbG9vbVBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBibG9vbSBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZW5kZXIgdGV4dHVyZSByZXNvbHV0aW9uIHNjYWxlLCByZWxhdGl2ZSB0byB0aGUgc2NyZWVuIHJlbmRlciBzaXplLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuTEFSR0VdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmludGVuc2l0eT0xLjBdIC0gVGhlIHN0cmVuZ3RoIG9mIHRoZSBibG9vbSBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRpc3RpbmN0aW9uPTEuMF0gLSBUaGUgbHVtaW5hbmNlIGRpc3RpbmN0aW9uIGZhY3Rvci4gUmFpc2UgdGhpcyB2YWx1ZSB0byBicmluZyBvdXQgdGhlIGJyaWdodGVyIGVsZW1lbnRzIGluIHRoZSBzY2VuZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2NyZWVuTW9kZT10cnVlXSAtIFdoZXRoZXIgdGhlIHNjcmVlbiBibGVuZCBtb2RlIHNob3VsZCBiZSB1c2VkIGZvciBjb21iaW5pbmcgdGhlIGJsb29tIHRleHR1cmUgd2l0aCB0aGUgc2NlbmUgY29sb3JzLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJCbG9vbVBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGJsdXIgcGFzcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qmx1clBhc3N9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5ibHVyUGFzcyA9IG5ldyBCbHVyUGFzcyhvcHRpb25zKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVuZGVyIHRhcmdldC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJUYXJnZXR9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoMSwgMSwge1xyXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0bWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aEJ1ZmZlcjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiQmxvb20uVGFyZ2V0XCI7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBjb21iaW5lIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q29tYmluZU1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY29tYmluZU1hdGVyaWFsID0gbmV3IENvbWJpbmVNYXRlcmlhbCgob3B0aW9ucy5zY3JlZW5Nb2RlICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5zY3JlZW5Nb2RlIDogdHJ1ZSk7XHJcblxyXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBvcHRpb25zLmludGVuc2l0eTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbHVtaW5vc2l0eSBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0x1bWlub3NpdHlNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmx1bWlub3NpdHlNYXRlcmlhbCA9IG5ldyBMdW1pbm9zaXR5TWF0ZXJpYWwodHJ1ZSk7XHJcblxyXG5cdFx0dGhpcy5kaXN0aW5jdGlvbiA9IG9wdGlvbnMuZGlzdGluY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlc29sdXRpb24gc2NhbGUuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDAuNVxyXG5cdCAqL1xyXG5cclxuXHRnZXQgcmVzb2x1dGlvblNjYWxlKCkgeyByZXR1cm4gdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uU2NhbGU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogWW91IG5lZWQgdG8gY2FsbCB7QGxpbmsgRWZmZWN0Q29tcG9zZXIjc2V0U2l6ZX0gYWZ0ZXIgY2hhbmdpbmcgdGhpcyB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCByZXNvbHV0aW9uU2NhbGUoeCA9IDAuNSkgeyB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb25TY2FsZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGJsdXIga2VybmVsIHNpemUuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7S2VybmVsU2l6ZX1cclxuXHQgKiBAZGVmYXVsdCBLZXJuZWxTaXplLkxBUkdFXHJcblx0ICovXHJcblxyXG5cdGdldCBrZXJuZWxTaXplKCkgeyByZXR1cm4gdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtLZXJuZWxTaXplfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQga2VybmVsU2l6ZSh4ID0gS2VybmVsU2l6ZS5MQVJHRSkgeyB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB4OyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBvdmVyYWxsIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAZGVmYXVsdCAxLjBcclxuXHQgKi9cclxuXHJcblx0Z2V0IGludGVuc2l0eSgpIHsgcmV0dXJuIHRoaXMuY29tYmluZU1hdGVyaWFsLnVuaWZvcm1zLm9wYWNpdHkyLnZhbHVlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCBpbnRlbnNpdHkoeCA9IDEuMCkgeyB0aGlzLmNvbWJpbmVNYXRlcmlhbC51bmlmb3Jtcy5vcGFjaXR5Mi52YWx1ZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGx1bWluYW5jZSBkaXN0aW5jdGlvbiBmYWN0b3IuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDEuMFxyXG5cdCAqL1xyXG5cclxuXHRnZXQgZGlzdGluY3Rpb24oKSB7IHJldHVybiB0aGlzLmx1bWlub3NpdHlNYXRlcmlhbC51bmlmb3Jtcy5kaXN0aW5jdGlvbi52YWx1ZTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgZGlzdGluY3Rpb24oeCA9IDEuMCkgeyB0aGlzLmx1bWlub3NpdHlNYXRlcmlhbC51bmlmb3Jtcy5kaXN0aW5jdGlvbi52YWx1ZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogRXh0cmFjdHMgYSBsdW1pbmFuY2UgbWFwIGZyb20gdGhlIHJlYWQgYnVmZmVyLCBibHVycyBpdCBhbmQgY29tYmluZXMgaXRcclxuXHQgKiB3aXRoIHRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpIHtcclxuXHJcblx0XHRjb25zdCBxdWFkID0gdGhpcy5xdWFkO1xyXG5cdFx0Y29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xyXG5cdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XHJcblx0XHRjb25zdCBibHVyUGFzcyA9IHRoaXMuYmx1clBhc3M7XHJcblxyXG5cdFx0Y29uc3QgbHVtaW5vc2l0eU1hdGVyaWFsID0gdGhpcy5sdW1pbm9zaXR5TWF0ZXJpYWw7XHJcblx0XHRjb25zdCBjb21iaW5lTWF0ZXJpYWwgPSB0aGlzLmNvbWJpbmVNYXRlcmlhbDtcclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdC8vIEx1bWluYW5jZSBmaWx0ZXIuXHJcblx0XHRxdWFkLm1hdGVyaWFsID0gbHVtaW5vc2l0eU1hdGVyaWFsO1xyXG5cdFx0bHVtaW5vc2l0eU1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCk7XHJcblxyXG5cdFx0Ly8gQ29udm9sdXRpb24gcGhhc2UuXHJcblx0XHRibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0KTtcclxuXHJcblx0XHQvLyBSZW5kZXIgdGhlIG9yaWdpbmFsIHNjZW5lIHdpdGggc3VwZXJpbXBvc2VkIGJsdXIuXHJcblx0XHRxdWFkLm1hdGVyaWFsID0gY29tYmluZU1hdGVyaWFsO1xyXG5cdFx0Y29tYmluZU1hdGVyaWFsLnVuaWZvcm1zLnRleHR1cmUxLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cdFx0Y29tYmluZU1hdGVyaWFsLnVuaWZvcm1zLnRleHR1cmUyLnZhbHVlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkanVzdHMgdGhlIGZvcm1hdCBvZiB0aGUgcmVuZGVyIHRhcmdldHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpIHtcclxuXHJcblx0XHR0aGlzLmJsdXJQYXNzLmluaXRpYWxpc2UocmVuZGVyZXIsIGFscGhhKTtcclxuXHJcblx0XHRpZighYWxwaGEpIHsgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgPSBSR0JGb3JtYXQ7IH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgcGFzcyB3aXRoIHRoZSByZW5kZXJlcidzIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG5cclxuXHRcdHRoaXMuYmx1clBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcblx0XHR3aWR0aCA9IHRoaXMuYmx1clBhc3Mud2lkdGg7XHJcblx0XHRoZWlnaHQgPSB0aGlzLmJsdXJQYXNzLmhlaWdodDtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEJva2VoTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBEZXB0aCBvZiBGaWVsZCAoRG9GKSBwYXNzIHVzaW5nIGEgYm9rZWggc2hhZGVyLlxyXG4gKlxyXG4gKiBUaGlzIHBhc3MgcmVxdWlyZXMgYSB7QGxpbmsgRWZmZWN0Q29tcG9zZXIjZGVwdGhUZXh0dXJlfS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQm9rZWhQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYm9rZWggcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS4gVXNlZCB0byBvYnRhaW4gdGhlIGFzcGVjdCByYXRpbyBhbmQgdGhlIG5lYXIgYW5kIGZhciBwbGFuZSBzZXR0aW5ncy5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2N1cz0xLjBdIC0gRm9jdXMgZGlzdGFuY2UuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFwZXJ0dXJlPTAuMDI1XSAtIENhbWVyYSBhcGVydHVyZSBzY2FsZS4gQmlnZ2VyIHZhbHVlcyBmb3Igc2hhbGxvd2VyIGRlcHRoIG9mIGZpZWxkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhCbHVyPTEuMF0gLSBNYXhpbXVtIGJsdXIgc3RyZW5ndGguXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKGNhbWVyYSwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiQm9rZWhQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBib2tlaCBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jva2VoTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5ib2tlaE1hdGVyaWFsID0gbmV3IEJva2VoTWF0ZXJpYWwoY2FtZXJhLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLmJva2VoTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdHRoaXMuYm9rZWhNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdHRoaXMuYm9rZWhNYXRlcmlhbC51bmlmb3Jtcy50RGVwdGgudmFsdWUgPSByZWFkQnVmZmVyLmRlcHRoVGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBwYXNzIHdpdGggdGhlIHJlbmRlcmVyJ3Mgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0dGhpcy5ib2tlaE1hdGVyaWFsLnVuaWZvcm1zLmFzcGVjdC52YWx1ZSA9IHdpZHRoIC8gaGVpZ2h0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEJva2VoMk1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFkdmFuY2VkIERlcHRoIG9mIEZpZWxkIChEb0YpIHBhc3MuXHJcbiAqXHJcbiAqIFlpZWxkcyBtb3JlIHJlYWxpc3RpYyByZXN1bHRzIGJ1dCBpcyBhbHNvIG1vcmUgZGVtYW5kaW5nLlxyXG4gKlxyXG4gKiBUaGlzIHBhc3MgcmVxdWlyZXMgYSB7QGxpbmsgRWZmZWN0Q29tcG9zZXIjZGVwdGhUZXh0dXJlfS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQm9rZWgyUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoMiBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLiBVc2VkIHRvIG9idGFpbiB0aGUgZm9jYWwgbGVuZ3RoIGFuZCB0aGUgbmVhciBhbmQgZmFyIHBsYW5lIHNldHRpbmdzLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJpbmdzPTNdIC0gVGhlIGFtb3VudCBvZiBibHVyIHJpbmdzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzPTRdIC0gVGhlIGFtb3VudCBvZiBzYW1wbGVzIHBlciByaW5nLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2hvd0ZvY3VzPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGZvY3VzIHBvaW50IHNob3VsZCBiZSBoaWdobGlnaHRlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hbnVhbERvRj1mYWxzZV0gLSBFbmFibGVzIG1hbnVhbCBkZXB0aCBvZiBmaWVsZCBibHVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmlnbmV0dGU9ZmFsc2VdIC0gRW5hYmxlcyBhIHZpZ25ldHRlIGVmZmVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBlbnRhZ29uPWZhbHNlXSAtIEVuYWJsZSB0byB1c2UgYSBwZW50YWdvbmFsIHNoYXBlIHRvIHNjYWxlIGdhdGhlcmVkIHRleGVscy5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNoYWRlckZvY3VzPXRydWVdIC0gRGlzYWJsZSBpZiB5b3UgY29tcHV0ZSB5b3VyIG93biBmb2NhbERlcHRoIChpbiBtZXRyZXMhKS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vaXNlPXRydWVdIC0gRGlzYWJsZSBpZiB5b3UgZG9uJ3Qgd2FudCBub2lzZSBwYXR0ZXJucyBmb3IgZGl0aGVyaW5nLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihjYW1lcmEsIG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkJva2VoMlBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGJva2VoIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9rZWhNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmJva2VoTWF0ZXJpYWwgPSBuZXcgQm9rZWgyTWF0ZXJpYWwoY2FtZXJhLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLmJva2VoTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdHRoaXMuYm9rZWhNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdHRoaXMuYm9rZWhNYXRlcmlhbC51bmlmb3Jtcy50RGVwdGgudmFsdWUgPSByZWFkQnVmZmVyLmRlcHRoVGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBwYXNzIHdpdGggdGhlIHJlbmRlcmVyJ3Mgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0dGhpcy5ib2tlaE1hdGVyaWFsLnNldFRleGVsU2l6ZSgxLjAgLyB3aWR0aCwgMS4wIC8gaGVpZ2h0KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgcGFzcyB0aGF0IGRpc2FibGVzIHRoZSBzdGVuY2lsIG1hc2suXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIENsZWFyTWFza1Bhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjbGVhciBtYXNrIHBhc3MuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKG51bGwsIG51bGwsIG51bGwpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJDbGVhck1hc2tQYXNzXCI7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGlzYWJsZXMgdGhlIHN0ZW5jaWwgdGVzdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlcikge1xyXG5cclxuXHRcdHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRUZXN0KGZhbHNlKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gXCJ0aHJlZVwiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgZm9yIHNhdmluZyB0aGUgb3JpZ2luYWwgY2xlYXIgY29sb3Igb2YgdGhlIHJlbmRlcmVyLlxyXG4gKlxyXG4gKiBAdHlwZSBDb2xvclxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqL1xyXG5cclxuY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoKTtcclxuXHJcbi8qKlxyXG4gKiBBIGNsZWFyIHBhc3MuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcHJldmVudCBzcGVjaWZpYyBidWZmZXJzIGZyb20gYmVpbmcgY2xlYXJlZCBieSBzZXR0aW5nIGVpdGhlciB0aGVcclxuICogYXV0b0NsZWFyQ29sb3IsIGF1dG9DbGVhclN0ZW5jaWwgb3IgYXV0b0NsZWFyRGVwdGggcHJvcGVydGllcyBvZiB0aGUgcmVuZGVyZXJcclxuICogdG8gZmFsc2UuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIENsZWFyUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNsZWFyIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7Q29sb3J9IFtvcHRpb25zLmNsZWFyQ29sb3I9bnVsbF0gLSBBbiBvdmVycmlkZSBjbGVhciBjb2xvci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2xlYXJBbHBoYT0wLjBdIC0gQW4gb3ZlcnJpZGUgY2xlYXIgYWxwaGEuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKG51bGwsIG51bGwsIG51bGwpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJDbGVhclBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENsZWFyIGNvbG9yLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDb2xvcn1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY2xlYXJDb2xvciA9IChvcHRpb25zLmNsZWFyQ29sb3IgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmNsZWFyQ29sb3IgOiBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ2xlYXIgYWxwaGEuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDAuMFxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jbGVhckFscGhhID0gKG9wdGlvbnMuY2xlYXJBbHBoYSAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY2xlYXJBbHBoYSA6IDAuMDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhcnMgdGhlIHJlYWQgYnVmZmVyIG9yIHRoZSBzY3JlZW4uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlcikge1xyXG5cclxuXHRcdGNvbnN0IGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XHJcblxyXG5cdFx0bGV0IGNsZWFyQWxwaGE7XHJcblxyXG5cdFx0aWYoY2xlYXJDb2xvciAhPT0gbnVsbCkge1xyXG5cclxuXHRcdFx0Y29sb3IuY29weShyZW5kZXJlci5nZXRDbGVhckNvbG9yKCkpO1xyXG5cdFx0XHRjbGVhckFscGhhID0gcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xyXG5cdFx0XHRyZW5kZXJlci5zZXRDbGVhckNvbG9yKGNsZWFyQ29sb3IsIHRoaXMuY2xlYXJBbHBoYSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHJlYWRCdWZmZXIpO1xyXG5cdFx0cmVuZGVyZXIuY2xlYXIoKTtcclxuXHJcblx0XHRpZihjbGVhckNvbG9yICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5zZXRDbGVhckNvbG9yKGNvbG9yLCBjbGVhckFscGhhKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgRG90U2NyZWVuTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBkb3Qgc2NyZWVuIHBhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIERvdFNjcmVlblBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBkb3Qgc2NyZWVuIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTEuNTddIC0gVGhlIGFuZ2xlIG9mIHRoZSBwYXR0ZXJuLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZT0xLjBdIC0gVGhlIHNjYWxlIG9mIHRoZSBvdmVyYWxsIGVmZmVjdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW50ZW5zaXR5PTEuMF0gLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdmVyYWdlPWZhbHNlXSAtIFdoZXRoZXIgdGhlIHNoYWRlciBzaG91bGQgb3V0cHV0IGEgY29sb3VyIGF2ZXJhZ2UgKGJsYWNrIGFuZCB3aGl0ZSkuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkRvdFNjcmVlblBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGRvdCBzY3JlZW4gc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtEb3RTY3JlZW5NYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IERvdFNjcmVlbk1hdGVyaWFsKG9wdGlvbnMuYXZlcmFnZSk7XHJcblxyXG5cdFx0aWYob3B0aW9ucy5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7IHRoaXMubWF0ZXJpYWwudW5pZm9ybXMuYW5nbGUudmFsdWUgPSBvcHRpb25zLmFuZ2xlOyB9XHJcblx0XHRpZihvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQpIHsgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG9wdGlvbnMuc2NhbGU7IH1cclxuXHRcdGlmKG9wdGlvbnMuaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIHsgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5pbnRlbnNpdHkudmFsdWUgPSBvcHRpb25zLmludGVuc2l0eTsgfVxyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgcGFzcyB3aXRoIHRoZSByZW5kZXJlcidzIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0d2lkdGggPSBNYXRoLm1heCgxLCB3aWR0aCk7XHJcblx0XHRoZWlnaHQgPSBNYXRoLm1heCgxLCBoZWlnaHQpO1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwudW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnogPSB3aWR0aDtcclxuXHRcdHRoaXMubWF0ZXJpYWwudW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLncgPSBoZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgRGVwdGhNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGRlcHRoIHBhc3MuXHJcbiAqXHJcbiAqIFJlYWRzIHRoZSBkZXB0aCBmcm9tIGEgZGVwdGggdGV4dHVyZSBhbmQgcmVuZGVycyBpdC5cclxuICpcclxuICogVGhpcyBwYXNzIHJlcXVpcmVzIGEge0BsaW5rIEVmZmVjdENvbXBvc2VyI2RlcHRoVGV4dHVyZX0uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIERlcHRoUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuIFVzZWQgdG8gb2J0YWluIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmUgc2V0dGluZ3MuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkRlcHRoUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgZGVwdGggc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtEZXB0aE1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuZGVwdGhNYXRlcmlhbCA9IG5ldyBEZXB0aE1hdGVyaWFsKGNhbWVyYSk7XHJcblxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5kZXB0aE1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpIHtcclxuXHJcblx0XHR0aGlzLmRlcHRoTWF0ZXJpYWwudW5pZm9ybXMudERlcHRoLnZhbHVlID0gcmVhZEJ1ZmZlci5kZXB0aFRleHR1cmU7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBGaWxtTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBmaWxtIHBhc3MuXHJcbiAqXHJcbiAqIFByb3ZpZGVzIHZhcmlvdXMgY2luZW1hdGljIGVmZmVjdHMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEZpbG1QYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZmlsbSBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLiBEaXNhYmxlZCBlZmZlY3RzIGhhdmUgbm8gbmVnYXRpdmUgaW1wYWN0IG9uIHBlcmZvcm1hbmNlLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ3JleXNjYWxlPWZhbHNlXSAtIEVuYWJsZSBncmV5c2NhbGUgZWZmZWN0LiBHcmV5c2NhbGUgYW5kIHNlcGlhIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXBpYT1mYWxzZV0gLSBFbmFibGUgc2VwaWEgZWZmZWN0LiBHcmV5c2NhbGUgYW5kIHNlcGlhIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52aWduZXR0ZT1mYWxzZV0gLSBBcHBseSB2aWduZXR0ZSBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lc2tpbD1mYWxzZV0gLSBVc2UgRXNraWwncyB2aWduZXR0ZSBhcHByb2FjaC4gVGhlIGRlZmF1bHQgbG9va3MgZHVzdHkgd2hpbGUgRXNraWwgbG9va3MgbW9yZSBidXJuZWQgb3V0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2NyZWVuTW9kZT10cnVlXSAtIFdoZXRoZXIgdGhlIHNjcmVlbiBibGVuZCBtb2RlIHNob3VsZCBiZSB1c2VkIGZvciBub2lzZSBhbmQgc2NhbmxpbmVzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2NhbmxpbmVzPXRydWVdIC0gU2hvdyBzY2FubGluZXMuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub2lzZT10cnVlXSAtIFNob3cgbm9pc2UtYmFzZWQgZmlsbSBncmFpbi5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubm9pc2VJbnRlbnNpdHk9MC41XSAtIFRoZSBub2lzZSBpbnRlbnNpdHkuIDAuMCB0byAxLjAuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjYW5saW5lSW50ZW5zaXR5PTAuMDVdIC0gVGhlIHNjYW5saW5lIGludGVuc2l0eS4gMC4wIHRvIDEuMC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2NhbmxpbmVEZW5zaXR5PTEuMF0gLSBUaGUgbnVtYmVyIG9mIHNjYW5saW5lcyBpbiBwZXJjZW50LCByZWxhdGl2ZSB0byB0aGUgc2NyZWVuIGhlaWdodC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ3JleXNjYWxlSW50ZW5zaXR5PTEuMF0gLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBncmV5c2NhbGUgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZXBpYUludGVuc2l0eT0xLjBdIC0gVGhlIGludGVuc2l0eSBvZiB0aGUgc2VwaWEgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWduZXR0ZU9mZnNldD0xLjBdIC0gVGhlIG9mZnNldCBvZiB0aGUgdmlnbmV0dGUgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWduZXR0ZURhcmtuZXNzPTEuMF0gLSBUaGUgZGFya25lc3Mgb2YgdGhlIHZpZ25ldHRlIGVmZmVjdC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiRmlsbVBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBGaWxtIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7RmlsbU1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgRmlsbU1hdGVyaWFsKG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYW1vdW50IG9mIHNjYW5saW5lcyBpbiBwZXJjZW50LCByZWxhdGl2ZSB0byB0aGUgc2NyZWVuIGhlaWdodC5cclxuXHRcdCAqXHJcblx0XHQgKiBZb3UgbmVlZCB0byBjYWxsIHtAbGluayBFZmZlY3RDb21wb3NlciNzZXRTaXplfSBhZnRlciBjaGFuZ2luZyB0aGlzXHJcblx0XHQgKiB2YWx1ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMS4yNVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5zY2FubGluZURlbnNpdHkgPSAob3B0aW9ucy5zY2FubGluZURlbnNpdHkgPT09IHVuZGVmaW5lZCkgPyAxLjI1IDogb3B0aW9ucy5zY2FubGluZURlbnNpdHk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgLSBUaGUgcmVuZGVyIGRlbHRhIHRpbWUuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIsIGRlbHRhKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudGltZS52YWx1ZSArPSBkZWx0YTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkanVzdHMgdGhlIHNjYW5saW5lIGNvdW50IHVzaW5nIHRoZSByZW5kZXJlcidzIGhlaWdodC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5zY2FubGluZUNvdW50LnZhbHVlID0gTWF0aC5yb3VuZChoZWlnaHQgKiB0aGlzLnNjYW5saW5lRGVuc2l0eSk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgRGF0YVRleHR1cmUsIFJHQkZvcm1hdCwgRmxvYXRUeXBlIH0gZnJvbSBcInRocmVlXCI7XHJcbmltcG9ydCB7IEdsaXRjaE1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgLSBUaGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaCAtIFRoZSBoaWdoZXN0IHBvc3NpYmxlIHZhbHVlLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYW5kb20gdmFsdWUuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmFuZG9tSW50KGxvdywgaGlnaCkge1xyXG5cclxuXHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cgKyAxKSk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHJhbmRvbSBmbG9hdCBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgLSBUaGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaCAtIFRoZSBoaWdoZXN0IHBvc3NpYmxlIHZhbHVlLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYW5kb20gdmFsdWUuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcmFuZG9tRmxvYXQobG93LCBoaWdoKSB7XHJcblxyXG5cdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgZ2xpdGNoIHBhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEdsaXRjaFBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBnbGl0Y2ggcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLnBlcnR1cmJNYXBdIC0gQSBwZXJ0dXJiYXRpb24gbWFwLiBJZiBub25lIGlzIHByb3ZpZGVkLCBhIG5vaXNlIHRleHR1cmUgd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdFNpemU9NjRdIC0gVGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBub2lzZSBtYXAuIFdpbGwgYmUgaWdub3JlZCBpZiBhIHBlcnR1cmJhdGlvbiBtYXAgaXMgcHJvdmlkZWQuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkdsaXRjaFBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBHbGl0Y2ggc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtHbGl0Y2hNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IEdsaXRjaE1hdGVyaWFsKCk7XHJcblxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcGVydHVyYmF0aW9uIG1hcC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7VGV4dHVyZX1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnRleHR1cmUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMucGVydHVyYk1hcCA9IChvcHRpb25zLnBlcnR1cmJNYXAgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLnBlcnR1cmJNYXAgOiB0aGlzLmdlbmVyYXRlUGVydHVyYk1hcChvcHRpb25zLmR0U2l6ZSk7XHJcblx0XHR0aGlzLnBlcnR1cmJNYXAubmFtZSA9IFwiR2xpdGNoLlBlcnR1cmJhdGlvblwiO1xyXG5cdFx0dGhpcy5wZXJ0dXJiTWFwLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGVmZmVjdCBtb2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtHbGl0Y2hNb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgR2xpdGNoTW9kZS5TUE9SQURJQ1xyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5tb2RlID0gR2xpdGNoTW9kZS5TUE9SQURJQztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENvdW50ZXIgZm9yIGdsaXRjaCBhY3RpdmF0aW9uIGFuZCBkZWFjdGl2YXRpb24uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvdW50ZXIgPSAwO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByYW5kb20gYnJlYWsgcG9pbnQgZm9yIHRoZSBzcG9yYWRpYyBnbGl0Y2ggYWN0aXZhdGlvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuYnJlYWtQb2ludCA9IHJhbmRvbUludCgxMjAsIDI0MCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGN1cnJlbnQgcGVydHVyYmF0aW9uIG1hcC5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtUZXh0dXJlfVxyXG5cdCAqL1xyXG5cclxuXHRnZXQgcGVydHVyYk1hcCgpIHsgcmV0dXJuIHRoaXMudGV4dHVyZTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBBc3NpZ25pbmcgYSBuZXcgcGVydHVyYmF0aW9uIG1hcCBkb2VzIG5vdCBkZXN0cm95IHRoZSBjdXJyZW50IG9uZSFcclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtUZXh0dXJlfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgcGVydHVyYk1hcCh4KSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlID0geDtcclxuXHRcdHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudFBlcnR1cmIudmFsdWUgPSB4O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlc3Ryb3lzIHRoZSBjdXJyZW50IHBlcnR1cmJhdGlvbiBtYXAgYW5kIHJlcGxhY2VzIGl0IHdpdGggYSBuZXcgb25lLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplPTY0XSAtIFRoZSB0ZXh0dXJlIHNpemUuXHJcblx0ICogQHJldHVybiB7RGF0YVRleHR1cmV9IFRoZSBwZXJ0dXJiYXRpb24gdGV4dHVyZS5cclxuXHQgKi9cclxuXHJcblx0Z2VuZXJhdGVQZXJ0dXJiTWFwKHNpemUgPSA2NCkge1xyXG5cclxuXHRcdGNvbnN0IHBpeGVscyA9IHNpemUgKiBzaXplO1xyXG5cdFx0Y29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocGl4ZWxzICogMyk7XHJcblxyXG5cdFx0bGV0IGR0ID0gdGhpcy5wZXJ0dXJiTWFwO1xyXG5cdFx0bGV0IGksIHg7XHJcblxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgcGl4ZWxzOyArK2kpIHtcclxuXHJcblx0XHRcdHggPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuXHRcdFx0ZGF0YVtpICogM10gPSB4O1xyXG5cdFx0XHRkYXRhW2kgKiAzICsgMV0gPSB4O1xyXG5cdFx0XHRkYXRhW2kgKiAzICsgMl0gPSB4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZihkdCAhPT0gbnVsbCkge1xyXG5cclxuXHRcdFx0ZHQuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkdCA9IG5ldyBEYXRhVGV4dHVyZShkYXRhLCBzaXplLCBzaXplLCBSR0JGb3JtYXQsIEZsb2F0VHlwZSk7XHJcblx0XHRkdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5wZXJ0dXJiTWFwID0gZHQ7XHJcblxyXG5cdFx0cmV0dXJuIGR0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpIHtcclxuXHJcblx0XHRjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xyXG5cdFx0Y29uc3QgY291bnRlciA9IHRoaXMuY291bnRlcjtcclxuXHRcdGNvbnN0IGJyZWFrUG9pbnQgPSB0aGlzLmJyZWFrUG9pbnQ7XHJcblx0XHRjb25zdCB1bmlmb3JtcyA9IHRoaXMubWF0ZXJpYWwudW5pZm9ybXM7XHJcblxyXG5cdFx0dW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblx0XHR1bmlmb3Jtcy5zZWVkLnZhbHVlID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdHVuaWZvcm1zLmFjdGl2ZS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0aWYoY291bnRlciAlIGJyZWFrUG9pbnQgPT09IDAgfHwgbW9kZSA9PT0gR2xpdGNoTW9kZS5DT05TVEFOVF9XSUxEKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hbW91bnQudmFsdWUgPSBNYXRoLnJhbmRvbSgpIC8gMzAuMDtcclxuXHRcdFx0dW5pZm9ybXMuYW5nbGUudmFsdWUgPSByYW5kb21GbG9hdCgtTWF0aC5QSSwgTWF0aC5QSSk7XHJcblx0XHRcdHVuaWZvcm1zLnNlZWRYLnZhbHVlID0gcmFuZG9tRmxvYXQoLTEuMCwgMS4wKTtcclxuXHRcdFx0dW5pZm9ybXMuc2VlZFkudmFsdWUgPSByYW5kb21GbG9hdCgtMS4wLCAxLjApO1xyXG5cdFx0XHR1bmlmb3Jtcy5kaXN0b3J0aW9uWC52YWx1ZSA9IHJhbmRvbUZsb2F0KDAuMCwgMS4wKTtcclxuXHRcdFx0dW5pZm9ybXMuZGlzdG9ydGlvblkudmFsdWUgPSByYW5kb21GbG9hdCgwLjAsIDEuMCk7XHJcblxyXG5cdFx0XHR0aGlzLmJyZWFrUG9pbnQgPSByYW5kb21JbnQoMTIwLCAyNDApO1xyXG5cdFx0XHR0aGlzLmNvdW50ZXIgPSAwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZihjb3VudGVyICUgYnJlYWtQb2ludCA8IGJyZWFrUG9pbnQgLyA1IHx8IG1vZGUgPT09IEdsaXRjaE1vZGUuQ09OU1RBTlRfTUlMRCkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5hbW91bnQudmFsdWUgPSBNYXRoLnJhbmRvbSgpIC8gOTAuMDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5hbmdsZS52YWx1ZSA9IHJhbmRvbUZsb2F0KC1NYXRoLlBJLCBNYXRoLlBJKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXN0b3J0aW9uWC52YWx1ZSA9IHJhbmRvbUZsb2F0KDAuMCwgMS4wKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXN0b3J0aW9uWS52YWx1ZSA9IHJhbmRvbUZsb2F0KDAuMCwgMS4wKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5zZWVkWC52YWx1ZSA9IHJhbmRvbUZsb2F0KC0wLjMsIDAuMyk7XHJcblx0XHRcdFx0dW5pZm9ybXMuc2VlZFkudmFsdWUgPSByYW5kb21GbG9hdCgtMC4zLCAwLjMpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gU3BvcmFkaWMuXHJcblx0XHRcdFx0dW5pZm9ybXMuYWN0aXZlLnZhbHVlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdCsrdGhpcy5jb3VudGVyO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGdsaXRjaCBtb2RlIGVudW1lcmF0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gU1BPUkFESUMgLSBTcG9yYWRpYyBnbGl0Y2hlcy5cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IENPTlNUQU5UX01JTEQgLSBDb25zdGFudCBtaWxkIGdsaXRjaGVzLlxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ09OU1RBTlRfV0lMRCAtIENvbnN0YW50IHdpbGQgZ2xpdGNoZXMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IEdsaXRjaE1vZGUgPSB7XHJcblxyXG5cdFNQT1JBRElDOiAwLFxyXG5cdENPTlNUQU5UX01JTEQ6IDEsXHJcblx0Q09OU1RBTlRfV0lMRDogMlxyXG5cclxufTtcclxuIiwiaW1wb3J0IHsgQ2xlYXJQYXNzIH0gZnJvbSBcIi4vQ2xlYXJQYXNzLmpzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBwYXNzIHRoYXQgcmVuZGVycyBhIGdpdmVuIHNjZW5lIGRpcmVjdGx5IG9uIHNjcmVlbiBvciBpbnRvIHRoZSByZWFkIGJ1ZmZlclxyXG4gKiBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBSZW5kZXJQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcmVuZGVyIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXHJcblx0ICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBjYW1lcmEgdG8gdXNlIHRvIHJlbmRlciB0aGUgc2NlbmUuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5vdmVycmlkZU1hdGVyaWFsPW51bGxdIC0gQW4gb3ZlcnJpZGUgbWF0ZXJpYWwgZm9yIHRoZSBzY2VuZS5cclxuXHQgKiBAcGFyYW0ge0NvbG9yfSBbb3B0aW9ucy5jbGVhckNvbG9yPW51bGxdIC0gQW4gb3ZlcnJpZGUgY2xlYXIgY29sb3IuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsZWFyQWxwaGE9MS4wXSAtIEFuIG92ZXJyaWRlIGNsZWFyIGFscGhhLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xlYXJEZXB0aD1mYWxzZV0gLSBXaGV0aGVyIGRlcHRoIHNob3VsZCBiZSBjbGVhcmVkIGV4cGxpY2l0bHkuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGVhcj10cnVlXSAtIFdoZXRoZXIgYWxsIGJ1ZmZlcnMgc2hvdWxkIGJlIGNsZWFyZWQuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKHNjZW5lLCBjYW1lcmEsIG51bGwpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJSZW5kZXJQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGNsZWFyIHBhc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0NsZWFyUGFzc31cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyhvcHRpb25zKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEFuIG92ZXJyaWRlIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtNYXRlcmlhbH1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IChvcHRpb25zLm92ZXJyaWRlTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLm92ZXJyaWRlTWF0ZXJpYWwgOiBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlcHRoIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZCBleHBsaWNpdGx5LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IChvcHRpb25zLmNsZWFyRGVwdGggIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmNsZWFyRGVwdGggOiBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjb2xvciwgZGVwdGggYW5kIHN0ZW5jaWwgYnVmZmVycyBzaG91bGQgYmUgY2xlYXJlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBFdmVuIHdpdGggY2xlYXIgc2V0IHRvIHRydWUgeW91IGNhbiBwcmV2ZW50IHNwZWNpZmljIGJ1ZmZlcnMgZnJvbSBiZWluZ1xyXG5cdFx0ICogY2xlYXJlZCBieSBzZXR0aW5nIGVpdGhlciB0aGUgYXV0b0NsZWFyQ29sb3IsIGF1dG9DbGVhclN0ZW5jaWwgb3JcclxuXHRcdCAqIGF1dG9DbGVhckRlcHRoIHByb3BlcnRpZXMgb2YgdGhlIHJlbmRlcmVyIHRvIGZhbHNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jbGVhciA9IChvcHRpb25zLmNsZWFyICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5jbGVhciA6IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgc2NlbmUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlcikge1xyXG5cclxuXHRcdGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcclxuXHRcdGNvbnN0IHRhcmdldCA9IHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogcmVhZEJ1ZmZlcjtcclxuXHJcblx0XHRpZih0aGlzLmNsZWFyKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRhcmdldCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmKHRoaXMuY2xlYXJEZXB0aCkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRhcmdldCk7XHJcblx0XHRcdHJlbmRlcmVyLmNsZWFyRGVwdGgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbDtcclxuXHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgdGhpcy5jYW1lcmEsIHRhcmdldCk7XHJcblx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG5cdENvbG9yLFxyXG5cdExpbmVhckZpbHRlcixcclxuXHRNZXNoQmFzaWNNYXRlcmlhbCxcclxuXHRSR0JGb3JtYXQsXHJcblx0U2NlbmUsXHJcblx0VmVjdG9yMyxcclxuXHRXZWJHTFJlbmRlclRhcmdldFxyXG59IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuaW1wb3J0IHsgQ29tYmluZU1hdGVyaWFsLCBHb2RSYXlzTWF0ZXJpYWwsIEtlcm5lbFNpemUgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFJlbmRlclBhc3MgfSBmcm9tIFwiLi9SZW5kZXJQYXNzLmpzXCI7XHJcbmltcG9ydCB7IEJsdXJQYXNzIH0gZnJvbSBcIi4vQmx1clBhc3MuanNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBDbGFtcHMgYSBnaXZlbiB2YWx1ZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2xhbXAuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gLSBUaGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IC0gVGhlIGhpZ2hlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNsYW1wZWQgdmFsdWUuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XHJcblxyXG5cdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGNyZXB1c2N1bGFyIHJheXMgcGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgR29kUmF5c1Bhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBnb2QgcmF5cyBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgbWFpbiBzY2VuZS5cclxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IGxpZ2h0U291cmNlIC0gVGhlIG1haW4gbGlnaHQgc291cmNlLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVuc2l0eT0wLjk2XSAtIFRoZSBkZW5zaXR5IG9mIHRoZSBsaWdodCByYXlzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZWNheT0wLjkzXSAtIEFuIGlsbHVtaW5hdGlvbiBkZWNheSBmYWN0b3IuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndlaWdodD0wLjRdIC0gQSBsaWdodCByYXkgd2VpZ2h0IGZhY3Rvci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZXhwb3N1cmU9MC42XSAtIEEgY29uc3RhbnQgYXR0ZW51YXRpb24gY29lZmZpY2llbnQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsYW1wTWF4PTEuMF0gLSBBbiB1cHBlciBib3VuZCBmb3IgdGhlIHNhdHVyYXRpb24gb2YgdGhlIG92ZXJhbGwgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIEEgY29uc3RhbnQgZmFjdG9yIGZvciBhZGRpdGl2ZSBibGVuZGluZy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVuZGVyIHRleHR1cmUgcmVzb2x1dGlvbiBzY2FsZSwgcmVsYXRpdmUgdG8gdGhlIHNjcmVlbiByZW5kZXIgc2l6ZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLkxBUkdFXSAtIFRoZSBibHVyIGtlcm5lbCBzaXplLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzPTYwXSAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjcmVlbk1vZGU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBzY3JlZW4gYmxlbmQgbW9kZSBzaG91bGQgYmUgdXNlZCBmb3IgY29tYmluaW5nIHRoZSBnb2QgcmF5cyB0ZXh0dXJlIHdpdGggdGhlIHNjZW5lIGNvbG9ycy5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwgbGlnaHRTb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkdvZFJheXNQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzY2VuZSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGxpZ2h0IHNvdXJjZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2NlbmV9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5saWdodFNjZW5lID0gbmV3IFNjZW5lKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbWFpbiBzY2VuZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2NlbmV9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5tYWluU2NlbmUgPSBzY2VuZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBtYWluIGNhbWVyYS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q2FtZXJhfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubWFpbkNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcGFzcyB0aGF0IG9ubHkgcmVuZGVycyB0aGUgbGlnaHQgc291cmNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtSZW5kZXJQYXNzfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyUGFzc0xpZ2h0ID0gbmV3IFJlbmRlclBhc3ModGhpcy5saWdodFNjZW5lLCB0aGlzLm1haW5DYW1lcmEpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBwYXNzIHRoYXQgcmVuZGVycyB0aGUgbWFza2VkIHNjZW5lIG92ZXIgdGhlIGxpZ2h0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtSZW5kZXJQYXNzfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyUGFzc01hc2sgPSBuZXcgUmVuZGVyUGFzcyh0aGlzLm1haW5TY2VuZSwgdGhpcy5tYWluQ2FtZXJhLCB7XHJcblx0XHRcdG92ZXJyaWRlTWF0ZXJpYWw6IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweDAwMDAwMCB9KSxcclxuXHRcdFx0Y2xlYXJDb2xvcjogbmV3IENvbG9yKDB4MDAwMDAwKVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJQYXNzTWFzay5jbGVhciA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBibHVyIHBhc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0JsdXJQYXNzfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuYmx1clBhc3MgPSBuZXcgQmx1clBhc3Mob3B0aW9ucyk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlbmRlciB0YXJnZXQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCB7XHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0c3RlbmNpbEJ1ZmZlcjogZmFsc2UsXHJcblx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRYLnRleHR1cmUubmFtZSA9IFwiR29kUmF5cy5UYXJnZXRYXCI7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFgudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgc2Vjb25kIHJlbmRlciB0YXJnZXQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WSA9IHRoaXMucmVuZGVyVGFyZ2V0WC5jbG9uZSgpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WS50ZXh0dXJlLm5hbWUgPSBcIkdvZFJheXMuVGFyZ2V0WVwiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZW5kZXIgdGFyZ2V0IGZvciB0aGUgbWFza2VkIGxpZ2h0IHNjZW5lLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldE1hc2sgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoMSwgMSwge1xyXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0bWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXJcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0TWFzay50ZXh0dXJlLm5hbWUgPSBcIkdvZFJheXMuTWFza1wiO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRNYXNrLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbGlnaHQgc291cmNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3QzRH1cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubGlnaHRTb3VyY2UgPSBsaWdodFNvdXJjZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBsaWdodCBwb3NpdGlvbiBpbiBzY3JlZW4gc3BhY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5zY3JlZW5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGdvZCByYXlzIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7R29kUmF5c01hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuZ29kUmF5c01hdGVyaWFsID0gbmV3IEdvZFJheXNNYXRlcmlhbCgpO1xyXG5cdFx0dGhpcy5nb2RSYXlzTWF0ZXJpYWwudW5pZm9ybXMubGlnaHRQb3NpdGlvbi52YWx1ZSA9IHRoaXMuc2NyZWVuUG9zaXRpb247XHJcblxyXG5cdFx0aWYob3B0aW9ucy5leHBvc3VyZSAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuZ29kUmF5c01hdGVyaWFsLnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlID0gb3B0aW9ucy5leHBvc3VyZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5kZW5zaXR5ICE9PSB1bmRlZmluZWQpIHsgdGhpcy5nb2RSYXlzTWF0ZXJpYWwudW5pZm9ybXMuZGVuc2l0eS52YWx1ZSA9IG9wdGlvbnMuZGVuc2l0eTsgfVxyXG5cdFx0aWYob3B0aW9ucy5kZWNheSAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuZ29kUmF5c01hdGVyaWFsLnVuaWZvcm1zLmRlY2F5LnZhbHVlID0gb3B0aW9ucy5kZWNheTsgfVxyXG5cdFx0aWYob3B0aW9ucy53ZWlnaHQgIT09IHVuZGVmaW5lZCkgeyB0aGlzLmdvZFJheXNNYXRlcmlhbC51bmlmb3Jtcy53ZWlnaHQudmFsdWUgPSBvcHRpb25zLndlaWdodDsgfVxyXG5cdFx0aWYob3B0aW9ucy5jbGFtcE1heCAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuZ29kUmF5c01hdGVyaWFsLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlID0gb3B0aW9ucy5jbGFtcE1heDsgfVxyXG5cclxuXHRcdHRoaXMuc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgY29tYmluZSBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0NvbWJpbmVNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvbWJpbmVNYXRlcmlhbCA9IG5ldyBDb21iaW5lTWF0ZXJpYWwoKG9wdGlvbnMuc2NyZWVuTW9kZSAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuc2NyZWVuTW9kZSA6IHRydWUpO1xyXG5cclxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gb3B0aW9ucy5pbnRlbnNpdHk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlc29sdXRpb24gc2NhbGUuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDAuNVxyXG5cdCAqL1xyXG5cclxuXHRnZXQgcmVzb2x1dGlvblNjYWxlKCkgeyByZXR1cm4gdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uU2NhbGU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogWW91IG5lZWQgdG8gY2FsbCB7QGxpbmsgRWZmZWN0Q29tcG9zZXIjc2V0U2l6ZX0gYWZ0ZXIgY2hhbmdpbmcgdGhpcyB2YWx1ZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCByZXNvbHV0aW9uU2NhbGUoeCA9IDAuNSkgeyB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb25TY2FsZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGJsdXIga2VybmVsIHNpemUuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7S2VybmVsU2l6ZX1cclxuXHQgKiBAZGVmYXVsdCBLZXJuZWxTaXplLkxBUkdFXHJcblx0ICovXHJcblxyXG5cdGdldCBrZXJuZWxTaXplKCkgeyByZXR1cm4gdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtLZXJuZWxTaXplfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQga2VybmVsU2l6ZSh4ID0gS2VybmVsU2l6ZS5MQVJHRSkgeyB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB4OyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBvdmVyYWxsIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAZGVmYXVsdCAxLjBcclxuXHQgKi9cclxuXHJcblx0Z2V0IGludGVuc2l0eSgpIHsgcmV0dXJuIHRoaXMuY29tYmluZU1hdGVyaWFsLnVuaWZvcm1zLm9wYWNpdHkyLnZhbHVlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCBpbnRlbnNpdHkoeCA9IDEuMCkgeyB0aGlzLmNvbWJpbmVNYXRlcmlhbC51bmlmb3Jtcy5vcGFjaXR5Mi52YWx1ZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgNjBcclxuXHQgKi9cclxuXHJcblx0Z2V0IHNhbXBsZXMoKSB7IHJldHVybiBOdW1iZXIucGFyc2VJbnQodGhpcy5nb2RSYXlzTWF0ZXJpYWwuZGVmaW5lcy5OVU1fU0FNUExFU19JTlQpOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgdmFsdWUgbXVzdCBiZSBjYXJlZnVsbHkgY2hvc2VuLiBBIGhpZ2hlciB2YWx1ZSBkaXJlY3RseSBpbmNyZWFzZXMgdGhlXHJcblx0ICogR1BVIGxvYWQuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgc2FtcGxlcyh4ID0gNjApIHtcclxuXHJcblx0XHR4ID0gTWF0aC5mbG9vcih4KTtcclxuXHJcblx0XHR0aGlzLmdvZFJheXNNYXRlcmlhbC5kZWZpbmVzLk5VTV9TQU1QTEVTX0ZMT0FUID0geC50b0ZpeGVkKDEpO1xyXG5cdFx0dGhpcy5nb2RSYXlzTWF0ZXJpYWwuZGVmaW5lcy5OVU1fU0FNUExFU19JTlQgPSB4LnRvRml4ZWQoMCk7XHJcblx0XHR0aGlzLmdvZFJheXNNYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgc2NlbmUuXHJcblx0ICpcclxuXHQgKiBUaGUgZ29kIHJheXMgcGFzcyBoYXMgZm91ciBwaGFzZXM6XHJcblx0ICpcclxuXHQgKiBNYXNrIFBoYXNlOlxyXG5cdCAqICBGaXJzdCwgdGhlIGxpZ2h0IHNvdXJjZSBpcyByZW5kZXJlZC4gVGhlbiB0aGUgc2NlbmUgaXMgcmVuZGVyZWQgaW50byB0aGVcclxuXHQgKiAgc2FtZSBidWZmZXIgdXNpbmcgYSBtYXNrIG92ZXJyaWRlIG1hdGVyaWFsIHdpdGggZGVwdGggdGVzdCBlbmFibGVkLlxyXG5cdCAqXHJcblx0ICogUHJlbGltaW5hcnkgQmx1ciBQaGFzZTpcclxuXHQgKiAgVGhlIG1hc2tlZCBzY2VuZSBpcyBibHVycmVkLlxyXG5cdCAqXHJcblx0ICogR29kIFJheXMgUGhhc2U6XHJcblx0ICogIFRoZSBibHVycmVkIHNjZW5lIGlzIGJsdXJyZWQgYWdhaW4sIGJ1dCB0aGlzIHRpbWUgYWxvbmcgcmFkaWFsIGxpbmVzXHJcblx0ICogIHRvd2FyZHMgdGhlIGxpZ2h0IHNvdXJjZS5cclxuXHQgKlxyXG5cdCAqIENvbXBvc2l0ZSBQaGFzZTpcclxuXHQgKiAgVGhlIGZpbmFsIHJlc3VsdCBpcyBjb21iaW5lZCB3aXRoIHRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpIHtcclxuXHJcblx0XHRjb25zdCBxdWFkID0gdGhpcy5xdWFkO1xyXG5cdFx0Y29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xyXG5cdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XHJcblx0XHRjb25zdCBtYWluU2NlbmUgPSB0aGlzLm1haW5TY2VuZTtcclxuXHJcblx0XHRjb25zdCBsaWdodFNvdXJjZSA9IHRoaXMubGlnaHRTb3VyY2U7XHJcblx0XHRjb25zdCBzY3JlZW5Qb3NpdGlvbiA9IHRoaXMuc2NyZWVuUG9zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgZ29kUmF5c01hdGVyaWFsID0gdGhpcy5nb2RSYXlzTWF0ZXJpYWw7XHJcblx0XHRjb25zdCBjb21iaW5lTWF0ZXJpYWwgPSB0aGlzLmNvbWJpbmVNYXRlcmlhbDtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRNYXNrID0gdGhpcy5yZW5kZXJUYXJnZXRNYXNrO1xyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0WCA9IHRoaXMucmVuZGVyVGFyZ2V0WDtcclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFkgPSB0aGlzLnJlbmRlclRhcmdldFk7XHJcblxyXG5cdFx0bGV0IGJhY2tncm91bmQsIHBhcmVudDtcclxuXHJcblx0XHQvLyBDb21wdXRlIHRoZSBzY3JlZW4gbGlnaHQgcG9zaXRpb24gYW5kIHRyYW5zbGF0ZSBpdCB0byBbMCwgMV0uXHJcblx0XHRzY3JlZW5Qb3NpdGlvbi5jb3B5KGxpZ2h0U291cmNlLnBvc2l0aW9uKS5wcm9qZWN0KHRoaXMubWFpbkNhbWVyYSk7XHJcblx0XHRzY3JlZW5Qb3NpdGlvbi54ID0gY2xhbXAoKHNjcmVlblBvc2l0aW9uLnggKyAxLjApICogMC41LCAwLjAsIDEuMCk7XHJcblx0XHRzY3JlZW5Qb3NpdGlvbi55ID0gY2xhbXAoKHNjcmVlblBvc2l0aW9uLnkgKyAxLjApICogMC41LCAwLjAsIDEuMCk7XHJcblxyXG5cdFx0Ly8gUmVuZGVyIHRoZSBtYXNrZWQgc2NlbmUuXHJcblx0XHRwYXJlbnQgPSBsaWdodFNvdXJjZS5wYXJlbnQ7XHJcblx0XHRiYWNrZ3JvdW5kID0gbWFpblNjZW5lLmJhY2tncm91bmQ7XHJcblx0XHRtYWluU2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XHJcblx0XHR0aGlzLmxpZ2h0U2NlbmUuYWRkKGxpZ2h0U291cmNlKTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclBhc3NMaWdodC5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldE1hc2spO1xyXG5cdFx0dGhpcy5yZW5kZXJQYXNzTWFzay5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldE1hc2spO1xyXG5cclxuXHRcdGlmKHBhcmVudCAhPT0gbnVsbCkge1xyXG5cclxuXHRcdFx0cGFyZW50LmFkZChsaWdodFNvdXJjZSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1haW5TY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcclxuXHJcblx0XHQvLyBDb252b2x1dGlvbiBwaGFzZS5cclxuXHRcdHRoaXMuYmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRNYXNrLCByZW5kZXJUYXJnZXRYKTtcclxuXHJcblx0XHQvLyBHb2QgcmF5cyBwYXNzLlxyXG5cdFx0cXVhZC5tYXRlcmlhbCA9IGdvZFJheXNNYXRlcmlhbDtcclxuXHRcdGdvZFJheXNNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlbmRlclRhcmdldFgudGV4dHVyZTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXRZKTtcclxuXHJcblx0XHQvLyBGaW5hbCBwYXNzIC0gY29tcG9zaXRlIGdvZCByYXlzIG9udG8gY29sb3Vycy5cclxuXHRcdHF1YWQubWF0ZXJpYWwgPSBjb21iaW5lTWF0ZXJpYWw7XHJcblx0XHRjb21iaW5lTWF0ZXJpYWwudW5pZm9ybXMudGV4dHVyZTEudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblx0XHRjb21iaW5lTWF0ZXJpYWwudW5pZm9ybXMudGV4dHVyZTIudmFsdWUgPSByZW5kZXJUYXJnZXRZLnRleHR1cmU7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkanVzdHMgdGhlIGZvcm1hdCBvZiB0aGUgcmVuZGVyIHRhcmdldHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlclBhc3NMaWdodC5pbml0aWFsaXNlKHJlbmRlcmVyLCBhbHBoYSk7XHJcblx0XHR0aGlzLnJlbmRlclBhc3NNYXNrLmluaXRpYWxpc2UocmVuZGVyZXIsIGFscGhhKTtcclxuXHRcdHRoaXMuYmx1clBhc3MuaW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpO1xyXG5cclxuXHRcdGlmKCFhbHBoYSkge1xyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJUYXJnZXRNYXNrLnRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0O1xyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldFgudGV4dHVyZS5mb3JtYXQgPSBSR0JGb3JtYXQ7XHJcblx0XHRcdHRoaXMucmVuZGVyVGFyZ2V0WS50ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlclBhc3NMaWdodC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0dGhpcy5yZW5kZXJQYXNzTWFzay5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0dGhpcy5ibHVyUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdHdpZHRoID0gdGhpcy5ibHVyUGFzcy53aWR0aDtcclxuXHRcdGhlaWdodCA9IHRoaXMuYmx1clBhc3MuaGVpZ2h0O1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRYLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFkuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWFzayBwYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBNYXNrUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG1hc2sgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lIHRvIHJlbmRlci5cclxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEpIHtcclxuXHJcblx0XHRzdXBlcihzY2VuZSwgY2FtZXJhLCBudWxsKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiTWFza1Bhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEludmVyc2UgZmxhZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmludmVyc2UgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFN0ZW5jaWwgYnVmZmVyIGNsZWFyIGZsYWcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNsZWFyU3RlbmNpbCA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIHN0ZW5jaWwgYml0IG1hc2suXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKSB7XHJcblxyXG5cdFx0Y29uc3QgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblx0XHRjb25zdCBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xyXG5cclxuXHRcdGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcclxuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG5cclxuXHRcdGNvbnN0IHdyaXRlVmFsdWUgPSB0aGlzLmludmVyc2UgPyAwIDogMTtcclxuXHRcdGNvbnN0IGNsZWFyVmFsdWUgPSAxIC0gd3JpdGVWYWx1ZTtcclxuXHJcblx0XHQvLyBEb24ndCB1cGRhdGUgY29sb3Igb3IgZGVwdGguXHJcblx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2soZmFsc2UpO1xyXG5cdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKGZhbHNlKTtcclxuXHJcblx0XHQvLyBMb2NrIHRoZSBidWZmZXJzLlxyXG5cdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRMb2NrZWQodHJ1ZSk7XHJcblx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldExvY2tlZCh0cnVlKTtcclxuXHJcblx0XHQvLyBDb25maWd1cmUgdGhlIHN0ZW5jaWwuXHJcblx0XHRzdGF0ZS5idWZmZXJzLnN0ZW5jaWwuc2V0VGVzdCh0cnVlKTtcclxuXHRcdHN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRPcChjb250ZXh0LlJFUExBQ0UsIGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFKTtcclxuXHRcdHN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRGdW5jKGNvbnRleHQuQUxXQVlTLCB3cml0ZVZhbHVlLCAweGZmZmZmZmZmKTtcclxuXHRcdHN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRDbGVhcihjbGVhclZhbHVlKTtcclxuXHJcblx0XHQvLyBDbGVhciB0aGUgc3RlbmNpbC5cclxuXHRcdGlmKHRoaXMuY2xlYXJTdGVuY2lsKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVhZEJ1ZmZlcik7XHJcblx0XHRcdHJlbmRlcmVyLmNsZWFyU3RlbmNpbCgpO1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHdyaXRlQnVmZmVyKTtcclxuXHRcdFx0cmVuZGVyZXIuY2xlYXJTdGVuY2lsKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERyYXcgdGhlIG1hc2sgaW50byBib3RoIGJ1ZmZlcnMuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgcmVhZEJ1ZmZlcik7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgd3JpdGVCdWZmZXIpO1xyXG5cclxuXHRcdC8vIFVubG9jayB0aGUgYnVmZmVycy5cclxuXHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0TG9ja2VkKGZhbHNlKTtcclxuXHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TG9ja2VkKGZhbHNlKTtcclxuXHJcblx0XHQvLyBPbmx5IHJlbmRlciB3aGVyZSB0aGUgc3RlbmNpbCBpcyBzZXQgdG8gMS5cclxuXHRcdHN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRGdW5jKGNvbnRleHQuRVFVQUwsIDEsIDB4ZmZmZmZmZmYpO1xyXG5cdFx0c3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldE9wKGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFBpeGVsYXRpb25NYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBpeGVsYXRpb24gcGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgUGl4ZWxhdGlvblBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwaXhlbGF0aW9uIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2dyYW51bGFyaXR5PTMwLjBdIC0gVGhlIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihncmFudWxhcml0eSA9IDMwLjApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJQaXhlbGF0aW9uUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcGl4ZWxhdGlvbiBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1BpeGVsYXRpb25NYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnBpeGVsYXRpb25NYXRlcmlhbCA9IG5ldyBQaXhlbGF0aW9uTWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLmdyYW51bGFyaXR5ID0gZ3JhbnVsYXJpdHk7XHJcblxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5waXhlbGF0aW9uTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHBpeGVsIGdyYW51bGFyaXR5LlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAZGVmYXVsdCAzMC4wXHJcblx0ICovXHJcblxyXG5cdGdldCBncmFudWxhcml0eSgpIHsgcmV0dXJuIHRoaXMucGl4ZWxhdGlvbk1hdGVyaWFsLmdyYW51bGFyaXR5OyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgaGlnaGVyIHZhbHVlIHlpZWxkcyBjb2Fyc2VyIHZpc3VhbHMuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgZ3JhbnVsYXJpdHkoeCA9IDMwKSB7XHJcblxyXG5cdFx0eCA9IE1hdGguZmxvb3IoeCk7XHJcblxyXG5cdFx0aWYoeCAlIDIgPiAwKSB7XHJcblxyXG5cdFx0XHR4ICs9IDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucGl4ZWxhdGlvbk1hdGVyaWFsLmdyYW51bGFyaXR5ID0geDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKSB7XHJcblxyXG5cdFx0dGhpcy5waXhlbGF0aW9uTWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgcGFzcyB3aXRoIHRoZSByZW5kZXJlcidzIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG5cclxuXHRcdHRoaXMucGl4ZWxhdGlvbk1hdGVyaWFsLnNldFJlc29sdXRpb24od2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgTGluZWFyRmlsdGVyLCBSR0JGb3JtYXQsIFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSBcInRocmVlXCI7XHJcbmltcG9ydCB7IENvcHlNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBhc3MgdGhhdCByZW5kZXJzIHRoZSByZXN1bHQgZnJvbSBhIHByZXZpb3VzIHBhc3MgdG8gYW5vdGhlciByZW5kZXIgdGFyZ2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBTYXZlUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNhdmUgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtyZW5kZXJUYXJnZXRdIC0gVGhlIHJlbmRlciB0YXJnZXQgdG8gdXNlIGZvciBzYXZpbmcgdGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jlc2l6ZT10cnVlXSAtIFdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2hvdWxkIGFkanVzdCB0byB0aGUgc2l6ZSBvZiB0aGUgcmVhZC93cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHJlbmRlclRhcmdldCwgcmVzaXplID0gdHJ1ZSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIlNhdmVQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDb3B5IHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q29weU1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgQ29weU1hdGVyaWFsKCk7XHJcblxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gKHJlbmRlclRhcmdldCAhPT0gdW5kZWZpbmVkKSA/IHJlbmRlclRhcmdldCA6IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCB7XHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0c3RlbmNpbEJ1ZmZlcjogZmFsc2UsXHJcblx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJTYXZlLlRhcmdldFwiO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBiZSByZXNpemVkIHdoZW4gdGhlIHNpemUgb2ZcclxuXHRcdCAqIHRoZSBjb21wb3NlcidzIHJlYWQvd3JpdGUgYnVmZmVyIGNoYW5nZXMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlc2l6ZSA9IHJlc2l6ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTYXZlcyB0aGUgcmVhZCBidWZmZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlcikge1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRhcmdldCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRqdXN0cyB0aGUgZm9ybWF0IG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpc2UocmVuZGVyZXIsIGFscGhhKSB7XHJcblxyXG5cdFx0aWYoIWFscGhhKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHRpZih0aGlzLnJlc2l6ZSkge1xyXG5cclxuXHRcdFx0d2lkdGggPSBNYXRoLm1heCgxLCB3aWR0aCk7XHJcblx0XHRcdGhlaWdodCA9IE1hdGgubWF4KDEsIGhlaWdodCk7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgc2hhZGVyIHBhc3MuXHJcbiAqXHJcbiAqIFVzZWQgdG8gcmVuZGVyIGFueSBzaGFkZXIgbWF0ZXJpYWwgYXMgYSAyRCBmaWx0ZXIuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFNoYWRlclBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzaGFkZXIgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U2hhZGVyTWF0ZXJpYWx9IG1hdGVyaWFsIC0gVGhlIHNoYWRlciBtYXRlcmlhbCB0byB1c2UuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0dXJlSUQ9XCJ0RGlmZnVzZVwiXSAtIFRoZSB0ZXh0dXJlIHVuaWZvcm0gaWRlbnRpZmllci5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IobWF0ZXJpYWwsIHRleHR1cmVJRCA9IFwidERpZmZ1c2VcIikge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIlNoYWRlclBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgc2hhZGVyIG1hdGVyaWFsIHRvIHVzZSBmb3IgcmVuZGVyaW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTaGFkZXJNYXRlcmlhbH1cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIGNvbG9yIHNhbXBsZXIgdW5pZm9ybSBvZiB0aGUgZ2l2ZW4gbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0IFwidERpZmZ1c2VcIlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlSUQgPSB0ZXh0dXJlSUQ7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdGlmKHRoaXMubWF0ZXJpYWwudW5pZm9ybXNbdGhpcy50ZXh0dXJlSURdICE9PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdHRoaXMubWF0ZXJpYWwudW5pZm9ybXNbdGhpcy50ZXh0dXJlSURdLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcclxuaW1wb3J0IHsgQ29weU1hdGVyaWFsLCBTaG9ja1dhdmVNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBIYWxmIFBJLlxyXG4gKlxyXG4gKiBAdHlwZSB7TnVtYmVyfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBmaW5hbFxyXG4gKi9cclxuXHJcbmNvbnN0IEhBTEZfUEkgPSBNYXRoLlBJICogMC41O1xyXG5cclxuLyoqXHJcbiAqIEEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAdHlwZSB7VmVjdG9yM31cclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAZmluYWxcclxuICovXHJcblxyXG5jb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcbi8qKlxyXG4gKiBBIHZlY3Rvci5cclxuICpcclxuICogQHR5cGUge1ZlY3RvcjN9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQGZpbmFsXHJcbiAqL1xyXG5cclxuY29uc3QgYWIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuLyoqXHJcbiAqIEEgc2hvY2sgd2F2ZSBwYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBTaG9ja1dhdmVQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2hvY2sgd2F2ZSBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS5cclxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFtlcGljZW50ZXJdIC0gVGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlIGVwaWNlbnRlci5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNwZWVkPTEuMF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSYWRpdXM9MS4wXSAtIFRoZSBleHRlbnQgb2YgdGhlIHNob2NrIHdhdmUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndhdmVTaXplPTAuMl0gLSBUaGUgd2F2ZSBzaXplLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbXBsaXR1ZGU9MC4wNV0gLSBUaGUgZGlzdG9ydGlvbiBhbXBsaXR1ZGUuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKGNhbWVyYSwgZXBpY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiU2hvY2tXYXZlUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBtYWluIGNhbWVyYS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0M0R9XHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm1haW5DYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZXBpY2VudGVyLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxyXG5cdFx0ICogQGV4YW1wbGUgc2hvY2tXYXZlUGFzcy5lcGljZW50ZXIgPSBteU1lc2gucG9zaXRpb247XHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmVwaWNlbnRlciA9IGVwaWNlbnRlcjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBvYmplY3QgcG9zaXRpb24gaW4gc2NyZWVuIHNwYWNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtWZWN0b3IzfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuc2NyZWVuUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNwZWVkIG9mIHRoZSBzaG9jayB3YXZlIGFuaW1hdGlvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMi4wXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnNwZWVkID0gKG9wdGlvbnMuc3BlZWQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLnNwZWVkIDogMi4wO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSB0aW1lIGFjY3VtdWxhdG9yLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy50aW1lID0gMC4wO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNob2NrIHdhdmUgYW5pbWF0aW9uIGlzIGFjdGl2ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzaG9jayB3YXZlIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2hvY2tXYXZlTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5zaG9ja1dhdmVNYXRlcmlhbCA9IG5ldyBTaG9ja1dhdmVNYXRlcmlhbChvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLnNob2NrV2F2ZU1hdGVyaWFsLnVuaWZvcm1zLmNlbnRlci52YWx1ZSA9IHRoaXMuc2NyZWVuUG9zaXRpb247XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGNvcHkgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDb3B5TWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jb3B5TWF0ZXJpYWwgPSBuZXcgQ29weU1hdGVyaWFsKCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHMgdGhlIHNob2NrIHdhdmUuXHJcblx0ICovXHJcblxyXG5cdGV4cGxvZGUoKSB7XHJcblxyXG5cdFx0dGhpcy50aW1lID0gMC4wO1xyXG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIC0gVGhlIHJlbmRlciBkZWx0YSB0aW1lLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyLCBkZWx0YSkge1xyXG5cclxuXHRcdGNvbnN0IGVwaWNlbnRlciA9IHRoaXMuZXBpY2VudGVyO1xyXG5cdFx0Y29uc3QgbWFpbkNhbWVyYSA9IHRoaXMubWFpbkNhbWVyYTtcclxuXHRcdGNvbnN0IHNjcmVlblBvc2l0aW9uID0gdGhpcy5zY3JlZW5Qb3NpdGlvbjtcclxuXHJcblx0XHRjb25zdCBzaG9ja1dhdmVNYXRlcmlhbCA9IHRoaXMuc2hvY2tXYXZlTWF0ZXJpYWw7XHJcblx0XHRjb25zdCB1bmlmb3JtcyA9IHNob2NrV2F2ZU1hdGVyaWFsLnVuaWZvcm1zO1xyXG5cdFx0Y29uc3QgY2VudGVyID0gdW5pZm9ybXMuY2VudGVyO1xyXG5cdFx0Y29uc3QgcmFkaXVzID0gdW5pZm9ybXMucmFkaXVzO1xyXG5cdFx0Y29uc3QgbWF4UmFkaXVzID0gdW5pZm9ybXMubWF4UmFkaXVzO1xyXG5cdFx0Y29uc3Qgd2F2ZVNpemUgPSB1bmlmb3Jtcy53YXZlU2l6ZTtcclxuXHJcblx0XHR0aGlzLmNvcHlNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xyXG5cclxuXHRcdGlmKHRoaXMuYWN0aXZlKSB7XHJcblxyXG5cdFx0XHQvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHZlY3RvcnMuXHJcblx0XHRcdG1haW5DYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24odik7XHJcblx0XHRcdGFiLmNvcHkobWFpbkNhbWVyYS5wb3NpdGlvbikuc3ViKGVwaWNlbnRlcik7XHJcblxyXG5cdFx0XHQvLyBEb24ndCByZW5kZXIgdGhlIGVmZmVjdCBpZiB0aGUgb2JqZWN0IGlzIGJlaGluZCB0aGUgY2FtZXJhLlxyXG5cdFx0XHRpZih2LmFuZ2xlVG8oYWIpID4gSEFMRl9QSSkge1xyXG5cclxuXHRcdFx0XHQvLyBTY2FsZSB0aGUgZWZmZWN0IGJhc2VkIG9uIGRpc3RhbmNlIHRvIHRoZSBvYmplY3QuXHJcblx0XHRcdFx0dW5pZm9ybXMuY2FtZXJhRGlzdGFuY2UudmFsdWUgPSBtYWluQ2FtZXJhLnBvc2l0aW9uLmRpc3RhbmNlVG8oZXBpY2VudGVyKTtcclxuXHJcblx0XHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBzY3JlZW4gcG9zaXRpb24gb2YgdGhlIGVwaWNlbnRlci5cclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi5jb3B5KGVwaWNlbnRlcikucHJvamVjdChtYWluQ2FtZXJhKTtcclxuXHRcdFx0XHRjZW50ZXIudmFsdWUueCA9IChzY3JlZW5Qb3NpdGlvbi54ICsgMS4wKSAqIDAuNTtcclxuXHRcdFx0XHRjZW50ZXIudmFsdWUueSA9IChzY3JlZW5Qb3NpdGlvbi55ICsgMS4wKSAqIDAuNTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblx0XHRcdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gc2hvY2tXYXZlTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgdGhlIHNob2NrIHdhdmUgcmFkaXVzIGJhc2VkIG9uIHRpbWUuXHJcblx0XHRcdHRoaXMudGltZSArPSBkZWx0YSAqIHRoaXMuc3BlZWQ7XHJcblx0XHRcdHJhZGl1cy52YWx1ZSA9IHRoaXMudGltZSAtIHdhdmVTaXplLnZhbHVlO1xyXG5cclxuXHRcdFx0aWYocmFkaXVzLnZhbHVlID49IChtYXhSYWRpdXMudmFsdWUgKyB3YXZlU2l6ZS52YWx1ZSkgKiAyKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR0aGlzLnNob2NrV2F2ZU1hdGVyaWFsLnVuaWZvcm1zLmFzcGVjdC52YWx1ZSA9IHdpZHRoIC8gaGVpZ2h0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7XHJcblx0TGluZWFyRmlsdGVyLFxyXG5cdE5lYXJlc3RGaWx0ZXIsXHJcblx0UkdCQUZvcm1hdCxcclxuXHRSR0JGb3JtYXQsXHJcblx0VGV4dHVyZSxcclxuXHRXZWJHTFJlbmRlclRhcmdldFxyXG59IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuaW1wb3J0IHsgU01BQUJsZW5kTWF0ZXJpYWwsIFNNQUFDb2xvckVkZ2VzTWF0ZXJpYWwsIFNNQUFXZWlnaHRzTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogU3VicGl4ZWwgTW9ycGhvbG9naWNhbCBBbnRpYWxpYXNpbmcgKFNNQUEpIHYyLjguXHJcbiAqXHJcbiAqIFByZXNldDogU01BQSAxeCBNZWRpdW0gKHdpdGggY29sb3IgZWRnZSBkZXRlY3Rpb24pLlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL2lyeW9rdS9zbWFhL3JlbGVhc2VzL3RhZy92Mi44XHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFNNQUFQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgU01BQSBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtJbWFnZX0gSW1hZ2UgLSBUaGlzIHBhc3MgcmVxdWlyZXMgYW4gSW1hZ2UgY2xhc3MgdG8gY3JlYXRlIGludGVybmFsIHRleHR1cmVzLiBQcm92aWRlIHdpbmRvdy5JbWFnZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKEltYWdlKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiU01BQVBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlbmRlciB0YXJnZXQgZm9yIHRoZSBjb2xvciBlZGdlIGRldGVjdGlvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJUYXJnZXR9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRDb2xvckVkZ2VzID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHtcclxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdGZvcm1hdDogUkdCRm9ybWF0LFxyXG5cdFx0XHRzdGVuY2lsQnVmZmVyOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhCdWZmZXI6IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldENvbG9yRWRnZXMudGV4dHVyZS5uYW1lID0gXCJTTUFBLkNvbG9yRWRnZXNcIjtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0Q29sb3JFZGdlcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZW5kZXIgdGFyZ2V0IGZvciB0aGUgU01BQSB3ZWlnaHRzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFdlaWdodHMgPSB0aGlzLnJlbmRlclRhcmdldENvbG9yRWRnZXMuY2xvbmUoKTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFdlaWdodHMudGV4dHVyZS5uYW1lID0gXCJTTUFBLldlaWdodHNcIjtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlLmZvcm1hdCA9IFJHQkFGb3JtYXQ7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTTUFBIGNvbG9yIGVkZ2UgZGV0ZWN0aW9uIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U01BQUNvbG9yRWRnZXNNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvbG9yRWRnZXNNYXRlcmlhbCA9IG5ldyBTTUFBQ29sb3JFZGdlc01hdGVyaWFsKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTTUFBIHdlaWdodHMgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTTUFBV2VpZ2h0c01hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMud2VpZ2h0c01hdGVyaWFsID0gbmV3IFNNQUFXZWlnaHRzTWF0ZXJpYWwoKTtcclxuXHJcblx0XHRjb25zdCBhcmVhSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHRcdGFyZWFJbWFnZS5zcmMgPSB0aGlzLndlaWdodHNNYXRlcmlhbC5hcmVhSW1hZ2U7XHJcblxyXG5cdFx0Y29uc3QgYXJlYVRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xyXG5cdFx0YXJlYVRleHR1cmUuaW1hZ2UgPSBhcmVhSW1hZ2U7XHJcblx0XHRhcmVhVGV4dHVyZS5uYW1lID0gXCJTTUFBLkFyZWFcIjtcclxuXHRcdGFyZWFUZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcclxuXHRcdGFyZWFUZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDtcclxuXHRcdGFyZWFUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cdFx0YXJlYVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0YXJlYVRleHR1cmUuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHRjb25zdCBzZWFyY2hJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cdFx0c2VhcmNoSW1hZ2Uuc3JjID0gdGhpcy53ZWlnaHRzTWF0ZXJpYWwuc2VhcmNoSW1hZ2U7XHJcblxyXG5cdFx0Y29uc3Qgc2VhcmNoVGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XHJcblx0XHRzZWFyY2hUZXh0dXJlLmltYWdlID0gc2VhcmNoSW1hZ2U7XHJcblx0XHRzZWFyY2hUZXh0dXJlLm5hbWUgPSBcIlNNQUEuU2VhcmNoXCI7XHJcblx0XHRzZWFyY2hUZXh0dXJlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcblx0XHRzZWFyY2hUZXh0dXJlLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcblx0XHRzZWFyY2hUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cdFx0c2VhcmNoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRzZWFyY2hUZXh0dXJlLmZsaXBZID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy53ZWlnaHRzTWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldENvbG9yRWRnZXMudGV4dHVyZTtcclxuXHRcdHRoaXMud2VpZ2h0c01hdGVyaWFsLnVuaWZvcm1zLnRBcmVhLnZhbHVlID0gYXJlYVRleHR1cmU7XHJcblx0XHR0aGlzLndlaWdodHNNYXRlcmlhbC51bmlmb3Jtcy50U2VhcmNoLnZhbHVlID0gc2VhcmNoVGV4dHVyZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNNQUEgYmxlbmQgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTTUFBQmxlbmRNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmJsZW5kTWF0ZXJpYWwgPSBuZXcgU01BQUJsZW5kTWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLmJsZW5kTWF0ZXJpYWwudW5pZm9ybXMudFdlaWdodHMudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldFdlaWdodHMudGV4dHVyZTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLmJsZW5kTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQW50aWFsaWFzZXMgdGhlIHNjZW5lLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdC8vIERldGVjdCBjb2xvciBlZGdlcy5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuY29sb3JFZGdlc01hdGVyaWFsO1xyXG5cdFx0dGhpcy5jb2xvckVkZ2VzTWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVGFyZ2V0Q29sb3JFZGdlcywgdHJ1ZSk7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZSBlZGdlIHdlaWdodHMuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLndlaWdodHNNYXRlcmlhbDtcclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gQXBwbHkgdGhlIGFudGlhbGlhc2luZyBmaWx0ZXIgdG8gdGhlIGNvbG9ycy5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuYmxlbmRNYXRlcmlhbDtcclxuXHRcdHRoaXMuYmxlbmRNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBwYXNzIHdpdGggdGhlIHJlbmRlcmVyJ3Mgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRDb2xvckVkZ2VzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFdlaWdodHMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcblx0XHR0aGlzLmNvbG9yRWRnZXNNYXRlcmlhbC51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuY29weShcclxuXHRcdFx0dGhpcy53ZWlnaHRzTWF0ZXJpYWwudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLmNvcHkoXHJcblx0XHRcdFx0dGhpcy5ibGVuZE1hdGVyaWFsLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoXHJcblx0XHRcdFx0XHQxLjAgLyB3aWR0aCwgMS4wIC8gaGVpZ2h0XHJcblx0XHQpKSk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQWRkaXRpdmVCbGVuZGluZyB9IGZyb20gXCJ0aHJlZVwiO1xyXG5pbXBvcnQgeyBDb3B5TWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBwYXNzIHRoYXQgcmVuZGVycyBhIGdpdmVuIHRleHR1cmUuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFRleHR1cmVQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdGV4dHVyZSBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcGFjaXR5PTEuMF0gLSBUaGUgdGV4dHVyZSBvcGFjaXR5LlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBvcGFjaXR5ID0gMS4wKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiVGV4dHVyZVBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgY29weSBzaGFkZXIgbWF0ZXJpYWwgdXNlZCBmb3IgcmVuZGVyaW5nIHRvIHRleHR1cmUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0NvcHlNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvcHlNYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcclxuXHRcdHRoaXMuY29weU1hdGVyaWFsLmJsZW5kaW5nID0gQWRkaXRpdmVCbGVuZGluZztcclxuXHRcdHRoaXMuY29weU1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG5cdFx0dGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLmNvcHlNYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdGV4dHVyZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtUZXh0dXJlfVxyXG5cdCAqL1xyXG5cclxuXHRnZXQgdGV4dHVyZSgpIHsgcmV0dXJuIHRoaXMuY29weU1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtUZXh0dXJlfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgdGV4dHVyZSh4KSB7IHRoaXMuY29weU1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0geDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgb3BhY2l0eS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMS4wXHJcblx0ICovXHJcblxyXG5cdGdldCBvcGFjaXR5KCkgeyByZXR1cm4gdGhpcy5jb3B5TWF0ZXJpYWwudW5pZm9ybXMub3BhY2l0eS52YWx1ZTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgb3BhY2l0eSh4ID0gMS4wKSB7IHRoaXMuY29weU1hdGVyaWFsLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB4OyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyKSB7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHJlYWRCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7XHJcblx0TGluZWFyRmlsdGVyLFxyXG5cdExpbmVhck1pcE1hcExpbmVhckZpbHRlcixcclxuXHRNZXNoQmFzaWNNYXRlcmlhbCxcclxuXHRSR0JGb3JtYXQsXHJcblx0V2ViR0xSZW5kZXJUYXJnZXRcclxufSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmltcG9ydCB7XHJcblx0QWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwsXHJcblx0Q29weU1hdGVyaWFsLFxyXG5cdEx1bWlub3NpdHlNYXRlcmlhbCxcclxuXHRUb25lTWFwcGluZ01hdGVyaWFsXHJcbn0gZnJvbSBcIi4uL21hdGVyaWFsc1wiO1xyXG5cclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBSb3VuZHMgdGhlIGdpdmVuIG51bWJlciB1cCB0byB0aGUgbmV4dCBwb3dlciBvZiB0d28uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBBIG51bWJlci5cclxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgbmV4dCBwb3dlciBvZiB0d28uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY2VpbDIobikgeyByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGgubG9nMihuKSkpKTsgfVxyXG5cclxuLyoqXHJcbiAqIEEgdG9uZSBtYXBwaW5nIHBhc3MgdGhhdCBzdXBwb3J0cyBhZGFwdGl2ZSBsdW1pbm9zaXR5LlxyXG4gKlxyXG4gKiBJZiBhZGFwdGl2aXR5IGlzIGVuYWJsZWQsIHRoaXMgcGFzcyBnZW5lcmF0ZXMgYSB0ZXh0dXJlIHRoYXQgcmVwcmVzZW50cyB0aGVcclxuICogbHVtaW5vc2l0eSBvZiB0aGUgY3VycmVudCBzY2VuZSBhbmQgYWRqdXN0cyBpdCBvdmVyIHRpbWUgdG8gc2ltdWxhdGUgdGhlXHJcbiAqIG9wdGljIG5lcnZlIHJlc3BvbmRpbmcgdG8gdGhlIGFtb3VudCBvZiBsaWdodCBpdCBpcyByZWNlaXZpbmcuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZTpcclxuICogIEdEQzIwMDcgLSBXb2xmZ2FuZyBFbmdlbCwgUG9zdC1Qcm9jZXNzaW5nIFBpcGVsaW5lXHJcbiAqICBodHRwOi8vcGVyc28udW5pdi1seW9uMS5mci9qZWFuLWNsYXVkZS5pZWhsL1B1YmxpYy9lZHVjL0dBTUEvMjAwNy9nZGMwNy9Qb3N0LVByb2Nlc3NpbmdfUGlwZWxpbmUucGRmXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFRvbmVNYXBwaW5nUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHRvbmUgbWFwcGluZyBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWRhcHRpdmU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSB0b25lIG1hcHBpbmcgc2hvdWxkIHVzZSBhbiBhZGFwdGl2ZSBsdW1pbmFuY2UgbWFwLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTI1Nl0gLSBUaGUgcmVuZGVyIHRleHR1cmUgcmVzb2x1dGlvbi5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGlzdGluY3Rpb249MS4wXSAtIEEgbHVtaW5hbmNlIGRpc3RpbmN0aW9uIGZhY3Rvci5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiVG9uZU1hcHBpbmdQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHJlbmRlciB0YXJnZXQgZm9yIHRoZSBjdXJyZW50IGx1bWlub3NpdHkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0b2RvIFVzZSBSRUQgZm9ybWF0IGluIFdlYkdMIDIuMC5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0THVtaW5vc2l0eSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCB7XHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0Zm9ybWF0OiBSR0JGb3JtYXQsXHJcblx0XHRcdHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aEJ1ZmZlcjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0THVtaW5vc2l0eS50ZXh0dXJlLm5hbWUgPSBcIlRvbmVNYXBwaW5nLkx1bWlub3NpdHlcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSByZW5kZXIgdGFyZ2V0IGZvciBhZGFwdGVkIGx1bWlub3NpdHkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZCA9IHRoaXMucmVuZGVyVGFyZ2V0THVtaW5vc2l0eS5jbG9uZSgpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlLm5hbWUgPSBcIlRvbmVNYXBwaW5nLkFkYXB0ZWRMdW1pbm9zaXR5XCI7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVuZGVyIHRhcmdldCB0aGF0IGhvbGRzIGEgY29weSBvZiB0aGUgYWRhcHRlZCBsaW1vbm9zaXR5LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzID0gdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cy50ZXh0dXJlLm5hbWUgPSBcIlRvbmVNYXBwaW5nLlByZXZpb3VzTHVtaW5vc2l0eVwiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ29weSBzaGFkZXIgbWF0ZXJpYWwgdXNlZCBmb3Igc2F2aW5nIHRoZSBsdW1pbmFuY2UgbWFwLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDb3B5TWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jb3B5TWF0ZXJpYWwgPSBuZXcgQ29weU1hdGVyaWFsKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGx1bWlub3NpdHkgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtMdW1pbm9zaXR5TWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5sdW1pbm9zaXR5TWF0ZXJpYWwgPSBuZXcgTHVtaW5vc2l0eU1hdGVyaWFsKCk7XHJcblxyXG5cdFx0dGhpcy5sdW1pbm9zaXR5TWF0ZXJpYWwudW5pZm9ybXMuZGlzdGluY3Rpb24udmFsdWUgPSAob3B0aW9ucy5kaXN0aW5jdGlvbiAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuZGlzdGluY3Rpb24gOiAxLjA7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBbiBhZGFwdGl2ZSBsdW1pbmFuY2Ugc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtBZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsID0gbmV3IEFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsKCk7XHJcblxyXG5cdFx0dGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSB0b25lIG1hcHBpbmcgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtUb25lTWFwcGluZ01hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMudG9uZU1hcHBpbmdNYXRlcmlhbCA9IG5ldyBUb25lTWFwcGluZ01hdGVyaWFsKCk7XHJcblxyXG5cdFx0dGhpcy5hZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlciB0YXJnZXRzLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAZGVmYXVsdCAyNTZcclxuXHQgKi9cclxuXHJcblx0Z2V0IHJlc29sdXRpb24oKSB7IHJldHVybiB0aGlzLnJlbmRlclRhcmdldEx1bWlub3NpdHkud2lkdGg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlciB0YXJnZXRzLiBNdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGZvciBtaXBtYXBzLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0c2V0IHJlc29sdXRpb24oeCA9IDI1Nikge1xyXG5cclxuXHRcdHggPSBjZWlsMih4KTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldEx1bWlub3NpdHkuc2V0U2l6ZSh4LCB4KTtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMuc2V0U2l6ZSh4LCB4KTtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC5zZXRTaXplKHgsIHgpO1xyXG5cclxuXHRcdHRoaXMuYWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwuZGVmaW5lcy5NSVBfTEVWRUxfMVgxID0gKE1hdGgucm91bmQoTWF0aC5sb2coeCkpIC8gTWF0aC5sb2coMikpLnRvRml4ZWQoMSk7XHJcblx0XHR0aGlzLmFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXaGV0aGVyIHRoaXMgcGFzcyB1c2VzIGFkYXB0aXZlIGx1bWlub3NpdHkuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICovXHJcblxyXG5cdGdldCBhZGFwdGl2ZSgpIHsgcmV0dXJuICh0aGlzLnRvbmVNYXBwaW5nTWF0ZXJpYWwuZGVmaW5lcy5BREFQVEVEX0xVTUlOQU5DRSAhPT0gdW5kZWZpbmVkKTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBXaGV0aGVyIHRoaXMgcGFzcyBzaG91bGQgdXNlIGFkYXB0aXZlIGx1bWlub3NpdHkuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHQgKi9cclxuXHJcblx0c2V0IGFkYXB0aXZlKHggPSB0cnVlKSB7XHJcblxyXG5cdFx0aWYoeCkge1xyXG5cclxuXHRcdFx0dGhpcy50b25lTWFwcGluZ01hdGVyaWFsLmRlZmluZXMuQURBUFRFRF9MVU1JTkFOQ0UgPSBcIjFcIjtcclxuXHRcdFx0dGhpcy50b25lTWFwcGluZ01hdGVyaWFsLnVuaWZvcm1zLmx1bWluYW5jZU1hcC52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRkZWxldGUgdGhpcy50b25lTWFwcGluZ01hdGVyaWFsLmRlZmluZXMuQURBUFRFRF9MVU1JTkFOQ0U7XHJcblx0XHRcdHRoaXMudG9uZU1hcHBpbmdNYXRlcmlhbC51bmlmb3Jtcy5sdW1pbmFuY2VNYXAudmFsdWUgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRvbmVNYXBwaW5nTWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIC0gVGhlIHJlbmRlciBkZWx0YSB0aW1lLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyLCBkZWx0YSkge1xyXG5cclxuXHRcdGNvbnN0IHF1YWQgPSB0aGlzLnF1YWQ7XHJcblx0XHRjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XHJcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHJcblx0XHRjb25zdCBhZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbCA9IHRoaXMuYWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWw7XHJcblx0XHRjb25zdCBsdW1pbm9zaXR5TWF0ZXJpYWwgPSB0aGlzLmx1bWlub3NpdHlNYXRlcmlhbDtcclxuXHRcdGNvbnN0IHRvbmVNYXBwaW5nTWF0ZXJpYWwgPSB0aGlzLnRvbmVNYXBwaW5nTWF0ZXJpYWw7XHJcblx0XHRjb25zdCBjb3B5TWF0ZXJpYWwgPSB0aGlzLmNvcHlNYXRlcmlhbDtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcmV2aW91cyA9IHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXM7XHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRMdW1pbm9zaXR5ID0gdGhpcy5yZW5kZXJUYXJnZXRMdW1pbm9zaXR5O1xyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0QWRhcHRlZCA9IHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZDtcclxuXHJcblx0XHRpZih0aGlzLmFkYXB0aXZlKSB7XHJcblxyXG5cdFx0XHQvLyBSZW5kZXIgdGhlIGx1bWluYW5jZSBvZiB0aGUgY3VycmVudCBzY2VuZSBpbnRvIGEgcmVuZGVyIHRhcmdldCB3aXRoIG1pcG1hcHBpbmcgZW5hYmxlZC5cclxuXHRcdFx0cXVhZC5tYXRlcmlhbCA9IGx1bWlub3NpdHlNYXRlcmlhbDtcclxuXHRcdFx0bHVtaW5vc2l0eU1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0THVtaW5vc2l0eSk7XHJcblxyXG5cdFx0XHQvLyBVc2UgdGhlIG5ldyBsdW1pbmFuY2UgdmFsdWVzLCB0aGUgcHJldmlvdXMgbHVtaW5hbmNlIGFuZCB0aGUgZnJhbWUgZGVsdGEgdG8gYWRhcHQgdGhlIGx1bWluYW5jZSBvdmVyIHRpbWUuXHJcblx0XHRcdHF1YWQubWF0ZXJpYWwgPSBhZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbDtcclxuXHRcdFx0YWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwudW5pZm9ybXMuZGVsdGEudmFsdWUgPSBkZWx0YTtcclxuXHRcdFx0YWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwudW5pZm9ybXMudFByZXZpb3VzTHVtLnZhbHVlID0gcmVuZGVyVGFyZ2V0UHJldmlvdXMudGV4dHVyZTtcclxuXHRcdFx0YWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwudW5pZm9ybXMudEN1cnJlbnRMdW0udmFsdWUgPSByZW5kZXJUYXJnZXRMdW1pbm9zaXR5LnRleHR1cmU7XHJcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXRBZGFwdGVkKTtcclxuXHJcblx0XHRcdC8vIENvcHkgdGhlIG5ldyBhZGFwdGVkIGx1bWluYW5jZSB2YWx1ZSBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGJ5IHRoZSBuZXh0IGZyYW1lLlxyXG5cdFx0XHRxdWFkLm1hdGVyaWFsID0gY29weU1hdGVyaWFsO1xyXG5cdFx0XHRjb3B5TWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmU7XHJcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXRQcmV2aW91cyk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFwcGx5IHRoZSB0b25lIG1hcHBpbmcgdG8gdGhlIGNvbG91cnMuXHJcblx0XHRxdWFkLm1hdGVyaWFsID0gdG9uZU1hcHBpbmdNYXRlcmlhbDtcclxuXHRcdHRvbmVNYXBwaW5nTWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHNvbWV0aGluZyBpbnRvIHRoZSBwcmV2aW91cyBsdW1pbm9zaXR5IHRleHR1cmUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXNlKHJlbmRlcmVyKSB7XHJcblxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4N2ZmZmZmIH0pO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzKTtcclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqIEEgY29tcGlsYXRpb24gb2YgdGhlIHBvc3QgcHJvY2Vzc2luZyBwYXNzZXMuXHJcbiAqXHJcbiAqIEBtb2R1bGUgcG9zdHByb2Nlc3NpbmcvcGFzc2VzXHJcbiAqL1xyXG5cclxuZXhwb3J0IHsgQmxvb21QYXNzIH0gZnJvbSBcIi4vQmxvb21QYXNzLmpzXCI7XHJcbmV4cG9ydCB7IEJsdXJQYXNzIH0gZnJvbSBcIi4vQmx1clBhc3MuanNcIjtcclxuZXhwb3J0IHsgQm9rZWhQYXNzIH0gZnJvbSBcIi4vQm9rZWhQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IEJva2VoMlBhc3MgfSBmcm9tIFwiLi9Cb2tlaDJQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IENsZWFyTWFza1Bhc3MgfSBmcm9tIFwiLi9DbGVhck1hc2tQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IENsZWFyUGFzcyB9IGZyb20gXCIuL0NsZWFyUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBEb3RTY3JlZW5QYXNzIH0gZnJvbSBcIi4vRG90U2NyZWVuUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBEZXB0aFBhc3MgfSBmcm9tIFwiLi9EZXB0aFBhc3MuanNcIjtcclxuZXhwb3J0IHsgRmlsbVBhc3MgfSBmcm9tIFwiLi9GaWxtUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBHbGl0Y2hNb2RlLCBHbGl0Y2hQYXNzIH0gZnJvbSBcIi4vR2xpdGNoUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBHb2RSYXlzUGFzcyB9IGZyb20gXCIuL0dvZFJheXNQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IE1hc2tQYXNzIH0gZnJvbSBcIi4vTWFza1Bhc3MuanNcIjtcclxuZXhwb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuZXhwb3J0IHsgUGl4ZWxhdGlvblBhc3MgfSBmcm9tIFwiLi9QaXhlbGF0aW9uUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBSZW5kZXJQYXNzIH0gZnJvbSBcIi4vUmVuZGVyUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBTYXZlUGFzcyB9IGZyb20gXCIuL1NhdmVQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IFNoYWRlclBhc3MgfSBmcm9tIFwiLi9TaGFkZXJQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IFNob2NrV2F2ZVBhc3MgfSBmcm9tIFwiLi9TaG9ja1dhdmVQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IFNNQUFQYXNzIH0gZnJvbSBcIi4vU01BQVBhc3MuanNcIjtcclxuZXhwb3J0IHsgVGV4dHVyZVBhc3MgfSBmcm9tIFwiLi9UZXh0dXJlUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBUb25lTWFwcGluZ1Bhc3MgfSBmcm9tIFwiLi9Ub25lTWFwcGluZ1Bhc3MuanNcIjtcclxuIiwiaW1wb3J0IHtcclxuXHREZXB0aFN0ZW5jaWxGb3JtYXQsXHJcblx0RGVwdGhUZXh0dXJlLFxyXG5cdExpbmVhckZpbHRlcixcclxuXHRSR0JBRm9ybWF0LFxyXG5cdFJHQkZvcm1hdCxcclxuXHRVbnNpZ25lZEludDI0OFR5cGUsXHJcblx0V2ViR0xSZW5kZXJUYXJnZXRcclxufSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmltcG9ydCB7IENsZWFyTWFza1Bhc3MsIE1hc2tQYXNzLCBTaGFkZXJQYXNzIH0gZnJvbSBcIi4uL3Bhc3Nlc1wiO1xyXG5pbXBvcnQgeyBDb3B5TWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcblxyXG4vKipcclxuICogVGhlIEVmZmVjdENvbXBvc2VyIG1heSBiZSB1c2VkIGluIHBsYWNlIG9mIGEgbm9ybWFsIFdlYkdMUmVuZGVyZXIuXHJcbiAqXHJcbiAqIFRoZSBhdXRvIGNsZWFyIGJlaGF2aW91ciBvZiB0aGUgcHJvdmlkZWQgcmVuZGVyZXIgd2lsbCBiZSBkaXNhYmxlZCB0byBwcmV2ZW50XHJcbiAqIHVubmVjZXNzYXJ5IGNsZWFyIG9wZXJhdGlvbnMuXHJcbiAqXHJcbiAqIEl0IGlzIGNvbW1vbiBwcmFjdGljZSB0byB1c2UgYSB7QGxpbmsgUmVuZGVyUGFzc30gYXMgdGhlIGZpcnN0IHBhc3MgdG9cclxuICogYXV0b21hdGljYWxseSBjbGVhciB0aGUgc2NyZWVuIGFuZCByZW5kZXIgdGhlIHNjZW5lIHRvIGEgdGV4dHVyZSBmb3IgZnVydGhlclxyXG4gKiBwcm9jZXNzaW5nLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBFZmZlY3RDb21wb3NlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZWZmZWN0IGNvbXBvc2VyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSBbcmVuZGVyZXJdIC0gVGhlIHJlbmRlcmVyIHRoYXQgc2hvdWxkIGJlIHVzZWQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGVwdGhCdWZmZXI9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBtYWluIHJlbmRlciB0YXJnZXRzIHNob3VsZCBoYXZlIGEgZGVwdGggYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RlbmNpbEJ1ZmZlcj1mYWxzZV0gLSBXaGV0aGVyIHRoZSBtYWluIHJlbmRlciB0YXJnZXRzIHNob3VsZCBoYXZlIGEgc3RlbmNpbCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZXB0aFRleHR1cmU9ZmFsc2VdIC0gU2V0IHRvIHRydWUgaWYgb25lIG9mIHlvdXIgcGFzc2VzIHJlbGllcyBvbiBhIGRlcHRoIHRleHR1cmUuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHJlbmRlcmVyID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcmVuZGVyZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogWW91IG1heSByZXBsYWNlIHRoZSByZW5kZXJlciBhdCBhbnkgdGltZSBieSB1c2luZ1xyXG5cdFx0ICoge0BsaW5rIEVmZmVjdENvbXBvc2VyI3JlcGxhY2VSZW5kZXJlcn0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyZXJ9XHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcmVhZCBidWZmZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogUmVhZGluZyBmcm9tIGFuZCB3cml0aW5nIHRvIHRoZSBzYW1lIHJlbmRlciB0YXJnZXQgc2hvdWxkIGJlIGF2b2lkZWQuXHJcblx0XHQgKiBUaGVyZWZvcmUsIHR3byBzZXBlcmF0ZSB5ZXQgaWRlbnRpY2FsIGJ1ZmZlcnMgYXJlIHVzZWQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVhZEJ1ZmZlciA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLndyaXRlQnVmZmVyID0gbnVsbDtcclxuXHJcblx0XHRpZih0aGlzLnJlbmRlcmVyICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dGhpcy5yZWFkQnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoXHJcblx0XHRcdFx0KG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZSxcclxuXHRcdFx0XHQob3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5zdGVuY2lsQnVmZmVyIDogZmFsc2UsXHJcblx0XHRcdFx0KG9wdGlvbnMuZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5kZXB0aFRleHR1cmUgOiBmYWxzZVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0dGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVhZEJ1ZmZlci5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgY29weSBwYXNzIHVzZWQgZm9yIGNvcHlpbmcgbWFza2VkIHNjZW5lcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2hhZGVyUGFzc31cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvcHlQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IENvcHlNYXRlcmlhbCgpKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBwYXNzZXMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1Bhc3NbXX1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnBhc3NlcyA9IFtdO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkZXB0aCB0ZXh0dXJlIG9mIHRoZSByZWFkIGFuZCB3cml0ZSBidWZmZXJzLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge0RlcHRoVGV4dHVyZX1cclxuXHQgKiBAZGVmYXVsdCBudWxsXHJcblx0ICovXHJcblxyXG5cdGdldCBkZXB0aFRleHR1cmUoKSB7IHJldHVybiB0aGlzLnJlYWRCdWZmZXIuZGVwdGhUZXh0dXJlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSByZWFkIGFuZCB3cml0ZSBidWZmZXJzIHNoYXJlIGEgc2luZ2xlIGRlcHRoIHRleHR1cmUuIERlcHRoIHdpbGwgYmVcclxuXHQgKiB3cml0dGVuIHRvIHRoaXMgdGV4dHVyZSB3aGVuIHNvbWV0aGluZyBpcyByZW5kZXJlZCBpbnRvIG9uZSBvZiB0aGUgYnVmZmVyc1xyXG5cdCAqIGFuZCB0aGUgaW52b2x2ZWQgbWF0ZXJpYWxzIGhhdmUgZGVwdGggd3JpdGUgZW5hYmxlZC5cclxuXHQgKlxyXG5cdCAqIFlvdSBtYXkgZW5hYmxlIHRoaXMgbWVjaGFuaXNtIGR1cmluZyB0aGUgaW5zdGFudGlhdGlvbiBvZiB0aGUgY29tcG9zZXIgb3JcclxuXHQgKiBieSBhc3NpZ25pbmcgYSBEZXB0aFRleHR1cmUgaW5zdGFuY2UgbGF0ZXIgb24uIFlvdSBtYXkgYWxzbyBkaXNhYmxlIGl0IGJ5XHJcblx0ICogYXNzaWduaW5nIG51bGwuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7RGVwdGhUZXh0dXJlfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgZGVwdGhUZXh0dXJlKHgpIHtcclxuXHJcblx0XHR0aGlzLnJlYWRCdWZmZXIuZGVwdGhUZXh0dXJlID0geDtcclxuXHRcdHRoaXMud3JpdGVCdWZmZXIuZGVwdGhUZXh0dXJlID0geDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXBsYWNlcyB0aGUgY3VycmVudCByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvbmUuIFRoZSBET00gZWxlbWVudCBvZiB0aGVcclxuXHQgKiBjdXJyZW50IHJlbmRlcmVyIHdpbGwgYXV0b21hdGljYWxseSBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBub2RlIGFuZCB0aGVcclxuXHQgKiBET00gZWxlbWVudCBvZiB0aGUgbmV3IHJlbmRlcmVyIHdpbGwgdGFrZSBpdHMgcGxhY2UuXHJcblx0ICpcclxuXHQgKiBUaGUgYXV0byBjbGVhciBtZWNoYW5pc20gb2YgdGhlIHByb3ZpZGVkIHJlbmRlcmVyIHdpbGwgYmUgZGlzYWJsZWQuXHJcblx0ICpcclxuXHQgKiBTd2l0Y2hpbmcgYmV0d2VlbiByZW5kZXJlcnMgYWxsb3dzIHlvdSB0byBkeW5hbWljYWxseSBlbmFibGUgb3IgZGlzYWJsZVxyXG5cdCAqIGFudGlhbGlhc2luZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgbmV3IHJlbmRlcmVyLlxyXG5cdCAqIEByZXR1cm4ge1dlYkdMUmVuZGVyZXJ9IFRoZSBvbGQgcmVuZGVyZXIuXHJcblx0ICovXHJcblxyXG5cdHJlcGxhY2VSZW5kZXJlcihyZW5kZXJlcikge1xyXG5cclxuXHRcdGNvbnN0IG9sZFJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuXHJcblx0XHRsZXQgcGFyZW50LCBvbGRTaXplLCBuZXdTaXplO1xyXG5cclxuXHRcdGlmKG9sZFJlbmRlcmVyICE9PSBudWxsICYmIG9sZFJlbmRlcmVyICE9PSByZW5kZXJlcikge1xyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG5cdFx0XHR0aGlzLnJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cGFyZW50ID0gb2xkUmVuZGVyZXIuZG9tRWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdFx0XHRvbGRTaXplID0gb2xkUmVuZGVyZXIuZ2V0U2l6ZSgpO1xyXG5cdFx0XHRuZXdTaXplID0gcmVuZGVyZXIuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdFx0aWYocGFyZW50ICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHRcdHBhcmVudC5yZW1vdmVDaGlsZChvbGRSZW5kZXJlci5kb21FbGVtZW50KTtcclxuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihvbGRTaXplLndpZHRoICE9PSBuZXdTaXplLndpZHRoIHx8IG9sZFNpemUuaGVpZ2h0ICE9PSBuZXdTaXplLmhlaWdodCkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldFNpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9sZFJlbmRlcmVyO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgcmVuZGVyIHRhcmdldCBieSByZXBsaWNhdGluZyB0aGUgcmVuZGVyZXIncyBjYW52YXMuXHJcblx0ICpcclxuXHQgKiBUaGUgY3JlYXRlZCByZW5kZXIgdGFyZ2V0IHVzZXMgYSBsaW5lYXIgZmlsdGVyIGZvciB0ZXhlbCBtaW5pZmljYXRpb24gYW5kXHJcblx0ICogbWFnbmlmaWNhdGlvbi4gSXRzIHJlbmRlciB0ZXh0dXJlIGZvcm1hdCBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIHJlbmRlcmVyXHJcblx0ICogdXNlcyB0aGUgYWxwaGEgY2hhbm5lbC4gTWlwbWFwcyBhcmUgZGlzYWJsZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGRlcHRoQnVmZmVyIC0gV2hldGhlciB0aGUgcmVuZGVyIHRhcmdldCBzaG91bGQgaGF2ZSBhIGRlcHRoIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN0ZW5jaWxCdWZmZXIgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBoYXZlIGEgc3RlbmNpbCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBkZXB0aFRleHR1cmUgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBoYXZlIGEgZGVwdGggdGV4dHVyZS5cclxuXHQgKiBAcmV0dXJuIHtXZWJHTFJlbmRlclRhcmdldH0gQSBuZXcgcmVuZGVyIHRhcmdldCB0aGF0IGVxdWFscyB0aGUgcmVuZGVyZXIncyBjYW52YXMuXHJcblx0ICovXHJcblxyXG5cdGNyZWF0ZUJ1ZmZlcihkZXB0aEJ1ZmZlciwgc3RlbmNpbEJ1ZmZlciwgZGVwdGhUZXh0dXJlKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMucmVuZGVyZXIuZ2V0U2l6ZSgpO1xyXG5cdFx0Y29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xyXG5cdFx0Y29uc3QgYWxwaGEgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5hbHBoYTtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoc2l6ZS53aWR0aCAqIHBpeGVsUmF0aW8sIHNpemUuaGVpZ2h0ICogcGl4ZWxSYXRpbywge1xyXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0bWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdGZvcm1hdDogYWxwaGEgPyBSR0JBRm9ybWF0IDogUkdCRm9ybWF0LFxyXG5cdFx0XHRkZXB0aEJ1ZmZlcjogZGVwdGhCdWZmZXIsXHJcblx0XHRcdHN0ZW5jaWxCdWZmZXI6IHN0ZW5jaWxCdWZmZXIsXHJcblx0XHRcdGRlcHRoVGV4dHVyZTogZGVwdGhUZXh0dXJlID8gbmV3IERlcHRoVGV4dHVyZSgpIDogbnVsbFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYoZGVwdGhUZXh0dXJlICYmIHN0ZW5jaWxCdWZmZXIpIHtcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID0gRGVwdGhTdGVuY2lsRm9ybWF0O1xyXG5cdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkVmZmVjdENvbXBvc2VyLkJ1ZmZlclwiO1xyXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0cmV0dXJuIHJlbmRlclRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgcGFzcywgb3B0aW9uYWxseSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQYXNzfSBwYXNzIC0gQSBuZXcgcGFzcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAtIEFuIGluZGV4IGF0IHdoaWNoIHRoZSBwYXNzIHNob3VsZCBiZSBpbnNlcnRlZC5cclxuXHQgKi9cclxuXHJcblx0YWRkUGFzcyhwYXNzLCBpbmRleCkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuXHRcdGNvbnN0IHNpemUgPSByZW5kZXJlci5nZXRTaXplKCk7XHJcblx0XHRjb25zdCBwaXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xyXG5cclxuXHRcdHBhc3Muc2V0U2l6ZShzaXplLndpZHRoICogcGl4ZWxSYXRpbywgc2l6ZS5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcclxuXHRcdHBhc3MuaW5pdGlhbGlzZShyZW5kZXJlciwgcmVuZGVyZXIuY29udGV4dC5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhKTtcclxuXHJcblx0XHRpZihpbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhc3Nlcy5zcGxpY2UoaW5kZXgsIDAsIHBhc3MpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhc3Nlcy5wdXNoKHBhc3MpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGEgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGFzc30gcGFzcyAtIFRoZSBwYXNzLlxyXG5cdCAqL1xyXG5cclxuXHRyZW1vdmVQYXNzKHBhc3MpIHtcclxuXHJcblx0XHR0aGlzLnBhc3Nlcy5zcGxpY2UodGhpcy5wYXNzZXMuaW5kZXhPZihwYXNzKSwgMSk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyBhbGwgZW5hYmxlZCBwYXNzZXMgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIoZGVsdGEpIHtcclxuXHJcblx0XHRjb25zdCBwYXNzZXMgPSB0aGlzLnBhc3NlcztcclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuXHRcdGNvbnN0IGNvcHlQYXNzID0gdGhpcy5jb3B5UGFzcztcclxuXHJcblx0XHRsZXQgcmVhZEJ1ZmZlciA9IHRoaXMucmVhZEJ1ZmZlcjtcclxuXHRcdGxldCB3cml0ZUJ1ZmZlciA9IHRoaXMud3JpdGVCdWZmZXI7XHJcblxyXG5cdFx0bGV0IG1hc2tBY3RpdmUgPSBmYWxzZTtcclxuXHRcdGxldCBwYXNzLCBjb250ZXh0LCBidWZmZXI7XHJcblx0XHRsZXQgaSwgbDtcclxuXHJcblx0XHRmb3IoaSA9IDAsIGwgPSBwYXNzZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcblxyXG5cdFx0XHRwYXNzID0gcGFzc2VzW2ldO1xyXG5cclxuXHRcdFx0aWYocGFzcy5lbmFibGVkKSB7XHJcblxyXG5cdFx0XHRcdHBhc3MucmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlciwgZGVsdGEsIG1hc2tBY3RpdmUpO1xyXG5cclxuXHRcdFx0XHRpZihwYXNzLm5lZWRzU3dhcCkge1xyXG5cclxuXHRcdFx0XHRcdGlmKG1hc2tBY3RpdmUpIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LnN0ZW5jaWxGdW5jKGNvbnRleHQuTk9URVFVQUwsIDEsIDB4ZmZmZmZmZmYpO1xyXG5cdFx0XHRcdFx0XHRjb3B5UGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKTtcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5zdGVuY2lsRnVuYyhjb250ZXh0LkVRVUFMLCAxLCAweGZmZmZmZmZmKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnVmZmVyID0gcmVhZEJ1ZmZlcjtcclxuXHRcdFx0XHRcdHJlYWRCdWZmZXIgPSB3cml0ZUJ1ZmZlcjtcclxuXHRcdFx0XHRcdHdyaXRlQnVmZmVyID0gYnVmZmVyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKHBhc3MgaW5zdGFuY2VvZiBNYXNrUGFzcykge1xyXG5cclxuXHRcdFx0XHRcdG1hc2tBY3RpdmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYocGFzcyBpbnN0YW5jZW9mIENsZWFyTWFza1Bhc3MpIHtcclxuXHJcblx0XHRcdFx0XHRtYXNrQWN0aXZlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVycyBhbmQgdGhlIHJlbmRlcmVyJ3Mgb3V0cHV0IGNhbnZhcy5cclxuXHQgKlxyXG5cdCAqIEV2ZXJ5IHBhc3Mgd2lsbCBiZSBpbmZvcm1lZCBvZiB0aGUgbmV3IHNpemUuIEl0J3MgdXAgdG8gZWFjaCBwYXNzIGhvdyB0aGF0XHJcblx0ICogaW5mb3JtYXRpb24gaXMgdXNlZC5cclxuXHQgKlxyXG5cdCAqIElmIG5vIHdpZHRoIG9yIGhlaWdodCBpcyBzcGVjaWZpZWQsIHRoZSByZW5kZXIgdGFyZ2V0cyBhbmQgcGFzc2VzIHdpbGwgYmVcclxuXHQgKiB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgcmVuZGVyZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoXSAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodF0gLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHRjb25zdCBwYXNzZXMgPSB0aGlzLnBhc3NlcztcclxuXHRcdGNvbnN0IHNpemUgPSB0aGlzLnJlbmRlcmVyLmdldFNpemUoKTtcclxuXHRcdGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcclxuXHJcblx0XHRsZXQgaSwgbDtcclxuXHJcblx0XHRpZih3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcblxyXG5cdFx0XHR3aWR0aCA9IHNpemUud2lkdGg7XHJcblx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0d2lkdGggKj0gcGl4ZWxSYXRpbztcclxuXHRcdGhlaWdodCAqPSBwaXhlbFJhdGlvO1xyXG5cclxuXHRcdHRoaXMucmVhZEJ1ZmZlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0dGhpcy53cml0ZUJ1ZmZlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdGZvcihpID0gMCwgbCA9IHBhc3Nlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuXHJcblx0XHRcdHBhc3Nlc1tpXS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXNldHMgdGhpcyBjb21wb3NlciBieSBkZWxldGluZyBhbGwgcGFzc2VzIGFuZCBjcmVhdGluZyBuZXcgYnVmZmVycy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtyZW5kZXJUYXJnZXRdIC0gQSBuZXcgcmVuZGVyIHRhcmdldC4gSWYgbm9uZSBpcyBwcm92aWRlZCwgdGhlIHNldHRpbmdzIG9mIHRoZSByZW5kZXJlciB3aWxsIGJlIHVzZWQuXHJcblx0ICovXHJcblxyXG5cdHJlc2V0KHJlbmRlclRhcmdldCkge1xyXG5cclxuXHRcdGNvbnN0IGRlcHRoQnVmZmVyID0gdGhpcy5yZWFkQnVmZmVyLmRlcHRoQnVmZmVyO1xyXG5cdFx0Y29uc3Qgc3RlbmNpbEJ1ZmZlciA9IHRoaXMucmVhZEJ1ZmZlci5zdGVuY2lsQnVmZmVyO1xyXG5cdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gKHRoaXMucmVhZEJ1ZmZlci5kZXB0aFRleHR1cmUgIT09IG51bGwpO1xyXG5cclxuXHRcdHRoaXMuZGlzcG9zZSgocmVuZGVyVGFyZ2V0ID09PSB1bmRlZmluZWQpID9cclxuXHRcdFx0dGhpcy5jcmVhdGVCdWZmZXIoZGVwdGhCdWZmZXIsIHN0ZW5jaWxCdWZmZXIsIGRlcHRoVGV4dHVyZSkgOlxyXG5cdFx0XHRyZW5kZXJUYXJnZXRcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVzdHJveXMgYWxsIHBhc3NlcyBhbmQgcmVuZGVyIHRhcmdldHMuXHJcblx0ICpcclxuXHQgKiBUaGlzIG1ldGhvZCBkZWFsbG9jYXRlcyBhbGwgcmVuZGVyIHRhcmdldHMsIHRleHR1cmVzIGFuZCBtYXRlcmlhbHMgY3JlYXRlZFxyXG5cdCAqIGJ5IHRoZSBwYXNzZXMuIEl0IGFsc28gZGVsZXRlcyB0aGlzIGNvbXBvc2VyJ3MgZnJhbWUgYnVmZmVycy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtyZW5kZXJUYXJnZXRdIC0gQSBuZXcgcmVuZGVyIHRhcmdldC4gSWYgbm9uZSBpcyBwcm92aWRlZCwgdGhlIGNvbXBvc2VyIHdpbGwgYmVjb21lIGlub3BlcmF0aXZlLlxyXG5cdCAqL1xyXG5cclxuXHRkaXNwb3NlKHJlbmRlclRhcmdldCkge1xyXG5cclxuXHRcdGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xyXG5cclxuXHRcdGlmKHRoaXMucmVhZEJ1ZmZlciAhPT0gbnVsbCAmJiB0aGlzLndyaXRlQnVmZmVyICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlYWRCdWZmZXIuZGlzcG9zZSgpO1xyXG5cdFx0XHR0aGlzLndyaXRlQnVmZmVyLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRcdHRoaXMucmVhZEJ1ZmZlciA9IG51bGw7XHJcblx0XHRcdHRoaXMud3JpdGVCdWZmZXIgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZShwYXNzZXMubGVuZ3RoID4gMCkge1xyXG5cclxuXHRcdFx0cGFzc2VzLnBvcCgpLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYocmVuZGVyVGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdC8vIFJlYW5pbWF0ZS5cclxuXHRcdFx0dGhpcy5yZWFkQnVmZmVyID0gcmVuZGVyVGFyZ2V0O1xyXG5cdFx0XHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZWFkQnVmZmVyLmNsb25lKCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuY29weVBhc3MuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQge0VmZmVjdENvbXBvc2VyfSBmcm9tICdwb3N0cHJvY2Vzc2luZy9zcmMvY29yZS9FZmZlY3RDb21wb3Nlcic7XG5pbXBvcnQge1JlbmRlclBhc3N9IGZyb20gJ3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvUmVuZGVyUGFzcyc7XG5pbXBvcnQge1NoYWRlclBhc3N9IGZyb20gJ3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvU2hhZGVyUGFzcyc7XG5cbmltcG9ydCB7TG9vcH0gZnJvbSAnLi4vLi4vY29yZS9Mb29wJztcblxuY29uc3QgcG9seWZpbGwgPSAob2JqZWN0LCBtZXRob2QsIHNob3dXYXJuID0gdHJ1ZSkgPT4ge1xuICBpZiAob2JqZWN0W21ldGhvZF0pIHJldHVybjtcbiAgaWYgKHNob3dXYXJuKSBjb25zb2xlLndhcm4oYEBQb3N0UHJvY2Vzc29yTW9kdWxlOiBwYXNzLiR7bWV0aG9kfSgpIHdhcyBub3QgZm91bmQuYCwgb2JqZWN0KTtcbiAgb2JqZWN0W21ldGhvZF0gPSAoKSA9PiB7fTtcbn07XG5cbi8qKlxuICogQGNsYXNzIFBvc3RQcm9jZXNzb3JNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj4gQ3JlYXRpbmcgYSByZW5kZXJpbmcgbW9kdWxlIGFuZCBwYXNzaW5nIGl0IHRvIEFwcCdzIG1vZHVsZXM8L2NhcHRpb24+XG4gKiBuZXcgQXBwKFtcbiAqICAgbmV3IEVsZW1lbnRNb2R1bGUoKSxcbiAqICAgbmV3IFNjZW5lTW9kdWxlKCksXG4gKiAgIG5ldyBEZWZpbmVNb2R1bGUoJ2NhbWVyYScsIG5ldyBXSFMuUGVyc3BlY3RpdmVDYW1lcmEoe1xuICogICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLCA2LCAxOCksXG4gKiAgICAgZmFyOiAxMDAwMFxuICogICB9KSksXG4gKiAgIG5ldyBSZW5kZXJpbmdNb2R1bGUoKSxcbiAqICAgbmV3IFBvc3RQcm9jZXNzb3JNb2R1bGUoKVxuICogXSk7XG4gKlxuICogY29uc3QgcHJvY2Vzc29yID0gYXBwLnVzZSgncG9zdHByb2Nlc3NvcicpO1xuICpcbiAqIHByb2Nlc3NvclxuICogICAucmVuZGVyKClcbiAqICAgLnBhc3MobmV3IEdsaXRjaFBhc3MoKSlcbiAqICAgLnJlbmRlclRvU2NyZWVuKClcbiAqL1xuZXhwb3J0IGNsYXNzIFBvc3RQcm9jZXNzb3JNb2R1bGUge1xuICBjdXJyZW50UGFzcyA9IG51bGw7XG5cbiAgZGVmZXIgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICB9KTtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGVidWc6IHRydWVcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSBQb3N0UHJvY2Vzc29yTW9kdWxlLmRlZmF1bHRzKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IHBhcmFtcy5kZWJ1ZztcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuZGVmaW5lKCdwb3N0cHJvY2Vzc29yJyk7XG5cbiAgICB0aGlzLmVmZmVjdHMgPSBtYW5hZ2VyLnVzZSgncmVuZGVyaW5nJykuZWZmZWN0cztcbiAgICB0aGlzLnJlbmRlcmVyID0gbWFuYWdlci5nZXQoJ3JlbmRlcmVyJyk7XG4gICAgdGhpcy5zY2VuZSA9IG1hbmFnZXIuZ2V0KCdzY2VuZScpO1xuICAgIHRoaXMuY2FtZXJhID0gbWFuYWdlci5nZXQoJ2NhbWVyYScpO1xuXG4gICAgdGhpcy5jb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3Nlcih0aGlzLnJlbmRlcmVyLCB0aGlzLnBhcmFtcyk7XG5cbiAgICBtYW5hZ2VyLnVzZSgncmVuZGVyaW5nJykuc3RvcCgpO1xuXG4gICAgY29uc3QgY29tcG9zZXIgPSB0aGlzLmNvbXBvc2VyO1xuICAgIHRoaXMucmVuZGVyTG9vcCA9IG5ldyBMb29wKGNsb2NrID0+IGNvbXBvc2VyLnJlbmRlcihjbG9jay5nZXREZWx0YSgpKSkuc3RhcnQobWFuYWdlci5oYW5kbGVyKTtcblxuICAgIG1hbmFnZXIudXBkYXRlKHtcbiAgICAgIHJlbmRlcmVyOiByZW5kZXJlciA9PiB7XG4gICAgICAgIHRoaXMuY29tcG9zZXIucmVwbGFjZVJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICAgIH0sXG5cbiAgICAgIHNjZW5lOiBzY2VuZSA9PiB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgIH0sXG5cbiAgICAgIGNhbWVyYTogY2FtZXJhID0+IHtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbmRlclxuICAgKiBAZGVzY3JpcHRpb24gQWRkcyBSZW5kZXJQYXNzXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUG9zdFByb2Nlc3Nvck1vZHVsZVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuZGVmZXIudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBwYXNzID0gbmV3IFJlbmRlclBhc3ModGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEubmF0aXZlKTtcblxuICAgICAgLy8gVE9ETzogU3VwcG9ydCBmb3IgZWZmZWN0cy5cblxuICAgICAgdGhpcy5jb21wb3Nlci5hZGRQYXNzKHBhc3MpO1xuICAgICAgdGhpcy5jdXJyZW50UGFzcyA9IHBhc3M7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBhc3NcbiAgICogQGRlc2NyaXB0aW9uIEFkZHMgeW91ciBjdXN0b20gcGFzc1xuICAgKiBAcGFyYW0ge1Bhc3N9IHBhc3MgQSBjdXN0b20gcGFzc1xuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlBvc3RQcm9jZXNzb3JNb2R1bGVcbiAgICovXG4gIHBhc3MocGFzcykge1xuICAgIHRoaXMuZGVmZXIudGhlbigoKSA9PiB7XG4gICAgICBwb2x5ZmlsbChwYXNzLCAnc2V0U2l6ZScsIHRoaXMuZGVidWcpO1xuICAgICAgcG9seWZpbGwocGFzcywgJ2luaXRpYWxpc2UnLCB0aGlzLmRlYnVnKTtcblxuICAgICAgdGhpcy5jb21wb3Nlci5hZGRQYXNzKHBhc3MpO1xuICAgICAgdGhpcy5jdXJyZW50UGFzcyA9IHBhc3M7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNoYWRlclxuICAgKiBAZGVzY3JpcHRpb24gQWRkcyBhIHBhc3MgbWFkZSBmcm9tIHNoYWRlciBtYXRlcmlhbFxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbCBBIFNoYWRlck1hdGVyaWFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0dXJlSUQgTmFtZSBvZiB0aGUgcmVhZEJ1ZmZlciB1bmlmb3JtXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUG9zdFByb2Nlc3Nvck1vZHVsZVxuICAgKi9cbiAgc2hhZGVyKG1hdGVyaWFsLCB0ZXh0dXJlSUQgPSAncmVhZEJ1ZmZlcicpIHtcbiAgICB0aGlzLmRlZmVyLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCFtYXRlcmlhbC51bmlmb3Jtc1t0ZXh0dXJlSURdKVxuICAgICAgICBtYXRlcmlhbC51bmlmb3Jtc1t0ZXh0dXJlSURdID0ge3ZhbHVlOiBudWxsfTtcblxuICAgICAgY29uc3QgcGFzcyA9IG5ldyBTaGFkZXJQYXNzKG1hdGVyaWFsLCB0ZXh0dXJlSUQpO1xuXG4gICAgICB0aGlzLmNvbXBvc2VyLmFkZFBhc3MocGFzcyk7XG4gICAgICB0aGlzLmN1cnJlbnRQYXNzID0gcGFzcztcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgcGFzcyBieSB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFzc1xuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlBvc3RQcm9jZXNzb3JNb2R1bGVcbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVcbiAgICAgID8gdGhpcy5jb21wb3Nlci5wYXNzZXMuZmlsdGVyKHBhc3MgPT4gcGFzcy5uYW1lID09PSBuYW1lKVswXVxuICAgICAgOiB0aGlzLmN1cnJlbnRQYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVuZGVyVG9TY3JlZW5cbiAgICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIHJlbmRlclRvU2NyZWVuIHByb3BlcnR5IG9mIGN1cnJlbnRQYXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZT10cnVlXSBUaGUgbmFtZSBvZiB0aGUgcGFzc1xuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlBvc3RQcm9jZXNzb3JNb2R1bGVcbiAgICovXG4gIHJlbmRlclRvU2NyZWVuKGJvb2wgPSB0cnVlKSB7XG4gICAgdGhpcy5kZWZlci50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFBhc3MucmVuZGVyVG9TY3JlZW4gPSBib29sO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsIi8qKlxuICogQGNsYXNzIEV2ZW50c1BhdGNoTW9kdWxlXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBvbmUgaXMgdXNlZCBpbiB0aGUgY29yZSB0byBoYW5kbGUgZXZlbnRzIHVzZWQgYnkgbW9kdWxlcy4gSWYgeW91IHdhbnQgdG8gbWFrZSBjdXN0b20gZXZlbnRzIC0gcGxlYXNlIG1ha2UgYSBzaW1pbGFyIG9uZS5cbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcFxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRzUGF0Y2hNb2R1bGUge1xuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLmRlZmluZSgnZXZlbnRzJyk7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5nZXQoJ3JlbmRlcmVyJykuZG9tRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gcGF0Y2hFdmVudHNcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgbWV0aG9kcyBwYXRjaGVzIHRoZSBsaXN0IG9mIGV2ZW50cyBvbiBzcGVjaWZpYyBvYmplY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcmlnaW5PYmplY3QgLSBUaGUgb2JqZWN0IHRoYXQgZ2l2ZXMgZXZlbnRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Rlc3RPYmplY3Q9dGhpc10gLSBUaGUgb2JqZWN0IHRoYXQgdGFrZXMgZXZlbnRzLlxuICAgKiBAcGFyYW0ge0FycmF5W1N0cmluZ3NdfSBbZXZlbnRzPVtdXSAtIFRoZSBsaXN0IG9mIGV2ZW50cyBieSBuYW1lcy5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5FdmVudHNQYXRjaE1vZHVsZVxuICAgKi9cbiAgcGF0Y2hFdmVudHMob3JpZ2luT2JqZWN0LCBkZXN0T2JqZWN0ID0gdGhpcywgZXZlbnRzID0gW10pIHtcbiAgICBldmVudHMuZm9yRWFjaChldmVudCA9PlxuICAgICAgb3JpZ2luT2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGUgPT4gZGVzdE9iamVjdC5lbWl0KGV2ZW50LCBlKSlcbiAgICApO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICBjb25zdCB7ZWxlbWVudCwgcGF0Y2hFdmVudHN9ID0gc2VsZjtcblxuICAgIHBhdGNoRXZlbnRzKGVsZW1lbnQsIHRoaXMsIFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNldXAnLFxuICAgICAgJ2NvbnRleHRtZW51JyxcbiAgICAgICdtb3VzZWRvd24nLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgICd3aGVlbCcsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2hlbmQnLFxuICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAna2V5ZG93bicsXG4gICAgICAna2V5dXAnLFxuICAgICAgJ2tleXByZXNzJ1xuICAgIF0pO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBWZWN0b3IyLFxuICBSYXljYXN0ZXIsXG4gIFBsYW5lLFxuICBWZWN0b3IzXG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IEV2ZW50cyBmcm9tICdtaW5pdmVudHMnO1xuaW1wb3J0IHtFdmVudHNQYXRjaE1vZHVsZX0gZnJvbSAnLi9FdmVudHNQYXRjaE1vZHVsZSc7XG5cbi8qKlxuICogQGNsYXNzIFZpcnR1YWxNb3VzZU1vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtnbG9iYWxNb3ZlbWVudD1mYWxzZV1cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHBcbiAqIEBleHRlbmRzIEV2ZW50c1xuICovXG5leHBvcnQgY2xhc3MgVmlydHVhbE1vdXNlTW9kdWxlIGV4dGVuZHMgRXZlbnRzIHtcbiAgbW91c2UgPSBuZXcgVmVjdG9yMigpO1xuICByYXljYXN0ZXIgPSBuZXcgUmF5Y2FzdGVyKCk7XG4gIHdvcmxkID0gbnVsbDtcbiAgY2FudmFzID0gbnVsbDtcbiAgcHJvamVjdGlvblBsYW5lID0gbmV3IFBsYW5lKG5ldyBWZWN0b3IzKDAsIDAsIDEpLCAwKTtcblxuICBjb25zdHJ1Y3RvcihnbG9iYWxNb3ZlbWVudCA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmdsb2JhbE1vdmVtZW50ID0gZ2xvYmFsTW92ZW1lbnQ7XG4gIH1cblxuICB1cGRhdGUoZSwgY3VzdG9tWCwgY3VzdG9tWSkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGNvbnN0IHggPSBjdXN0b21YIHx8IGUuY2xpZW50WDtcbiAgICBjb25zdCB5ID0gY3VzdG9tWSB8fCBlLmNsaWVudFk7XG5cbiAgICB0aGlzLm1vdXNlLnggPSAoKHggLSByZWN0LmxlZnQpIC8gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpKSAqIDIgLSAxO1xuICAgIHRoaXMubW91c2UueSA9IC0oKHkgLSByZWN0LnRvcCkgLyAocmVjdC5ib3R0b20gLSByZWN0LnRvcCkpICogMiArIDE7XG5cbiAgICB0aGlzLnByb2plY3Rpb25QbGFuZS5ub3JtYWwuY29weSh0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcblxuICAgIHRoaXMucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5tb3VzZSwgdGhpcy5jYW1lcmEpO1xuICAgIHRoaXMuZW1pdCgnbW92ZScpO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5kZWZpbmUoJ21vdXNlJyk7XG4gICAgbWFuYWdlci5yZXF1aXJlKCdldmVudHMnLCAoKSA9PiBuZXcgRXZlbnRzUGF0Y2hNb2R1bGUoKSk7XG5cbiAgICB0aGlzLmNhbnZhcyA9IG1hbmFnZXIuZ2V0KCdyZW5kZXJlcicpLmRvbUVsZW1lbnQ7XG4gICAgdGhpcy5jYW1lcmEgPSBtYW5hZ2VyLmdldCgnY2FtZXJhJykubmF0aXZlO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICBbXG4gICAgICAnY2xpY2snLFxuICAgICAgJ21vdXNlZG93bicsXG4gICAgICAnbW91c2V1cCcsXG4gICAgICAnbW91c2Vtb3ZlJ1xuICAgIF0uZm9yRWFjaChldiA9PiB0aGlzLm9uKGV2LCBlID0+IHNlbGYuZW1pdChldiwgZSkpKTtcblxuICAgIHNlbGYuZ2xvYmFsWCA9IDA7XG4gICAgc2VsZi5nbG9iYWxZID0gMDtcblxuICAgIHRoaXMub24oJ21vdXNlbW92ZScsIGUgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBzZWxmLmdsb2JhbFggKz0gZS5tb3ZlbWVudFg7XG4gICAgICAgIHNlbGYuZ2xvYmFsWSArPSBlLm1vdmVtZW50WTtcblxuICAgICAgICBzZWxmLnVwZGF0ZShlLCBzZWxmLmdsb2JhbFgsIHNlbGYuZ2xvYmFsWSk7XG4gICAgICB9IGVsc2Ugc2VsZi51cGRhdGUoZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0cmFja1xuICAgKiBAZGVzY3JpcHRpb24gU3RhcnRzIHRyYWNraW5nIGV2ZW50cyBvbiBhIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50IEEgY29tcG9uZW50LCB0aGF0IHNob3VsZCBiZSB0cmFja2VkIGJ5IHRoZSBtb3VzZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lc3RlZCBXaGV0aGVyIGNvbXBvbmVudCdzIGNoaWxkcmVuIHNob3VsZCBiZSB0cmFja2VkIG9yIG5vdFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlZpcnR1YWxNb3VzZU1vZHVsZVxuICAgKi9cbiAgdHJhY2soY29tcG9uZW50LCBuZXN0ZWQgPSB0cnVlKSB7XG4gICAgbGV0IGlzSG92ZXJlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5vbignbW92ZScsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmhvdmVycyhjb21wb25lbnQsIG5lc3RlZCkpIHtcbiAgICAgICAgaWYgKGlzSG92ZXJlZCkgY29tcG9uZW50LmVtaXQoJ21vdXNlbW92ZScpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnQuZW1pdCgnbW91c2VvdmVyJyk7XG4gICAgICAgICAgaXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0hvdmVyZWQpIHtcbiAgICAgICAgY29tcG9uZW50LmVtaXQoJ21vdXNlb3V0Jyk7XG4gICAgICAgIGlzSG92ZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICBpZiAoaXNIb3ZlcmVkKSBjb21wb25lbnQuZW1pdCgnY2xpY2snKTtcbiAgICAgIGVsc2UgY29tcG9uZW50LmVtaXQoJ29mZkNsaWNrJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgICBpZiAoaXNIb3ZlcmVkKSBjb21wb25lbnQuZW1pdCgnbW91c2Vkb3duJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgaWYgKGlzSG92ZXJlZCkgY29tcG9uZW50LmVtaXQoJ21vdXNldXAnKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGludGVyc2VjdGlvblxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhbiBpbnRlcnNlY3Rpb24gZGF0YVxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgaW50ZXJzZWN0cyB3aXRoIG1vdXNlIHJheSAob3IgZG9lc24ndClcbiAgICogQHBhcmFtIHtCb29sZWFufSBuZXN0ZWQgV2hldGhlciBjb21wb25lbnQncyBjaGlsZHJlbiBzaG91bGQgYmUgdHJhY2tlZCBvciBub3RcbiAgICogQHJldHVybiB7QXJyYXl9IGludGVyc2VjdGlvbiBkYXRhLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlZpcnR1YWxNb3VzZU1vZHVsZVxuICAgKi9cbiAgaW50ZXJzZWN0aW9uKHtuYXRpdmV9LCBuZXN0ZWQgPSB0cnVlKSB7XG4gICAgaWYgKG5hdGl2ZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIG5lc3RlZCkge1xuICAgICAgY29uc3Qgb2JqZWN0cyA9IFtdO1xuICAgICAgbmF0aXZlLnRyYXZlcnNlKGNoaWxkID0+IG9iamVjdHMucHVzaChjaGlsZCkpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyhvYmplY3RzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG5hdGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwcm9qZWN0XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgdmVjdG9yIGJhc2VkIG9uIG1vdXNlIHJheSBpbnRlcnNlY3Rpb24gd2l0aCBwbGFuZVxuICAgKiBAcGFyYW0ge1RIUkVFLlBsYW5lfSBbcGxhbmU9dGhpcy5wcm9qZWN0aW9uUGxhbmVdIE1hdGggcGxhbmUgdGhhdCBpcyB1c2VkXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gW3RhcmdldF0gT3B0aW9uYWwgdGFyZ2V0XG4gICAqIEByZXR1cm4ge1ZlY3RvcjN9IEFuIGludGVyc2VjdGlvbiBwb2ludC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5WaXJ0dWFsTW91c2VNb2R1bGVcbiAgICovXG4gIHByb2plY3QocGxhbmUgPSB0aGlzLnByb2plY3Rpb25QbGFuZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMucmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RQbGFuZShwbGFuZSwgdGFyZ2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhvdmVyc1xuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIGJvb2xlYW4gYmFzZWQgb24gaW50ZXJzZWN0aW9uIGRhdGEgKFdoZXRoZXIgbW91c2UgaG92ZXJzIHRoZSBjb21wb25lbnQpXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBpbnRlcnNlY3RzIHdpdGggbW91c2UgcmF5IChvciBkb2Vzbid0KVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lc3RlZCBXaGV0aGVyIGNvbXBvbmVudCdzIGNoaWxkcmVuIHNob3VsZCBiZSB0cmFja2VkIG9yIG5vdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb21wb25lbnQgaXMgaG92ZXJlZC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5WaXJ0dWFsTW91c2VNb2R1bGVcbiAgICovXG4gIGhvdmVycyhjb21wb25lbnQsIG5lc3RlZCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb24oY29tcG9uZW50LCBuZXN0ZWQpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgcmF5XG4gICAqIEBtZW1iZXIge1RIUkVFLlJheX0gbW9kdWxlOm1vZHVsZXMvYXBwLlZpcnR1YWxNb3VzZU1vZHVsZSNyYXlcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IHJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5yYXljYXN0ZXIucmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIHggWy0xOyAxXVxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1vZHVsZTptb2R1bGVzL2FwcC5WaXJ0dWFsTW91c2VNb2R1bGUjeFxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZS54O1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIHkgWy0xOyAxXVxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1vZHVsZTptb2R1bGVzL2FwcC5WaXJ0dWFsTW91c2VNb2R1bGUjeVxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZS55O1xuICB9XG59XG4iLCJpbXBvcnQge0xvb3B9IGZyb20gJy4uLy4uL2NvcmUvTG9vcCc7XG5pbXBvcnQge0V2ZW50c1BhdGNoTW9kdWxlfSBmcm9tICcuL0V2ZW50c1BhdGNoTW9kdWxlJztcblxuLyoqXG4gKiBAY2xhc3MgQ29udHJvbHNNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj4gQ3JlYXRpbmcgYSByZW5kZXJpbmcgbW9kdWxlIGFuZCBwYXNzaW5nIGl0IHRvIEFwcCdzIG1vZHVsZXM8L2NhcHRpb24+XG4gKiBuZXcgQXBwKFtcbiAqICAgbmV3IEVsZW1lbnRNb2R1bGUoKSxcbiAqICAgbmV3IFNjZW5lTW9kdWxlKCksXG4gKiAgIG5ldyBEZWZpbmVNb2R1bGUoJ2NhbWVyYScsIG5ldyBXSFMuUGVyc3BlY3RpdmVDYW1lcmEoe1xuICogICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLCA2LCAxOCksXG4gKiAgICAgZmFyOiAxMDAwMFxuICogICB9KSksXG4gKiAgIG5ldyBSZW5kZXJpbmdNb2R1bGUoKSxcbiAqICAgbmV3IENvbnRyb2xzTW9kdWxlLmZyb20obmV3IFRIUkVFLlRyYWNrYmFsbENvbnRyb2xzKCkpXG4gKiBdKTtcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyb2xzTW9kdWxlIHtcbiAgc3RhdGljIGZyb20oY29udHJvbHMpIHtcbiAgICByZXR1cm4gbmV3IENvbnRyb2xzTW9kdWxlKHtjb250cm9sc30pO1xuICB9XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgY29udHJvbHM6IGZhbHNlLFxuICAgICAgZml4OiBjb250cm9scyA9PiBjb250cm9scyxcblxuICAgICAgdXBkYXRlKGMpIHtcbiAgICAgICAgdGhpcy5jb250cm9scy51cGRhdGUoYy5nZXREZWx0YSgpKTtcbiAgICAgIH1cbiAgICB9LCBwYXJhbXMpO1xuXG4gICAgdGhpcy5jb250cm9scyA9IHRoaXMucGFyYW1zLmNvbnRyb2xzO1xuICAgIHRoaXMudXBkYXRlID0gdGhpcy5wYXJhbXMudXBkYXRlO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5kZWZpbmUoJ2NvbnRyb2xzJyk7XG4gICAgbWFuYWdlci5yZXF1aXJlKCdldmVudHMnLCAoKSA9PiBuZXcgRXZlbnRzUGF0Y2hNb2R1bGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRDb250cm9sc1xuICAgKiBAZGVzY3JpcHRpb24gU2V0IHdvcmtpbmcgY29udHJvbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRyb2xzIFdvcmtpbmcgdGhyZWUuanMgY29udHJvbHMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLkNvbnRyb2xzTW9kdWxlXG4gICAqL1xuICBzZXRDb250cm9scyhjb250cm9scykge1xuICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFVwZGF0ZVxuICAgKiBAZGVzY3JpcHRpb24gU2V0IGNvbnRyb2xzIHVwZGF0ZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGUgVXBkYXRlIGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuQ29udHJvbHNNb2R1bGVcbiAgICovXG4gIHNldFVwZGF0ZSh1cGRhdGUpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludGVncmF0ZShzZWxmKSB7XG4gICAgc2VsZi51cGRhdGVMb29wID0gbmV3IExvb3Aoc2VsZi51cGRhdGUuYmluZChzZWxmKSk7XG4gICAgc2VsZi51cGRhdGVMb29wLnN0YXJ0KHRoaXMpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBGb2dFeHAyLFxuICBGb2dcbn0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIEBjbGFzcyBGb2dNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXM9e2NvbG9yOiAweGVmZDFiNSwgZGVuc2l0eTogMC4wMjAsIG5lYXI6IDEwLCBmYXI6IDEwMDB9XSAtIFRoZSBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZT1leHAyXSAtIFRoZSB0eXBlIG9mIGZvZyAtIGV4cDIgb3IgbGluZWFyXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ib3cgdG8gY3JlYXRlIGFuZCBhcHBseSBhIEZvZ01vZHVsZTwvY2FwdGlvbj5cbiAqIGNvbnN0IGZvZ01vZHVsZSA9IG5ldyBGb2dNb2R1bGUoe1xuICogICAgY29sb3I6IDB4ZmZmZmZmLFxuICogICAgZGVuc2l0eTogMC4wMyxcbiAqICAgIG5lYXI6IDIwLFxuICogICAgZmFyOiAyMDBcbiAqICB9LCAnZXhwMicpO1xuICpcbiAqIG5ldyBBcHAoW1xuICogIC4uLixcbiAqICBmb2dNb2R1bGVcbiAqIF0pO1xuICovXG5leHBvcnQgY2xhc3MgRm9nTW9kdWxlIHtcbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30sIHR5cGUpIHtcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgY29sb3I6IDB4ZWZkMWI1LFxuICAgICAgZGVuc2l0eTogMC4wMjAsXG4gICAgICBuZWFyOiAxMCxcbiAgICAgIGZhcjogMTAwMFxuICAgIH0sIHBhcmFtcyk7XG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdleHAyJykgdGhpcy5mb2cgPSBuZXcgRm9nRXhwMih0aGlzLnBhcmFtcy5jb2xvciwgdGhpcy5wYXJhbXMuZGVuc2l0eSk7XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2xpbmVhcicpIHRoaXMuZm9nID0gbmV3IEZvZyh0aGlzLnBhcmFtcy5jb2xvciwgdGhpcy5wYXJhbXMubmVhciwgdGhpcy5wYXJhbXMuZmFyKTtcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuc2V0KCdmb2cnLCB0aGlzLmZvZyk7XG4gICAgbWFuYWdlci5nZXQoJ3NjZW5lJykuZm9nID0gdGhpcy5mb2c7XG4gIH1cbn1cbiIsImltcG9ydCB7Y3JlYXRlU3RvcmV9IGZyb20gJ3JlZHV4JztcblxuY29uc3QgaXNFcXVhbERlZmF1bHQgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGVsc2UgaWYgKGEgJiYgYS5lcXVhbHMgJiYgYS5lcXVhbHMoYikpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQGNsYXNzIFN0YXRlTW9kdWxlXG4gKiBAZGVzY3JpcHRpb24gYFN0YXRlTW9kdWxlYCBpcyB1c2VmdWwgZm9yIGFwcHMsIHdoZXJlIHlvdSBuZWVkIHN0YXRlIG1hbmlwdWxhdGlvbi5cbiAqIFRoaXMgY2FuIGJlOiBfdHJhbnNpdGlvbnMgYmV0d2VlbiBzY3JlZW5zLCBnYW1lcywgZGV2ZWxvcG1lbnQgbW9tZW50c18uXG4gKiBZb3UgY2FuIGNoZWNrIFtiYXNpYy9zdGF0ZV0oaHR0cHM6Ly93aHMtZGV2LnN1cmdlLnNoL2V4YW1wbGVzLz9iYXNpYy9zdGF0ZSkgZXhhbXBsZS5cbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj4gQ3JlYXRpbmcgYSBzdGF0ZSBtb2R1bGU8L2NhcHRpb24+XG4gKiBuZXcgQXBwKFtcbiAqICAgLy8gLi4uXG4gKiAgIG5ldyBTdGF0ZU1vZHVsZSgpLmRlZmF1bHQoe1xuICogICAgIHNwaGVyZUNvbG9yOiAweGZmMDAwMFxuICogICB9KVxuICogXSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0ZU1vZHVsZSB7XG4gIHN0YXRpYyBhY3Rpb25HZW5lcmF0ZShpc0VxdWFsKSB7XG4gICAgcmV0dXJuIChzdGF0ZSA9IFt7fSwgJyddLCB7a2V5LCBkYXRhfSkgPT4ge1xuICAgICAgaWYgKGlzRXF1YWwoc3RhdGVbMF1ba2V5XSwgZGF0YSkpIHJldHVybiBzdGF0ZTtcblxuICAgICAgc3RhdGVbMF1ba2V5XSA9IGRhdGE7XG4gICAgICBzdGF0ZVsxXSA9IGtleTtcblxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihlcXVhbENoZWNrID0gaXNFcXVhbERlZmF1bHQpIHtcbiAgICB0aGlzLnN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgICBTdGF0ZU1vZHVsZS5hY3Rpb25HZW5lcmF0ZShlcXVhbENoZWNrKVxuICAgICk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICB0aGlzLmN1cnJlbnRDb25maWcgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5wcmV2Q29uZmlnID0gJ2RlZmF1bHQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb24gQWRkIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQ29uZmlndXJhdGlvbiBzZXR1cFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqIEBleGFtcGxlXG4gICAqIG5ldyBXSFMuU3RhdGVNb2R1bGUoKS5kZWZhdWx0KHtcbiAgICogICBzcGhlcmVDb2xvcjogVVRJTFMuJGNvbG9ycy5tZXNoLFxuICAgKiAgIHBsYW5lQ29sb3I6IDB4NDQ3RjhCXG4gICAqIH0pXG4gICAqL1xuICBkZWZhdWx0KGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZyh7ZGVmYXVsdDogZGF0YX0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0RXF1YWxDaGVja1xuICAgKiBAZGVzY3JpcHRpb24gU2V0cyBhbiBlcXVhbENoZWNrIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgZXF1YWwgY2hlY2tcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5TdGF0ZU1vZHVsZVxuICAgKi9cbiAgc2V0RXF1YWxDaGVjayhmdW5jKSB7XG4gICAgdGhpcy5zdG9yZS5yZXBsYWNlUmVkdWNlcihcbiAgICAgIFN0YXRlTW9kdWxlLmFjdGlvbkdlbmVyYXRlKGZ1bmMpXG4gICAgKTtcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuZGVmaW5lKCdzdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29uZmlnXG4gICAqIEBkZXNjcmlwdGlvbiBMb2FkIGNvbmZpZ3VyYXRpb25zIGZyb20gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlncyBDb25maWd1cmF0aW9uIGRhdGFcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5TdGF0ZU1vZHVsZVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj4gQWRkaW5nIGBncmVlbmAgY29uZmlndXJhdGlvbjwvY2FwdGlvbj5cbiAgICogc3RhdGUuY29uZmlnKHtcbiAgICogICBncmVlbjoge1xuICAgKiAgICAgc3BoZXJlQ29sb3I6IDB4MDBmZjAwLFxuICAgKiAgICAgcGxhbmVDb2xvcjogMHgwMGZmMDBcbiAgICogICB9XG4gICAqIH0pO1xuICAgKi9cbiAgY29uZmlnKGNvbmZpZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWdzKSB7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbltrZXldID0ga2V5ID09PSAnZGVmYXVsdCdcbiAgICAgICAgICA/IGNvbmZpZ3Nba2V5XVxuICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWd1cmF0aW9uLmRlZmF1bHQsIGNvbmZpZ3Nba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqIEBkZXNjcmlwdGlvbiBMb2FkIHVwZGF0ZXMgZnJvbSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVzIFVwZGF0ZXMgZGF0YVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPiBVcGRhdGUgY2FsbGJhY2sgZm9yIGBzcGhlcmVDb2xvcmA8L2NhcHRpb24+XG4gICAqIHN0YXRlLnVwZGF0ZSh7XG4gICAqICAgc3BoZXJlQ29sb3I6IGNvbG9yID0+IHNwaGVyZS5tYXRlcmlhbC5jb2xvci5zZXRIZXgoY29sb3IpXG4gICAqIH0pO1xuICAgKi9cbiAgdXBkYXRlKHVwZGF0ZXMgPSB7fSkge1xuICAgIHRoaXMuc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IFtkYXRhLCBjaGFuZ2VkS2V5XSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdXBkYXRlc1tjaGFuZ2VkS2V5XTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhkYXRhW2NoYW5nZWRLZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvXG4gICAqIEBkZXNjcmlwdGlvbiBTd2l0Y2ggdG8gY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ05hbWUgQ29uZmlndXJhdGlvbiBuYW1lLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPiBDaGFuZ2VzIGNvbmZpZ3VyYXRpb24gdG8gYGdyZWVuYDwvY2FwdGlvbj5cbiAgICogc3RhdGUudG8oJ2dyZWVuJyk7XG4gICAqL1xuICB0byhjb25maWdOYW1lKSB7XG4gICAgdGhpcy5wcmV2Q29uZmlnID0gdGhpcy5jdXJyZW50Q29uZmlnO1xuICAgIHRoaXMuY3VycmVudENvbmZpZyA9IGNvbmZpZ05hbWU7XG5cbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZ3VyYXRpb25bY29uZmlnTmFtZV1cbiAgICAgID8gdGhpcy5jb25maWd1cmF0aW9uW2NvbmZpZ05hbWVdXG4gICAgICA6IHRoaXMuY29uZmlndXJhdGlvbi5kZWZhdWx0O1xuXG4gICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAZGVzY3JpcHRpb24gU2V0IGN1cnJlbnQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQ29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqIEBleGFtcGxlXG4gICAqIHN0YXRlLnNldCh7XG4gICAqICAgc3BoZXJlQ29sb3I6IDB4MDBmZjAwXG4gICAqIH0pO1xuICAgKi9cbiAgc2V0KGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKVxuICAgICAgaWYgKGtleSkgdGhpcy5zdG9yZS5kaXNwYXRjaCh7dHlwZTogJ0FERCcsIGtleSwgZGF0YTogZGF0YVtrZXldfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybiBkYXRhIG9mIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBQYXJhbWV0ZXIgbmFtZS5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5TdGF0ZU1vZHVsZVxuICAgKiBAZXhhbXBsZVxuICAgKiBzdGF0ZS5nZXQoJ3NwaGVyZUNvbG9yJyk7IC8vIDB4MDBmZjAwXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVswXVtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGB0cnVlVmFsYCBpZiBgY29uZmlnYCBtYXRjaCBwcmV2aW91cyBjb25maWd1cmF0aW9uLCBpbiBvdGhlciBjYXNlIC0gcmV0dXJuIGBmYWxzZVZhbGAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcgQ29uZmlndXJhdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0ge0FueX0gdHJ1ZVZhbCBWYWx1ZSByZXR1cm5lZCBpZiBjb25kaXRpb24gaXMgdHJ1dGh5LlxuICAgKiBAcGFyYW0ge0FueX0gZmFsc2VWYWwgVmFsdWUgcmV0dXJuZWQgaWYgY29uZGl0aW9uIGlzIGZhbHN5LlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqL1xuICBwcmV2KGNvbmZpZywgdHJ1ZVZhbCwgZmFsc2VWYWwpIHtcbiAgICByZXR1cm4gdGhpcy5wcmV2Q29uZmlnID09PSBjb25maWcgPyB0cnVlVmFsIDogZmFsc2VWYWw7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjdXJyZW50XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYHRydWVWYWxgIGlmIGBjb25maWdgIG1hdGNoIGN1cnJlbnQgY29uZmlndXJhdGlvbiwgaW4gb3RoZXIgY2FzZSAtIHJldHVybiBgZmFsc2VWYWxgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnIENvbmZpZ3VyYXRpb24gbmFtZS5cbiAgICogQHBhcmFtIHtBbnl9IHRydWVWYWwgVmFsdWUgcmV0dXJuZWQgaWYgY29uZGl0aW9uIGlzIHRydXRoeS5cbiAgICogQHBhcmFtIHtBbnl9IGZhbHNlVmFsIFZhbHVlIHJldHVybmVkIGlmIGNvbmRpdGlvbiBpcyBmYWxzeS5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5TdGF0ZU1vZHVsZVxuICAgKi9cbiAgY3VycmVudChjb25maWcsIHRydWVWYWwsIGZhbHNlVmFsKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvbmZpZyA9PT0gY29uZmlnID8gdHJ1ZVZhbCA6IGZhbHNlVmFsO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBNT1VTRSxcbiAgUXVhdGVybmlvbixcbiAgU3BoZXJpY2FsLFxuICBWZWN0b3IyLFxuICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAgT3J0aG9ncmFwaGljQ2FtZXJhLFxuICBFdmVudERpc3BhdGNoZXIsXG4gIFZlY3RvcjNcbn0gZnJvbSAndGhyZWUnO1xuXG4vLyBUaGlzIHNldCBvZiBjb250cm9scyBwZXJmb3JtcyBvcmJpdGluZywgZG9sbHlpbmcgKHpvb21pbmcpLCBhbmQgcGFubmluZy5cbi8vIFVubGlrZSBUcmFja2JhbGxDb250cm9scywgaXQgbWFpbnRhaW5zIHRoZSBcInVwXCIgZGlyZWN0aW9uIG9iamVjdC51cCAoK1kgYnkgZGVmYXVsdCkuXG4vL1xuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxuLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28gZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbnRlciBzd2lwZVxuXG5leHBvcnQgY2xhc3MgVGhyZWVPcmJpdENvbnRyb2xzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50LCBldmVudEhhbmRsZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSAoZG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IGRvY3VtZW50IDogZG9tRWxlbWVudDtcbiAgICB0aGlzLmV2ZW50SGFuZGxlciA9IGV2ZW50SGFuZGxlcjtcblxuICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgb2JqZWN0IG9yYml0cyBhcm91bmRcbiAgICB0aGlzLnRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dCAoIFBlcnNwZWN0aXZlQ2FtZXJhIG9ubHkgKVxuICAgIHRoaXMubWluRGlzdGFuY2UgPSAwO1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuICAgIC8vIEhvdyBmYXIgeW91IGNhbiB6b29tIGluIGFuZCBvdXQgKCBPcnRob2dyYXBoaWNDYW1lcmEgb25seSApXG4gICAgdGhpcy5taW5ab29tID0gMDtcbiAgICB0aGlzLm1heFpvb20gPSBJbmZpbml0eTtcblxuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuICAgIC8vIFJhbmdlIGlzIDAgdG8gTWF0aC5QSSByYWRpYW5zLlxuICAgIHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcbiAgICB0aGlzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJOyAvLyByYWRpYW5zXG5cbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgaG9yaXpvbnRhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuICAgIC8vIElmIHNldCwgbXVzdCBiZSBhIHN1Yi1pbnRlcnZhbCBvZiB0aGUgaW50ZXJ2YWwgWyAtIE1hdGguUEksIE1hdGguUEkgXS5cbiAgICB0aGlzLm1pbkF6aW11dGhBbmdsZSA9IC1JbmZpbml0eTsgLy8gcmFkaWFuc1xuICAgIHRoaXMubWF4QXppbXV0aEFuZ2xlID0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblxuICAgIC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuICAgIC8vIElmIGRhbXBpbmcgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG4gICAgdGhpcy5lbmFibGVEYW1waW5nID0gZmFsc2U7XG4gICAgdGhpcy5kYW1waW5nRmFjdG9yID0gMC4yNTtcblxuICAgIC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuICAgIHRoaXMuZW5hYmxlWm9vbSA9IHRydWU7XG4gICAgdGhpcy56b29tU3BlZWQgPSAxLjA7XG5cbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSByb3RhdGluZ1xuICAgIHRoaXMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcbiAgICB0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcGFubmluZ1xuICAgIHRoaXMuZW5hYmxlUGFuID0gdHJ1ZTtcbiAgICB0aGlzLmtleVBhblNwZWVkID0gNy4wOyAvLyBwaXhlbHMgbW92ZWQgcGVyIGFycm93IGtleSBwdXNoXG5cbiAgICAvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxuICAgIC8vIElmIGF1dG8tcm90YXRlIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuICAgIHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuYXV0b1JvdGF0ZVNwZWVkID0gMi4wOyAvLyAzMCBzZWNvbmRzIHBlciByb3VuZCB3aGVuIGZwcyBpcyA2MFxuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXG4gICAgdGhpcy5lbmFibGVLZXlzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBmb3VyIGFycm93IGtleXNcbiAgICB0aGlzLmtleXMgPSB7TEVGVDogMzcsIFVQOiAzOCwgUklHSFQ6IDM5LCBCT1RUT006IDQwfTtcblxuICAgIC8vIE1vdXNlIGJ1dHRvbnNcbiAgICB0aGlzLm1vdXNlQnV0dG9ucyA9IHtPUkJJVDogTU9VU0UuTEVGVCwgWk9PTTogTU9VU0UuTUlERExFLCBQQU46IE1PVVNFLlJJR0hUfTtcblxuICAgIC8vIGZvciByZXNldFxuICAgIHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIHRoaXMuem9vbTAgPSB0aGlzLm9iamVjdC56b29tO1xuXG4gICAgLy9cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIC8vXG5cbiAgICB0aGlzLmdldFBvbGFyQW5nbGUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gc3BoZXJpY2FsLnBoaTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRBemltdXRoYWxBbmdsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBzcGhlcmljYWwudGhldGE7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRhcmdldC5jb3B5KHRoaXMudGFyZ2V0MCk7XG4gICAgICB0aGlzLm9iamVjdC5wb3NpdGlvbi5jb3B5KHRoaXMucG9zaXRpb24wKTtcbiAgICAgIHRoaXMub2JqZWN0Lnpvb20gPSB0aGlzLnpvb20wO1xuXG4gICAgICB0aGlzLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgfTtcblxuICAgIC8vIHRoaXMgbWV0aG9kIGlzIGV4cG9zZWQsIGJ1dCBwZXJoYXBzIGl0IHdvdWxkIGJlIGJldHRlciBpZiB3ZSBjYW4gbWFrZSBpdCBwcml2YXRlLi4uXG4gICAgdGhpcy51cGRhdGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgICAvLyBzbyBjYW1lcmEudXAgaXMgdGhlIG9yYml0IGF4aXNcbiAgICAgIGNvbnN0IHF1YXQgPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyhvYmplY3QudXAsIG5ldyBWZWN0b3IzKDAsIDEsIDApKTtcbiAgICAgIGNvbnN0IHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVyc2UoKTtcblxuICAgICAgY29uc3QgbGFzdFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNvbnN0IGxhc3RRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgICAgcmV0dXJuICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vYmplY3QucG9zaXRpb247XG5cbiAgICAgICAgb2Zmc2V0LmNvcHkocG9zaXRpb24pLnN1Yih0aGlzLnRhcmdldCk7XG5cbiAgICAgICAgLy8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXG4gICAgICAgIG9mZnNldC5hcHBseVF1YXRlcm5pb24ocXVhdCk7XG5cbiAgICAgICAgLy8gYW5nbGUgZnJvbSB6LWF4aXMgYXJvdW5kIHktYXhpc1xuICAgICAgICBzcGhlcmljYWwuc2V0RnJvbVZlY3RvcjMob2Zmc2V0KTtcblxuICAgICAgICBpZiAodGhpcy5hdXRvUm90YXRlICYmIHN0YXRlID09PSBTVEFURS5OT05FKVxuICAgICAgICAgIHJvdGF0ZUxlZnQoZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSk7XG5cbiAgICAgICAgc3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhO1xuICAgICAgICBzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaTtcblxuICAgICAgICAvLyByZXN0cmljdCB0aGV0YSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgIHNwaGVyaWNhbC50aGV0YSA9IE1hdGgubWF4KHRoaXMubWluQXppbXV0aEFuZ2xlLCBNYXRoLm1pbih0aGlzLm1heEF6aW11dGhBbmdsZSwgc3BoZXJpY2FsLnRoZXRhKSk7XG5cbiAgICAgICAgLy8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcbiAgICAgICAgc3BoZXJpY2FsLnBoaSA9IE1hdGgubWF4KHRoaXMubWluUG9sYXJBbmdsZSwgTWF0aC5taW4odGhpcy5tYXhQb2xhckFuZ2xlLCBzcGhlcmljYWwucGhpKSk7XG5cbiAgICAgICAgc3BoZXJpY2FsLm1ha2VTYWZlKCk7XG5cbiAgICAgICAgc3BoZXJpY2FsLnJhZGl1cyAqPSBzY2FsZTtcblxuICAgICAgICAvLyByZXN0cmljdCByYWRpdXMgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuICAgICAgICBzcGhlcmljYWwucmFkaXVzID0gTWF0aC5tYXgodGhpcy5taW5EaXN0YW5jZSwgTWF0aC5taW4odGhpcy5tYXhEaXN0YW5jZSwgc3BoZXJpY2FsLnJhZGl1cykpO1xuXG4gICAgICAgIC8vIG1vdmUgdGFyZ2V0IHRvIHBhbm5lZCBsb2NhdGlvblxuICAgICAgICB0aGlzLnRhcmdldC5hZGQocGFuT2Zmc2V0KTtcblxuICAgICAgICBvZmZzZXQuc2V0RnJvbVNwaGVyaWNhbChzcGhlcmljYWwpO1xuXG4gICAgICAgIC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuICAgICAgICBvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKHF1YXRJbnZlcnNlKTtcblxuICAgICAgICBwb3NpdGlvbi5jb3B5KHRoaXMudGFyZ2V0KS5hZGQob2Zmc2V0KTtcblxuICAgICAgICB0aGlzLm9iamVjdC5sb29rQXQodGhpcy50YXJnZXQpO1xuXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZURhbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAoMSAtIHRoaXMuZGFtcGluZ0ZhY3Rvcik7XG4gICAgICAgICAgc3BoZXJpY2FsRGVsdGEucGhpICo9ICgxIC0gdGhpcy5kYW1waW5nRmFjdG9yKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc3BoZXJpY2FsRGVsdGEuc2V0KDAsIDAsIDApO1xuXG4gICAgICAgIHNjYWxlID0gMTtcbiAgICAgICAgcGFuT2Zmc2V0LnNldCgwLCAwLCAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgY29uZGl0aW9uIGlzOlxuICAgICAgICAvLyBtaW4oY2FtZXJhIGRpc3BsYWNlbWVudCwgY2FtZXJhIHJvdGF0aW9uIGluIHJhZGlhbnMpXjIgPiBFUFNcbiAgICAgICAgLy8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cbiAgICAgICAgaWYgKHpvb21DaGFuZ2VkXG4gICAgICAgICAgfHwgbGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMub2JqZWN0LnBvc2l0aW9uKSA+IEVQU1xuICAgICAgICAgIHx8IDggKiAoMSAtIGxhc3RRdWF0ZXJuaW9uLmRvdCh0aGlzLm9iamVjdC5xdWF0ZXJuaW9uKSkgPiBFUFMpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuXG4gICAgICAgICAgbGFzdFBvc2l0aW9uLmNvcHkodGhpcy5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgIGxhc3RRdWF0ZXJuaW9uLmNvcHkodGhpcy5vYmplY3QucXVhdGVybmlvbik7XG4gICAgICAgICAgem9vbUNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kaXNwb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlKTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UpO1xuXG4gICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTsgLy8gc2hvdWxkIHRoaXMgYmUgYWRkZWQgaGVyZT9cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBpbnRlcm5hbHNcbiAgICAvL1xuXG4gICAgY29uc3QgY2hhbmdlRXZlbnQgPSB7dHlwZTogJ2NoYW5nZSd9O1xuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB7dHlwZTogJ3N0YXJ0J307XG4gICAgY29uc3QgZW5kRXZlbnQgPSB7dHlwZTogJ2VuZCd9O1xuXG4gICAgY29uc3QgU1RBVEUgPSB7Tk9ORTogLTEsIFJPVEFURTogMCwgRE9MTFk6IDEsIFBBTjogMiwgVE9VQ0hfUk9UQVRFOiAzLCBUT1VDSF9ET0xMWTogNCwgVE9VQ0hfUEFOOiA1fTtcblxuICAgIGxldCBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICBjb25zdCBFUFMgPSAwLjAwMDAwMTtcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgY29uc3Qgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgpO1xuICAgIGNvbnN0IHNwaGVyaWNhbERlbHRhID0gbmV3IFNwaGVyaWNhbCgpO1xuXG4gICAgbGV0IHNjYWxlID0gMTtcbiAgICBjb25zdCBwYW5PZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGxldCB6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgY29uc3Qgcm90YXRlU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHJvdGF0ZUVuZCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3Qgcm90YXRlRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG4gICAgY29uc3QgcGFuU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHBhbkVuZCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcGFuRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG4gICAgY29uc3QgZG9sbHlTdGFydCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgZG9sbHlFbmQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IGRvbGx5RGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG4gICAgY29uc3QgZ2V0QXV0b1JvdGF0aW9uQW5nbGUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogdGhpcy5hdXRvUm90YXRlU3BlZWQ7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFpvb21TY2FsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygwLjk1LCB0aGlzLnpvb21TcGVlZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJvdGF0ZUxlZnQgPSBhbmdsZSA9PiB7XG4gICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAtPSBhbmdsZTtcbiAgICB9O1xuXG4gICAgY29uc3Qgcm90YXRlVXAgPSBhbmdsZSA9PiB7XG4gICAgICBzcGhlcmljYWxEZWx0YS5waGkgLT0gYW5nbGU7XG4gICAgfTtcblxuICAgIGNvbnN0IHBhbkxlZnQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICAgIHJldHVybiAoZGlzdGFuY2UsIG9iamVjdE1hdHJpeCkgPT4ge1xuICAgICAgICB2LnNldEZyb21NYXRyaXhDb2x1bW4ob2JqZWN0TWF0cml4LCAwKTsgLy8gZ2V0IFggY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuICAgICAgICB2Lm11bHRpcGx5U2NhbGFyKC1kaXN0YW5jZSk7XG4gICAgICAgIHBhbk9mZnNldC5hZGQodik7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBjb25zdCBwYW5VcCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgICAgcmV0dXJuIChkaXN0YW5jZSwgb2JqZWN0TWF0cml4KSA9PiB7XG4gICAgICAgIHYuc2V0RnJvbU1hdHJpeENvbHVtbihvYmplY3RNYXRyaXgsIDEpOyAvLyBnZXQgWSBjb2x1bW4gb2Ygb2JqZWN0TWF0cml4XG4gICAgICAgIHYubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UpO1xuICAgICAgICBwYW5PZmZzZXQuYWRkKHYpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgLy8gZGVsdGFYIGFuZCBkZWx0YVkgYXJlIGluIHBpeGVsczsgcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXG4gICAgY29uc3QgcGFuID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICAgIHJldHVybiAoZGVsdGFYLCBkZWx0YVkpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyB0aGlzLmRvbUVsZW1lbnQuYm9keSA6IHRoaXMuZG9tRWxlbWVudDtcblxuICAgICAgICBpZiAodGhpcy5vYmplY3QgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgIC8vIHBlcnNwZWN0aXZlXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9iamVjdC5wb3NpdGlvbjtcbiAgICAgICAgICBvZmZzZXQuY29weShwb3NpdGlvbikuc3ViKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICBsZXQgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG5cbiAgICAgICAgICAvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cbiAgICAgICAgICB0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbigodGhpcy5vYmplY3QuZm92IC8gMikgKiBNYXRoLlBJIC8gMTgwLjApO1xuXG4gICAgICAgICAgLy8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxuICAgICAgICAgIHBhbkxlZnQoMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHRoaXMub2JqZWN0Lm1hdHJpeCk7XG4gICAgICAgICAgcGFuVXAoMiAqIGRlbHRhWSAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHRoaXMub2JqZWN0Lm1hdHJpeCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vYmplY3QgaW5zdGFuY2VvZiBPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICAvLyBvcnRob2dyYXBoaWNcbiAgICAgICAgICBwYW5MZWZ0KGRlbHRhWCAqICh0aGlzLm9iamVjdC5yaWdodCAtIHRoaXMub2JqZWN0LmxlZnQpIC8gdGhpcy5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50V2lkdGgsIHRoaXMub2JqZWN0Lm1hdHJpeCk7XG4gICAgICAgICAgcGFuVXAoZGVsdGFZICogKHRoaXMub2JqZWN0LnRvcCAtIHRoaXMub2JqZWN0LmJvdHRvbSkgLyB0aGlzLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHRoaXMub2JqZWN0Lm1hdHJpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG5vciBwZXJzcGVjdGl2ZVxuICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogT3JiaXRDb250cm9sc01vZHVsZS5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLicpO1xuICAgICAgICAgIHRoaXMuZW5hYmxlUGFuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGNvbnN0IGRvbGx5SW4gPSBkb2xseVNjYWxlID0+IHtcbiAgICAgIGlmICh0aGlzLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhKVxuICAgICAgICBzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG4gICAgICBlbHNlIGlmICh0aGlzLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICB0aGlzLm9iamVjdC56b29tID0gTWF0aC5tYXgodGhpcy5taW5ab29tLCBNYXRoLm1pbih0aGlzLm1heFpvb20sIHRoaXMub2JqZWN0Lnpvb20gKiBkb2xseVNjYWxlKSk7XG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgem9vbUNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBPcmJpdENvbnRyb2xzTW9kdWxlLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLicpO1xuICAgICAgICB0aGlzLmVuYWJsZVpvb20gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZG9sbHlPdXQgPSBkb2xseVNjYWxlID0+IHtcbiAgICAgIGlmICh0aGlzLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhKVxuICAgICAgICBzY2FsZSAqPSBkb2xseVNjYWxlO1xuXG4gICAgICBlbHNlIGlmICh0aGlzLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICB0aGlzLm9iamVjdC56b29tID0gTWF0aC5tYXgodGhpcy5taW5ab29tLCBNYXRoLm1pbih0aGlzLm1heFpvb20sIHRoaXMub2JqZWN0Lnpvb20gLyBkb2xseVNjYWxlKSk7XG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgem9vbUNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBPcmJpdENvbnRyb2xzTW9kdWxlLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLicpO1xuICAgICAgICB0aGlzLmVuYWJsZVpvb20gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBldmVudCBjYWxsYmFja3MgLSB1cGRhdGUgdGhlIG9iamVjdCBzdGF0ZVxuICAgIC8vXG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZURvd25Sb3RhdGUgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93blJvdGF0ZScgKTtcblxuICAgICAgcm90YXRlU3RhcnQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZURvd25Eb2xseSA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duRG9sbHknICk7XG5cbiAgICAgIGRvbGx5U3RhcnQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZURvd25QYW4gPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93blBhbicgKTtcblxuICAgICAgcGFuU3RhcnQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmVSb3RhdGUgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZVJvdGF0ZScgKTtcblxuICAgICAgcm90YXRlRW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMocm90YXRlRW5kLCByb3RhdGVTdGFydCk7XG5cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gdGhpcy5kb21FbGVtZW50LmJvZHkgOiB0aGlzLmRvbUVsZW1lbnQ7XG5cbiAgICAgIC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcbiAgICAgIHJvdGF0ZUxlZnQoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHRoaXMucm90YXRlU3BlZWQpO1xuXG4gICAgICAvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcbiAgICAgIHJvdGF0ZVVwKDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogdGhpcy5yb3RhdGVTcGVlZCk7XG5cbiAgICAgIHJvdGF0ZVN0YXJ0LmNvcHkocm90YXRlRW5kKTtcblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VNb3ZlRG9sbHkgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZURvbGx5JyApO1xuXG4gICAgICBkb2xseUVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG5cbiAgICAgIGRvbGx5RGVsdGEuc3ViVmVjdG9ycyhkb2xseUVuZCwgZG9sbHlTdGFydCk7XG5cbiAgICAgIGlmIChkb2xseURlbHRhLnkgPiAwKVxuICAgICAgICBkb2xseUluKGdldFpvb21TY2FsZSgpKTtcblxuICAgICAgZWxzZSBpZiAoZG9sbHlEZWx0YS55IDwgMClcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpO1xuXG4gICAgICBkb2xseVN0YXJ0LmNvcHkoZG9sbHlFbmQpO1xuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmVQYW4gPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZVBhbicgKTtcblxuICAgICAgcGFuRW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcblxuICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyhwYW5FbmQsIHBhblN0YXJ0KTtcblxuICAgICAgcGFuKHBhbkRlbHRhLngsIHBhbkRlbHRhLnkpO1xuXG4gICAgICBwYW5TdGFydC5jb3B5KHBhbkVuZCk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlVXAgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlVXAnICk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlV2hlZWwgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlV2hlZWwnICk7XG5cbiAgICAgIGlmIChldmVudC5kZWx0YVkgPCAwKVxuICAgICAgICBkb2xseU91dChnZXRab29tU2NhbGUoKSk7XG5cbiAgICAgIGVsc2UgaWYgKGV2ZW50LmRlbHRhWSA+IDApXG4gICAgICAgIGRvbGx5SW4oZ2V0Wm9vbVNjYWxlKCkpO1xuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coICdoYW5kbGVLZXlEb3duJyApO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSB0aGlzLmtleXMuVVA6XG4gICAgICAgICAgcGFuKDAsIHRoaXMua2V5UGFuU3BlZWQpO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0aGlzLmtleXMuQk9UVE9NOlxuICAgICAgICAgIHBhbigwLCAtdGhpcy5rZXlQYW5TcGVlZCk7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRoaXMua2V5cy5MRUZUOlxuICAgICAgICAgIHBhbih0aGlzLmtleVBhblNwZWVkLCAwKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdGhpcy5rZXlzLlJJR0hUOlxuICAgICAgICAgIHBhbigtdGhpcy5rZXlQYW5TcGVlZCwgMCk7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0Um90YXRlJyApO1xuXG4gICAgICByb3RhdGVTdGFydC5zZXQoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnREb2xseSA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydERvbGx5JyApO1xuXG4gICAgICBjb25zdCBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgY29uc3QgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcblxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICBkb2xseVN0YXJ0LnNldCgwLCBkaXN0YW5jZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnRQYW4gPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnRQYW4nICk7XG5cbiAgICAgIHBhblN0YXJ0LnNldChldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlVG91Y2hNb3ZlUm90YXRlID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVSb3RhdGUnICk7XG5cbiAgICAgIHJvdGF0ZUVuZC5zZXQoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSk7XG4gICAgICByb3RhdGVEZWx0YS5zdWJWZWN0b3JzKHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQpO1xuXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHRoaXMuZG9tRWxlbWVudC5ib2R5IDogdGhpcy5kb21FbGVtZW50O1xuXG4gICAgICAvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXG4gICAgICByb3RhdGVMZWZ0KDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiB0aGlzLnJvdGF0ZVNwZWVkKTtcblxuICAgICAgLy8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG4gICAgICByb3RhdGVVcCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHRoaXMucm90YXRlU3BlZWQpO1xuXG4gICAgICByb3RhdGVTdGFydC5jb3B5KHJvdGF0ZUVuZCk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoTW92ZURvbGx5ID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVEb2xseScgKTtcblxuICAgICAgY29uc3QgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgIGNvbnN0IGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XG5cbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgZG9sbHlFbmQuc2V0KDAsIGRpc3RhbmNlKTtcblxuICAgICAgZG9sbHlEZWx0YS5zdWJWZWN0b3JzKGRvbGx5RW5kLCBkb2xseVN0YXJ0KTtcblxuICAgICAgaWYgKGRvbGx5RGVsdGEueSA+IDApXG4gICAgICAgIGRvbGx5T3V0KGdldFpvb21TY2FsZSgpKTtcblxuICAgICAgZWxzZSBpZiAoZG9sbHlEZWx0YS55IDwgMClcbiAgICAgICAgZG9sbHlJbihnZXRab29tU2NhbGUoKSk7XG5cbiAgICAgIGRvbGx5U3RhcnQuY29weShkb2xseUVuZCk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoTW92ZVBhbiA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlUGFuJyApO1xuXG4gICAgICBwYW5FbmQuc2V0KGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpO1xuXG4gICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKHBhbkVuZCwgcGFuU3RhcnQpO1xuXG4gICAgICBwYW4ocGFuRGVsdGEueCwgcGFuRGVsdGEueSk7XG5cbiAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlVG91Y2hFbmQgPSAoKSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoRW5kJyApO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIGV2ZW50IGhhbmRsZXJzIC0gRlNNOiBsaXN0ZW4gZm9yIGV2ZW50cyBhbmQgcmVzZXQgc3RhdGVcbiAgICAvL1xuXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSB0aGlzLm1vdXNlQnV0dG9ucy5PUkJJVCkge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaGFuZGxlTW91c2VEb3duUm90YXRlKGV2ZW50KTtcblxuICAgICAgICBzdGF0ZSA9IFNUQVRFLlJPVEFURTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09PSB0aGlzLm1vdXNlQnV0dG9ucy5aT09NKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVpvb20gPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaGFuZGxlTW91c2VEb3duRG9sbHkoZXZlbnQpO1xuXG4gICAgICAgIHN0YXRlID0gU1RBVEUuRE9MTFk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gdGhpcy5tb3VzZUJ1dHRvbnMuUEFOKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVBhbiA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBoYW5kbGVNb3VzZURvd25QYW4oZXZlbnQpO1xuXG4gICAgICAgIHN0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXIub24oJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLm9uKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvbk1vdXNlTW92ZSA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gU1RBVEUuUk9UQVRFKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBoYW5kbGVNb3VzZU1vdmVSb3RhdGUoZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gU1RBVEUuRE9MTFkpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlWm9vbSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBoYW5kbGVNb3VzZU1vdmVEb2xseShldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBTVEFURS5QQU4pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGhhbmRsZU1vdXNlTW92ZVBhbihldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VVcCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGhhbmRsZU1vdXNlVXAoZXZlbnQpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuXG4gICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VXaGVlbCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlIHx8IHRoaXMuZW5hYmxlWm9vbSA9PT0gZmFsc2UgfHwgKHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUpKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgaGFuZGxlTW91c2VXaGVlbChldmVudCk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTsgLy8gbm90IHN1cmUgd2h5IHRoZXNlIGFyZSBoZXJlLi4uXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSB8fCB0aGlzLmVuYWJsZUtleXMgPT09IGZhbHNlIHx8IHRoaXMuZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBoYW5kbGVLZXlEb3duKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Ub3VjaFN0YXJ0ID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cbiAgICAgICAgICBpZiAodGhpcy5lbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKGV2ZW50KTtcblxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cbiAgICAgICAgICBpZiAodGhpcy5lbmFibGVab29tID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5KGV2ZW50KTtcblxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVBhbiA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnRQYW4oZXZlbnQpO1xuXG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuTk9ORSlcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvblRvdWNoTW92ZSA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cbiAgICAgICAgICBpZiAodGhpcy5lbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUpIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXG5cbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoZXZlbnQpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cbiAgICAgICAgICBpZiAodGhpcy5lbmFibGVab29tID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfRE9MTFkpIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXG5cbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseShldmVudCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVBhbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTikgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZVBhbihldmVudCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uVG91Y2hFbmQgPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBoYW5kbGVUb3VjaEVuZChldmVudCk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG5cbiAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIC8vXG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlci5vbignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51LCBmYWxzZSk7XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlci5vbignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICB0aGlzLmV2ZW50SGFuZGxlci5vbignd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlKTtcblxuICAgIHRoaXMuZXZlbnRIYW5kbGVyLm9uKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgdGhpcy5ldmVudEhhbmRsZXIub24oJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgIHRoaXMuZXZlbnRIYW5kbGVyLm9uKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuXG4gICAgdGhpcy5ldmVudEhhbmRsZXIub24oJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlKTtcblxuICAgIC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBjZW50ZXIoKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAuY2VudGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnRhcmdldCcpO1xuICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgfVxuXG4gIGdldCBub1pvb20oKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAubm9ab29tIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlWm9vbSBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAhdGhpcy5lbmFibGVab29tO1xuICB9XG5cbiAgc2V0IG5vWm9vbSh2YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9sczogLm5vWm9vbSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVpvb20gaW5zdGVhZC4nKTtcbiAgICB0aGlzLmVuYWJsZVpvb20gPSAhdmFsdWU7XG4gIH1cblxuICBnZXQgbm9Sb3RhdGUoKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAubm9Sb3RhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVSb3RhdGUgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gIXRoaXMuZW5hYmxlUm90YXRlO1xuICB9XG5cbiAgc2V0IG5vUm90YXRlKHZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAubm9Sb3RhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVSb3RhdGUgaW5zdGVhZC4nKTtcbiAgICB0aGlzLmVuYWJsZVJvdGF0ZSA9ICF2YWx1ZTtcbiAgfVxuXG4gIGdldCBub1BhbigpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5ub1BhbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVBhbiBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAhdGhpcy5lbmFibGVQYW47XG4gIH1cblxuICBzZXQgbm9QYW4odmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5ub1BhbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVBhbiBpbnN0ZWFkLicpO1xuICAgIHRoaXMuZW5hYmxlUGFuID0gIXZhbHVlO1xuICB9XG5cbiAgZ2V0IG5vS2V5cygpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5ub0tleXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVLZXlzIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICF0aGlzLmVuYWJsZUtleXM7XG4gIH1cblxuICBzZXQgbm9LZXlzKHZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAubm9LZXlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlS2V5cyBpbnN0ZWFkLicpO1xuICAgIHRoaXMuZW5hYmxlS2V5cyA9ICF2YWx1ZTtcbiAgfVxuXG4gIGdldCBzdGF0aWNNb3ZpbmcoKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAuc3RhdGljTW92aW5nIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlRGFtcGluZyBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAhdGhpcy5lbmFibGVEYW1waW5nO1xuICB9XG5cbiAgc2V0IHN0YXRpY01vdmluZyh2YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9sczogLnN0YXRpY01vdmluZyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZURhbXBpbmcgaW5zdGVhZC4nKTtcbiAgICB0aGlzLmVuYWJsZURhbXBpbmcgPSAhdmFsdWU7XG4gIH1cblxuICBnZXQgZHluYW1pY0RhbXBpbmdGYWN0b3IoKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIHRoaXMuZGFtcGluZ0ZhY3RvcjtcbiAgfVxuXG4gIHNldCBkeW5hbWljRGFtcGluZ0ZhY3Rvcih2YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9sczogLmR5bmFtaWNEYW1waW5nRmFjdG9yIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSAuZGFtcGluZ0ZhY3RvciBpbnN0ZWFkLicpO1xuICAgIHRoaXMuZGFtcGluZ0ZhY3RvciA9IHZhbHVlO1xuICB9XG59XG4iLCJpbXBvcnQge1ZlY3RvcjN9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7Q29udHJvbHNNb2R1bGV9IGZyb20gJy4uL0NvbnRyb2xzTW9kdWxlJztcblxuaW1wb3J0IHtUaHJlZU9yYml0Q29udHJvbHN9IGZyb20gJy4vbGliL1RocmVlT3JiaXRDb250cm9scyc7XG5cbi8qKlxuICogQGNsYXNzIE9yYml0Q29udHJvbHNNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcy5vYmplY3Q9Y2FtZXJhXSBPYmplY3QgdG8gd2hpY2ggY29udHJvbHMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IFtwYXJhbXMudGFyZ2V0PW5ldyBWZWN0b3IzKCldIENvbnRyb2xzIGNlbnRlciB2ZWN0b3IuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuZm9sbG93PWZhbHNlXSBGb2xsb3cgdGhlIHRhcmdldFxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcFxuICogQGV4YW1wbGUgPGNhcHRpb24+IENyZWF0aW5nIGEgcmVuZGVyaW5nIG1vZHVsZSBhbmQgcGFzc2luZyBpdCB0byBBcHAncyBtb2R1bGVzPC9jYXB0aW9uPlxuICogbmV3IEFwcChbXG4gKiAgIG5ldyBFbGVtZW50TW9kdWxlKCksXG4gKiAgIG5ldyBTY2VuZU1vZHVsZSgpLFxuICogICBuZXcgRGVmaW5lTW9kdWxlKCdjYW1lcmEnLCBuZXcgV0hTLlBlcnNwZWN0aXZlQ2FtZXJhKHtcbiAqICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoMCwgNiwgMTgpLFxuICogICAgIGZhcjogMTAwMDBcbiAqICAgfSkpLFxuICogICBuZXcgUmVuZGVyaW5nTW9kdWxlKCksXG4gKiAgIG5ldyBPcmJpdENvbnRyb2xzTW9kdWxlKClcbiAqIF0pO1xuICovXG5leHBvcnQgY2xhc3MgT3JiaXRDb250cm9sc01vZHVsZSBleHRlbmRzIENvbnRyb2xzTW9kdWxlIHtcbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGZvbGxvdzogZmFsc2UsXG4gICAgICBvYmplY3Q6IG51bGwsXG4gICAgICB0YXJnZXQ6IG5ldyBWZWN0b3IzKClcbiAgICB9LCBwYXJhbXMpO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIubWFuYWdlcihtYW5hZ2VyKTtcblxuICAgIGNvbnN0IHtvYmplY3Q6IG9iaiwgZm9sbG93LCB0YXJnZXR9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3Qgb2JqZWN0ID0gb2JqID8gb2JqLm5hdGl2ZSA6IG1hbmFnZXIuZ2V0KCdjYW1lcmEnKS5uYXRpdmU7XG5cbiAgICBjb25zdCBjb250cm9scyA9IG5ldyBUaHJlZU9yYml0Q29udHJvbHMoXG4gICAgICBvYmplY3QsXG4gICAgICBtYW5hZ2VyLmdldCgnZWxlbWVudCcpLFxuICAgICAgbWFuYWdlci5oYW5kbGVyXG4gICAgKTtcblxuICAgIGNvbnN0IHVwZGF0ZVByb2Nlc3NvciA9IGZvbGxvdyA/IGMgPT4ge1xuICAgICAgY29udHJvbHMudXBkYXRlKGMuZ2V0RGVsdGEoKSk7XG4gICAgICBjb250cm9scy50YXJnZXQuY29weSh0YXJnZXQpO1xuICAgIH0gOiBjID0+IHtcbiAgICAgIGNvbnRyb2xzLnVwZGF0ZShjLmdldERlbHRhKCkpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldENvbnRyb2xzKGNvbnRyb2xzKTtcbiAgICB0aGlzLnNldFVwZGF0ZSh1cGRhdGVQcm9jZXNzb3IpO1xuXG4gICAgbWFuYWdlci51cGRhdGUoe1xuICAgICAgY2FtZXJhOiBjYW1lcmEgPT4ge1xuICAgICAgICBpZiAob2JqKSByZXR1cm47XG4gICAgICAgIGNvbnRyb2xzLm9iamVjdCA9IGNhbWVyYS5uYXRpdmU7XG4gICAgICB9LFxuICAgICAgZWxlbWVudDogZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnRyb2xzLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udHJvbHMudGFyZ2V0LmNvcHkodGFyZ2V0KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgbW9kdWxlcy9hcHAvY29udHJvbHMgKi9cbmV4cG9ydCAqIGZyb20gJy4vT3JiaXRDb250cm9sc01vZHVsZSc7XG4iLCIvKiogQG1vZHVsZSBtb2R1bGVzL2FwcCAqL1xuZXhwb3J0ICogZnJvbSAnLi9FbGVtZW50TW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vUmVuZGVyaW5nTW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vU2NlbmVNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9SZXNpemVNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9Qb3N0UHJvY2Vzc29yTW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vVmlydHVhbE1vdXNlTW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vRXZlbnRzUGF0Y2hNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9Db250cm9sc01vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL0ZvZ01vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL1N0YXRlTW9kdWxlJztcblxuLy8gY29udHJvbHNcbmV4cG9ydCAqIGZyb20gJy4vY29udHJvbHMvaW5kZXgnO1xuIiwiLyoqXG4gKiBAY2xhc3MgRHluYW1pY0dlb21ldHJ5TW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlcy9tZXNoXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcz17YXR0cmlidXRlczogZmFsc2V9XSAtIHBhcmFtc1xuICogQHBhcmFtIHtCb29sZWFufSBbcGF0Y2hFdmVudHM9dHJ1ZV1cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9tZXNoXG4gKi9cbmV4cG9ydCBjbGFzcyBEeW5hbWljR2VvbWV0cnlNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhdHRyaWJ1dGVzOiBmYWxzZVxuICAgIH0sIHBhcmFtcyk7XG4gIH1cblxuICBpbnRlZ3JhdGUoc2VsZikge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNlbGYucGFyYW1zO1xuXG4gICAgdGhpcy5nXyA9IGZ1bmN0aW9uIChwYXJhbXMgPSB7fSkge1xuICAgICAgaWYgKHRoaXMuYnVpbGRHZW9tZXRyeSkge1xuICAgICAgICB0aGlzLm5hdGl2ZS5nZW9tZXRyeSA9IHRoaXMuYnVpbGRHZW9tZXRyeShcbiAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmFtcyh7Z2VvbWV0cnk6IHBhcmFtc30pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChwYXJhbXMuYXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJhbXMuZ2VvbWV0cnkpIHtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBgZ18ke2tleX1gLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZS5nZW9tZXRyeS5wYXJhbWV0ZXJzW2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRoaXMubmF0aXZlLmdlb21ldHJ5ID0gdGhpcy5idWlsZEdlb21ldHJ5KHRoaXMudXBkYXRlUGFyYW1zKHtnZW9tZXRyeToge1trZXldOiB2YWx1ZX19KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBSZXBlYXRXcmFwcGluZyxcbiAgVVZNYXBwaW5nLFxuICBOZWFyZXN0RmlsdGVyLFxuICBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsXG4gIFRleHR1cmVMb2FkZXIsXG4gIFZlY3RvcjJcbn0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuXG4vKipcbiAqIEBjbGFzcyBUZXh0dXJlTW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlcy9tZXNoXG4gKiBAZGVzY3JpcHRpb24gQSBUZXh0dXJlTW9kdWxlIGNhbiBiZSBhcHBsaWVkIHRvIGFueSBNZXNoIG9yIE1vZGVsLlxuICogQHBhcmFtIHtBcnJheX0gW3RleHR1cmVzXSAtIGFycmF5IG9mIHRleHR1cmUgb2JqZWN0c1xuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL21lc2hcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGFuIGluc3RhbmNlLiB1cmwgdGFrZXMgYSBwYXRoLCBvciBhIGRhdGEgb2JqZWN0LjwvY2FwdGlvbj5cbiAqIHZhciB3b29kVGV4dHVyZSA9IG5ldyBUZXh0dXJlTW9kdWxlKHtcbiAqICAgdXJsOiBgJHtwcm9jZXNzLmFzc2V0c1BhdGh9L3RleHR1cmVzL3dvb2QuanBnYFxuICogfSk7XG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Nb3JlIGNvbXByZWhlbnNpdmUgZXhhbXBsZSwgd29vZCB0ZXh0dXJlIGFwcGxpZWQgdG8gYSBCb3guPC9jYXB0aW9uPlxuICogbmV3IEJveCh7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgd2lkdGg6IDIsXG4gKiAgICAgaGVpZ2h0OiAyLFxuICogICAgIGRlcHRoOiAyXG4gKiAgIH0sXG4gKiAgIG1vZHVsZXM6IFtcbiAqICAgICBuZXcgVGV4dHVyZU1vZHVsZSh7XG4gKiAgICAgICB1cmw6IGBwYXRoL3RvL3RleHR1cmUuanBnYCxcbiAqICAgICAgIHJlcGVhdDogbmV3IFRIUkVFLlZlY3RvcjIoMSwgMSkgLy8gb3B0aW9uYWxcbiAqICAgICB9KVxuICogICBdLFxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKiAgIHBvc2l0aW9uOiBbNTAsIDYwLCA3MF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0dXJlTW9kdWxlIHtcbiAgc3RhdGljIGxvYWQodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlTW9kdWxlKHt1cmx9KS50ZXh0dXJlc1swXVsxXTtcbiAgfVxuXG4gIHRleHR1cmVzID0gW107XG5cbiAgY29uc3RydWN0b3IoLi4udGV4dHVyZXMpIHtcbiAgICB0ZXh0dXJlcy5mb3JFYWNoKCh7XG4gICAgICB1cmwsXG4gICAgICB0eXBlID0gJ21hcCcsXG4gICAgICBvZmZzZXQgPSBuZXcgVmVjdG9yMigwLCAwKSxcbiAgICAgIHJlcGVhdCA9IG5ldyBWZWN0b3IyKDEsIDEpLFxuICAgICAgd3JhcCA9IFJlcGVhdFdyYXBwaW5nLFxuICAgICAgbWFwcGluZyA9IFVWTWFwcGluZyxcbiAgICAgIGZpeCA9IHRleCA9PiB0ZXhcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gbG9hZGVyLmxvYWQodXJsKTtcblxuICAgICAgaWYgKHdyYXAubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZXh0dXJlLndyYXBTID0gd3JhcFswXTtcbiAgICAgICAgdGV4dHVyZS53cmFwVCA9IHdyYXBbMV07XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGV4dHVyZS53cmFwUyA9IHRleHR1cmUud3JhcFQgPSB3cmFwO1xuXG4gICAgICB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xuXG4gICAgICB0ZXh0dXJlLm9mZnNldC5jb3B5KG9mZnNldCk7XG4gICAgICB0ZXh0dXJlLnJlcGVhdC5jb3B5KHJlcGVhdCk7XG5cbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcbiAgICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG4gICAgICB0aGlzLnRleHR1cmVzLnB1c2goW3R5cGUsIGZpeCh0ZXh0dXJlKV0pO1xuICAgIH0pO1xuICB9XG5cbiAgYnJpZGdlID0ge1xuICAgIG1hdGVyaWFsKG1hdGVyaWFsLCBzZWxmKSB7XG4gICAgICBzZWxmLnRleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICAgIG1hdGVyaWFsW3RleHR1cmVbMF1dID0gdGV4dHVyZVsxXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWF0ZXJpYWw7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBBbmltYXRpb25NaXhlcixcbiAgQW5pbWF0aW9uQ2xpcCxcbiAgQ2xvY2tcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge0xvb3B9IGZyb20gJy4uLy4uL2NvcmUvTG9vcCc7XG5cbi8qKlxuICogQGNsYXNzIEFuaW1hdGlvbk1vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvbWVzaFxuICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIG1vZHVsZSB0aGF0IHdyYXBzIHRoZSA8YSBocmVmPSdodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9pbnRyb2R1Y3Rpb24vQW5pbWF0aW9uLXN5c3RlbSc+dGhyZWUuanMgYW5pbWF0aW9uIHN5c3RlbTwvYT5cbiAqIEBwYXJhbSB7QXBwfSBhcHAgLSB0aGUgYXBwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0RlZmVycmVkPWZhbHNlXSAtIHNldCB0byB0cnVlIGlmIGFuaW1hdGlvbiBzaG91bGQgbm90IHN0YXJ0IGF1dG9tYXRpY2FsbHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXtzcGVlZDogMX1dIC0gdGhlIHBhcmFtc1xuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL21lc2hcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhbmltYXRpb24gbW9kdWxlIGFuZCBwbGF5IGEgZ2l2ZW4gY2xpcCBvZiBhbiBpbXBvcnRlZCBtb2RlbDwvY2FwdGlvbj5cbiAqIGNvbnN0IGFuaW1hdGlvbk1vZHVsZSA9IG5ldyBBbmltYXRpb25Nb2R1bGUoYXBwLCBmYWxzZSwge1xuICogICBzcGVlZDogMS4yIC8vIHNwZWVkIHVwIGFuaW1hdGlvbiBieSAyMCVcbiAqIH0pO1xuICpcbiAqIG5ldyBJbXBvcnRlcih7XG4gKiAgIHBhcnNlcihnZW9tZXRyeSwgbWF0ZXJpYWxzKSB7XG4gKiAgICAgLy8gT3ZlcnJpZGUgcGFyc2UgdG8gZ2VuZXJhdGUgYSBza2lubmVkTWVzaCwgbmVlZGVkIGZvciBza2lubmVkIG1vZGVsc1xuICogICAgIHJldHVybiBuZXcgVEhSRUUuU2tpbm5lZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFscyk7XG4gKiAgIH0sXG4gKlxuICogICB1cmw6IGBwYXRoL3RvL21vZGVsLmpzb25gLFxuICogICB1c2VDdXN0b21NYXRlcmlhbDogdHJ1ZSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICogICAgIHNraW5uaW5nOiB0cnVlXG4gKiAgIH0pLFxuICpcbiAqICAgbW9kdWxlczogW2FuaW1hdGlvbk1vZHVsZV1cbiAqIH0pLmFkZFRvKGFwcCkudGhlbigoKSA9PiB7XG4gKiAgIC8vIGFkZGluZyBtb2RlbCB0byBhcHAgcmV0dXJucyBhIHByb21pc2UsIHNvIHBpcGUgdGhlIGZ1bmN0aW9uIHRvIGtpY2sgb2ZmIHRoZSBhbmltYXRpb24gY2xpcFxuICogICBhbmltYXRpb25Nb2R1bGUucGxheSgnY2xpcE5hbWUnKTtcbiAqIH0pO1xuICovXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uTW9kdWxlIHtcbiAgY29uc3RydWN0b3IoYXBwLCBpc0RlZmVycmVkLCBwYXJhbXMgPSB7fSkge1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzcGVlZDogMVxuICAgIH0sIHBhcmFtcyk7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBDbG9jaygpO1xuXG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5pc0RlZmVycmVkID0gaXNEZWZlcnJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBsYXlcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBQbGF5cyB0aGUgZ2l2ZW4gY2xpcCBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGlwTmFtZSAtIHRoZSBjbGlwIHRvIHBsYXlcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL21lc2guQW5pbWF0aW9uTW9kdWxlXG4gICAqL1xuICBwbGF5KGNsaXBOYW1lKSB7XG4gICAgY29uc3QgY2xpcCA9IEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSh0aGlzLmNsaXBzLCBjbGlwTmFtZSk7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5taXhlci5jbGlwQWN0aW9uKGNsaXApO1xuXG4gICAgYWN0aW9uLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZSB0aGUgbWl4ZXIgKGJlaW5nIGNhbGxlZCBvbiBmcmFtZSBhbmltYXRpb24gbG9vcClcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL21lc2guQW5pbWF0aW9uTW9kdWxlXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMubWl4ZXIpIHRoaXMubWl4ZXIudXBkYXRlKHRoaXMuY2xvY2suZ2V0RGVsdGEoKSAqIHRoaXMucGFyYW1zLnNwZWVkKTtcbiAgfVxuXG4gIGludGVncmF0ZShzZWxmKSB7XG4gICAgc2VsZi5sb29wID0gbmV3IExvb3AoKCkgPT4ge1xuICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICB9KTtcblxuICAgIGlmICghc2VsZi5pc0RlZmVycmVkKSBzZWxmLmxvb3Auc3RhcnQoc2VsZi5hcHApO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5kZWZpbmUoJ2FuaW1hdGlvbicpO1xuICB9XG5cbiAgYnJpZGdlID0ge1xuICAgIG1lc2gobWVzaCwgc2VsZikge1xuICAgICAgbWVzaC5nZW9tZXRyeS5za2VsZXRvbiA9IG1lc2guc2tlbGV0b247XG5cbiAgICAgIHNlbGYubWl4ZXIgPSBuZXcgQW5pbWF0aW9uTWl4ZXIobWVzaC5nZW9tZXRyeSk7XG4gICAgICBzZWxmLmNsaXBzID0gbWVzaC5nZW9tZXRyeS5hbmltYXRpb25zO1xuXG4gICAgICByZXR1cm4gbWVzaDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIG1vZHVsZXMvbWVzaCAqL1xuZXhwb3J0ICogZnJvbSAnLi9EeW5hbWljR2VvbWV0cnlNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9UZXh0dXJlTW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vQW5pbWF0aW9uTW9kdWxlJztcbiIsIi8qKlxuICogQGNsYXNzIERlZmluZU1vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj4gQ3JlYXRpbmcgYSBEZWZpbmVNb2R1bGUgd2l0aCBQZXJzcGVjdGl2ZUNhbWVyYSBhcyBjYW1lcmEgbW9kdWxlIGFuZCBwYXNzaW5nIGl0IHRvIEFwcCdzIG1vZHVsZXM8L2NhcHRpb24+XG4gKiBuZXcgQXBwKFtcbiAqICAgLy8gLi4uXG4gKiAgIG5ldyBEZWZpbmVNb2R1bGUoJ2NhbWVyYScsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICogXSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZpbmVNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5zZXQodGhpcy5uYW1lLCB0aGlzLmRhdGEpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBtb2R1bGVzICovXG5cbmV4cG9ydCAqIGZyb20gJy4vYXBwL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vbWVzaC9pbmRleCc7XG5cbi8vIG1vZHVsZXNcbmV4cG9ydCAqIGZyb20gJy4vRGVmaW5lTW9kdWxlJztcbiIsImltcG9ydCB7SW1wb3J0ZXJ9IGZyb20gJy4vY29tcG9uZW50cy9tZXNoZXMvSW1wb3J0ZXInO1xuaW1wb3J0IHtQZXJzcGVjdGl2ZUNhbWVyYX0gZnJvbSAnLi9jb21wb25lbnRzL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG5leHBvcnQgY2xhc3MgTW9kZWwgZXh0ZW5kcyBJbXBvcnRlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgLi4uYWRkaXRpb25hbCkge1xuICAgIGNvbnNvbGUud2FybignTW9kZWwgaXMgZGVwcmVjYXRlZC4gVXNlIEltcG9ydGVyIGluc3RlYWQuJyk7XG5cbiAgICBpZiAocGFyYW1zLmdlb21ldHJ5KSB7XG4gICAgICBwYXJhbXMudXJsID0gcGFyYW1zLmdlb21ldHJ5LnBhdGg7XG4gICAgICBwYXJhbXMubG9hZGVyID0gcGFyYW1zLmdlb21ldHJ5LmxvYWRlcjtcbiAgICB9XG5cbiAgICBzdXBlcihwYXJhbXMsIC4uLmFkZGl0aW9uYWwpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDYW1lcmFNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIGNvbnNvbGUud2FybignQ2FtZXJhTW9kdWxlIGlzIGRlcHJlY2F0ZWQuIFVzZSBEZWZpbmVNb2R1bGUgaW5zdGVhZC4nKTtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShwYXJhbXMpO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICB0aGlzLmFkZChzZWxmLmNhbWVyYSk7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLnNldCgnY2FtZXJhJywgdGhpcy5jYW1lcmEpO1xuICB9XG59XG4iLCIvKipcbiAqIE5hbWVzcGFjZSBjb250YWluaW5nIGFsbCBjbGFzc2VzIGZyb20gYWxsIG1vZHVsZXMuIFVzZWQgYXMgZ2xvYmFsIGluIFVNRCBwYXR0ZXJuLlxuICogQG5hbWVzcGFjZSBXSFNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRoZSB1c2Ugb2YgV0hTIG5hbWVzcGFjZS48L2NhcHRpb24+XG4gKiBuZXcgV0hTLkFwcCgpIC8vIGNvcmVcbiAqIG5ldyBXSFMuUGVyc3BlY3RpdmVDYW1lcmEoKSAvLyBjb21wb25lbnRzXG4gKiBuZXcgV0hTLlJlc2l6ZU1vZHVsZSgpIC8vIG1vZHVsZXNcbiAqIFdIUy5leHRlbmQoKSAvLyB1dGlsc1xuICovXG5cblxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9saWdodHMvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2NhbWVyYXMvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL21lc2hlcy9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vbW9kdWxlcy9pbmRleCc7XG5cbi8vIERFUFJFQ0FUSU9OXG5leHBvcnQgKiBmcm9tICcuL2RlcHJlY2F0aW9uJztcbiJdLCJuYW1lcyI6WyJleHRlbmQiLCJvYmplY3QiLCJleHRlbnNpb25zIiwiZXh0ZW5zaW9uIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3AiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsImNvbnN0cnVjdG9yIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJpbnN0cnVjdCIsImFycmF5IiwiaW5zdEFycmF5IiwidGVtcE9iamVjdCIsImkiLCJtYXgiLCJsZW5ndGgiLCJndWlkZSIsInRyYW5zZm9ybURhdGEiLCJpbnN0cnVjdGlvbnMiLCJrZXkiLCJ0b0FycmF5IiwiaW5zdHJ1Y3Rpb24iLCJ0ZW1wQXJyYXkiLCJDb21wb3NpdGlvbkVycm9yIiwiY2xhc3NJbnN0YW5jZSIsIm1lc3NhZ2UiLCJjb21wb25lbnQiLCJzdGFja0FycmF5Iiwic3RhY2siLCJzcGxpdCIsInNwbGljZSIsImpvaW4iLCJjb25zb2xlIiwiZXJyb3IiLCJuYW1lIiwiRXJyb3IiLCJEZXBlbmRlbmN5RXJyb3IiLCJhY3RpdmVNb2R1bGUiLCJkZXBlbmRlbmN5TW9kdWxlIiwiTWFuYWdlckVycm9yIiwid2FybkRlcHMiLCJSRVZJU0lPTiIsImVyciIsIk1vZHVsZVN5c3RlbSIsInNvdXJjZSIsIm1vZHVsZXMiLCJhcHBseU1vZHVsZSIsImFwcGx5QnJpZGdlIiwib25Db3B5IiwiYnJpZGdlTWFwIiwibW9kdWxlIiwiYnJpZGdlIiwiYXBwbHkiLCJjYiIsImZ1bmMiLCJtb2R1bGVTY29wZSIsInB1c2giLCJtYW5hZ2VyIiwiYWN0aXZlIiwiaW50ZWdyYXRlIiwiYmluZCIsImRpc3Bvc2VNb2R1bGUiLCJpbmRleE9mIiwiZGlzcG9zZSIsIkV2ZW50cyIsIlN5bWJvbCIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJzeW1Ub1N0cmluZ1RhZyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwicm9vdCIsInBvbnlmaWxsIiwiJCRvYnNlcnZhYmxlIiwiTW9kdWxlTWFuYWdlciIsImhhbmRsZXIiLCJjdXJyZW50TW9kdWxlIiwic3RvcmUiLCJjcmVhdGVTdG9yZSIsInN0YXRlIiwiYWN0aW9uIiwiZGF0YSIsImRpc3BhdGNoIiwiZ2V0U3RhdGUiLCJCb29sZWFuIiwiZGVwc01hcCIsInN1YnNjcmliZSIsImNoYW5nZWRLZXkiLCJjYWxsYmFjayIsIndhcm4iLCJzZXQiLCJtb2R1bGVFeGVjdXRvciIsInVzZSIsIkNvbXBvbmVudCIsInBhcmFtcyIsImRlZmF1bHRzIiwiX3dhaXQiLCJjaGlsZHJlbiIsImludGVncmF0ZU1vZHVsZXMiLCJwcm9taXNlIiwiUHJvbWlzZSIsImFsbCIsImlzRGVmZmVyZWQiLCJ3YWl0IiwidGhlbiIsImNvcHkiLCJjdXN0b21pemUiLCJuYXRpdmUiLCJjbG9uZSIsInBhcmVudCIsInJlc29sdmUiLCJyZWplY3QiLCJkZWZlciIsImFkZFByb21pc2UiLCJvbkFkZCIsInJlc29sdmVyIiwiYWRkIiwicmVtb3ZlIiwiX21hbmFnZXIiLCJfbmF0aXZlIiwibWVzaCIsImF0dHJpYnV0ZXMiLCJtYXBwZXJzIiwidGFyZ2V0IiwibWFwcGVyIiwiayIsIm1hcCIsImF0dHJpYnV0ZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0dGVyIiwic2V0dGVyIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInZhbHVlIiwibWlycm9yIiwiTWVzaENvbXBvbmVudCIsImdlb20iLCJNZXNoIiwibWF0ZXJpYWwiLCJnZW9tZXRyeSIsImN1c3RvbSIsImJ1aWxkIiwid3JhcCIsImFwcGx5Q29tbWFuZCIsInBvc2l0aW9uIiwicm90YXRpb24iLCJzY2FsZSIsInNoYWRvdyIsIngiLCJ5IiwieiIsImNhc3RTaGFkb3ciLCJjYXN0IiwicmVjZWl2ZVNoYWRvdyIsInJlY2VpdmUiLCJvbldyYXAiLCJxdWF0ZXJuaW9uIiwiZGVzdCIsIkxpZ2h0Q29tcG9uZW50IiwibGlnaHQiLCJ3cmFwU2hhZG93IiwibWFwU2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiYmlhcyIsInJhZGl1cyIsInNoYWRvd0NhbWVyYSIsImNhbWVyYSIsIm5lYXIiLCJmYXIiLCJmb3YiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJDYW1lcmFDb21wb25lbnQiLCJzeXN0ZW0iLCJ3aW5kb3ciLCJnbG9iYWwiLCJBcHAiLCJsb2ciLCJ2ZXJzaW9uIiwiZW5hYmxlZCIsImxvb3BzIiwicmVxdWVzdEFuaW1GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJwcm9jZXNzIiwibGwiLCJlIiwiZXhlY3V0ZSIsImNsb2NrIiwibG9vcCIsImluZGV4IiwiZ2V0IiwiTG9vcCIsInVzZUNsb2NrIiwiQ2xvY2siLCJ3b3JsZCIsImFkZExvb3AiLCJzdGFydCIsInN0b3AiLCJyZW1vdmVMb29wIiwiQW1iaWVudExpZ2h0IiwiQW1iaWVudExpZ2h0TmF0aXZlIiwiY29sb3IiLCJpbnRlbnNpdHkiLCJEaXJlY3Rpb25hbExpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodE5hdGl2ZSIsIkhlbWlzcGhlcmVMaWdodCIsIkhlbWlzcGhlcmVMaWdodE5hdGl2ZSIsInNreUNvbG9yIiwiZ3JvdW5kQ29sb3IiLCJQb2ludExpZ2h0IiwiUG9pbnRMaWdodE5hdGl2ZSIsImRpc3RhbmNlIiwiZGVjYXkiLCJTcG90TGlnaHQiLCJTcG90TGlnaHROYXRpdmUiLCJhbmdsZSIsImV4cG9uZW50IiwiTWF0aCIsIlBJIiwiQXJlYUxpZ2h0IiwiUmVjdEFyZWFMaWdodE5hdGl2ZSIsIkN1YmVDYW1lcmEiLCJDdWJlQ2FtZXJhTmF0aXZlIiwiY3ViZVJlc29sdXRpb24iLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmFOYXRpdmUiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhTmF0aXZlIiwiYXNwZWN0IiwiQm94IiwiYnVpbGRHZW9tZXRyeSIsImJ1ZmZlciIsIkJveEJ1ZmZlckdlb21ldHJ5IiwiQm94R2VvbWV0cnkiLCJkZXB0aCIsIndpZHRoU2VnbWVudHMiLCJoZWlnaHRTZWdtZW50cyIsImRlcHRoU2VnbWVudHMiLCJDaXJjbGUiLCJDaXJjbGVCdWZmZXJHZW9tZXRyeSIsIkNpcmNsZUdlb21ldHJ5Iiwic2VnbWVudHMiLCJ0aGV0YVN0YXJ0IiwidGhldGFMZW5ndGgiLCJDb25lIiwiQ29uZUJ1ZmZlckdlb21ldHJ5IiwiQ29uZUdlb21ldHJ5IiwicmFkaXVzU2VnbWVudHMiLCJvcGVuRW5kZWQiLCJDeWxpbmRlciIsIkN5bGluZGVyQnVmZmVyR2VvbWV0cnkiLCJDeWxpbmRlckdlb21ldHJ5IiwicmFkaXVzVG9wIiwicmFkaXVzQm90dG9tIiwiRG9kZWNhaGVkcm9uIiwiRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkiLCJEb2RlY2FoZWRyb25HZW9tZXRyeSIsImRldGFpbCIsIkV4dHJ1ZGUiLCJFeHRydWRlR2VvbWV0cnkiLCJzaGFwZXMiLCJvcHRpb25zIiwiQnVmZmVyR2VvbWV0cnkiLCJmcm9tR2VvbWV0cnkiLCJJY29zYWhlZHJvbiIsIkljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkiLCJJY29zYWhlZHJvbkdlb21ldHJ5IiwiTGF0aGUiLCJMYXRoZUJ1ZmZlckdlb21ldHJ5IiwiTGF0aGVHZW9tZXRyeSIsInBvaW50cyIsIkxpbmUiLCJMaW5lTmF0aXZlIiwiR2VvbWV0cnkiLCJwcCIsImN1cnZlIiwiZ2V0UG9pbnRzIiwidmVydHMiLCJGbG9hdDMyQXJyYXkiLCJpMyIsImFkZEF0dHJpYnV0ZSIsIkJ1ZmZlckF0dHJpYnV0ZSIsInZlcnRpY2VzIiwiSW1wb3J0ZXIiLCJmaWx0ZXIiLCJwcm9jZXNzRmlsdGVyIiwiZm9yRWFjaCIsImVsIiwidGV4dHVyZVBhdGgiLCJsb2FkZXIiLCJzZXRUZXh0dXJlUGF0aCIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJwYXJzZXIiLCJvblByb2dyZXNzIiwib25FcnJvciIsIkpTT05Mb2FkZXIiLCJtYXQiLCJPY3RhaGVkcm9uIiwiT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5IiwiT2N0YWhlZHJvbkdlb21ldHJ5IiwiUGFyYW1ldHJpYyIsIlBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSIsIlBhcmFtZXRyaWNHZW9tZXRyeSIsInNsaWNlcyIsInN0YWNrcyIsInUiLCJ2IiwiVmVjdG9yMyIsIlBsYW5lIiwiUGxhbmVCdWZmZXJHZW9tZXRyeSIsIlBsYW5lR2VvbWV0cnkiLCJ3U2VnbWVudHMiLCJoU2VnbWVudHMiLCJ2ZXJ0aWNlc09mQ3ViZSIsImluZGljZXNPZkZhY2VzIiwiUG9seWhlZHJvbiIsIlBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSIsIlBvbHloZWRyb25HZW9tZXRyeSIsIlJpbmciLCJSaW5nQnVmZmVyR2VvbWV0cnkiLCJSaW5nR2VvbWV0cnkiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwidGhldGFTZWdtZW50cyIsInBoaVNlZ21lbnRzIiwiU2hhcGUiLCJTaGFwZUJ1ZmZlckdlb21ldHJ5IiwiU2hhcGVHZW9tZXRyeSIsIlNwaGVyZSIsIlNwaGVyZUJ1ZmZlckdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJUZXRyYWhlZHJvbiIsIlRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkiLCJUZXRyYWhlZHJvbkdlb21ldHJ5IiwiVGV4dCIsInBhdGgiLCJmb250IiwiVGV4dEdlb21ldHJ5IiwidGV4dCIsImFzc2lnbiIsIkZvbnQiLCJGb250TG9hZGVyIiwiVG9ydXMiLCJUb3J1c0dlb21ldHJ5IiwidHViZSIsInJhZGlhbFNlZ21lbnRzIiwidHVidWxhclNlZ21lbnRzIiwiYXJjIiwiVG9ydXNrbm90IiwiR0NvbnN0cnVjdCIsIlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5IiwiVG9ydXNLbm90R2VvbWV0cnkiLCJwIiwicSIsIlR1YmUiLCJUdWJlQnVmZmVyR2VvbWV0cnkiLCJUdWJlR2VvbWV0cnkiLCJjbG9zZWQiLCJMaW5lQ3VydmUzIiwiR3JvdXAiLCJvYmplY3RzIiwib2JqIiwiYWRkVG8iLCJPYmplY3QzRCIsIkVsZW1lbnRNb2R1bGUiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImJvZHkiLCJjcmVhdGVFbGVtZW50IiwiZWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwic2VsZiIsImFwcGVuZENoaWxkIiwiUmVuZGVyaW5nTW9kdWxlIiwiYWRkaXRpb25hbCIsIlZlY3RvcjIiLCJkZXZpY2VQaXhlbFJhdGlvIiwiYmdDb2xvciIsImJnT3BhY2l0eSIsInJlbmRlcmVyIiwicGl4ZWxSYXRpbyIsInJlc29sdXRpb24iLCJmaXgiLCJXZWJHTFJlbmRlcmVyIiwiZWZmZWN0cyIsInNldENsZWFyQ29sb3IiLCJzZXRQaXhlbFJhdGlvIiwic2V0U2l6ZSIsIk51bWJlciIsInRvRml4ZWQiLCJhcHBseUFkZGl0aW9uYWwiLCJzY2VuZSIsImF0dGFjaFRvQ2FudmFzIiwicmVuZGVyIiwiZWZmZWN0IiwiZWZmZWN0TG9vcCIsInJlbmRlckxvb3AiLCJzaXplIiwiZ2V0U2l6ZSIsImFwcCIsImNhbnZhcyIsImRvbUVsZW1lbnQiLCJkZWZpbmUiLCJpbnRlZ3JhdGVSZW5kZXJlciIsInVwZGF0ZSIsImZvcmNlQ29udGV4dExvc3MiLCJzaGFkb3dNYXAiLCJTY2VuZU1vZHVsZSIsIndpbGxTY2VuZUJlUmVwbGFjZWQiLCJTY2VuZSIsInNldFNjZW5lIiwiUmVzaXplTW9kdWxlIiwiY2FsbGJhY2tzIiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInJlbmRlcmluZyIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZ2V0Q29udGFpbmVyIiwiZ2V0UmVzb2x1dGlvbiIsImF1dG8iLCJhZGRFdmVudExpc3RlbmVyIiwidHJpZ2dlciIsImFkZEF1dG9yZXNpemUiLCJmcmFnbWVudCIsInZlcnRleCIsIkFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsIiwiVW5pZm9ybSIsIlNoYWRlck1hdGVyaWFsIiwiQm9rZWhNYXRlcmlhbCIsImZvY3VzIiwiYXBlcnR1cmUiLCJtYXhCbHVyIiwiYWRvcHRDYW1lcmFTZXR0aW5ncyIsInVuaWZvcm1zIiwiY2FtZXJhTmVhciIsImNhbWVyYUZhciIsIkJva2VoMk1hdGVyaWFsIiwicmluZ3MiLCJzYW1wbGVzIiwic2hvd0ZvY3VzIiwibWFudWFsRG9GIiwidmlnbmV0dGUiLCJwZW50YWdvbiIsInNoYWRlckZvY3VzIiwibm9pc2UiLCJkZWZpbmVzIiwiU0hPV19GT0NVUyIsIk1BTlVBTF9ET0YiLCJWSUdORVRURSIsIlBFTlRBR09OIiwiU0hBREVSX0ZPQ1VTIiwiTk9JU0UiLCJ0ZXhlbFNpemUiLCJzZXRUZXhlbFNpemUiLCJoYWxmVGV4ZWxTaXplIiwibXVsdGlwbHlTY2FsYXIiLCJmb2NhbExlbmd0aCIsImdldEZvY2FsTGVuZ3RoIiwiQ29tYmluZU1hdGVyaWFsIiwic2NyZWVuTW9kZSIsIlNDUkVFTl9NT0RFIiwiQ29udm9sdXRpb25NYXRlcmlhbCIsImtlcm5lbFNpemUiLCJLZXJuZWxTaXplIiwiTEFSR0UiLCJrZXJuZWxQcmVzZXRzIiwiQ29weU1hdGVyaWFsIiwiRGVwdGhNYXRlcmlhbCIsIkRvdFNjcmVlbk1hdGVyaWFsIiwiYXZlcmFnZSIsIlZlY3RvcjQiLCJBVkVSQUdFIiwiRmlsbU1hdGVyaWFsIiwic2NhbmxpbmVzIiwiZ3JleXNjYWxlIiwic2VwaWEiLCJlc2tpbCIsIm5vaXNlSW50ZW5zaXR5Iiwic2NhbmxpbmVJbnRlbnNpdHkiLCJncmV5c2NhbGVJbnRlbnNpdHkiLCJzZXBpYUludGVuc2l0eSIsInZpZ25ldHRlT2Zmc2V0IiwidmlnbmV0dGVEYXJrbmVzcyIsIkdSRVlTQ0FMRSIsIlNFUElBIiwiRVNLSUwiLCJTQ0FOTElORVMiLCJHbGl0Y2hNYXRlcmlhbCIsIkdvZFJheXNNYXRlcmlhbCIsIkx1bWlub3NpdHlNYXRlcmlhbCIsInJhbmdlIiwiQ09MT1IiLCJSQU5HRSIsIlBpeGVsYXRpb25NYXRlcmlhbCIsImdyYW51bGFyaXR5IiwiZHgiLCJkeSIsIlNob2NrV2F2ZU1hdGVyaWFsIiwibWF4UmFkaXVzIiwid2F2ZVNpemUiLCJhbXBsaXR1ZGUiLCJTTUFBQmxlbmRNYXRlcmlhbCIsIlNNQUFDb2xvckVkZ2VzTWF0ZXJpYWwiLCJTTUFBV2VpZ2h0c01hdGVyaWFsIiwiYXJlYUltYWdlIiwic2VhcmNoSW1hZ2UiLCJUb25lTWFwcGluZ01hdGVyaWFsIiwiUGFzcyIsInF1YWQiLCJmcnVzdHVtQ3VsbGVkIiwibmVlZHNTd2FwIiwicmVuZGVyVG9TY3JlZW4iLCJyZWFkQnVmZmVyIiwid3JpdGVCdWZmZXIiLCJkZWx0YSIsIm1hc2tBY3RpdmUiLCJhbHBoYSIsImtleXMiLCJCbHVyUGFzcyIsInJlbmRlclRhcmdldFgiLCJXZWJHTFJlbmRlclRhcmdldCIsIkxpbmVhckZpbHRlciIsInRleHR1cmUiLCJnZW5lcmF0ZU1pcG1hcHMiLCJyZW5kZXJUYXJnZXRZIiwicmVzb2x1dGlvblNjYWxlIiwiY29udm9sdXRpb25NYXRlcmlhbCIsImtlcm5lbCIsImdldEtlcm5lbCIsImxhc3RSVCIsImRlc3RSVCIsImwiLCJ0RGlmZnVzZSIsImZvcm1hdCIsIlJHQkZvcm1hdCIsImZsb29yIiwiQmxvb21QYXNzIiwiYmx1clBhc3MiLCJyZW5kZXJUYXJnZXQiLCJjb21iaW5lTWF0ZXJpYWwiLCJsdW1pbm9zaXR5TWF0ZXJpYWwiLCJkaXN0aW5jdGlvbiIsInRleHR1cmUxIiwidGV4dHVyZTIiLCJpbml0aWFsaXNlIiwib3BhY2l0eTIiLCJCb2tlaFBhc3MiLCJib2tlaE1hdGVyaWFsIiwidERlcHRoIiwiZGVwdGhUZXh0dXJlIiwiQm9rZWgyUGFzcyIsIkNsZWFyTWFza1Bhc3MiLCJidWZmZXJzIiwic3RlbmNpbCIsInNldFRlc3QiLCJDb2xvciIsIkNsZWFyUGFzcyIsImNsZWFyQ29sb3IiLCJjbGVhckFscGhhIiwiZ2V0Q2xlYXJDb2xvciIsImdldENsZWFyQWxwaGEiLCJzZXRSZW5kZXJUYXJnZXQiLCJjbGVhciIsIkRvdFNjcmVlblBhc3MiLCJvZmZzZXRSZXBlYXQiLCJ3IiwiRGVwdGhQYXNzIiwiZGVwdGhNYXRlcmlhbCIsIkZpbG1QYXNzIiwic2NhbmxpbmVEZW5zaXR5IiwidGltZSIsInNjYW5saW5lQ291bnQiLCJyb3VuZCIsInJhbmRvbUludCIsImxvdyIsImhpZ2giLCJyYW5kb20iLCJyYW5kb21GbG9hdCIsIkdsaXRjaFBhc3MiLCJwZXJ0dXJiTWFwIiwiZ2VuZXJhdGVQZXJ0dXJiTWFwIiwiZHRTaXplIiwibW9kZSIsIkdsaXRjaE1vZGUiLCJTUE9SQURJQyIsImNvdW50ZXIiLCJicmVha1BvaW50IiwicGl4ZWxzIiwiZHQiLCJEYXRhVGV4dHVyZSIsIkZsb2F0VHlwZSIsIm5lZWRzVXBkYXRlIiwic2VlZCIsIkNPTlNUQU5UX1dJTEQiLCJhbW91bnQiLCJzZWVkWCIsInNlZWRZIiwiZGlzdG9ydGlvblgiLCJkaXN0b3J0aW9uWSIsIkNPTlNUQU5UX01JTEQiLCJ0UGVydHVyYiIsIlJlbmRlclBhc3MiLCJjbGVhclBhc3MiLCJvdmVycmlkZU1hdGVyaWFsIiwiY2xlYXJEZXB0aCIsImNsYW1wIiwibWluIiwiR29kUmF5c1Bhc3MiLCJsaWdodFNvdXJjZSIsImxpZ2h0U2NlbmUiLCJtYWluU2NlbmUiLCJtYWluQ2FtZXJhIiwicmVuZGVyUGFzc0xpZ2h0IiwicmVuZGVyUGFzc01hc2siLCJNZXNoQmFzaWNNYXRlcmlhbCIsInJlbmRlclRhcmdldE1hc2siLCJzY3JlZW5Qb3NpdGlvbiIsImdvZFJheXNNYXRlcmlhbCIsImxpZ2h0UG9zaXRpb24iLCJleHBvc3VyZSIsImRlbnNpdHkiLCJ3ZWlnaHQiLCJjbGFtcE1heCIsImJhY2tncm91bmQiLCJwcm9qZWN0IiwicGFyc2VJbnQiLCJOVU1fU0FNUExFU19JTlQiLCJOVU1fU0FNUExFU19GTE9BVCIsIk1hc2tQYXNzIiwiaW52ZXJzZSIsImNsZWFyU3RlbmNpbCIsImNvbnRleHQiLCJ3cml0ZVZhbHVlIiwiY2xlYXJWYWx1ZSIsInNldE1hc2siLCJzZXRMb2NrZWQiLCJzZXRPcCIsIlJFUExBQ0UiLCJzZXRGdW5jIiwiQUxXQVlTIiwic2V0Q2xlYXIiLCJFUVVBTCIsIktFRVAiLCJQaXhlbGF0aW9uUGFzcyIsInBpeGVsYXRpb25NYXRlcmlhbCIsInNldFJlc29sdXRpb24iLCJTYXZlUGFzcyIsInJlc2l6ZSIsIlNoYWRlclBhc3MiLCJ0ZXh0dXJlSUQiLCJIQUxGX1BJIiwiYWIiLCJTaG9ja1dhdmVQYXNzIiwiZXBpY2VudGVyIiwic3BlZWQiLCJzaG9ja1dhdmVNYXRlcmlhbCIsImNlbnRlciIsImNvcHlNYXRlcmlhbCIsImdldFdvcmxkRGlyZWN0aW9uIiwic3ViIiwiYW5nbGVUbyIsImNhbWVyYURpc3RhbmNlIiwiZGlzdGFuY2VUbyIsIlNNQUFQYXNzIiwiSW1hZ2UiLCJyZW5kZXJUYXJnZXRDb2xvckVkZ2VzIiwicmVuZGVyVGFyZ2V0V2VpZ2h0cyIsIlJHQkFGb3JtYXQiLCJjb2xvckVkZ2VzTWF0ZXJpYWwiLCJ3ZWlnaHRzTWF0ZXJpYWwiLCJzcmMiLCJhcmVhVGV4dHVyZSIsIlRleHR1cmUiLCJpbWFnZSIsIm1pbkZpbHRlciIsImZsaXBZIiwic2VhcmNoVGV4dHVyZSIsIm1hZ0ZpbHRlciIsIk5lYXJlc3RGaWx0ZXIiLCJ0QXJlYSIsInRTZWFyY2giLCJibGVuZE1hdGVyaWFsIiwidFdlaWdodHMiLCJUZXh0dXJlUGFzcyIsIm9wYWNpdHkiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJ0cmFuc3BhcmVudCIsImNlaWwyIiwibiIsInBvdyIsImNlaWwiLCJsb2cyIiwiVG9uZU1hcHBpbmdQYXNzIiwicmVuZGVyVGFyZ2V0THVtaW5vc2l0eSIsIkxpbmVhck1pcE1hcExpbmVhckZpbHRlciIsInJlbmRlclRhcmdldEFkYXB0ZWQiLCJyZW5kZXJUYXJnZXRQcmV2aW91cyIsImFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsIiwidG9uZU1hcHBpbmdNYXRlcmlhbCIsImFkYXB0aXZlIiwidFByZXZpb3VzTHVtIiwidEN1cnJlbnRMdW0iLCJNSVBfTEVWRUxfMVgxIiwiQURBUFRFRF9MVU1JTkFOQ0UiLCJsdW1pbmFuY2VNYXAiLCJFZmZlY3RDb21wb3NlciIsImF1dG9DbGVhciIsImNyZWF0ZUJ1ZmZlciIsImRlcHRoQnVmZmVyIiwic3RlbmNpbEJ1ZmZlciIsImNvcHlQYXNzIiwicGFzc2VzIiwib2xkUmVuZGVyZXIiLCJvbGRTaXplIiwibmV3U2l6ZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImdldFBpeGVsUmF0aW8iLCJnZXRDb250ZXh0QXR0cmlidXRlcyIsIkRlcHRoVGV4dHVyZSIsIkRlcHRoU3RlbmNpbEZvcm1hdCIsInR5cGUiLCJVbnNpZ25lZEludDI0OFR5cGUiLCJwYXNzIiwic3RlbmNpbEZ1bmMiLCJOT1RFUVVBTCIsInBvcCIsInBvbHlmaWxsIiwibWV0aG9kIiwic2hvd1dhcm4iLCJQb3N0UHJvY2Vzc29yTW9kdWxlIiwiY3VycmVudFBhc3MiLCJkZWJ1ZyIsImNvbXBvc2VyIiwiZ2V0RGVsdGEiLCJyZXBsYWNlUmVuZGVyZXIiLCJhZGRQYXNzIiwiYm9vbCIsIkV2ZW50c1BhdGNoTW9kdWxlIiwib3JpZ2luT2JqZWN0IiwiZGVzdE9iamVjdCIsImV2ZW50cyIsImV2ZW50IiwiZW1pdCIsInBhdGNoRXZlbnRzIiwiVmlydHVhbE1vdXNlTW9kdWxlIiwiZ2xvYmFsTW92ZW1lbnQiLCJtb3VzZSIsInJheWNhc3RlciIsIlJheWNhc3RlciIsInByb2plY3Rpb25QbGFuZSIsImN1c3RvbVgiLCJjdXN0b21ZIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwibm9ybWFsIiwic2V0RnJvbUNhbWVyYSIsInJlcXVpcmUiLCJvbiIsImV2IiwiZ2xvYmFsWCIsImdsb2JhbFkiLCJwb2ludGVyTG9ja0VsZW1lbnQiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJuZXN0ZWQiLCJpc0hvdmVyZWQiLCJob3ZlcnMiLCJ0cmF2ZXJzZSIsImNoaWxkIiwiaW50ZXJzZWN0T2JqZWN0cyIsImludGVyc2VjdE9iamVjdCIsInBsYW5lIiwicmF5IiwiaW50ZXJzZWN0UGxhbmUiLCJpbnRlcnNlY3Rpb24iLCJDb250cm9sc01vZHVsZSIsImNvbnRyb2xzIiwiYyIsInVwZGF0ZUxvb3AiLCJGb2dNb2R1bGUiLCJmb2ciLCJGb2dFeHAyIiwiRm9nIiwiaXNFcXVhbERlZmF1bHQiLCJhIiwiYiIsImVxdWFscyIsIlN0YXRlTW9kdWxlIiwiaXNFcXVhbCIsImVxdWFsQ2hlY2siLCJhY3Rpb25HZW5lcmF0ZSIsImNvbmZpZ3VyYXRpb24iLCJjdXJyZW50Q29uZmlnIiwicHJldkNvbmZpZyIsImNvbmZpZyIsImRlZmF1bHQiLCJyZXBsYWNlUmVkdWNlciIsImNvbmZpZ3MiLCJ1cGRhdGVzIiwiY29uZmlnTmFtZSIsInRydWVWYWwiLCJmYWxzZVZhbCIsIlRocmVlT3JiaXRDb250cm9scyIsImV2ZW50SGFuZGxlciIsIm1pbkRpc3RhbmNlIiwibWF4RGlzdGFuY2UiLCJJbmZpbml0eSIsIm1pblpvb20iLCJtYXhab29tIiwibWluUG9sYXJBbmdsZSIsIm1heFBvbGFyQW5nbGUiLCJtaW5BemltdXRoQW5nbGUiLCJtYXhBemltdXRoQW5nbGUiLCJlbmFibGVEYW1waW5nIiwiZGFtcGluZ0ZhY3RvciIsImVuYWJsZVpvb20iLCJ6b29tU3BlZWQiLCJlbmFibGVSb3RhdGUiLCJyb3RhdGVTcGVlZCIsImVuYWJsZVBhbiIsImtleVBhblNwZWVkIiwiYXV0b1JvdGF0ZSIsImF1dG9Sb3RhdGVTcGVlZCIsImVuYWJsZUtleXMiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkJPVFRPTSIsIm1vdXNlQnV0dG9ucyIsIk9SQklUIiwiTU9VU0UiLCJaT09NIiwiTUlERExFIiwiUEFOIiwidGFyZ2V0MCIsInBvc2l0aW9uMCIsInpvb20wIiwiem9vbSIsImdldFBvbGFyQW5nbGUiLCJzcGhlcmljYWwiLCJwaGkiLCJnZXRBemltdXRoYWxBbmdsZSIsInRoZXRhIiwicmVzZXQiLCJkaXNwYXRjaEV2ZW50IiwiY2hhbmdlRXZlbnQiLCJTVEFURSIsIk5PTkUiLCJvZmZzZXQiLCJxdWF0IiwiUXVhdGVybmlvbiIsInNldEZyb21Vbml0VmVjdG9ycyIsInVwIiwicXVhdEludmVyc2UiLCJsYXN0UG9zaXRpb24iLCJsYXN0UXVhdGVybmlvbiIsImFwcGx5UXVhdGVybmlvbiIsInNldEZyb21WZWN0b3IzIiwicm90YXRlTGVmdCIsImdldEF1dG9Sb3RhdGlvbkFuZ2xlIiwic3BoZXJpY2FsRGVsdGEiLCJtYWtlU2FmZSIsInBhbk9mZnNldCIsInNldEZyb21TcGhlcmljYWwiLCJsb29rQXQiLCJ6b29tQ2hhbmdlZCIsImRpc3RhbmNlVG9TcXVhcmVkIiwiRVBTIiwiZG90IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uQ29udGV4dE1lbnUiLCJvbk1vdXNlRG93biIsIm9uTW91c2VXaGVlbCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoTW92ZSIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwib25LZXlEb3duIiwic3RhcnRFdmVudCIsImVuZEV2ZW50IiwiUk9UQVRFIiwiRE9MTFkiLCJUT1VDSF9ST1RBVEUiLCJUT1VDSF9ET0xMWSIsIlRPVUNIX1BBTiIsIlNwaGVyaWNhbCIsInJvdGF0ZVN0YXJ0Iiwicm90YXRlRW5kIiwicm90YXRlRGVsdGEiLCJwYW5TdGFydCIsInBhbkVuZCIsInBhbkRlbHRhIiwiZG9sbHlTdGFydCIsImRvbGx5RW5kIiwiZG9sbHlEZWx0YSIsImdldFpvb21TY2FsZSIsInJvdGF0ZVVwIiwicGFuTGVmdCIsIm9iamVjdE1hdHJpeCIsInNldEZyb21NYXRyaXhDb2x1bW4iLCJwYW5VcCIsInBhbiIsImRlbHRhWCIsImRlbHRhWSIsInRhcmdldERpc3RhbmNlIiwidGFuIiwiY2xpZW50SGVpZ2h0IiwibWF0cml4IiwiY2xpZW50V2lkdGgiLCJkb2xseUluIiwiZG9sbHlTY2FsZSIsImRvbGx5T3V0IiwiaGFuZGxlTW91c2VEb3duUm90YXRlIiwiaGFuZGxlTW91c2VEb3duRG9sbHkiLCJoYW5kbGVNb3VzZURvd25QYW4iLCJoYW5kbGVNb3VzZU1vdmVSb3RhdGUiLCJzdWJWZWN0b3JzIiwiaGFuZGxlTW91c2VNb3ZlRG9sbHkiLCJoYW5kbGVNb3VzZU1vdmVQYW4iLCJoYW5kbGVNb3VzZVVwIiwiaGFuZGxlTW91c2VXaGVlbCIsImhhbmRsZUtleURvd24iLCJrZXlDb2RlIiwiaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiaGFuZGxlVG91Y2hTdGFydERvbGx5Iiwic3FydCIsImhhbmRsZVRvdWNoU3RhcnRQYW4iLCJoYW5kbGVUb3VjaE1vdmVSb3RhdGUiLCJoYW5kbGVUb3VjaE1vdmVEb2xseSIsImhhbmRsZVRvdWNoTW92ZVBhbiIsImhhbmRsZVRvdWNoRW5kIiwicHJldmVudERlZmF1bHQiLCJidXR0b24iLCJzdG9wUHJvcGFnYXRpb24iLCJFdmVudERpc3BhdGNoZXIiLCJPcmJpdENvbnRyb2xzTW9kdWxlIiwiZm9sbG93IiwidXBkYXRlUHJvY2Vzc29yIiwic2V0Q29udHJvbHMiLCJzZXRVcGRhdGUiLCJEeW5hbWljR2VvbWV0cnlNb2R1bGUiLCJnXyIsInVwZGF0ZVBhcmFtcyIsInBhcmFtZXRlcnMiLCJUZXh0dXJlTG9hZGVyIiwiVGV4dHVyZU1vZHVsZSIsInRleHR1cmVzIiwicmVwZWF0IiwiUmVwZWF0V3JhcHBpbmciLCJtYXBwaW5nIiwiVVZNYXBwaW5nIiwidGV4Iiwid3JhcFMiLCJ3cmFwVCIsIkFuaW1hdGlvbk1vZHVsZSIsImlzRGVmZXJyZWQiLCJza2VsZXRvbiIsIm1peGVyIiwiQW5pbWF0aW9uTWl4ZXIiLCJjbGlwcyIsImFuaW1hdGlvbnMiLCJjbGlwTmFtZSIsImNsaXAiLCJBbmltYXRpb25DbGlwIiwiZmluZEJ5TmFtZSIsImNsaXBBY3Rpb24iLCJwbGF5IiwiRGVmaW5lTW9kdWxlIiwiTW9kZWwiLCJDYW1lcmFNb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTyxJQUFNQSxTQUFTLFNBQVRBLE1BQVMsQ0FBQ0MsTUFBRCxFQUEyQjtvQ0FBZkMsVUFBZTtjQUFBOzs7Ozs7Ozs7eUJBQ3ZCQSxVQUF4Qiw4SEFBb0M7VUFBekJDLFNBQXlCOzs7OztVQUk5QixDQUFDQSxTQUFMLEVBQ0UsU0FMZ0M7Ozs7Ozs7OEJBT2ZDLE9BQU9DLG1CQUFQLENBQTJCRixTQUEzQixDQUFuQixtSUFBMEQ7Y0FBL0NHLElBQStDOztjQUNwREwsT0FB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QU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFDO0lBQ3REOzs7O0VBSUQsTUFBTSxDQUFDLEdBQUcsR0FBRyxTQUFTLElBQUksRUFBRSxJQUFJLENBQUM7SUFDL0IsSUFBSSxLQUFLLE1BQU0sR0FBRyxFQUFFLEVBQUM7SUFDckIsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUs7UUFDNUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQzdDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUM7SUFDbEQ7Ozs7RUFJRCxNQUFNLENBQUMsSUFBSSxHQUFHLFNBQVMsSUFBSSxDQUFDO0lBQzFCLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdEYsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFDO0dBQ3BFLENBQUM7Q0FDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
