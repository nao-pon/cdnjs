(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ons = factory());
}(this, (function () { 'use strict';

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Add vendor prefix.
 *
 * @param {String} name
 * @return {String}
 */
var prefix = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

  return function (name) {
    return '-' + prefix + '-' + util.hyphenate(name);
  };
}();

/**
 * Minimal utility library for manipulating element's style.
 * Set element's style.
 *
 * @param {Element} element
 * @param {Object} styles
 * @return {Element}
 */
var styler = function styler(element, style) {
  Object.keys(style).forEach(function (key) {
    if (key in element.style) {
      element.style[key] = style[key];
    } else if (prefix(key) in element.style) {
      element.style[prefix(key)] = style[key];
    } else {
      util.warn('No such style property: ' + key);
    }
  });
  return element;
};

/**
 * @param {Element} element
 * @param {String} styles Space-separated CSS properties to remove
 */
styler.clear = function (element) {
  var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var clearlist = styles.split(/\s+/).reduce(function (r, s) {
    return r.concat([util.hyphenate(s), prefix(s)]);
  }, []),
      keys = [];

  var _loop = function _loop(i) {
    var key = element.style[i];
    if (clearlist.length === 0 || clearlist.some(function (s) {
      return key.indexOf(s) === 0;
    })) {
      keys.push(key); // Store the key to fix Safari style indexes
    }
  };

  for (var i = element.style.length - 1; i >= 0; i--) {
    _loop(i);
  }

  keys.forEach(function (key) {
    return element.style[key] = '';
  });
  element.getAttribute('style') === '' && element.removeAttribute('style');
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// Save HTMLElement object before Custom Elements polyfill patch global HTMLElement.
var NativeHTMLElement = window.HTMLElement;

/**
 * @object ons.platform
 * @category util
 * @description
 *   [en]Utility methods to detect current platform.[/en]
 *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 */

var Platform = function () {

  /**
   * All elements will be rendered as if the app was running on this platform.
   * @type {String}
   */
  function Platform() {
    classCallCheck(this, Platform);

    this._selectedPlatform = null;
    this._ignorePlatformSelect = false;
  }

  /**
   * @method select
   * @signature select(platform)
   * @param  {string} platform Name of the platform.
   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
   * @description
   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
   */


  createClass(Platform, [{
    key: 'select',
    value: function select(platform) {
      if (typeof platform === 'string') {
        this._selectedPlatform = platform.trim().toLowerCase();
      }
    }
  }, {
    key: '_getSelectedPlatform',
    value: function _getSelectedPlatform() {
      return this._ignorePlatformSelect ? null : this._selectedPlatform;
    }
  }, {
    key: '_runOnActualPlatform',
    value: function _runOnActualPlatform(fn) {
      this._ignorePlatformSelect = true;
      var result = fn();
      this._ignorePlatformSelect = false;

      return result;
    }

    //----------------
    // General
    //----------------
    /**
     * @method isWebView
     * @signature isWebView()
     * @description
     *   [en]Returns whether app is running in Cordova.[/en]
     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWebView',
    value: function isWebView() {
      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
        throw new Error('isWebView() method is available after dom contents loaded.');
      }

      return !!(window.cordova || window.phonegap || window.PhoneGap);
    }

    //----------------
    // iOS devices
    //----------------
    /**
     * @method isIPhone
     * @signature isIPhone()
     * @description
     *   [en]Returns whether the device is iPhone.[/en]
     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhone',
    value: function isIPhone() {
      return (/iPhone/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isIPhoneX
     * @signature isIPhoneX()
     * @description
     *   [en]Returns whether the device is iPhone X.[/en]
     *   [ja]iPhone X上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhoneX',
    value: function isIPhoneX() {
      // iPhone 8 and iPhone X have a same user agent. We cannot avoid using window.screen.
      // This works well both in iOS Safari and (UI|WK)WebView of iPhone X.
      return this.isIPhone() && window.screen.width === 375 && window.screen.height === 812;
    }

    /**
     * @method isIPad
     * @signature isIPad()
     * @description
     *   [en]Returns whether the device is iPad.[/en]
     *   [ja]iPad上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPad',
    value: function isIPad() {
      return (/iPad/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isIPod',
    value: function isIPod() {
      return (/iPod/i.test(navigator.userAgent)
      );
    }

    //----------------
    // iOS versions
    //----------------
    /**
     * @method isIOS
     * @signature isIOS()
     * @description
     *   [en]Returns whether the OS is iOS.[/en]
     *   [ja]iOS上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS',
    value: function isIOS() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'ios';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform)
        );
      } else {
        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isIOS7above
     * @signature isIOS7above()
     * @description
     *   [en]Returns whether the iOS version is 7 or above.[/en]
     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS7above',
    value: function isIOS7above() {
      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
        );
      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
        return parseInt(ver.split('.')[0]) >= 7;
      }
      return false;
    }

    //----------------
    // iOS browsers
    //----------------
    /**
     * @method isIOSSafari
     * @signature isIOSSafari()
     * @description
     *   [en]Returns whether app is running in iOS Safari.[/en]
     *   [ja]iOS Safariで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOSSafari',
    value: function isIOSSafari() {
      var navigator = window.navigator;
      var ua = navigator.userAgent;

      return !!(this.isIOS() && ua.indexOf('Safari') !== -1 && ua.indexOf('Version') !== -1 && !navigator.standalone);
    }

    /**
     * @method isWKWebView
     * @signature isWKWebView()
     * @description
     *   [en]Returns whether app is running in WKWebView.[/en]
     *   [ja]WKWebViewで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWKWebView',
    value: function isWKWebView() {
      var lte9 = /constructor/i.test(NativeHTMLElement);
      return !!(this.isIOS() && window.webkit && window.webkit.messageHandlers && window.indexedDB && !lte9);
    }

    /**
     * @method isUIWebView
     * @signature isUIWebView()
     * @description
     *   [en]Returns whether app is running in UIWebView.[/en]
     *   [ja]UIWebViewで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isUIWebView',
    value: function isUIWebView() {
      return !!(this.isIOS() && !this.isIOSSafari() && !this.isWKWebView());
    }

    //----------------
    // Android devices
    //----------------
    /**
     * @method isAndroidPhone
     * @signature isAndroidPhone()
     * @description
     *   [en]Returns whether the device is Android phone.[/en]
     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidPhone',
    value: function isAndroidPhone() {
      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isAndroidTablet
     * @signature isAndroidTablet()
     * @description
     *   [en]Returns whether the device is Android tablet.[/en]
     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidTablet',
    value: function isAndroidTablet() {
      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
      );
    }

    //----------------
    // Android versions
    //----------------
    /**
     * @method isAndroid
     * @signature isAndroid()
     * @description
     *   [en]Returns whether the OS is Android.[/en]
     *   [ja]Android上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroid',
    value: function isAndroid() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'android';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Android/i.test(device.platform)
        );
      } else {
        return (/Android/i.test(navigator.userAgent)
        );
      }
    }

    //----------------
    // Other devices
    //----------------
    /**
     * @return {Boolean}
     */

  }, {
    key: 'isWP',
    value: function isWP() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'wp';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Win32NT|WinCE/i.test(device.platform)
        );
      } else {
        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isBlackBerry
     * @signature isBlackBerry()
     * @description
     *   [en]Returns whether the device is BlackBerry.[/en]
     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isBlackBerry',
    value: function isBlackBerry() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'blackberry';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/BlackBerry/i.test(device.platform)
        );
      } else {
        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
        );
      }
    }

    //----------------
    // Other browsers
    //----------------
    /**
     * @method isOpera
     * @signature isOpera()
     * @description
     *   [en]Returns whether the browser is Opera.[/en]
     *   [ja]Opera上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isOpera',
    value: function isOpera() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'opera';
      }

      return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    }

    /**
     * @method isFirefox
     * @signature isFirefox()
     * @description
     *   [en]Returns whether the browser is Firefox.[/en]
     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isFirefox',
    value: function isFirefox() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'firefox';
      }

      return typeof InstallTrigger !== 'undefined';
    }

    /**
     * @method isSafari
     * @signature isSafari()
     * @description
     *   [en]Returns whether the browser is Safari.[/en]
     *   [ja]Safari上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isSafari',
    value: function isSafari() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'safari';
      }

      return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || function (p) {
        return p.toString() === '[object SafariRemoteNotification]';
      }(!window['safari'] || safari.pushNotification);
    }

    /**
     * @method isChrome
     * @signature isChrome()
     * @description
     *   [en]Returns whether the browser is Chrome.[/en]
     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isChrome',
    value: function isChrome() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'chrome';
      }

      return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
    }

    /**
     * @method isIE
     * @signature isIE()
     * @description
     *   [en]Returns whether the browser is Internet Explorer.[/en]
     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIE',
    value: function isIE() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'ie';
      }

      return false || !!document.documentMode;
    }

    /**
     * @method isEdge
     * @signature isEdge()
     * @description
     *   [en]Returns whether the browser is Edge.[/en]
     *   [ja]Edge上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isEdge',
    value: function isEdge() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'edge';
      }

      return navigator.userAgent.indexOf(' Edge/') >= 0;
    }

    //----------------
    // Utility functions
    //----------------
    /**
     * @return {String}
     */

  }, {
    key: 'getMobileOS',
    value: function getMobileOS() {
      if (this.isAndroid()) {
        return 'android';
      } else if (this.isIOS()) {
        return 'ios';
      } else if (this.isWP()) {
        return 'wp';
      } else {
        return 'other';
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getIOSDevice',
    value: function getIOSDevice() {
      if (this.isIPhone()) {
        return 'iphone';
      } else if (this.isIPad()) {
        return 'ipad';
      } else if (this.isIPod()) {
        return 'ipod';
      } else {
        return 'na';
      }
    }
  }]);
  return Platform;
}();

var platform = new Platform();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var pageAttributeExpression = {
  _variables: {},

  /**
   * Define a variable.
   *
   * @param {String} name Name of the variable
   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
   */
  defineVariable: function defineVariable(name, value) {
    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (typeof name !== 'string') {
      throw new Error('Variable name must be a string.');
    } else if (typeof value !== 'string' && typeof value !== 'function') {
      throw new Error('Variable value must be a string or a function.');
    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
      throw new Error('"' + name + '" is already defined.');
    }
    this._variables[name] = value;
  },

  /**
   * Get a variable.
   *
   * @param {String} name Name of the variable.
   * @return {String|Function|null}
   */
  getVariable: function getVariable(name) {
    if (!this._variables.hasOwnProperty(name)) {
      return null;
    }

    return this._variables[name];
  },

  /**
   * Remove a variable.
   *
   * @param {String} name Name of the varaible.
   */
  removeVariable: function removeVariable(name) {
    delete this._variables[name];
  },

  /**
   * Get all variables.
   *
   * @return {Object}
   */
  getAllVariables: function getAllVariables() {
    return this._variables;
  },
  _parsePart: function _parsePart(part) {
    var c = void 0,
        inInterpolation = false,
        currentIndex = 0;

    var tokens = [];

    if (part.length === 0) {
      throw new Error('Unable to parse empty string.');
    }

    for (var i = 0; i < part.length; i++) {
      c = part.charAt(i);

      if (c === '$' && part.charAt(i + 1) === '{') {
        if (inInterpolation) {
          throw new Error('Nested interpolation not supported.');
        }

        var token = part.substring(currentIndex, i);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i));
        }

        currentIndex = i;
        inInterpolation = true;
      } else if (c === '}') {
        if (!inInterpolation) {
          throw new Error('} must be preceeded by ${');
        }

        var _token = part.substring(currentIndex, i + 1);
        if (_token.length > 0) {
          tokens.push(part.substring(currentIndex, i + 1));
        }

        currentIndex = i + 1;
        inInterpolation = false;
      }
    }

    if (inInterpolation) {
      throw new Error('Unterminated interpolation.');
    }

    tokens.push(part.substring(currentIndex, part.length));

    return tokens;
  },
  _replaceToken: function _replaceToken(token) {
    var re = /^\${(.*?)}$/,
        match = token.match(re);

    if (match) {
      var name = match[1].trim();
      var variable = this.getVariable(name);

      if (variable === null) {
        throw new Error('Variable "' + name + '" does not exist.');
      } else if (typeof variable === 'string') {
        return variable;
      } else {
        var rv = variable();

        if (typeof rv !== 'string') {
          throw new Error('Must return a string.');
        }

        return rv;
      }
    } else {
      return token;
    }
  },
  _replaceTokens: function _replaceTokens(tokens) {
    return tokens.map(this._replaceToken.bind(this));
  },
  _parseExpression: function _parseExpression(expression) {
    return expression.split(',').map(function (part) {
      return part.trim();
    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
      return part.join('');
    });
  },

  /**
   * Evaluate an expression.
   *
   * @param {String} expression An page attribute expression.
   * @return {Array}
   */
  evaluate: function evaluate(expression) {
    if (!expression) {
      return [];
    }

    return this._parseExpression(expression);
  }
};

// Define default variables.
pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
pageAttributeExpression.defineVariable('runtime', function () {
  return platform.isWebView() ? 'cordova' : 'browser';
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var internal$1 = {};

internal$1.config = {
  autoStatusBarFill: true,
  animationsDisabled: false,
  warningsDisabled: false
};

internal$1.nullElement = window.document.createElement('div');

/**
 * @return {Boolean}
 */
internal$1.isEnabledAutoStatusBarFill = function () {
  return !!internal$1.config.autoStatusBarFill;
};

/**
 * @param {String} html
 * @return {String}
 */
internal$1.normalizePageHTML = function (html) {
  return ('' + html).trim();
};

internal$1.waitDOMContentLoaded = function (callback) {
  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
    var wrappedCallback = function wrappedCallback() {
      callback();
      window.document.removeEventListener('DOMContentLoaded', wrappedCallback);
    };
    window.document.addEventListener('DOMContentLoaded', wrappedCallback);
  } else {
    setImmediate(callback);
  }
};

internal$1.autoStatusBarFill = function (action) {
  var onReady = function onReady() {
    if (internal$1.shouldFillStatusBar()) {
      action();
    }
    document.removeEventListener('deviceready', onReady);
  };

  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {
    document.addEventListener('deviceready', onReady);
  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
    internal$1.waitDOMContentLoaded(onReady);
  } else {
    onReady();
  }
};

internal$1.shouldFillStatusBar = function () {
  return internal$1.isEnabledAutoStatusBarFill() && (platform.isWebView() && platform.isIOS7above() && !platform.isIPhoneX() || document.body.querySelector('.ons-status-bar-mock.ios'));
};

internal$1.templateStore = {
  _storage: {},

  /**
   * @param {String} key
   * @return {String/null} template
   */
  get: function get$$1(key) {
    return internal$1.templateStore._storage[key] || null;
  },


  /**
   * @param {String} key
   * @param {String} template
   */
  set: function set$$1(key, template) {
    internal$1.templateStore._storage[key] = template;
  }
};

window.document.addEventListener('_templateloaded', function (e) {
  if (e.target.nodeName.toLowerCase() === 'ons-template') {
    internal$1.templateStore.set(e.templateId, e.template);
  }
}, false);

internal$1.waitDOMContentLoaded(function () {
  register('script[type="text/ons-template"]');
  register('script[type="text/template"]');
  register('script[type="text/ng-template"]');
  register('template');

  function register(query) {
    var templates = window.document.querySelectorAll(query);
    for (var i = 0; i < templates.length; i++) {
      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent || templates[i].content);
    }
  }
});

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getTemplateHTMLAsync = function (page) {
  return new Promise(function (resolve, reject) {
    internal$1.waitDOMContentLoaded(function () {
      var cache = internal$1.templateStore.get(page);
      if (cache) {
        if (cache instanceof DocumentFragment) {
          return resolve(cache);
        }

        var html = typeof cache === 'string' ? cache : cache[1];
        return resolve(internal$1.normalizePageHTML(html));
      }

      var local = window.document.getElementById(page);
      if (local) {
        var _html = local.textContent || local.content;
        return resolve(_html);
      }

      var xhr = new XMLHttpRequest();
      xhr.open('GET', page, true);
      xhr.onload = function () {
        var html = xhr.responseText;
        if (xhr.status >= 400 && xhr.status < 600) {
          reject(html);
        } else {
          // Refresh script tags
          var fragment = util.createFragment(html);
          util.arrayFrom(fragment.querySelectorAll('script')).forEach(function (el) {
            var script = document.createElement('script');
            script.type = el.type || 'text/javascript';
            script.appendChild(document.createTextNode(el.text || el.textContent || el.innerHTML));
            el.parentNode.replaceChild(script, el);
          });

          internal$1.templateStore.set(page, fragment);
          resolve(fragment);
        }
      };
      xhr.onerror = function () {
        throw new Error('The page is not found: ' + page);
      };
      xhr.send(null);
    });
  });
};

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getPageHTMLAsync = function (page) {
  var pages = pageAttributeExpression.evaluate(page);

  var getPage = function getPage(page) {
    if (typeof page !== 'string') {
      return Promise.reject('Must specify a page.');
    }

    return internal$1.getTemplateHTMLAsync(page).catch(function (error) {
      if (pages.length === 0) {
        return Promise.reject(error);
      }

      return getPage(pages.shift());
    });
  };

  return getPage(pages.shift());
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AnimatorFactory = function () {

  /**
   * @param {Object} opts
   * @param {Object} opts.animators The dictionary for animator classes
   * @param {Function} opts.baseClass The base class of animators
   * @param {String} [opts.baseClassName] The name of the base class of animators
   * @param {String} [opts.defaultAnimation] The default animation name
   * @param {Object} [opts.defaultAnimationOptions] The default animation options
   */
  function AnimatorFactory(opts) {
    classCallCheck(this, AnimatorFactory);

    this._animators = opts.animators;
    this._baseClass = opts.baseClass;
    this._baseClassName = opts.baseClassName || opts.baseClass.name;
    this._animation = opts.defaultAnimation || 'default';
    this._animationOptions = opts.defaultAnimationOptions || {};

    if (!this._animators[this._animation]) {
      throw new Error('No such animation: ' + this._animation);
    }
  }

  /**
   * @param {String} jsonString
   * @return {Object/null}
   */


  createClass(AnimatorFactory, [{
    key: 'setAnimationOptions',


    /**
     * @param {Object} options
     */
    value: function setAnimationOptions(options) {
      this._animationOptions = options;
    }

    /**
     * @param {Object} options
     * @param {String} [options.animation] The animation name
     * @param {Object} [options.animationOptions] The animation options
     * @param {Object} defaultAnimator The default animator instance
     * @return {Object} An animator instance
     */

  }, {
    key: 'newAnimator',
    value: function newAnimator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultAnimator = arguments[1];


      var animator = null;

      if (options.animation instanceof this._baseClass) {
        return options.animation;
      }

      var Animator = null;

      if (typeof options.animation === 'string') {
        Animator = this._animators[options.animation];
      }

      if (!Animator && defaultAnimator) {
        animator = defaultAnimator;
      } else {
        Animator = Animator || this._animators[this._animation];

        var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

        animator = new Animator(animationOpts);

        if (typeof animator === 'function') {
          animator = new animator(animationOpts); // eslint-disable-line new-cap
        }
      }

      if (!(animator instanceof this._baseClass)) {
        throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
      }

      return animator;
    }
  }], [{
    key: 'parseAnimationOptionsString',
    value: function parseAnimationOptionsString(jsonString) {
      try {
        if (typeof jsonString === 'string') {
          var result = util.animationOptionsParse(jsonString);
          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
            return result;
          } else {
            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
          }
        }
        return {};
      } catch (e) {
        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
        return {};
      }
    }
  }]);
  return AnimatorFactory;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoStyleEnabled = true;

// Modifiers
var modifiersMap = {
  'quiet': 'material--flat',
  'light': 'material--flat',
  'outline': 'material--flat',
  'cta': '',
  'large--quiet': 'material--flat large',
  'large--cta': 'large',
  'noborder': '',
  'tappable': ''
};

var platforms = {};

platforms.android = function (element) {

  var elementName = element.tagName.toLowerCase();

  if (!util.hasModifier(element, 'material')) {
    var oldModifier = element.getAttribute('modifier') || '';

    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
    });
    newModifier.unshift('material');

    element.setAttribute('modifier', newModifier.join(' ').trim());
  }

  var elements = ['ons-alert-dialog-button', 'ons-toolbar-button', 'ons-back-button', 'ons-button', 'ons-list-item', 'ons-fab', 'ons-speed-dial', 'ons-speed-dial-item', 'ons-tab'];

  // Effects
  if (elements.indexOf(elementName) !== -1 && !element.hasAttribute('ripple') && !element.querySelector('ons-ripple')) {

    if (elementName === 'ons-list-item') {
      if (element.hasAttribute('tappable')) {
        element.setAttribute('ripple', '');
        element.removeAttribute('tappable');
      }
    } else {
      element.setAttribute('ripple', '');
    }
  }
};

platforms.ios = function (element) {

  // Modifiers
  if (util.removeModifier(element, 'material')) {
    if (util.removeModifier(element, 'material--flat')) {
      util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
    }

    if (!element.getAttribute('modifier')) {
      element.removeAttribute('modifier');
    }
  }

  // Effects
  if (element.hasAttribute('ripple')) {
    if (element.tagName.toLowerCase() === 'ons-list-item') {
      element.setAttribute('tappable', '');
    }

    element.removeAttribute('ripple');
  }
};

var unlocked = {
  android: true
};

var getPlatform = function getPlatform(element, force) {
  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
    var mobileOS = platform.getMobileOS();
    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
      return mobileOS;
    }
  }
  return null;
};

var prepare = function prepare(element, force) {
  var p = getPlatform(element, force);
  p && platforms[p](element);
};

var mapModifier = function mapModifier(modifier, element, force) {
  if (getPlatform(element, force)) {
    return modifier.split(/\s+/).map(function (m) {
      return modifiersMap.hasOwnProperty(m) ? modifiersMap[m] : m;
    }).join(' ');
  }
  return modifier;
};

var restoreModifier = function restoreModifier(element) {
  if (getPlatform(element) === 'android') {
    var modifier = element.getAttribute('modifier') || '';
    var newModifier = mapModifier(modifier, element);

    if (!/(^|\s+)material($|\s+)/i.test(modifier)) {
      newModifier = 'material ' + newModifier;
    }

    if (newModifier !== modifier) {
      element.setAttribute('modifier', newModifier.trim());
      return true;
    }
  }
  return false;
};

var autoStyle = {
  isEnabled: function isEnabled() {
    return autoStyleEnabled;
  },
  enable: function enable() {
    return autoStyleEnabled = true;
  },
  disable: function disable() {
    return autoStyleEnabled = false;
  },
  prepare: prepare,
  mapModifier: mapModifier,
  getPlatform: getPlatform,
  restoreModifier: restoreModifier
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModifierUtil = function () {
  function ModifierUtil() {
    classCallCheck(this, ModifierUtil);
  }

  createClass(ModifierUtil, null, [{
    key: 'diff',

    /**
     * @param {String} last
     * @param {String} current
     */
    value: function diff(last, current) {
      last = makeDict(('' + last).trim());
      current = makeDict(('' + current).trim());

      var removed = Object.keys(last).reduce(function (result, token) {
        if (!current[token]) {
          result.push(token);
        }
        return result;
      }, []);

      var added = Object.keys(current).reduce(function (result, token) {
        if (!last[token]) {
          result.push(token);
        }
        return result;
      }, []);

      return { added: added, removed: removed };

      function makeDict(modifier) {
        var dict = {};
        ModifierUtil.split(modifier).forEach(function (token) {
          return dict[token] = token;
        });
        return dict;
      }
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {Object} classList
     * @param {String} template
     */

  }, {
    key: 'applyDiffToClassList',
    value: function applyDiffToClassList(diff, classList, template) {
      diff.added.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return klass.split(/\s+/).forEach(function (k) {
          return classList.add(k);
        });
      });

      diff.removed.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return klass.split(/\s+/).forEach(function (k) {
          return classList.remove(k);
        });
      });
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'applyDiffToElement',
    value: function applyDiffToElement(diff, element, scheme) {
      Object.keys(scheme).forEach(function (selector) {
        var targetElements = !selector || util.match(element, selector) ? [element] : Array.prototype.filter.call(element.querySelectorAll(selector), function (targetElement) {
          return !util.findParent(targetElement, element.tagName, function (parent) {
            return parent === element;
          });
        });

        for (var i = 0; i < targetElements.length; i++) {
          ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
        }
      });
    }

    /**
     * @param {String} last
     * @param {String} current
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'onModifierChanged',
    value: function onModifierChanged(last, current, element, scheme) {
      ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
      autoStyle.restoreModifier(element);
    }
  }, {
    key: 'refresh',
    value: function refresh(element, scheme) {
      ModifierUtil.applyDiffToElement(ModifierUtil.diff('', element.getAttribute('modifier') || ''), element, scheme);
    }

    /**
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'initModifier',
    value: function initModifier(element, scheme) {
      var modifier = element.getAttribute('modifier');
      if (typeof modifier !== 'string') {
        return;
      }

      ModifierUtil.applyDiffToElement({
        removed: [],
        added: ModifierUtil.split(modifier)
      }, element, scheme);
    }
  }, {
    key: 'split',
    value: function split(modifier) {
      if (typeof modifier !== 'string') {
        return [];
      }

      return modifier.trim().split(/ +/).filter(function (token) {
        return token !== '';
      });
    }

    /**
     * Add modifier token to an element.
     */

  }, {
    key: 'addModifier',
    value: function addModifier(element, modifierToken) {
      if (!element.hasAttribute('modifier')) {
        element.setAttribute('modifier', modifierToken);
      } else {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        if (tokens.indexOf(modifierToken) == -1) {
          tokens.push(modifierToken);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }

    /**
     * Remove modifier token from an element.
     */

  }, {
    key: 'removeModifier',
    value: function removeModifier(element, modifierToken) {
      if (element.hasAttribute('modifier')) {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        var index = tokens.indexOf(modifierToken);
        if (index !== -1) {
          tokens.splice(index, 1);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }
  }]);
  return ModifierUtil;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$2 = {
  _ready: false,

  _domContentLoaded: false,

  _onDOMContentLoaded: function _onDOMContentLoaded() {
    util$2._domContentLoaded = true;

    if (platform.isWebView()) {
      window.document.addEventListener('deviceready', function () {
        util$2._ready = true;
      }, false);
    } else {
      util$2._ready = true;
    }
  },

  addBackButtonListener: function addBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.addEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.addEventListener('backbutton', fn, false);
      });
    }
  },

  removeBackButtonListener: function removeBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.removeEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.removeEventListener('backbutton', fn, false);
      });
    }
  }
};
window.addEventListener('DOMContentLoaded', function () {
  return util$2._onDOMContentLoaded();
}, false);

var HandlerRepository = {
  _store: {},

  _genId: function () {
    var i = 0;
    return function () {
      return i++;
    };
  }(),

  set: function set$$1(element, handler) {
    if (element.dataset.deviceBackButtonHandlerId) {
      this.remove(element);
    }
    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
    this._store[id] = handler;
  },

  remove: function remove(element) {
    if (element.dataset.deviceBackButtonHandlerId) {
      delete this._store[element.dataset.deviceBackButtonHandlerId];
      delete element.dataset.deviceBackButtonHandlerId;
    }
  },

  get: function get$$1(element) {
    if (!element.dataset.deviceBackButtonHandlerId) {
      return undefined;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    if (!this._store[id]) {
      throw new Error();
    }

    return this._store[id];
  },

  has: function has(element) {
    if (!element.dataset) {
      return false;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    return !!this._store[id];
  }
};

var DeviceBackButtonDispatcher = function () {
  function DeviceBackButtonDispatcher() {
    classCallCheck(this, DeviceBackButtonDispatcher);

    this._isEnabled = false;
    this._boundCallback = this._callback.bind(this);
  }

  /**
   * Enable to handle 'backbutton' events.
   */


  createClass(DeviceBackButtonDispatcher, [{
    key: 'enable',
    value: function enable() {
      if (!this._isEnabled) {
        util$2.addBackButtonListener(this._boundCallback);
        this._isEnabled = true;
      }
    }

    /**
     * Disable to handle 'backbutton' events.
     */

  }, {
    key: 'disable',
    value: function disable() {
      if (this._isEnabled) {
        util$2.removeBackButtonListener(this._boundCallback);
        this._isEnabled = false;
      }
    }

    /**
     * Fire a 'backbutton' event manually.
     */

  }, {
    key: 'fireDeviceBackButtonEvent',
    value: function fireDeviceBackButtonEvent() {
      var event = document.createEvent('Event');
      event.initEvent('backbutton', true, true);
      document.dispatchEvent(event);
    }
  }, {
    key: '_callback',
    value: function _callback() {
      this._dispatchDeviceBackButtonEvent();
    }

    /**
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }, {
    key: 'createHandler',
    value: function createHandler(element, callback) {
      if (!(element instanceof HTMLElement)) {
        throw new Error('element must be an instance of HTMLElement');
      }

      if (!(callback instanceof Function)) {
        throw new Error('callback must be an instance of Function');
      }

      var handler = {
        _callback: callback,
        _element: element,

        disable: function disable() {
          HandlerRepository.remove(element);
        },

        setListener: function setListener(callback) {
          this._callback = callback;
        },

        enable: function enable() {
          HandlerRepository.set(element, this);
        },

        isEnabled: function isEnabled() {
          return HandlerRepository.get(element) === this;
        },

        destroy: function destroy() {
          HandlerRepository.remove(element);
          this._callback = this._element = null;
        }
      };

      handler.enable();

      return handler;
    }
  }, {
    key: '_dispatchDeviceBackButtonEvent',
    value: function _dispatchDeviceBackButtonEvent() {
      var tree = this._captureTree();

      var element = this._findHandlerLeafElement(tree);

      var handler = HandlerRepository.get(element);
      handler._callback(createEvent(element));

      function createEvent(element) {
        return {
          _element: element,
          callParentHandler: function callParentHandler() {
            var parent = this._element.parentNode;

            while (parent) {
              handler = HandlerRepository.get(parent);
              if (handler) {
                return handler._callback(createEvent(parent));
              }
              parent = parent.parentNode;
            }
          }
        };
      }
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_captureTree',
    value: function _captureTree() {
      return createTree(document.body);

      function createTree(element) {
        var tree = {
          element: element,
          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

            if (childElement.style.display === 'none' || childElement._isShown === false) {
              return [];
            }

            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
              return [];
            }

            var result = createTree(childElement);

            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
              return [];
            }

            return [result];
          }))
        };

        if (!HandlerRepository.has(tree.element)) {
          for (var i = 0; i < tree.children.length; i++) {
            var subTree = tree.children[i];
            if (HandlerRepository.has(subTree.element)) {
              return subTree;
            }
          }
        }

        return tree;
      }

      function arrayOf(target) {
        var result = [];
        for (var i = 0; i < target.length; i++) {
          result.push(target[i]);
        }
        return result;
      }
    }

    /**
     * @param {Object} tree
     * @return {HTMLElement}
     */

  }, {
    key: '_findHandlerLeafElement',
    value: function _findHandlerLeafElement(tree) {
      return find(tree);

      function find(node) {
        if (node.children.length === 0) {
          return node.element;
        }

        if (node.children.length === 1) {
          return find(node.children[0]);
        }

        return node.children.map(function (childNode) {
          return childNode.element;
        }).reduce(function (left, right) {
          if (!left) {
            return right;
          }

          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

          if (!isNaN(leftZ) && !isNaN(rightZ)) {
            return leftZ > rightZ ? left : right;
          }

          throw new Error('Capturing backbutton-handler is failure.');
        }, null);
      }
    }
  }]);
  return DeviceBackButtonDispatcher;
}();

var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
internal$1.AnimatorFactory = AnimatorFactory;
internal$1.ModifierUtil = ModifierUtil;
internal$1.dbbDispatcher = deviceBackButtonDispatcher;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

'use strict';

var startsWith = function startsWith(s, c) {
  return s.substr(0, c.length) === c;
};
var endsWith = function endsWith(s, c) {
  return s.substr(s.length - c.length, c.length) === c;
};
var unwrap = function unwrap(s) {
  return s.slice(1, -1);
};
var isObjectString = function isObjectString(s) {
  return startsWith(s, '{') && endsWith(s, '}');
};
var isArrayString = function isArrayString(s) {
  return startsWith(s, '[') && endsWith(s, ']');
};
var isQuotedString = function isQuotedString(s) {
  return startsWith(s, '\'') && endsWith(s, '\'') || startsWith(s, '"') && endsWith(s, '"');
};

var error = function error(token, string, originalString) {
  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
};

var processToken = function processToken(token, string, originalString) {
  if (token === 'true' || token === 'false') {
    return token === 'true';
  } else if (isQuotedString(token)) {
    return unwrap(token);
  } else if (!isNaN(token)) {
    return +token;
  } else if (isObjectString(token)) {
    return parseObject(unwrap(token));
  } else if (isArrayString(token)) {
    return parseArray(unwrap(token));
  } else {
    error(token, string, originalString);
  }
};

var nextToken = function nextToken(string) {
  string = string.trim();
  var limit = string.length;

  if (string[0] === ':' || string[0] === ',') {

    limit = 1;
  } else if (string[0] === '{' || string[0] === '[') {

    var c = string.charCodeAt(0);
    var nestedObject = 1;
    for (var i = 1; i < string.length; i++) {
      if (string.charCodeAt(i) === c) {
        nestedObject++;
      } else if (string.charCodeAt(i) === c + 2) {
        nestedObject--;
        if (nestedObject === 0) {
          limit = i + 1;
          break;
        }
      }
    }
  } else if (string[0] === '\'' || string[0] === '"') {

    for (var _i = 1; _i < string.length; _i++) {
      if (string[_i] === string[0]) {
        limit = _i + 1;
        break;
      }
    }
  } else {

    for (var _i2 = 1; _i2 < string.length; _i2++) {
      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
        limit = _i2;
        break;
      }
    }
  }

  return string.slice(0, limit);
};

var parseObject = function parseObject(string) {
  var isValidKey = function isValidKey(key) {
    return (/^[A-Z_$][A-Z0-9_$]*$/i.test(key)
    );
  };

  string = string.trim();
  var originalString = string;
  var object = {};
  var readingKey = true,
      key = void 0,
      previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();

    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
      error(token, string, originalString);
    } else if (token === ':' && readingKey && previousToken) {
      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;
      if (isValidKey(previousToken)) {
        key = previousToken;
        readingKey = false;
      } else {
        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
      }
    } else if (token === ',' && !readingKey && previousToken) {
      object[key] = processToken(previousToken, string, originalString);
      readingKey = true;
    }
  }

  if (token) {
    object[key] = processToken(token, string, originalString);
  }

  return object;
};

var parseArray = function parseArray(string) {
  string = string.trim();
  var originalString = string;
  var array = [];
  var previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();

    if (token === ',' && (!previousToken || previousToken === ',')) {
      error(token, string, originalString);
    } else if (token === ',') {
      array.push(processToken(previousToken, string, originalString));
    }
  }

  if (token) {
    if (token !== ',') {
      array.push(processToken(token, string, originalString));
    } else {
      error(token, string, originalString);
    }
  }

  return array;
};

var parse = function parse(string) {
  string = string.trim();

  if (isObjectString(string)) {
    return parseObject(unwrap(string));
  } else if (isArrayString(string)) {
    return parseArray(unwrap(string));
  } else {
    throw new Error('Provided string must be object or array like: ' + string);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util = {};

util.globals = {
  fabOffset: 0
};

/**
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {Function}
 */
util.prepareQuery = function (query) {
  return query instanceof Function ? query : function (element) {
    return util.match(element, query);
  };
};

/**
 * @param {Element} e
 * @param {String/Function} s CSS Selector.
 * @return {Boolean}
 */
util.match = function (e, s) {
  return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findChild = function (element, query) {
  var match = util.prepareQuery(query);

  // Caution: `element.children` is `undefined` in some environments if `element` is `svg`
  for (var i = 0; i < element.childNodes.length; i++) {
    var node = element.childNodes[i];
    if (node.nodeType !== Node.ELEMENT_NODE) {
      // process only element nodes
      continue;
    }
    if (match(node)) {
      return node;
    }
  }
  return null;
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util.findParent = function (element, query, until) {
  var match = util.prepareQuery(query);

  var parent = element.parentNode;
  for (;;) {
    if (!parent || parent === document || parent instanceof DocumentFragment || until && until(parent)) {
      return null;
    } else if (match(parent)) {
      return parent;
    }
    parent = parent.parentNode;
  }
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.isAttached = function (element) {
  return document.body.contains(element);
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.hasAnyComponentAsParent = function (element) {
  while (element && document.documentElement !== element) {
    element = element.parentNode;
    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal)/)) {
      return true;
    }
  }
  return false;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util.isPageControl = function (element) {
  return element.nodeName.match(/^ons-(navigator|splitter|tabbar|page)$/i);
};

/**
 * @param {Element} element
 * @param {String} action to propagate
 */
util.propagateAction = function (element, action) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (child[action] instanceof Function) {
      child[action]();
    } else {
      util.propagateAction(child, action);
    }
  }
};

/**
 * @param {String} string - string to be camelized
 * @return {String} Camelized string
 */
util.camelize = function (string) {
  return string.toLowerCase().replace(/-([a-z])/g, function (m, l) {
    return l.toUpperCase();
  });
};

/**
 * @param {String} string - string to be hyphenated
 * @return {String} Hyphenated string
 */
util.hyphenate = function (string) {
  return string.replace(/([a-zA-Z])([A-Z])/g, '$1-$2').toLowerCase();
};

/**
 * @param {String} selector - tag and class only
 * @param {Object} style
 * @param {Element}
 */
util.create = function () {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var classList = selector.split('.');
  var element = document.createElement(classList.shift() || 'div');

  if (classList.length) {
    element.className = classList.join(' ');
  }

  styler(element, style);

  return element;
};

/**
 * @param {String} html
 * @return {Element}
 */
util.createElement = function (html) {
  var wrapper = document.createElement('div');

  if (html instanceof DocumentFragment) {
    wrapper.appendChild(document.importNode(html, true));
  } else {
    wrapper.innerHTML = html.trim();
  }

  if (wrapper.children.length > 1) {
    throw new Error('"html" must be one wrapper element.');
  }

  var element = wrapper.children[0];
  wrapper.children[0].remove();
  return element;
};

/**
 * @param {String} html
 * @return {HTMLFragment}
 */
util.createFragment = function (html) {
  var template = document.createElement('template');
  template.innerHTML = html;
  return document.importNode(template.content, true);
};

/*
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
util.extend = function (dst) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < args.length; i++) {
    if (args[i]) {
      var keys = Object.keys(args[i]);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        dst[key] = args[i][key];
      }
    }
  }

  return dst;
};

/**
 * @param {Object} arrayLike
 * @return {Array}
 */
util.arrayFrom = function (arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

/**
 * @param {String} jsonString
 * @param {Object} [failSafe]
 * @return {Object}
 */
util.parseJSONObjectSafely = function (jsonString) {
  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    var result = JSON.parse('' + jsonString);
    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
      return result;
    }
  } catch (e) {
    return failSafe;
  }
  return failSafe;
};

/**
 * @param {String} path - path such as 'myApp.controllers.data.loadData'
 * @return {Any} - whatever is located at that path
 */
util.findFromPath = function (path) {
  path = path.split('.');
  var el = window,
      key;
  while (key = path.shift()) {
    // eslint-disable-line no-cond-assign
    el = el[key];
  }
  return el;
};

/**
 * @param {HTMLElement} container - Page or page-container that implements 'topPage'
 * @return {HTMLElement|null} - Visible page element or null if not found.
 */
util.getTopPage = function (container) {
  return container && (container.tagName.toLowerCase() === 'ons-page' ? container : container.topPage) || null;
};

/**
 * @param {HTMLElement} container - Element where the search begins
 * @return {HTMLElement|null} - Page element that contains the visible toolbar or null.
 */
util.findToolbarPage = function (container) {
  var page = util.getTopPage(container);

  if (page) {
    if (page._canAnimateToolbar()) {
      return page;
    }

    for (var i = 0; i < page._contentElement.children.length; i++) {
      var nextPage = util.getTopPage(page._contentElement.children[i]);
      if (nextPage && !/ons-tabbar/i.test(page._contentElement.children[i].tagName)) {
        return util.findToolbarPage(nextPage);
      }
    }
  }

  return null;
};

/**
 * @param {Element} element
 * @param {String} eventName
 * @param {Object} [detail]
 * @return {CustomEvent}
 */
util.triggerElementEvent = function (target, eventName) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  var event = new CustomEvent(eventName, {
    bubbles: true,
    cancelable: true,
    detail: detail
  });

  Object.keys(detail).forEach(function (key) {
    event[key] = detail[key];
  });

  target.dispatchEvent(event);

  return event;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean}
 */
util.hasModifier = function (target, modifierName) {
  if (!target.hasAttribute('modifier')) {
    return false;
  }

  return RegExp('(^|\\s+)' + modifierName + '($|\\s+)', 'i').test(target.getAttribute('modifier'));
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was added or not.
 */
util.addModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  if (util.hasModifier(target, modifierName)) {
    return false;
  }

  target.setAttribute('modifier', ((target.getAttribute('modifier') || '') + ' ' + modifierName).trim());
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was found or not.
 */
util.removeModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  if (!target.getAttribute('modifier') || !util.hasModifier(target, modifierName)) {
    return false;
  }

  var newModifiers = target.getAttribute('modifier').split(/\s+/).filter(function (m) {
    return m && m !== modifierName;
  });
  newModifiers.length ? target.setAttribute('modifier', newModifiers.join(' ')) : target.removeAttribute('modifier');
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Boolean} options.force Forces modifier to be added or removed.
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Boolean} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was found or not.
 */
util.toggleModifier = function () {
  var options = arguments.length > 2 ? arguments.length <= 2 ? undefined : arguments[2] : {};
  var force = typeof options === 'boolean' ? options : options.force;

  var toggle = typeof force === 'boolean' ? force : !util.hasModifier.apply(util, arguments);
  toggle ? util.addModifier.apply(util, arguments) : util.removeModifier.apply(util, arguments);
};

/**
 * @param {Element} el
 * @param {String} defaultClass
 * @param {Object} scheme
 */
util.restoreClass = function (el, defaultClass, scheme) {
  defaultClass.split(/\s+/).forEach(function (c) {
    return c !== '' && !el.classList.contains(c) && el.classList.add(c);
  });
  el.hasAttribute('modifier') && ModifierUtil.refresh(el, scheme);
};

// TODO: FIX
util.updateParentPosition = function (el) {
  if (!el._parentUpdated && el.parentElement) {
    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
      el.parentElement.style.position = 'relative';
    }
    el._parentUpdated = true;
  }
};

util.toggleAttribute = function (element, name, value) {
  if (value) {
    element.setAttribute(name, typeof value === 'boolean' ? '' : value);
  } else {
    element.removeAttribute(name);
  }
};

util.bindListeners = function (element, listenerNames) {
  listenerNames.forEach(function (name) {
    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
    element[boundName] = element[boundName] || element[name].bind(element);
  });
};

util.each = function (obj, f) {
  return Object.keys(obj).forEach(function (key) {
    return f(key, obj[key]);
  });
};

/**
 * @param {Element} target
 * @param {boolean} hasRipple
 * @param {Object} attrs
 */
util.updateRipple = function (target, hasRipple) {
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (hasRipple === undefined) {
    hasRipple = target.hasAttribute('ripple');
  }

  var rippleElement = util.findChild(target, 'ons-ripple');

  if (hasRipple) {
    if (!rippleElement) {
      var element = document.createElement('ons-ripple');
      Object.keys(attrs).forEach(function (key) {
        return element.setAttribute(key, attrs[key]);
      });
      target.insertBefore(element, target.firstChild);
    }
  } else if (rippleElement) {
    rippleElement.remove();
  }
};

/**
 * @param {String}
 * @return {Object}
 */
util.animationOptionsParse = parse;

/**
 * @param {*} value
 */
util.isInteger = function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

/**
 * @return {Object} Deferred promise.
 */
util.defer = function () {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

/**
 * Show warnings when they are enabled.
 *
 * @param {*} arguments to console.warn
 */
util.warn = function () {
  if (!internal$1.config.warningsDisabled) {
    var _console;

    (_console = console).warn.apply(_console, arguments);
  }
};

/**
 * Prevent scrolling while draging horizontally.
 *
 * @param {gd} GestureDetector instance
 */
util.preventScroll = function (gd) {
  var prevent = function prevent(e) {
    return e.cancelable && e.preventDefault();
  };

  var clean = function clean(e) {
    gd.off('touchmove', prevent);
    gd.off('dragend', clean);
  };

  gd.on('touchmove', prevent);
  gd.on('dragend', clean);
};

/**
 * Distance and deltaTime filter some weird dragstart events that are not fired immediately.
 *
 * @param {event}
 */
util.isValidGesture = function (event) {
  return event.gesture !== undefined && (event.gesture.distance <= 15 || event.gesture.deltaTime <= 100);
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
'use strict';

var TIMEOUT_RATIO = 1.4;

var util$3 = {};

// capitalize string
util$3.capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * @param {Object} params
 * @param {String} params.property
 * @param {Float} params.duration
 * @param {String} params.timing
 */
util$3.buildTransitionValue = function (params) {
  params.property = params.property || 'all';
  params.duration = params.duration || 0.4;
  params.timing = params.timing || 'linear';

  var props = params.property.split(/ +/);

  return props.map(function (prop) {
    return prop + ' ' + params.duration + 's ' + params.timing;
  }).join(', ');
};

/**
 * Add an event handler on "transitionend" event.
 */
util$3.onceOnTransitionEnd = function (element, callback) {
  if (!element) {
    return function () {};
  }

  var fn = function fn(event) {
    if (element == event.target) {
      event.stopPropagation();
      removeListeners();

      callback();
    }
  };

  var removeListeners = function removeListeners() {
    util$3._transitionEndEvents.forEach(function (eventName) {
      element.removeEventListener(eventName, fn, false);
    });
  };

  util$3._transitionEndEvents.forEach(function (eventName) {
    element.addEventListener(eventName, fn, false);
  });

  return removeListeners;
};

util$3._transitionEndEvents = function () {

  if ('ontransitionend' in window) {
    return ['transitionend'];
  }

  if ('onwebkittransitionend' in window) {
    return ['webkitTransitionEnd'];
  }

  if (util$3.vendorPrefix === 'webkit' || util$3.vendorPrefix === 'o' || util$3.vendorPrefix === 'moz' || util$3.vendorPrefix === 'ms') {
    return [util$3.vendorPrefix + 'TransitionEnd', 'transitionend'];
  }

  return [];
}();

util$3._cssPropertyDict = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var dict = {};
  var a = 'A'.charCodeAt(0);
  var z = 'z'.charCodeAt(0);

  var upper = function upper(s) {
    return s.substr(1).toUpperCase();
  };

  for (var i = 0; i < styles.length; i++) {

    var key = styles[i].replace(/^[-]+/, '').replace(/[-][a-z]/g, upper).replace(/^moz/, 'Moz');

    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
      if (key !== 'cssText' && key !== 'parentText') {
        dict[key] = true;
      }
    }
  }

  return dict;
}();

util$3.hasCssProperty = function (name) {
  return name in util$3._cssPropertyDict;
};

/**
 * Vendor prefix for css property.
 */
util$3.vendorPrefix = function () {
  var styles = window.getComputedStyle(document.documentElement, ''),
      pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];
  return pre;
}();

util$3.forceLayoutAtOnce = function (elements, callback) {
  this.batchImmediate(function () {
    elements.forEach(function (element) {
      // force layout
      element.offsetHeight;
    });
    callback();
  });
};

util$3.batchImmediate = function () {
  var callbacks = [];

  return function (callback) {
    if (callbacks.length === 0) {
      setImmediate(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$3.batchAnimationFrame = function () {
  var callbacks = [];

  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    setTimeout(callback, 1000 / 60);
  };

  return function (callback) {
    if (callbacks.length === 0) {
      raf(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$3.transitionPropertyName = function () {
  if (util$3.hasCssProperty('transitionDuration')) {
    return 'transition';
  }

  if (util$3.hasCssProperty(util$3.vendorPrefix + 'TransitionDuration')) {
    return util$3.vendorPrefix + 'Transition';
  }

  throw new Error('Invalid state');
}();

/**
 * @param {HTMLElement} element
 */
var Animit = function Animit(element) {
  if (!(this instanceof Animit)) {
    return new Animit(element);
  }

  if (element instanceof HTMLElement) {
    this.elements = [element];
  } else if (Object.prototype.toString.call(element) === '[object Array]') {
    this.elements = element;
  } else {
    throw new Error('First argument must be an array or an instance of HTMLElement.');
  }

  this.transitionQueue = [];
  this.lastStyleAttributeDict = [];
};

Animit.prototype = {

  /**
   * @property {Array}
   */
  transitionQueue: undefined,

  /**
   * @property {Array}
   */
  elements: undefined,

  /**
   * Start animation sequence with passed animations.
   *
   * @param {Function} callback
   */
  play: function play(callback) {
    if (typeof callback === 'function') {
      this.transitionQueue.push(function (done) {
        callback();
        done();
      });
    }

    this.startAnimation();

    return this;
  },

  /**
   * Queue transition animations or other function.
   *
   * e.g. animit(elt).queue({color: 'red'})
   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
   *
   * @param {Object|Animit.Transition|Function} transition
   * @param {Object} [options]
   */
  queue: function queue(transition, options) {
    var queue = this.transitionQueue;

    if (transition && options) {
      options.css = transition;
      transition = new Animit.Transition(options);
    }

    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
      if (transition.css) {
        transition = new Animit.Transition(transition);
      } else {
        transition = new Animit.Transition({
          css: transition
        });
      }
    }

    if (transition instanceof Function) {
      queue.push(transition);
    } else if (transition instanceof Animit.Transition) {
      queue.push(transition.build());
    } else {
      throw new Error('Invalid arguments');
    }

    return this;
  },

  /**
   * Queue transition animations.
   *
   * @param {Float} seconds
   */
  wait: function wait(seconds) {
    if (seconds > 0) {
      this.transitionQueue.push(function (done) {
        setTimeout(done, 1000 * seconds);
      });
    }

    return this;
  },

  saveStyle: function saveStyle() {

    this.transitionQueue.push(function (done) {
      this.elements.forEach(function (element, index) {
        var css = this.lastStyleAttributeDict[index] = {};

        for (var i = 0; i < element.style.length; i++) {
          css[element.style[i]] = element.style[element.style[i]];
        }
      }.bind(this));
      done();
    }.bind(this));

    return this;
  },

  /**
   * Restore element's style.
   *
   * @param {Object} [options]
   * @param {Float} [options.duration]
   * @param {String} [options.timing]
   * @param {String} [options.transition]
   */
  restoreStyle: function restoreStyle(options) {
    options = options || {};
    var self = this;

    if (options.transition && !options.duration) {
      throw new Error('"options.duration" is required when "options.transition" is enabled.');
    }

    var transitionName = util$3.transitionPropertyName;

    if (options.transition || options.duration && options.duration > 0) {
      var transitionValue = options.transition || 'all ' + options.duration + 's ' + (options.timing || 'linear');

      this.transitionQueue.push(function (done) {
        var elements = this.elements;
        var timeoutId;

        var clearTransition = function clearTransition() {
          elements.forEach(function (element) {
            element.style[transitionName] = '';
          });
        };

        // add "transitionend" event handler
        var removeListeners = util$3.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          clearTransition();
          done();
        });

        // for fail safe.
        timeoutId = setTimeout(function () {
          removeListeners();
          clearTransition();
          done();
        }, options.duration * 1000 * TIMEOUT_RATIO);

        // transition and style settings
        elements.forEach(function (element, index) {

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          var name;
          for (var i = 0, len = element.style.length; i < len; i++) {
            name = element.style[i];
            if (css[name] === undefined) {
              css[name] = '';
            }
          }

          element.style[transitionName] = transitionValue;

          Object.keys(css).forEach(function (key) {
            if (key !== transitionName) {
              element.style[key] = css[key];
            }
          });

          element.style[transitionName] = transitionValue;
        });
      });
    } else {
      this.transitionQueue.push(function (done) {
        reset();
        done();
      });
    }

    return this;

    function reset() {
      // Clear transition animation settings.
      self.elements.forEach(function (element, index) {
        element.style[transitionName] = 'none';

        var css = self.lastStyleAttributeDict[index];

        if (!css) {
          throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
        }

        self.lastStyleAttributeDict[index] = undefined;

        for (var i = 0; i < element.style.length; i++) {
          if (typeof css[element.style[i]] === 'undefined') {
            css[element.style[i]] = '';
          }
        }

        Object.keys(css).forEach(function (key) {
          element.style[key] = css[key];
        });
      });
    }
  },

  /**
   * Start animation sequence.
   */
  startAnimation: function startAnimation() {
    this._dequeueTransition();

    return this;
  },

  _dequeueTransition: function _dequeueTransition() {
    var transition = this.transitionQueue.shift();
    if (this._currentTransition) {
      throw new Error('Current transition exists.');
    }
    this._currentTransition = transition;
    var self = this;
    var called = false;

    var done = function done() {
      if (!called) {
        called = true;
        self._currentTransition = undefined;
        self._dequeueTransition();
      } else {
        throw new Error('Invalid state: This callback is called twice.');
      }
    };

    if (transition) {
      transition.call(this, done);
    }
  }

};

/**
 * @param {Animit} arguments
 */
Animit.runAll = function () /* arguments... */{
  for (var i = 0; i < arguments.length; i++) {
    arguments[i].play();
  }
};

/**
 * @param {Object} options
 * @param {Float} [options.duration]
 * @param {String} [options.property]
 * @param {String} [options.timing]
 */
Animit.Transition = function (options) {
  this.options = options || {};
  this.options.duration = this.options.duration || 0;
  this.options.timing = this.options.timing || 'linear';
  this.options.css = this.options.css || {};
  this.options.property = this.options.property || 'all';
};

Animit.Transition.prototype = {

  /**
   * @param {HTMLElement} element
   * @return {Function}
   */
  build: function build() {

    if (Object.keys(this.options.css).length === 0) {
      throw new Error('options.css is required.');
    }

    var css = createActualCssProps(this.options.css);

    if (this.options.duration > 0) {
      var transitionValue = util$3.buildTransitionValue(this.options);
      var self = this;

      return function (callback) {
        var elements = this.elements;
        var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
        var timeoutId;

        var removeListeners = util$3.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          callback();
        });

        timeoutId = setTimeout(function () {
          removeListeners();
          callback();
        }, timeout);

        elements.forEach(function (element) {
          element.style[util$3.transitionPropertyName] = transitionValue;

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });
      };
    }

    if (this.options.duration <= 0) {
      return function (callback) {
        var elements = this.elements;

        elements.forEach(function (element) {
          element.style[util$3.transitionPropertyName] = '';

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });

        if (elements.length > 0) {
          util$3.forceLayoutAtOnce(elements, function () {
            util$3.batchAnimationFrame(callback);
          });
        } else {
          util$3.batchAnimationFrame(callback);
        }
      };
    }

    function createActualCssProps(css) {
      var result = {};

      Object.keys(css).forEach(function (name) {
        var value = css[name];

        if (util$3.hasCssProperty(name)) {
          result[name] = value;
          return;
        }

        var prefixed = util$3.vendorPrefix + util$3.capitalize(name);
        if (util$3.hasCssProperty(prefixed)) {
          result[prefixed] = value;
        } else {
          result[prefixed] = value;
          result[name] = value;
        }
      });

      return result;
    }
  }
};

/*
 * Gesture detector library that forked from github.com/EightMedia/hammer.js.
 */

'use strict';

var Event$1;
var Utils;
var Detection;
var PointerEvent;

/**
 * @object ons.GestureDetector
 * @category gesture
 * @description
 *   [en]Utility class for gesture detection.[/en]
 *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
 */

/**
 * @method constructor
 * @signature constructor(element[, options])
 * @description
 *  [en]Create a new GestureDetector instance.[/en]
 *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
 * @param {Element} element
 *   [en]Name of the event.[/en]
 *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
 * @param {Object} [options]
 *   [en]Options object.[/en]
 *   [ja]オプションを指定します。[/ja]
 * @return {ons.GestureDetector.Instance}
 */
var GestureDetector = function GestureDetector(element, options) {
  return new GestureDetector.Instance(element, options || {});
};

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  GestureDetector.defaults.drag = false;
 *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
 *  delete GestureDetector.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
GestureDetector.defaults = {
  behavior: {
    // userSelect: 'none', // Also disables selection in `input` children
    touchAction: 'pan-y',
    touchCallout: 'none',
    contentZooming: 'none',
    userDrag: 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }
};

/**
 * GestureDetector document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
GestureDetector.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

/**
 * interval in which GestureDetector recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
GestureDetector.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = GestureDetector.EVENT_START = 'start';
var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
var EVENT_END = GestureDetector.EVENT_END = 'end';
var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
GestureDetector.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
GestureDetector.plugins = GestureDetector.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
GestureDetector.gestures = GestureDetector.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup() {
  if (GestureDetector.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Event$1.determineEventTypes();

  // Register all gestures inside GestureDetector.gestures
  Utils.each(GestureDetector.gestures, function (gesture) {
    Detection.register(gesture);
  });

  // Add touch events on the document
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

  // GestureDetector is ready...!
  GestureDetector.READY = true;
}

/**
 * @module GestureDetector
 *
 * @class Utils
 * @static
 */
Utils = GestureDetector.utils = {
  /**
   * extend method, could also be used for cloning when `dest` is an empty object.
   * changes the dest object
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]  do a merge
   * @return {Object} dest
   */
  extend: function extend(dest, src, merge) {
    for (var key in src) {
      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
        dest[key] = src[key];
      }
    }
    return dest;
  },

  /**
   * simple addEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  on: function on(element, type, handler) {
    element.addEventListener(type, handler, false);
  },

  /**
   * simple removeEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  off: function off(element, type, handler) {
    element.removeEventListener(type, handler, false);
  },

  /**
   * forEach over arrays and objects
   * @param {Object|Array} obj
   * @param {Function} iterator
   * @param {any} iterator.item
   * @param {Number} iterator.index
   * @param {Object|Array} iterator.obj the source object
   * @param {Object} context value to use as `this` in the iterator
   */
  each: function each(obj, iterator, context) {
    var i, len;

    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
      // arrays
    } else if (obj.length !== undefined) {
      for (i = 0, len = obj.length; i < len; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
      // objects
    } else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a string contains the string using indexOf
   * @param {String} src
   * @param {String} find
   * @return {Boolean} found
   */
  inStr: function inStr(src, find) {
    return src.indexOf(find) > -1;
  },

  /**
   * find if a array contains the object using indexOf or a simple polyfill
   * @param {String} src
   * @param {String} find
   * @return {Boolean|Number} false when not found, or the index
   */
  inArray: function inArray(src, find, deep) {
    if (deep) {
      for (var i = 0, len = src.length; i < len; i++) {
        // Array.findIndex
        if (Object.keys(find).every(function (key) {
          return src[i][key] === find[key];
        })) {
          return i;
        }
      }
      return -1;
    }

    if (src.indexOf) {
      return src.indexOf(find);
    } else {
      for (var i = 0, len = src.length; i < len; i++) {
        if (src[i] === find) {
          return i;
        }
      }
      return -1;
    }
  },

  /**
   * convert an array-like object (`arguments`, `touchlist`) to an array
   * @param {Object} obj
   * @return {Array}
   */
  toArray: function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  },

  /**
   * find if a node is in the given parent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  hasParent: function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },

  /**
   * get the center of all the touches
   * @param {Array} touches
   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
   */
  getCenter: function getCenter(touches) {
    var pageX = [],
        pageY = [],
        clientX = [],
        clientY = [],
        min = Math.min,
        max = Math.max;

    // no need to loop when only one touch
    if (touches.length === 1) {
      return {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY,
        clientX: touches[0].clientX,
        clientY: touches[0].clientY
      };
    }

    Utils.each(touches, function (touch) {
      pageX.push(touch.pageX);
      pageY.push(touch.pageY);
      clientX.push(touch.clientX);
      clientY.push(touch.clientY);
    });

    return {
      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
    };
  },

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   * @return {Object} velocity `x` and `y`
   */
  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
    return {
      x: Math.abs(deltaX / deltaTime) || 0,
      y: Math.abs(deltaY / deltaTime) || 0
    };
  },

  /**
   * calculate the angle between two coordinates
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {Number} angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.atan2(y, x) * 180 / Math.PI;
  },

  /**
   * do a small comparison to get the direction between two touches.
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.clientX - touch2.clientX),
        y = Math.abs(touch1.clientY - touch2.clientY);

    if (x >= y) {
      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },

  /**
   * calculate the distance between two touches
   * @param {Touch}touch1
   * @param {Touch} touch2
   * @return {Number} distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.sqrt(x * x + y * y);
  },

  /**
   * calculate the scale factor between two touchLists
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if (start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },

  /**
   * calculate the rotation degrees between two touchLists
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if (start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },

  /**
   * find out if the direction is vertical   *
   * @param {String} direction matches `DIRECTION_UP|DOWN`
   * @return {Boolean} is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },

  /**
   * set css properties with their prefixes
   * @param {HTMLElement} element
   * @param {String} prop
   * @param {String} value
   * @param {Boolean} [toggle=true]
   * @return {Boolean}
   */
  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
    prop = Utils.toCamelCase(prop);

    for (var i = 0; i < prefixes.length; i++) {
      var p = prop;
      // prefixes
      if (prefixes[i]) {
        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
      }

      // test the style
      if (p in element.style) {
        element.style[p] = (toggle === null || toggle) && value || '';
        break;
      }
    }
  },

  /**
   * toggle browser default behavior by setting css properties.
   * `userSelect='none'` also sets `element.onselectstart` to false
   * `userDrag='none'` also sets `element.ondragstart` to false
   *
   * @param {HtmlElement} element
   * @param {Object} props
   * @param {Boolean} [toggle=true]
   */
  toggleBehavior: function toggleBehavior(element, props, toggle) {
    if (!props || !element || !element.style) {
      return;
    }

    // set the css properties
    Utils.each(props, function (value, prop) {
      Utils.setPrefixedCss(element, prop, value, toggle);
    });

    var falseFn = toggle && function () {
      return false;
    };

    // also the disable onselectstart
    if (props.userSelect == 'none') {
      element.onselectstart = falseFn;
    }
    // and disable ondragstart
    if (props.userDrag == 'none') {
      element.ondragstart = falseFn;
    }
  },

  /**
   * convert a string with underscores to camelCase
   * so prevent_default becomes preventDefault
   * @param {String} str
   * @return {String} camelCaseStr
   */
  toCamelCase: function toCamelCase(str) {
    return str.replace(/[_-]([a-z])/g, function (s) {
      return s[1].toUpperCase();
    });
  }
};

/**
 * @module GestureDetector
 */
/**
 * @class Event
 * @static
 */
Event$1 = GestureDetector.event = {
  /**
   * when touch events have been fired, this is true
   * this is used to stop mouse events
   * @property prevent_mouseevents
   * @private
   * @type {Boolean}
   */
  preventMouseEvents: false,

  /**
   * if EVENT_START has been fired
   * @property started
   * @private
   * @type {Boolean}
   */
  started: false,

  /**
   * when the mouse is hold down, this is true
   * @property should_detect
   * @private
   * @type {Boolean}
   */
  shouldDetect: false,

  /**
   * simple event binder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  on: function on(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.on(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * simple event unbinder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  off: function off(element, type, handler, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.off(element, type, handler);
      hook && hook(type);
    });
  },

  /**
   * the core touch event handler.
   * this finds out if we should to detect gestures
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Function} handler
   * @return onTouchHandler {Function} the core event handler
   */
  onTouch: function onTouch(element, eventType, handler) {
    var self = this;

    var onTouchHandler = function onTouchHandler(ev) {
      var srcType = ev.type.toLowerCase(),
          isPointer = GestureDetector.HAS_POINTEREVENTS,
          isMouse = Utils.inStr(srcType, 'mouse'),
          triggerType;

      // if we are in a mouseevent, but there has been a touchevent triggered in this session
      // we want to do nothing. simply break out of the event.
      if (isMouse && self.preventMouseEvents) {
        return;

        // mousebutton must be down
      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
        self.preventMouseEvents = false;
        self.shouldDetect = true;
      } else if (isPointer && eventType == EVENT_START) {
        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
        // just a valid start event, but no mouse
      } else if (!isMouse && eventType == EVENT_START) {
        self.preventMouseEvents = true;
        self.shouldDetect = true;
      }

      // update the pointer event before entering the detection
      if (isPointer && eventType != EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }

      // we are in a touch/down state, so allowed detection of gestures
      if (self.shouldDetect) {
        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
      }

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      if (triggerType == EVENT_END) {
        self.preventMouseEvents = false;
        self.shouldDetect = false;
        PointerEvent.reset();
        // update the pointerevent object after the detection
      }

      if (isPointer && eventType == EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
    };

    this.on(element, EVENT_TYPES[eventType], onTouchHandler);
    return onTouchHandler;
  },

  /**
   * the core detection method
   * this finds out what GestureDetector-touch-events to trigger
   * @param {Object} ev
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {HTMLElement} element
   * @param {Function} handler
   * @return {String} triggerType matches `EVENT_START|MOVE|END`
   */
  doDetect: function doDetect(ev, eventType, element, handler) {
    var touchList = this.getTouchList(ev, eventType);
    var touchListLength = touchList.length;
    var triggerType = eventType;
    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
    var changedLength = touchListLength;

    // at each touchstart-like event we want also want to trigger a TOUCH event...
    if (eventType == EVENT_START) {
      triggerChange = EVENT_TOUCH;
      // ...the same for a touchend-like event
    } else if (eventType == EVENT_END) {
      triggerChange = EVENT_RELEASE;

      // keep track of how many touches have been removed
      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
    }

    // after there are still touches on the screen,
    // we just want to trigger a MOVE event. so change the START or END to a MOVE
    // but only after detection has been started, the first time we actually want a START
    if (changedLength > 0 && this.started) {
      triggerType = EVENT_MOVE;
    }

    // detection has been started, we keep track of this, see above
    this.started = true;

    // generate some event data, some basic information
    var evData = this.collectEventData(element, triggerType, touchList, ev);

    // trigger the triggerType event before the change (TOUCH, RELEASE) events
    // but the END event should be at last
    if (eventType != EVENT_END) {
      handler.call(Detection, evData);
    }

    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
    if (triggerChange) {
      evData.changedLength = changedLength;
      evData.eventType = triggerChange;

      handler.call(Detection, evData);

      evData.eventType = triggerType;
      delete evData.changedLength;
    }

    // trigger the END event
    if (triggerType == EVENT_END) {
      handler.call(Detection, evData);

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      this.started = false;
    }

    return triggerType;
  },

  /**
   * we have different events for each device/browser
   * determine what we need and set them in the EVENT_TYPES constant
   * the `onTouch` method is bind to these properties.
   * @return {Object} events
   */
  determineEventTypes: function determineEventTypes() {
    var types;
    if (GestureDetector.HAS_POINTEREVENTS) {
      if (window.PointerEvent) {
        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
      } else {
        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
      }
    } else if (GestureDetector.NO_MOUSEEVENTS) {
      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
    } else {
      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
    }

    EVENT_TYPES[EVENT_START] = types[0];
    EVENT_TYPES[EVENT_MOVE] = types[1];
    EVENT_TYPES[EVENT_END] = types[2];
    return EVENT_TYPES;
  },

  /**
   * create touchList depending on the event
   * @param {Object} ev
   * @param {String} eventType
   * @return {Array} touches
   */
  getTouchList: function getTouchList(ev, eventType) {
    // get the fake pointerEvent touchlist
    if (GestureDetector.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }

    // get the touchlist
    if (ev.touches) {
      if (eventType == EVENT_MOVE) {
        return ev.touches;
      }

      var identifiers = [];
      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
      var touchList = [];

      Utils.each(concat, function (touch) {
        if (Utils.inArray(identifiers, touch.identifier) === -1) {
          touchList.push(touch);
        }
        identifiers.push(touch.identifier);
      });

      return touchList;
    }

    // make fake touchList from mouse position
    ev.identifier = 1;
    return [ev];
  },

  /**
   * collect basic event data
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Array} touches
   * @param {Object} ev
   * @return {Object} ev
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = POINTER_TOUCH;
    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
      pointerType = POINTER_PEN;
    }

    return {
      center: Utils.getCenter(touches),
      timeStamp: Date.now(),
      target: ev.target,
      touches: touches,
      eventType: eventType,
      pointerType: pointerType,
      srcEvent: ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function preventDefault() {
        var srcEvent = this.srcEvent;
        srcEvent.preventManipulation && srcEvent.preventManipulation();
        srcEvent.preventDefault && srcEvent.preventDefault();
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function stopPropagation() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function stopDetect() {
        return Detection.stopDetect();
      }
    };
  }
};

/**
 * @module GestureDetector
 *
 * @class PointerEvent
 * @static
 */
PointerEvent = GestureDetector.PointerEvent = {
  /**
   * holds all pointers, by `identifier`
   * @property pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get the pointers as an array
   * @return {Array} touchlist
   */
  getTouchList: function getTouchList() {
    var touchlist = [];
    // we can use forEach since pointerEvents only is in IE10
    Utils.each(this.pointers, function (pointer) {
      touchlist.push(pointer);
    });
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Object} pointerEvent
   */
  updatePointer: function updatePointer(eventType, pointerEvent) {
    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
      delete this.pointers[pointerEvent.pointerId];
    } else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }
  },

  /**
   * check if ev matches pointertype
   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
   * @param {PointerEvent} ev
   */
  matchType: function matchType(pointerType, ev) {
    if (!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
        types = {};

    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
    return types[pointerType];
  },

  /**
   * reset the stored pointers
   */
  reset: function resetList() {
    this.pointers = {};
  }
};

/**
 * @module GestureDetector
 *
 * @class Detection
 * @static
 */
Detection = GestureDetector.detection = {
  // contains all registered GestureDetector.gestures in the correct order
  gestures: [],

  // data of the current GestureDetector.gesture detection session
  current: null,

  // the previous GestureDetector.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped: false,

  /**
   * start GestureDetector.gesture detection
   * @param {GestureDetector.Instance} inst
   * @param {Object} eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a GestureDetector.gesture detection on an element
    if (this.current) {
      return;
    }

    this.stopped = false;

    // holds current session
    this.current = {
      inst: inst, // reference to GestureDetectorInstance we're working for
      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent: false, // last eventData
      lastCalcEvent: false, // last eventData for calculations.
      futureCalcEvent: false, // last eventData for calculations.
      lastCalcData: {}, // last lastCalcData
      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },

  /**
   * GestureDetector.gesture detection
   * @param {Object} eventData
   * @return {any}
   */
  detect: function detect(eventData) {
    if (!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // GestureDetector instance and instance options
    var inst = this.current.inst,
        instOptions = inst.options;

    // call GestureDetector.gesture handlers
    Utils.each(this.gestures, function triggerGesture(gesture) {
      // only when the instance options have enabled this gesture
      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
        gesture.handler.call(gesture, eventData, inst);
      }
    }, this);

    // store as previous event event
    if (this.current) {
      this.current.lastEvent = eventData;
    }

    if (eventData.eventType == EVENT_END) {
      this.stopDetect();
    }

    return eventData; // eslint-disable-line consistent-return
  },

  /**
   * clear the GestureDetector.gesture vars
   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
   * to stop other GestureDetector.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Utils.extend({}, this.current);

    // reset the current
    this.current = null;
    this.stopped = true;
  },

  /**
   * calculate velocity, angle and direction
   * @param {Object} ev
   * @param {Object} center
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   */
  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
    var cur = this.current,
        recalc = false,
        calcEv = cur.lastCalcEvent,
        calcData = cur.lastCalcData;

    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
      center = calcEv.center;
      deltaTime = ev.timeStamp - calcEv.timeStamp;
      deltaX = ev.center.clientX - calcEv.center.clientX;
      deltaY = ev.center.clientY - calcEv.center.clientY;
      recalc = true;
    }

    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      cur.futureCalcEvent = ev;
    }

    if (!cur.lastCalcEvent || recalc) {
      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
      calcData.angle = Utils.getAngle(center, ev.center);
      calcData.direction = Utils.getDirection(center, ev.center);

      cur.lastCalcEvent = cur.futureCalcEvent || ev;
      cur.futureCalcEvent = ev;
    }

    ev.velocityX = calcData.velocity.x;
    ev.velocityY = calcData.velocity.y;
    ev.interimAngle = calcData.angle;
    ev.interimDirection = calcData.direction;
  },

  /**
   * extend eventData for GestureDetector.gestures
   * @param {Object} ev
   * @return {Object} ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current,
        startEv = cur.startEvent,
        lastEv = cur.lastEvent || startEv;

    // update the start touchlist to calculate the scale/rotation
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      startEv.touches = [];
      Utils.each(ev.touches, function (touch) {
        startEv.touches.push({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
      });
    }

    var deltaTime = ev.timeStamp - startEv.timeStamp,
        deltaX = ev.center.clientX - startEv.center.clientX,
        deltaY = ev.center.clientY - startEv.center.clientY;

    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

    Utils.extend(ev, {
      startEvent: startEv,

      deltaTime: deltaTime,
      deltaX: deltaX,
      deltaY: deltaY,

      distance: Utils.getDistance(startEv.center, ev.center),
      angle: Utils.getAngle(startEv.center, ev.center),
      direction: Utils.getDirection(startEv.center, ev.center),
      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches)
    });

    return ev;
  },

  /**
   * register new gesture
   * @param {Object} gesture object, see `gestures/` for documentation
   * @return {Array} gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if (options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend GestureDetector default options with the GestureDetector.gesture options
    Utils.extend(GestureDetector.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add GestureDetector.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function (a, b) {
      if (a.index < b.index) {
        return -1;
      }
      if (a.index > b.index) {
        return 1;
      }
      return 0;
    });

    return this.gestures;
  }
};

/**
 * @module GestureDetector
 */

/**
 * create new GestureDetector instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
 * @return {GestureDetector.Instance}
 */
GestureDetector.Instance = function (element, options) {
  var self = this;

  // setup GestureDetectorJS window events and register all gestures
  // this also sets up the default options
  setup();

  /**
   * @property element
   * @type {HTMLElement}
   */
  this.element = element;

  /**
   * @property enabled
   * @type {Boolean}
   * @protected
   */
  this.enabled = true;

  /**
   * options, merged with the defaults
   * options with an _ are converted to camelCase
   * @property options
   * @type {Object}
   */
  Utils.each(options, function (value, name) {
    delete options[name];
    options[Utils.toCamelCase(name)] = value;
  });

  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

  // add some css to the element to prevent the browser from doing its native behavior
  if (this.options.behavior) {
    Utils.toggleBehavior(this.element, this.options.behavior, true);
  }

  /**
   * event start handler on the element to start the detection
   * @property eventStartHandler
   * @type {Object}
   */
  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
    if (self.enabled && ev.eventType == EVENT_START) {
      Detection.startDetect(self, ev);
    } else if (ev.eventType == EVENT_TOUCH) {
      Detection.detect(ev);
    }
  });

  /**
   * keep a list of user event handlers which needs to be removed when calling 'dispose'
   * @property eventHandlers
   * @type {Array}
   */
  this.eventHandlers = [];
};

GestureDetector.Instance.prototype = {
  /**
   * @method on
   * @signature on(gestures, handler)
   * @description
   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  on: function onEvent(gestures, handler) {
    var self = this;
    Event$1.on(self.element, gestures, handler, function (type) {
      self.eventHandlers.push({ gesture: type, handler: handler });
    });
    return self;
  },

  /**
   * @method off
   * @signature off(gestures, handler)
   * @description
   *  [en]Remove an event listener.[/en]
   *  [ja]イベントリスナーを削除します。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  off: function offEvent(gestures, handler) {
    var self = this;

    Event$1.off(self.element, gestures, handler, function (type) {
      var index = Utils.inArray(self.eventHandlers, { gesture: type, handler: handler }, true);
      if (index >= 0) {
        self.eventHandlers.splice(index, 1);
      }
    });
    return self;
  },

  /**
   * trigger gesture event
   * @method trigger
   * @signature trigger(gesture, eventData)
   * @param {String} gesture
   * @param {Object} [eventData]
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if (!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = GestureDetector.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if (Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },

  /**
   * @method enable
   * @signature enable(state)
   * @description
   *  [en]Enable or disable gesture detection.[/en]
   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
   * @param {Boolean} state
   *   [en]Specify if it should be enabled or not.[/en]
   *   [ja]有効にするかどうかを指定します。[/ja]
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },

  /**
   * @method dispose
   * @signature dispose()
   * @description
   *  [en]Remove and destroy all event handlers for this instance.[/en]
   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
   */
  dispose: function dispose() {
    var i, eh;

    // undo all changes made by stop_browser_behavior
    Utils.toggleBehavior(this.element, this.options.behavior, false);

    // unbind all custom event handlers
    for (i = -1; eh = this.eventHandlers[++i];) {
      // eslint-disable-line no-cond-assign
      Utils.off(this.element, eh.gesture, eh.handler);
    }

    this.eventHandlers = [];

    // unbind the start event listener
    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

    return null;
  }
};

/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  GestureDetectortime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function dragGesture(ev, inst) {
    var cur = Detection.current;

    // max touches
    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
      return;
    }

    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
          return;
        }

        var startCenter = cur.startEvent.center;

        // we are dragging!
        if (cur.name != name) {
          cur.name = name;
          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
            startCenter.pageX += ev.deltaX * factor;
            startCenter.pageY += ev.deltaY * factor;
            startCenter.clientX += ev.deltaX * factor;
            startCenter.clientY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
          ev.dragLockToAxis = true;
        }

        // keep direction on the axis that the drag gesture started on
        var lastDirection = cur.lastEvent.direction;
        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
          if (Utils.isVertical(lastDirection)) {
            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          } else {
            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        // trigger events
        inst.trigger(name, ev);
        inst.trigger(name + ev.direction, ev);

        var isVertical = Utils.isVertical(ev.direction);

        // block the browser events
        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
          ev.preventDefault();
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;

      case EVENT_END:
        triggered = false;
        break;
    }
  }

  GestureDetector.gestures.Drag = {
    name: name,
    index: 50,
    handler: dragGesture,
    defaults: {
      /**
       * minimal movement that have to be made before the drag event gets triggered
       * @property dragMinDistance
       * @type {Number}
       * @default 10
       */
      dragMinDistance: 10,

      /**
       * Set dragDistanceCorrection to true to make the starting point of the drag
       * be calculated from where the drag was triggered, not from where the touch started.
       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
       * through dragging difficult, and be visually unappealing.
       * @property dragDistanceCorrection
       * @type {Boolean}
       * @default true
       */
      dragDistanceCorrection: true,

      /**
       * set 0 for unlimited, but this can conflict with transform
       * @property dragMaxTouches
       * @type {Number}
       * @default 1
       */
      dragMaxTouches: 1,

      /**
       * prevent default browser behavior when dragging occurs
       * be careful with it, it makes the element a blocking element
       * when you are using the drag gesture, it is a good practice to set this true
       * @property dragBlockHorizontal
       * @type {Boolean}
       * @default false
       */
      dragBlockHorizontal: false,

      /**
       * same as `dragBlockHorizontal`, but for vertical movement
       * @property dragBlockVertical
       * @type {Boolean}
       * @default false
       */
      dragBlockVertical: false,

      /**
       * dragLockToAxis keeps the drag gesture on the axis that it started on,
       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
       * @property dragLockToAxis
       * @type {Boolean}
       * @default false
       */
      dragLockToAxis: false,

      /**
       * drag lock only kicks in when distance > dragLockMinDistance
       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
       * @property dragLockMinDistance
       * @type {Number}
       * @default 25
       */
      dragLockMinDistance: 25
    }
  };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
GestureDetector.gestures.Gesture = {
  name: 'gesture',
  index: 1337,
  handler: function releaseGesture(ev, inst) {
    inst.trigger(this.name, ev);
  }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var timer;

  function holdGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current;

    switch (ev.eventType) {
      case EVENT_START:
        clearTimeout(timer);

        // set the gesture so we can check in the timeout if it still is
        current.name = name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        timer = setTimeout(function () {
          if (current && current.name == name) {
            inst.trigger(name, ev);
          }
        }, options.holdTimeout);
        break;

      case EVENT_MOVE:
        if (ev.distance > options.holdThreshold) {
          clearTimeout(timer);
        }
        break;

      case EVENT_RELEASE:
        clearTimeout(timer);
        break;
    }
  }

  GestureDetector.gestures.Hold = {
    name: name,
    index: 10,
    defaults: {
      /**
       * @property holdTimeout
       * @type {Number}
       * @default 500
       */
      holdTimeout: 500,

      /**
       * movement allowed while holding
       * @property holdThreshold
       * @type {Number}
       * @default 2
       */
      holdThreshold: 2
    },
    handler: holdGesture
  };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
GestureDetector.gestures.Release = {
  name: 'release',
  index: Infinity,
  handler: function releaseGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
GestureDetector.gestures.Swipe = {
  name: 'swipe',
  index: 40,
  defaults: {
    /**
     * @property swipeMinTouches
     * @type {Number}
     * @default 1
     */
    swipeMinTouches: 1,

    /**
     * @property swipeMaxTouches
     * @type {Number}
     * @default 1
     */
    swipeMaxTouches: 1,

    /**
     * horizontal swipe velocity
     * @property swipeVelocityX
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityX: 0.6,

    /**
     * vertical swipe velocity
     * @property swipeVelocityY
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityY: 0.6
  },

  handler: function swipeGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      var touches = ev.touches.length,
          options = inst.options;

      // max touches
      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var hasMoved = false;

  function tapGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current,
        prev = Detection.previous,
        sincePrev,
        didDoubleTap;

    switch (ev.eventType) {
      case EVENT_START:
        hasMoved = false;
        break;

      case EVENT_MOVE:
        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
        break;

      case EVENT_END:
        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
          // previous gesture, for the double tap since these are two different gesture detections
          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
          didDoubleTap = false;

          // check if double tap
          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
            inst.trigger('doubletap', ev);
            didDoubleTap = true;
          }

          // do a single tap
          if (!didDoubleTap || options.tapAlways) {
            current.name = name;
            inst.trigger(current.name, ev);
          }
        }
        break;
    }
  }

  GestureDetector.gestures.Tap = {
    name: name,
    index: 100,
    handler: tapGesture,
    defaults: {
      /**
       * max time of a tap, this is for the slow tappers
       * @property tapMaxTime
       * @type {Number}
       * @default 250
       */
      tapMaxTime: 250,

      /**
       * max distance of movement of a tap, this is for the slow tappers
       * @property tapMaxDistance
       * @type {Number}
       * @default 10
       */
      tapMaxDistance: 10,

      /**
       * always trigger the `tap` event, even while double-tapping
       * @property tapAlways
       * @type {Boolean}
       * @default true
       */
      tapAlways: true,

      /**
       * max distance between two taps
       * @property doubleTapDistance
       * @type {Number}
       * @default 20
       */
      doubleTapDistance: 20,

      /**
       * max time between two taps
       * @property doubleTapInterval
       * @type {Number}
       * @default 300
       */
      doubleTapInterval: 300
    }
  };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
GestureDetector.gestures.Touch = {
  name: 'touch',
  index: -Infinity,
  defaults: {
    /**
     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
     * but it improves gestures like transforming and dragging.
     * be careful with using this, it can be very annoying for users to be stuck on the page
     * @property preventDefault
     * @type {Boolean}
     * @default false
     */
    preventDefault: false,

    /**
     * disable mouse events, so only touch (or pen!) input triggers events
     * @property preventMouse
     * @type {Boolean}
     * @default false
     */
    preventMouse: false
  },
  handler: function touchGesture(ev, inst) {
    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if (inst.options.preventDefault) {
      ev.preventDefault();
    }

    if (ev.eventType == EVENT_TOUCH) {
      inst.trigger('touch', ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function transformGesture(ev, inst) {
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // at least multitouch
        if (ev.touches.length < 2) {
          return;
        }

        var scaleThreshold = Math.abs(1 - ev.scale);
        var rotationThreshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
          return;
        }

        // we are transforming!
        Detection.current.name = name;

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        inst.trigger(name, ev); // basic transform event

        // trigger rotate event
        if (rotationThreshold > inst.options.transformMinRotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if (scaleThreshold > inst.options.transformMinScale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength < 2) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;
    }
  }

  GestureDetector.gestures.Transform = {
    name: name,
    index: 45,
    defaults: {
      /**
       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
       * @property transformMinScale
       * @type {Number}
       * @default 0.01
       */
      transformMinScale: 0.01,

      /**
       * rotation in degrees
       * @property transformMinRotation
       * @type {Number}
       * @default 1
       */
      transformMinRotation: 1
    },

    handler: transformGesture
  };
})('transform');

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var readyMap = new WeakMap();
var queueMap = new WeakMap();

function isContentReady(element) {
  if (element.childNodes.length > 0) {
    setContentReady(element);
  }
  return readyMap.has(element);
}

function setContentReady(element) {
  readyMap.set(element, true);
}

function addCallback(element, fn) {
  if (!queueMap.has(element)) {
    queueMap.set(element, []);
  }
  queueMap.get(element).push(fn);
}

function consumeQueue(element) {
  var callbacks = queueMap.get(element, []) || [];
  queueMap.delete(element);
  callbacks.forEach(function (callback) {
    return callback();
  });
}

function contentReady(element) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  addCallback(element, fn);

  if (isContentReady(element)) {
    consumeQueue(element);
    return;
  }

  var observer = new MutationObserver(function (changes) {
    setContentReady(element);
    consumeQueue(element);
  });
  observer.observe(element, { childList: true, characterData: true });

  // failback for elements has empty content.
  setImmediate(function () {
    setContentReady(element);
    consumeQueue(element);
  });
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ToastQueue = function () {
  function ToastQueue() {
    classCallCheck(this, ToastQueue);

    this.queue = [];
  }

  createClass(ToastQueue, [{
    key: "add",
    value: function add(fn, promise) {
      var _this = this;

      this.queue.push(fn);

      if (this.queue.length === 1) {
        setImmediate(this.queue[0]);
      }

      promise.then(function () {
        _this.queue.shift();

        if (_this.queue.length > 0) {
          setTimeout(_this.queue[0], 1000 / 30); // Apply some visual delay
        }
      });
    }
  }]);
  return ToastQueue;
}();

var ToastQueue$1 = new ToastQueue();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _setAttributes = function _setAttributes(element, options) {
  ['id', 'class', 'animation'].forEach(function (a) {
    return options.hasOwnProperty(a) && element.setAttribute(a, options[a]);
  });

  if (options.modifier) {
    util.addModifier(element, options.modifier);
  }
};

/**
 * @object ons.notification
 * @category dialog
 * @tutorial vanilla/Reference/dialog
 * @description
 *   [en]
 *     Utility methods to create different kinds of notifications. There are three methods available:
 *
 *     * `ons.notification.alert()`
 *     * `ons.notification.confirm()`
 *     * `ons.notification.prompt()`
 *     * `ons.notification.toast()`
 *
 *     It will automatically display a Material Design dialog on Android devices.
 *   [/en]
 *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 * @example
 * ons.notification.alert('Hello, world!');
 *
 * ons.notification.confirm('Are you ready?')
 *   .then(
 *     function(answer) {
 *       if (answer === 1) {
 *         ons.notification.alert('Let\'s go!');
 *       }
 *     }
 *   );
 *
 * ons.notification.prompt('How old are ?')
 *   .then(
 *     function(age) {
 *       ons.notification.alert('You are ' + age + ' years old.');
 *     }
 *   );
 */
var notification = {};

notification._createAlertDialog = function (options) {
  // Prompt input string
  var inputString = '';
  if (options.isPrompt) {
    inputString = '\n      <input\n        class="text-input text-input--underbar"\n        type="' + (options.inputType || 'text') + '"\n        placeholder="' + (options.placeholder || '') + '"\n        value="' + (options.defaultValue || '') + '"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ';
  }

  // Buttons string
  var buttons = '';
  options.buttonLabels.forEach(function (label, index) {
    buttons += '\n      <ons-alert-dialog-button\n        class="\n          ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--rowfooter' : '') + '\n        " \n        style="position: relative;">\n        ' + label + '\n      </ons-alert-dialog-button>\n    ';
  });

  // Dialog Element
  var el = {};
  var _destroyDialog = function _destroyDialog() {
    if (el.dialog.onDialogCancel) {
      el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);
    }

    Object.keys(el).forEach(function (key) {
      return delete el[key];
    });
    el = null;

    if (options.destroy instanceof Function) {
      options.destroy();
    }
  };

  el.dialog = document.createElement('ons-alert-dialog');
  el.dialog.innerHTML = '\n    <div class="alert-dialog-mask"></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          ' + (options.title || '') + '\n        </div>\n        <div class="alert-dialog-content">\n          ' + (options.message || options.messageHTML) + '\n          ' + inputString + '\n        </div>\n        <div class="\n          alert-dialog-footer\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--rowfooter' : '') + '\n        ">\n          ' + buttons + '\n        </div>\n      </div>\n    </div>\n  ';
  contentReady(el.dialog);

  // Set attributes
  _setAttributes(el.dialog, options);

  var deferred = util.defer();

  // Prompt events
  if (options.isPrompt && options.submitOnEnter) {
    el.input = el.dialog.querySelector('.text-input');
    el.input.onkeypress = function (event) {
      if (event.keyCode === 13) {
        el.dialog.hide().then(function () {
          if (el) {
            var resolveValue = el.input.value;
            _destroyDialog();
            options.callback(resolveValue);
            deferred.resolve(resolveValue);
          }
        });
      }
    };
  }

  // Button events
  el.footer = el.dialog.querySelector('.alert-dialog-footer');
  util.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {
    buttonElement.onclick = function () {
      el.dialog.hide().then(function () {
        if (el) {
          var resolveValue = index;
          if (options.isPrompt) {
            resolveValue = index === options.primaryButtonIndex ? el.input.value : null;
          }
          el.dialog.remove();
          _destroyDialog();
          options.callback(resolveValue);
          deferred.resolve(resolveValue);
        }
      });
    };

    el.footer.appendChild(buttonElement);
  });

  // Cancel events
  if (options.cancelable) {
    el.dialog.cancelable = true;
    el.dialog.onDialogCancel = function () {
      setImmediate(function () {
        el.dialog.remove();
        _destroyDialog();
      });
      var resolveValue = options.isPrompt ? null : -1;
      options.callback(resolveValue);
      deferred.resolve(resolveValue);
    };
    el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);
  }

  // Show dialog
  document.body.appendChild(el.dialog);
  options.compile(el.dialog);
  setImmediate(function () {
    el.dialog.show().then(function () {
      if (el.input && options.isPrompt && options.autofocus) {
        el.input.focus();
      }
    });
  });

  return deferred.promise;
};

var _normalizeArguments = function _normalizeArguments(message) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaults$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  options = _extends({}, options);
  typeof message === 'string' ? options.message = message : options = message;
  if (!options.message && !options.messageHTML) {
    throw new Error('Notifications must contain a message.');
  }

  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {
    options.buttonLabels = options.buttonLabels || options.buttonLabel;
    if (!Array.isArray(options.buttonLabels)) {
      options.buttonLabels = [options.buttonLabels || ''];
    }
  }

  return util.extend({
    compile: function compile(param) {
      return param;
    },
    callback: function callback(param) {
      return param;
    },
    animation: 'default',
    cancelable: false,
    primaryButtonIndex: (options.buttonLabels || defaults$$1.buttonLabels || []).length - 1
  }, defaults$$1, options);
};

/**
 * @method alert
 * @signature alert(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Notification message.[/en]
 *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
 * @param {String} [options.messageHTML]
 *   [en]Notification message in HTML.[/en]
 *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
 *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]
 *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade"のいずれかを指定できます。[/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
 *   [ja]ons-alert-dialog要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-alert-dialog>` element's class.[/en]
 *   [ja]ons-alert-dialog要素のclass。[/ja]
 * @param {String} [options.title]
 *   [en]Dialog title. Default is `"Alert"`.[/en]
 *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the dialog.[/en]
 *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after dialog has been closed.[/en]
 *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display an alert dialog to show the user a message.
 *
 *     The content of the message can be either simple text or HTML.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.alert(message, options);
 *     ons.notification.alert(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
 *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.alert = function (message, options) {
  options = _normalizeArguments(message, options, {
    buttonLabels: ['OK'],
    title: 'Alert'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method confirm
 * @signature confirm(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 * @param {Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
 *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
 * @description
 *   [en]
 *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.
 *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.confirm(message, options);
 *     ons.notification.confirm(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザに確認を促すダイアログを表示します。
 *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.confirm = function (message, options) {
  options = _normalizeArguments(message, options, {
    buttonLabels: ['Cancel', 'OK'],
    title: 'Confirm'
  });

  return notification._createAlertDialog(options);
};

/**
 * @method prompt
 * @signature prompt(message [, options] | options)
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve to the input value when the dialog is closed or `null` when canceled.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {String} [options.placeholder]
 *   [en]Placeholder for the text input.[/en]
 *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
 * @param {String} [options.defaultValue]
 *   [en]Default value for the text input.[/en]
 *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
 * @param {String} [options.inputType]
 *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.autofocus]
 *   [en]Autofocus the input element. Default is `true`. In Cordova, `KeyboardDisplayRequiresUserAction` in `config.xml` must be `false` to activate this feature.[/en]
 *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。Cordova環境では、この機能を有効にするためには `config.xml` で `KeyboardDisplayRequiresUserAction` を `false` に設定する必要があります。[/ja]
 * @param {Boolean} [options.submitOnEnter]
 *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
 *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
 * @description
 *   [en]
 *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.prompt(message, options);
 *     ons.notification.prompt(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーに入力を促すダイアログを表示します。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.prompt = function (message, options) {
  options = _normalizeArguments(message, options, {
    buttonLabels: ['OK'],
    title: 'Alert',
    isPrompt: true,
    autofocus: true,
    submitOnEnter: true
  });

  return notification._createAlertDialog(options);
};

/**
 * @method toast
 * @signature toast(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve when the toast is hidden.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Toast message. This argument is optional but if it's not defined then `options.message` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Notification message.[/en]
 *   [ja]トーストに表示する文字列を指定します。[/ja]
 * @param {String} [options.buttonLabel]
 *   [en]Label for the button.[/en]
 *   [ja]確認ボタンのラベルを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none`, `fade`, `ascend`, `lift` and `fall`. Default is `ascend` for Android and `lift` for iOS.[/en]
 *   [ja]トーストを表示する際のアニメーション名を指定します。"none", "fade", "ascend", "lift", "fall"のいずれかを指定できます。[/ja]
 * @param {Number} [options.timeout]
 *   [en]Number of miliseconds where the toast is visible before hiding automatically.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.force]
 *   [en]If `true`, the toast skips the notification queue and is shown immediately. Defaults to `false`.[/en]
 *   [ja][/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-toast>` element's ID.[/en]
 *   [ja]ons-toast要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-toast>` element's class.[/en]
 *   [ja]ons-toast要素のclass。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the element.[/en]
 *   [ja]トーストのmodifier属性の値を指定します。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after toast has been hidden.[/en]
 *   [ja]トーストが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display a simple notification toast with an optional button that can be used for simple actions.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.toast(message, options);
 *     ons.notification.toast(options);
 *     ```
 *   [/en]
 *   [ja][/ja]
 */
notification.toast = function (message, options) {
  options = _normalizeArguments(message, options, {
    timeout: 0,
    force: false
  });

  var toast = util.createElement('\n    <ons-toast>\n      ' + options.message + '\n      ' + (options.buttonLabels ? '<button>' + options.buttonLabels[0] + '</button>' : '') + '\n    </ons-toast>\n  ');

  _setAttributes(toast, options);

  var deferred = util.defer();
  var resolve = function resolve(value) {
    if (toast) {
      toast.hide().then(function () {
        if (toast) {
          toast.remove();
          toast = null;
          options.callback(value);
          deferred.resolve(value);
        }
      });
    }
  };

  if (options.buttonLabels) {
    util.findChild(toast._toast, 'button').onclick = function () {
      return resolve(0);
    };
  }

  document.body.appendChild(toast);
  options.compile(toast);

  var show = function show() {
    toast.parentElement && toast.show(options).then(function () {
      if (options.timeout) {
        setTimeout(function () {
          return resolve(-1);
        }, options.timeout);
      }
    });
  };

  options.force ? show() : ToastQueue$1.add(show, deferred.promise);

  return deferred.promise;
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// Validate parameters
var checkOptions = function checkOptions(options) {
  if (!Object.hasOwnProperty.call(options, 'buttons') || !(options.buttons instanceof Array)) {
    throw new Error('"options.buttons" must be an instance of Array.');
  }
  if (Object.hasOwnProperty.call(options, 'callback') && !(options.callback instanceof Function)) {
    throw new Error('"options.callback" must be an instance of Function.');
  }
  if (Object.hasOwnProperty.call(options, 'compile') && !(options.compile instanceof Function)) {
    throw new Error('"options.compile" must be an instance of Function.');
  }
  if (Object.hasOwnProperty.call(options, 'destroy') && !(options.destroy instanceof Function)) {
    throw new Error('"options.destroy" must be an instance of Function.');
  }
};

// Action Sheet
var actionSheet = (function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  checkOptions(options);

  // Main component
  var actionSheet = util.createElement('\n    <ons-action-sheet\n      ' + (options.title ? 'title="' + options.title + '"' : '') + '\n      ' + (options.cancelable ? 'cancelable' : '') + '\n      ' + (options.modifier ? 'modifier="' + options.modifier + '"' : '') + '\n      ' + (options.maskColor ? 'mask-color="' + options.maskColor + '"' : '') + '\n      ' + (options.id ? 'id="' + options.id + '"' : '') + '\n      ' + (options.class ? 'class="' + options.class + '"' : '') + '\n    >\n      <div class="action-sheet"></div>\n    </ons-action-sheet>\n  ');

  // Resolve action and clean up
  var deferred = util.defer();
  var resolver = function resolver(event) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

    if (actionSheet) {
      options.destroy && options.destroy(actionSheet);

      actionSheet.removeEventListener('dialog-cancel', resolver, false);
      actionSheet.remove();
      actionSheet = null;

      options.callback && options.callback(index);
      deferred.resolve(index);
    }
  };

  // Link cancel handler
  actionSheet.addEventListener('dialog-cancel', resolver, false);

  // Create buttons and link action handler
  var buttons = document.createDocumentFragment();
  options.buttons.forEach(function (item, index) {
    var buttonOptions = typeof item === 'string' ? { label: item } : _extends({}, item);
    if (options.destructive === index) {
      buttonOptions.modifier = (buttonOptions.modifier || '') + ' destructive';
    }

    var button = util.createElement('\n      <ons-action-sheet-button\n        ' + (buttonOptions.icon ? 'icon="' + buttonOptions.icon + '"' : '') + '\n        ' + (buttonOptions.modifier ? 'modifier="' + buttonOptions.modifier + '"' : '') + '\n      >\n        ' + buttonOptions.label + '\n      </ons-action-sheet-button>\n    ');

    button.onclick = function (event) {
      return actionSheet.hide().then(function () {
        return resolver(event, index);
      });
    };
    buttons.appendChild(button);
  });

  // Finish component and attach
  util.findChild(actionSheet, '.action-sheet').appendChild(buttons);
  document.body.appendChild(actionSheet);
  options.compile && options.compile(el.dialog);

  // Show
  setImmediate(function () {
    return actionSheet.show({
      animation: options.animation,
      animationOptions: options.animationOptions
    });
  });

  return deferred.promise;
});

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 *
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent = function MicroEvent() {};
MicroEvent.prototype = {
  on: function on(event, fct) {
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once: function once(event, fct) {
    var self = this;
    var wrapper = function wrapper() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off: function off(event, fct) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }

    this._events[event] = this._events[event].filter(function (_fct) {
      if (fct) {
        return fct !== _fct;
      } else {
        return false;
      }
    });
  },
  emit: function emit(event /* , args... */) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }
    for (var i = 0; i < this._events[event].length; i++) {
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin = function (destObject) {
  var props = ['on', 'once', 'off', 'emit'];
  for (var i = 0; i < props.length; i++) {
    if (typeof destObject === 'function') {
      destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
    } else {
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
};

window.MicroEvent = MicroEvent;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var create = function create() {

  /**
   * @object ons.orientation
   * @category util
   * @description
   *   [en]Utility methods for orientation detection.[/en]
   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
   */
  var obj = {
    /**
     * @event change
     * @description
     *   [en]Fired when the device orientation changes.[/en]
     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Boolean} event.isPortrait
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
     */

    /**
     * @method on
     * @signature on(eventName, listener)
     * @description
     *   [en]Add an event listener.[/en]
     *   [ja]イベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method once
     * @signature once(eventName, listener)
     * @description
     *  [en]Add an event listener that's only triggered once.[/en]
     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method off
     * @signature off(eventName, [listener])
     * @description
     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]削除するイベントリスナーを指定します。[/ja]
     */

    // actual implementation to detect if whether current screen is portrait or not
    _isPortrait: false,

    /**
     * @method isPortrait
     * @signature isPortrait()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
     */
    isPortrait: function isPortrait() {
      return this._isPortrait();
    },

    /**
     * @method isLandscape
     * @signature isLandscape()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is landscape mode.[/en]
     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
     */
    isLandscape: function isLandscape() {
      return !this.isPortrait();
    },

    _init: function _init() {
      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

      if ('orientation' in window) {
        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
      } else {
        window.addEventListener('resize', this._onResize.bind(this), false);
      }

      this._isPortrait = function () {
        return window.innerHeight > window.innerWidth;
      };

      return this;
    },

    _onDOMContentLoaded: function _onDOMContentLoaded() {
      this._installIsPortraitImplementation();
      this.emit('change', { isPortrait: this.isPortrait() });
    },

    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
      var isPortrait = window.innerWidth < window.innerHeight;

      if (!('orientation' in window)) {
        this._isPortrait = function () {
          return window.innerHeight > window.innerWidth;
        };
      } else if (window.orientation % 180 === 0) {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
        };
      } else {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
        };
      }
    },

    _onOrientationChange: function _onOrientationChange() {
      var _this = this;

      var isPortrait = this._isPortrait();

      // Wait for the dimensions to change because
      // of Android inconsistency.
      var nIter = 0;
      var interval = setInterval(function () {
        nIter++;

        var w = window.innerWidth;
        var h = window.innerHeight;

        if (isPortrait && w <= h || !isPortrait && w >= h) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        } else if (nIter === 50) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        }
      }, 20);
    },

    // Run on not mobile browser.
    _onResize: function _onResize() {
      this.emit('change', { isPortrait: this.isPortrait() });
    }
  };

  MicroEvent.mixin(obj);

  return obj;
};

var orientation = create()._init();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.modifier
 * @category visual
 * @description
 *   [en]
 *     Utility methods to change modifier attributes of Onsen UI elements..
 *   [/en]
 *   [ja][/ja]
 * @example
 * ons.modifier.add(myOnsInputElement, 'underbar');
 * ons.modifier.toggle(myOnsToastElement, 'custom-modifier');
 *
 */
var modifier = {
  /**
   * @method add
   * @signature add(element, modifier [, modifier])
   * @description
   *   [en]Add the specified modifiers to the element if they are not already included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  add: function add(element) {
    for (var _len = arguments.length, modifiers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      modifiers[_key - 1] = arguments[_key];
    }

    return modifiers.forEach(function (modifier) {
      return util.addModifier(element, modifier);
    });
  },
  /**
   * @method remove
   * @signature remove(element, modifier [, modifier])
   * @description
   *   [en]Remove the specified modifiers from the element if they are included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  remove: function remove(element) {
    for (var _len2 = arguments.length, modifiers = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      modifiers[_key2 - 1] = arguments[_key2];
    }

    return modifiers.forEach(function (modifier) {
      return util.removeModifier(element, modifier);
    });
  },
  /**
   * @method contains
   * @signature contains(element, modifier)
   * @description
   *   [en]Check whether the specified modifier is included in the element.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @return {Boolean}
   *   [en]`true` when the specified modifier is found in the element's `modifier` attribute. `false` otherwise.[/en]
   *   [ja][/ja]
   */
  contains: util.hasModifier,
  /**
   * @method toggle
   * @signature toggle(element, modifier [, force])
   * @description
   *   [en]Toggle the specified modifier.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @param {String} force
   *   [en]If it evaluates to true, add specified modifier value, and if it evaluates to false, remove it.[/en]
   *   [ja][/ja]
   */
  toggle: util.toggleModifier
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var softwareKeyboard = new MicroEvent();
softwareKeyboard._visible = false;

var onShow = function onShow() {
  softwareKeyboard._visible = true;
  softwareKeyboard.emit('show');
};

var onHide = function onHide() {
  softwareKeyboard._visible = false;
  softwareKeyboard.emit('hide');
};

var bindEvents = function bindEvents() {
  if (typeof Keyboard !== 'undefined') {
    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
    Keyboard.onshow = onShow;
    Keyboard.onhide = onHide;
    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

    return true;
  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
    window.addEventListener('native.keyboardshow', onShow);
    window.addEventListener('native.keyboardhide', onHide);
    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

    return true;
  }

  return false;
};

var noPluginError = function noPluginError() {
  util.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
};

document.addEventListener('deviceready', function () {
  if (!bindEvents()) {
    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
      noPluginError();
    }

    softwareKeyboard.on = noPluginError;
  }
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var generateId = function () {
  var i = 0;
  return function () {
    return i++;
  };
}();

/**
 * Door locking system.
 *
 * @param {Object} [options]
 * @param {Function} [options.log]
 */

var DoorLock = function () {
  function DoorLock() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DoorLock);

    this._lockList = [];
    this._waitList = [];
    this._log = options.log || function () {};
  }

  /**
   * Register a lock.
   *
   * @return {Function} Callback for unlocking.
   */


  createClass(DoorLock, [{
    key: 'lock',
    value: function lock() {
      var _this = this;

      var unlock = function unlock() {
        _this._unlock(unlock);
      };
      unlock.id = generateId();
      this._lockList.push(unlock);
      this._log('lock: ' + unlock.id);

      return unlock;
    }
  }, {
    key: '_unlock',
    value: function _unlock(fn) {
      var index = this._lockList.indexOf(fn);
      if (index === -1) {
        throw new Error('This function is not registered in the lock list.');
      }

      this._lockList.splice(index, 1);
      this._log('unlock: ' + fn.id);

      this._tryToFreeWaitList();
    }
  }, {
    key: '_tryToFreeWaitList',
    value: function _tryToFreeWaitList() {
      while (!this.isLocked() && this._waitList.length > 0) {
        this._waitList.shift()();
      }
    }

    /**
     * Register a callback for waiting unlocked door.
     *
     * @params {Function} callback Callback on unlocking the door completely.
     */

  }, {
    key: 'waitUnlock',
    value: function waitUnlock(callback) {
      if (!(callback instanceof Function)) {
        throw new Error('The callback param must be a function.');
      }

      if (this.isLocked()) {
        this._waitList.push(callback);
      } else {
        callback();
      }
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isLocked',
    value: function isLocked() {
      return this._lockList.length > 0;
    }
  }]);
  return DoorLock;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
// Default implementation for global PageLoader.
function loadPage(_ref, done) {
  var page = _ref.page,
      parent = _ref.parent;

  internal$1.getPageHTMLAsync(page).then(function (html) {
    var pageElement = util.createElement(html);
    parent.appendChild(pageElement);

    done(pageElement);
  });
}

function unloadPage(element) {
  if (element._destroy instanceof Function) {
    element._destroy();
  } else {
    element.remove();
  }
}

var PageLoader = function () {
  /**
   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
   */
  function PageLoader(loader, unloader) {
    classCallCheck(this, PageLoader);

    this._loader = loader instanceof Function ? loader : loadPage;
    this._unloader = unloader instanceof Function ? unloader : unloadPage;
  }

  /**
   * Set internal loader implementation.
   */


  createClass(PageLoader, [{
    key: 'load',


    /**
     * @param {any} options.page
     * @param {Element} options.parent A location to load page.
     * @param {Object} [options.params] Extra parameters for ons-page.
     * @param {Function} done Take an object that has "element" property and "unload" function.
     */
    value: function load(_ref2, done) {
      var page = _ref2.page,
          parent = _ref2.parent,
          _ref2$params = _ref2.params,
          params = _ref2$params === undefined ? {} : _ref2$params;

      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {
        if (!(pageElement instanceof Element)) {
          throw Error('pageElement must be an instance of Element.');
        }

        done(pageElement);
      });
    }
  }, {
    key: 'unload',
    value: function unload(pageElement) {
      if (!(pageElement instanceof Element)) {
        throw Error('pageElement must be an instance of Element.');
      }

      this._unloader(pageElement);
    }
  }, {
    key: 'internalLoader',
    set: function set$$1(fn) {
      if (!(fn instanceof Function)) {
        throw Error('First parameter must be an instance of Function');
      }
      this._loader = fn;
    },
    get: function get$$1() {
      return this._loader;
    }
  }]);
  return PageLoader;
}();

var defaultPageLoader = new PageLoader();

var instantPageLoader = new PageLoader(function (_ref3, done) {
  var page = _ref3.page,
      parent = _ref3.parent;

  var element = util.createElement(page.trim());
  parent.appendChild(element);

  done(element);
}, unloadPage);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons
 * @category util
 * @description
 *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
 *   [en]A global object that's used in Onsen UI. [/en]
 */
var ons$1 = {
  animit: Animit,
  defaultPageLoader: defaultPageLoader,
  elements: {},
  GestureDetector: GestureDetector,
  modifier: modifier,
  notification: notification,
  orientation: orientation,
  pageAttributeExpression: pageAttributeExpression,
  PageLoader: PageLoader,
  platform: platform,
  softwareKeyboard: softwareKeyboard,
  _autoStyle: autoStyle,
  _internal: internal$1,
  _readyLock: new DoorLock(),
  _util: util
};

ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

waitDeviceReady();

/**
 * @method isReady
 * @signature isReady()
 * @return {Boolean}
 *   [en]Will be true if Onsen UI is initialized.[/en]
 *   [ja]初期化されているかどうかを返します。[/ja]
 * @description
 *   [en]Returns true if Onsen UI is initialized.[/en]
 *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isReady = function () {
  return !ons$1._readyLock.isLocked();
};

/**
 * @method isWebView
 * @signature isWebView()
 * @return {Boolean}
 *   [en]Will be true if the app is running in Cordova.[/en]
 *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
 * @description
 *   [en]Returns true if running inside Cordova.[/en]
 *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isWebView = ons$1.platform.isWebView;

/**
 * @method ready
 * @signature ready(callback)
 * @description
 *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
 *   [en]Method used to wait for app initialization. Waits for `DOMContentLoaded` and `deviceready`, when necessary, before executing the callback.[/en]
 * @param {Function} callback
 *   [en]Function that executes after Onsen UI has been initialized.[/en]
 *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
 */
ons$1.ready = function (callback) {
  if (ons$1.isReady()) {
    callback();
  } else {
    ons$1._readyLock.waitUnlock(callback);
  }
};

/**
 * @method setDefaultDeviceBackButtonListener
 * @signature setDefaultDeviceBackButtonListener(listener)
 * @param {Function} listener
 *   [en]Function that executes when device back button is pressed. Must be called on `ons.ready`.[/en]
 *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]Set default handler for device back button.[/en]
 *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
 */
ons$1.setDefaultDeviceBackButtonListener = function (listener) {
  if (!ons$1.isReady()) {
    throw new Error('This method must be called after ons.isReady() is true.');
  }
  ons$1._defaultDeviceBackButtonHandler.setListener(listener);
};

/**
 * @method disableDeviceBackButtonHandler
 * @signature disableDeviceBackButtonHandler()
 * @description
 * [en]Disable device back button event handler. Must be called on `ons.ready`.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
 */
ons$1.disableDeviceBackButtonHandler = function () {
  if (!ons$1.isReady()) {
    throw new Error('This method must be called after ons.isReady() is true.');
  }
  internal$1.dbbDispatcher.disable();
};

/**
 * @method enableDeviceBackButtonHandler
 * @signature enableDeviceBackButtonHandler()
 * @description
 * [en]Enable device back button event handler. Must be called on `ons.ready`.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
 */
ons$1.enableDeviceBackButtonHandler = function () {
  if (!ons$1.isReady()) {
    throw new Error('This method must be called after ons.isReady() is true.');
  }
  internal$1.dbbDispatcher.enable();
};

ons$1.fireDeviceBackButtonEvent = function () {
  internal$1.dbbDispatcher.fireDeviceBackButtonEvent();
};

/**
 * @method enableAutoStatusBarFill
 * @signature enableAutoStatusBarFill()
 * @description
 *   [en]Enable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
 *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
 */
ons$1.enableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  internal$1.config.autoStatusBarFill = true;
};

/**
 * @method disableAutoStatusBarFill
 * @signature disableAutoStatusBarFill()
 * @description
 *   [en]Disable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
 *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
 */
ons$1.disableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }
  internal$1.config.autoStatusBarFill = false;
};

/**
 * @method mockStatusBar
 * @signature mockStatusBar()
 * @description
 *   [en]Creates a static element similar to iOS status bar. Only useful for browser testing. Must be called before `ons.ready`.[/en]
 *   [ja][/ja]
 */
ons$1.mockStatusBar = function () {
  if (ons$1.isReady()) {
    throw new Error('This method must be called before ons.isReady() is true.');
  }

  var mock = function mock() {
    if (!document.body.children[0] || !document.body.children[0].classList.contains('ons-status-bar-mock')) {
      var android = platform.isAndroid(),
          i = function i(_i) {
        return '<i class="' + _i.split('-')[0] + ' ' + _i + '"></i>';
      };
      var left = android ? i('zmdi-twitter') + ' ' + i('zmdi-google-play') : 'No SIM ' + i('fa-wifi'),
          center = android ? '' : '12:28 PM',
          right = android ? i('zmdi-network') + ' ' + i('zmdi-wifi') + ' ' + i('zmdi-battery') + ' 12:28 PM' : '80% ' + i('fa-battery-three-quarters');

      document.body.insertBefore(util.createElement('<div class="ons-status-bar-mock ' + (android ? 'android' : 'ios') + '">' + ('<div>' + left + '</div><div>' + center + '</div><div>' + right + '</div>') + '</div>'), document.body.firstChild);
    }
  };

  document.body ? mock() : internal$1.waitDOMContentLoaded(mock);
};

/**
 * @method disableAnimations
 * @signature disableAnimations()
 * @description
 *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
 *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
 */
ons$1.disableAnimations = function () {
  internal$1.config.animationsDisabled = true;
};

/**
 * @method enableAnimations
 * @signature enableAnimations()
 * @description
 *   [en]Enable animations (default).[/en]
 *   [ja]アニメーションを有効にします。[/ja]
 */
ons$1.enableAnimations = function () {
  internal$1.config.animationsDisabled = false;
};

ons$1._disableWarnings = function () {
  internal$1.config.warningsDisabled = true;
};

ons$1._enableWarnings = function () {
  internal$1.config.warningsDisabled = false;
};

/**
 * @method disableAutoStyling
 * @signature disableAutoStyling()
 * @description
 *   [en]Disable automatic styling.[/en]
 *   [ja][/ja]
 */
ons$1.disableAutoStyling = autoStyle.disable;

/**
 * @method enableAutoStyling
 * @signature enableAutoStyling()
 * @description
 *   [en]Enable automatic styling based on OS (default).[/en]
 *   [ja][/ja]
 */
ons$1.enableAutoStyling = autoStyle.enable;

/**
 * @method disableIconAutoPrefix
 * @signature disableIconAutoPrefix()
 * @description
 *   [en]Disable adding `fa-` prefix automatically to `ons-icon` classes. Useful when including custom icon packs.[/en]
 *   [ja][/ja]
 */
ons$1.disableIconAutoPrefix = function () {
  if (!ons$1.elements.Icon) {
    throw new Error('Expected \'ons-icon\' Custom Element to be registered before calling this method.');
  }
  ons$1.elements.Icon.setAutoPrefix(false);
};

/**
 * @method forcePlatformStyling
 * @signature forcePlatformStyling(platform)
 * @description
 *   [en]Refresh styling for the given platform. Only useful for demos. Use `ons.platform.select(...)` instead for development and production.[/en]
 *   [ja][/ja]
 * @param {string} platform New platform to style the elements.
 */
ons$1.forcePlatformStyling = function (newPlatform) {
  ons$1.enableAutoStyling();
  ons$1.platform.select(newPlatform || 'ios');

  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
    if (element.tagName.toLowerCase() === 'ons-if') {
      element._platformUpdate();
    } else if (element.tagName.match(/^ons-/i)) {
      autoStyle.prepare(element, true);
      if (element.tagName.toLowerCase() === 'ons-tabbar') {
        element._updatePosition();
      }
    }
  });
};

/**
 * @method preload
 * @signature preload(templatePaths)
 * @param {String|Array} templatePaths
 *   [en]Set of HTML file paths containing 'ons-page' elements.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Promise that resolves when all the templates are cached.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Separated files need to be requested on demand and this can slightly delay pushing new pages. This method requests and caches templates for later use.[/en]
 *   [ja][/ja]
 */
ons$1.preload = function () {
  var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return Promise.all((templates instanceof Array ? templates : [templates]).map(function (template) {
    if (typeof template !== 'string') {
      throw new Error('Expected string arguments but got ' + (typeof template === 'undefined' ? 'undefined' : _typeof(template)));
    }
    return internal$1.getTemplateHTMLAsync(template);
  }));
};

/**
 * @method createElement
 * @signature createElement(template, options)
 * @param {String} template
 *   [en]Either an HTML file path, an `<ons-template>` id or an HTML string such as `'<div id="foo">hoge</div>'`.[/en]
 *   [ja][/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Boolean|HTMLElement} [options.append]
 *   [en]Whether or not the element should be automatically appended to the DOM.  Defaults to `false`. If `true` value is given, `document.body` will be used as the target.[/en]
 *   [ja][/ja]
 * @param {HTMLElement} [options.insertBefore]
 *   [en]Reference node that becomes the next sibling of the new node (`options.append` element).[/en]
 *   [ja][/ja]
 * @return {HTMLElement|Promise}
 *   [en]If the provided template was an inline HTML string, it returns the new element. Otherwise, it returns a promise that resolves to the new element.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Create a new element from a template. Both inline HTML and external files are supported although the return value differs.[/en]
 *   [ja][/ja]
 */
ons$1.createElement = function (template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  template = template.trim();

  var create = function create(html) {
    var element = ons$1._util.createElement(html);
    element.remove();

    if (options.append) {
      var target = options.append instanceof HTMLElement ? options.append : document.body;
      target.insertBefore(element, options.insertBefore || null);
      options.link instanceof Function && options.link(element);
    }

    return element;
  };

  return template.charAt(0) === '<' ? create(template) : internal$1.getPageHTMLAsync(template).then(create);
};

/**
 * @method createPopover
 * @signature createPopover(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Object} [options.parentScope]
 *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
 *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the popover component object.[/en]
 *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a popover instance from a template.[/en]
 *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
 */
/**
 * @method createDialog
 * @signature createDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a dialog instance from a template.[/en]
 *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
 */
/**
 * @method createAlertDialog
 * @signature createAlertDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the alert dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a alert dialog instance from a template.[/en]
 *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
 */
ons$1.createPopover = ons$1.createDialog = ons$1.createAlertDialog = function (template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return ons$1.createElement(template, _extends({ append: true }, options));
};

/**
 * @method openActionSheet
 * @signature openActionSheet(options)
 * @description
 *   [en]Shows an instant Action Sheet and lets the user choose an action.[/en]
 *   [ja][/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Array} [options.buttons]
 *   [en]Represent each button of the action sheet following the specified order. Every item can be either a string label or an object containing `label`, `icon` and `modifier` properties.[/en]
 *   [ja][/ja]
 * @param {String} [options.title]
 *   [en]Optional title for the action sheet.[/en]
 *   [ja][/ja]
 * @param {Number} [options.destructive]
 *   [en]Optional index of the "destructive" button (only for iOS). It can be specified in the button array as well.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the action sheet can be canceled by tapping on the background mask or not.[/en]
 *   [ja][/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier attribute of the action sheet. E.g. `'destructive'`.[/en]
 *   [ja][/ja]
 * @param {String} [options.maskColor]
 *   [en]Optionally change the background mask color.[/en]
 *   [ja][/ja]
 * @param {String} [options.id]
 *   [en]The element's id attribute.[/en]
 *   [ja][/ja]
 * @param {String} [options.class]
 *   [en]The element's class attribute.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve when the action sheet is closed. The resolve value is either the index of the tapped button or -1 when canceled.[/en]
 *   [ja][/ja]
 */
ons$1.openActionSheet = actionSheet;

/**
 * @method resolveLoadingPlaceholder
 * @signature resolveLoadingPlaceholder(page)
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or a `<template>` id.[/en]
 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @description
 *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
 *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
 */
ons$1.resolveLoadingPlaceholder = function (page, link) {
  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));
  if (elements.length === 0) {
    throw new Error('No ons-loading-placeholder exists.');
  }

  elements.filter(function (element) {
    return !element.getAttribute('page');
  }).forEach(function (element) {
    element.setAttribute('ons-loading-placeholder', page);
    ons$1._resolveLoadingPlaceholder(element, page, link);
  });
};

ons$1._setupLoadingPlaceHolders = function () {
  ons$1.ready(function () {
    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

    elements.forEach(function (element) {
      var page = element.getAttribute('ons-loading-placeholder');
      if (typeof page === 'string') {
        ons$1._resolveLoadingPlaceholder(element, page);
      }
    });
  });
};

ons$1._resolveLoadingPlaceholder = function (parent, page) {
  var link = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el, done) {
    return done();
  };

  page && ons$1.createElement(page).then(function (element) {
    element.style.display = 'none';
    parent.appendChild(element);
    link(element, function () {
      while (parent.firstChild && parent.firstChild !== element) {
        parent.removeChild(parent.firstChild);
      }
      element.style.display = '';
    });
  }).catch(function (error) {
    return Promise.reject('Unabled to resolve placeholder: ' + error);
  });
};

function waitDeviceReady() {
  var unlockDeviceReady = ons$1._readyLock.lock();
  window.addEventListener('DOMContentLoaded', function () {
    if (ons$1.isWebView()) {
      window.document.addEventListener('deviceready', unlockDeviceReady, false);
    } else {
      unlockDeviceReady();
    }
  }, false);
}

/**
 * @method getScriptPage
 * @signature getScriptPage()
 * @description
 *   [en]Access the last created page from the current `script` scope. Only works inside `<script></script>` tags that are direct children of `ons-page` element. Use this to add lifecycle hooks to a page.[/en]
 *   [ja][/ja]
 * @return {HTMLElement}
 *   [en]Returns the corresponding page element.[/en]
 *   [ja][/ja]
 */
var getCS = 'currentScript' in document ? function () {
  return document.currentScript;
} : function () {
  return document.scripts[document.scripts.length - 1];
};
ons$1.getScriptPage = function () {
  return getCS() && /ons-page/i.test(getCS().parentElement.tagName) && getCS().parentElement || null;
};

// For @onsenui/custom-elements
if (window.customElements) {
    // even if native CE1 impl exists, use polyfill
    window.customElements.forcePolyfill = true;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.5.1' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _isObject = function _isObject(it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function _anObject(it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function _fails(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function _domCreate(it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function _toPrimitive(it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
  f: f
};

var _propertyDesc = function _propertyDesc(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function _has(it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function _uid(key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');
  var TO_STRING = 'toString';
  var $toString = Function[TO_STRING];
  var TPL = ('' + $toString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    }
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
});

var _aFunction = function _aFunction(it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function _ctx(fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

var f$2 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$2
};

var toString = {}.toString;

var _cof = function _cof(it) {
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function _defined(it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function _toIobject(it) {
  return _iobject(_defined(it));
};

var gOPD = Object.getOwnPropertyDescriptor;

var f$1 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};

var _objectGopd = {
  f: f$1
};

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */

var check = function check(O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

// 19.1.3.19 Object.setPrototypeOf(O, proto)

_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});
var _shared = function _shared(key) {
  return store[key] || (store[key] = {});
};

var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var _Symbol = _global.Symbol;
  var USE_SYMBOL = typeof _Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
});

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

var _classof = function _classof(it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  // builtinTag case
  : ARG ? _cof(O)
  // ES3 arguments fallback
  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

'use strict';
// 19.1.3.6 Object.prototype.toString()

var test = {};
test[_wks('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  _redefine(Object.prototype, 'toString', function toString() {
    return '[object ' + _classof(this) + ']';
  }, true);
}

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function _toInteger(it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// true  -> String#at
// false -> String#codePointAt
var _stringAt = function _stringAt(TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _library = false;

var _iterators = {};

// 7.1.15 ToLength

var min = Math.min;
var _toLength = function _toLength(it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes


var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

var shared = _shared('keys');

var _sharedKey = function _sharedKey(key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO$1 = _sharedKey('IE_PROTO');

var _objectKeysInternal = function _objectKeysInternal(object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
    if (key != IE_PROTO$1) _has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)


var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
    _objectDp.f(O, P = keys[i++], Properties[P]);
  }return O;
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


var IE_PROTO = _sharedKey('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE$1 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
    delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
  }return _createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = _createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

var def = _objectDp.f;

var TAG$1 = _wks('toStringTag');

var _setToStringTag = function _setToStringTag(it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });
};

'use strict';

var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () {
  return this;
});

var _iterCreate = function _iterCreate(Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

// 7.1.13 ToObject(argument)

var _toObject = function _toObject(it) {
  return Object(_defined(it));
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};

'use strict';

var ITERATOR = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!_library && !_has(IteratorPrototype, ITERATOR)) _hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    _hide(proto, ITERATOR, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

'use strict';
var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _wks('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
var _addToUnscopables = function _addToUnscopables(key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

var _iterStep = function _iterStep(done, value) {
  return { value: value, done: !!done };
};

'use strict';

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

_addToUnscopables('keys');
_addToUnscopables('values');
_addToUnscopables('entries');

var ITERATOR$1 = _wks('iterator');
var TO_STRING_TAG = _wks('toStringTag');
var ArrayValues = _iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = _global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);
    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = ArrayValues;
    if (explicit) for (key in es6_array_iterator) {
      if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
    }
  }
}

var _redefineAll = function _redefineAll(target, src, safe) {
  for (var key in src) {
    _redefine(target, key, src[key], safe);
  }return target;
};

var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }return it;
};

// call something on iterator step with safe closing on error

var _iterCall = function _iterCall(iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator

var ITERATOR$2 = _wks('iterator');
var ArrayProto$1 = Array.prototype;

var _isArrayIter = function _isArrayIter(it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
};

var ITERATOR$3 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || _iterators[_classof(it)];
};

var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () {
      return iterable;
    } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
});

'use strict';

var SPECIES = _wks('species');

var _setSpecies = function _setSpecies(KEY) {
  var C = _global[KEY];
  if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');

  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function setMeta(it) {
    setDesc(it, META, { value: {
        i: 'O' + ++id, // object ID
        w: {} // weak collections IDs
      } });
  };
  var fastKey = function fastKey(it, create) {
    // return primitive with prefix
    if (!_isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMeta(it);
      // return object ID
    }return it[META].i;
  };
  var getWeak = function getWeak(it, create) {
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMeta(it);
      // return hash weak collections IDs
    }return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function onFreeze(it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
});

var _validateCollection = function _validateCollection(it, TYPE) {
  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

'use strict';
var dP$1 = _objectDp.f;

var fastKey = _meta.fastKey;

var SIZE = _descriptors ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

var _collectionStrong = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      _anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = _objectCreate(null); // index
      that._f = undefined; // first entry
      that._l = undefined; // last entry
      that[SIZE] = 0; // size
      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
    });
    _redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = _validateCollection(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        _validateCollection(this, NAME);
        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(_validateCollection(this, NAME), key);
      }
    });
    if (_descriptors) dP$1(C.prototype, 'size', {
      get: function get() {
        return _validateCollection(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
      // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key, // <- key
        v: value, // <- value
        p: prev = that._l, // <- previous entry
        n: undefined, // <- next entry
        r: false // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    }return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    _iterDefine(C, NAME, function (iterated, kind) {
      this._t = _validateCollection(iterated, NAME); // target
      this._k = kind; // kind
      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return _iterStep(1);
      }
      // return step by kind
      if (kind == 'keys') return _iterStep(0, entry.k);
      if (kind == 'values') return _iterStep(0, entry.v);
      return _iterStep(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    _setSpecies(NAME);
  }
};

var ITERATOR$4 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$4]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  
} catch (e) {/* empty */}

var _iterDetect = function _iterDetect(exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$4]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR$4] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

var setPrototypeOf$2 = _setProto.set;
var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf$2) {
    setPrototypeOf$2(that, P);
  }return that;
};

'use strict';

var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = _global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    _redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);return this;
    });
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    _redefineAll(C.prototype, methods);
    _meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = _fails(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = _iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) {
        $instance[ADDER](index, index);
      }return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME);
        var that = _inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  _setToStringTag(C, NAME);

  O[NAME] = C;
  _export(_export.G + _export.W + _export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

'use strict';

var SET = 'Set';

// 23.2 Set Objects
var es6_set = _collection(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
  }
}, _collectionStrong);

var _arrayFromIterable = function _arrayFromIterable(iter, ITERATOR) {
  var result = [];
  _forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


var _collectionToJson = function _collectionToJson(NAME) {
  return function toJSON() {
    if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return _arrayFromIterable(this);
  };
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


_export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });

'use strict';
// https://tc39.github.io/proposal-setmap-offrom/


var _setCollectionOf = function _setCollectionOf(COLLECTION) {
  _export(_export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = Array(length);
      while (length--) {
        A[length] = arguments[length];
      }return new this(A);
    } });
};

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
_setCollectionOf('Set');

'use strict';
// https://tc39.github.io/proposal-setmap-offrom/


var _setCollectionFrom = function _setCollectionFrom(COLLECTION) {
  _export(_export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      _aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) _aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = _ctx(mapFn, arguments[2], 2);
        _forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        _forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
};

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
_setCollectionFrom('Set');

'use strict';

var MAP = 'Map';

// 23.1 Map Objects
var es6_map = _collection(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
  }
}, _collectionStrong, true);

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


_export(_export.P + _export.R, 'Map', { toJSON: _collectionToJson('Map') });

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
_setCollectionOf('Map');

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
_setCollectionFrom('Map');

var reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);

/**
 * @param {string} localName
 * @returns {boolean}
 */
function isValidCustomElementName(localName) {
  var reserved = reservedTagList.has(localName);
  var validForm = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(localName);
  return !reserved && validForm;
}

/**
 * @private
 * @param {!Node} node
 * @return {boolean}
 */
function isConnected(node) {
  // Use `Node#isConnected`, if defined.
  var nativeValue = node.isConnected;
  if (nativeValue !== undefined) {
    return nativeValue;
  }

  /** @type {?Node|undefined} */
  var current = node;
  while (current && !(current.__CE_isImportDocument || current instanceof Document)) {
    current = current.parentNode || (window.ShadowRoot && current instanceof ShadowRoot ? current.host : undefined);
  }
  return !!(current && (current.__CE_isImportDocument || current instanceof Document));
}

/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */
function nextSiblingOrAncestorSibling(root, start) {
  var node = start;
  while (node && node !== root && !node.nextSibling) {
    node = node.parentNode;
  }
  return !node || node === root ? null : node.nextSibling;
}

/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */
function nextNode(root, start) {
  return start.firstChild ? start.firstChild : nextSiblingOrAncestorSibling(root, start);
}

/**
 * @param {!Node} root
 * @param {!function(!Element)} callback
 * @param {!Set<Node>=} visitedImports
 */
function walkDeepDescendantElements(root, callback) {
  var visitedImports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();

  var node = root;
  while (node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      var element = /** @type {!Element} */node;

      callback(element);

      var localName = element.localName;
      if (localName === 'link' && element.getAttribute('rel') === 'import') {
        // If this import (polyfilled or not) has it's root node available,
        // walk it.
        var importNode = /** @type {!Node} */element.import;
        if (importNode instanceof Node && !visitedImports.has(importNode)) {
          // Prevent multiple walks of the same import root.
          visitedImports.add(importNode);

          for (var child = importNode.firstChild; child; child = child.nextSibling) {
            walkDeepDescendantElements(child, callback, visitedImports);
          }
        }

        // Ignore descendants of import links to prevent attempting to walk the
        // elements created by the HTML Imports polyfill that we just walked
        // above.
        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      } else if (localName === 'template') {
        // Ignore descendants of templates. There shouldn't be any descendants
        // because they will be moved into `.content` during construction in
        // browsers that support template but, in case they exist and are still
        // waiting to be moved by a polyfill, they will be ignored.
        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      }

      // Walk shadow roots.
      var shadowRoot = element.__CE_shadowRoot;
      if (shadowRoot) {
        for (var _child = shadowRoot.firstChild; _child; _child = _child.nextSibling) {
          walkDeepDescendantElements(_child, callback, visitedImports);
        }
      }
    }

    node = nextNode(root, node);
  }
}

/**
 * Used to suppress Closure's "Modifying the prototype is only allowed if the
 * constructor is in the same scope" warning without using
 * `@suppress {newCheckTypes, duplicate}` because `newCheckTypes` is too broad.
 *
 * @param {!Object} destination
 * @param {string} name
 * @param {*} value
 */
function setPropertyUnchecked(destination, name, value) {
  destination[name] = value;
}

/**
 * @enum {number}
 */
var CustomElementState = {
  custom: 1,
  failed: 2
};

var CustomElementInternals = function () {
  function CustomElementInternals() {
    classCallCheck(this, CustomElementInternals);

    /** @type {!Map<string, !CustomElementDefinition>} */
    this._localNameToDefinition = new Map();

    /** @type {!Map<!Function, !CustomElementDefinition>} */
    this._constructorToDefinition = new Map();

    /** @type {!Array<!function(!Node)>} */
    this._patches = [];

    /** @type {boolean} */
    this._hasPatches = false;
  }

  /**
   * @param {string} localName
   * @param {!CustomElementDefinition} definition
   */


  createClass(CustomElementInternals, [{
    key: 'setDefinition',
    value: function setDefinition(localName, definition) {
      this._localNameToDefinition.set(localName, definition);
      this._constructorToDefinition.set(definition.constructor, definition);
    }

    /**
     * @param {string} localName
     * @return {!CustomElementDefinition|undefined}
     */

  }, {
    key: 'localNameToDefinition',
    value: function localNameToDefinition(localName) {
      return this._localNameToDefinition.get(localName);
    }

    /**
     * @param {!Function} constructor
     * @return {!CustomElementDefinition|undefined}
     */

  }, {
    key: 'constructorToDefinition',
    value: function constructorToDefinition(constructor) {
      return this._constructorToDefinition.get(constructor);
    }

    /**
     * @param {!function(!Node)} listener
     */

  }, {
    key: 'addPatch',
    value: function addPatch(listener) {
      this._hasPatches = true;
      this._patches.push(listener);
    }

    /**
     * @param {!Node} node
     */

  }, {
    key: 'patchTree',
    value: function patchTree(node) {
      var _this = this;

      if (!this._hasPatches) return;

      walkDeepDescendantElements(node, function (element) {
        return _this.patch(element);
      });
    }

    /**
     * @param {!Node} node
     */

  }, {
    key: 'patch',
    value: function patch(node) {
      if (!this._hasPatches) return;

      if (node.__CE_patched) return;
      node.__CE_patched = true;

      for (var i = 0; i < this._patches.length; i++) {
        this._patches[i](node);
      }
    }

    /**
     * @param {!Node} root
     */

  }, {
    key: 'connectTree',
    value: function connectTree(root) {
      var elements = [];

      walkDeepDescendantElements(root, function (element) {
        return elements.push(element);
      });

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.__CE_state === CustomElementState.custom) {
          if (isConnected(element)) {
            this.connectedCallback(element);
          }
        } else {
          this.upgradeElement(element);
        }
      }
    }

    /**
     * @param {!Node} root
     */

  }, {
    key: 'disconnectTree',
    value: function disconnectTree(root) {
      var elements = [];

      walkDeepDescendantElements(root, function (element) {
        return elements.push(element);
      });

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.__CE_state === CustomElementState.custom) {
          this.disconnectedCallback(element);
        }
      }
    }

    /**
     * Upgrades all uncustomized custom elements at and below a root node for
     * which there is a definition. When custom element reaction callbacks are
     * assumed to be called synchronously (which, by the current DOM / HTML spec
     * definitions, they are *not*), callbacks for both elements customized
     * synchronously by the parser and elements being upgraded occur in the same
     * relative order.
     *
     * NOTE: This function, when used to simulate the construction of a tree that
     * is already created but not customized (i.e. by the parser), does *not*
     * prevent the element from reading the 'final' (true) state of the tree. For
     * example, the element, during truly synchronous parsing / construction would
     * see that it contains no children as they have not yet been inserted.
     * However, this function does not modify the tree, the element will
     * (incorrectly) have children. Additionally, self-modification restrictions
     * for custom element constructors imposed by the DOM spec are *not* enforced.
     *
     *
     * The following nested list shows the steps extending down from the HTML
     * spec's parsing section that cause elements to be synchronously created and
     * upgraded:
     *
     * The "in body" insertion mode:
     * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
     * - Switch on token:
     *   .. other cases ..
     *   -> Any other start tag
     *      - [Insert an HTML element](below) for the token.
     *
     * Insert an HTML element:
     * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element
     * - Insert a foreign element for the token in the HTML namespace:
     *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element
     *   - Create an element for a token:
     *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token
     *     - Will execute script flag is true?
     *       - (Element queue pushed to the custom element reactions stack.)
     *     - Create an element:
     *       https://dom.spec.whatwg.org/#concept-create-element
     *       - Sync CE flag is true?
     *         - Constructor called.
     *         - Self-modification restrictions enforced.
     *       - Sync CE flag is false?
     *         - (Upgrade reaction enqueued.)
     *     - Attributes appended to element.
     *       (`attributeChangedCallback` reactions enqueued.)
     *     - Will execute script flag is true?
     *       - (Element queue popped from the custom element reactions stack.
     *         Reactions in the popped stack are invoked.)
     *   - (Element queue pushed to the custom element reactions stack.)
     *   - Insert the element:
     *     https://dom.spec.whatwg.org/#concept-node-insert
     *     - Shadow-including descendants are connected. During parsing
     *       construction, there are no shadow-*excluding* descendants.
     *       However, the constructor may have validly attached a shadow
     *       tree to itself and added descendants to that shadow tree.
     *       (`connectedCallback` reactions enqueued.)
     *   - (Element queue popped from the custom element reactions stack.
     *     Reactions in the popped stack are invoked.)
     *
     * @param {!Node} root
     * @param {!Set<Node>=} visitedImports
     */

  }, {
    key: 'patchAndUpgradeTree',
    value: function patchAndUpgradeTree(root) {
      var _this2 = this;

      var visitedImports = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

      var elements = [];

      var gatherElements = function gatherElements(element) {
        if (element.localName === 'link' && element.getAttribute('rel') === 'import') {
          // The HTML Imports polyfill sets a descendant element of the link to
          // the `import` property, specifically this is *not* a Document.
          var importNode = /** @type {?Node} */element.import;

          if (importNode instanceof Node && importNode.readyState === 'complete') {
            importNode.__CE_isImportDocument = true;

            // Connected links are associated with the registry.
            importNode.__CE_hasRegistry = true;
          } else {
            // If this link's import root is not available, its contents can't be
            // walked. Wait for 'load' and walk it when it's ready.
            element.addEventListener('load', function () {
              var importNode = /** @type {!Node} */element.import;

              if (importNode.__CE_documentLoadHandled) return;
              importNode.__CE_documentLoadHandled = true;

              importNode.__CE_isImportDocument = true;

              // Connected links are associated with the registry.
              importNode.__CE_hasRegistry = true;

              // Clone the `visitedImports` set that was populated sync during
              // the `patchAndUpgradeTree` call that caused this 'load' handler to
              // be added. Then, remove *this* link's import node so that we can
              // walk that import again, even if it was partially walked later
              // during the same `patchAndUpgradeTree` call.
              visitedImports.delete(importNode);

              _this2.patchAndUpgradeTree(importNode, visitedImports);
            });
          }
        } else {
          elements.push(element);
        }
      };

      // `walkDeepDescendantElements` populates (and internally checks against)
      // `visitedImports` when traversing a loaded import.
      walkDeepDescendantElements(root, gatherElements, visitedImports);

      if (this._hasPatches) {
        for (var i = 0; i < elements.length; i++) {
          this.patch(elements[i]);
        }
      }

      for (var _i = 0; _i < elements.length; _i++) {
        this.upgradeElement(elements[_i]);
      }
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'upgradeElement',
    value: function upgradeElement(element) {
      var currentState = element.__CE_state;
      if (currentState !== undefined) return;

      var definition = this.localNameToDefinition(element.localName);
      if (!definition) return;

      definition.constructionStack.push(element);

      var constructor = definition.constructor;
      try {
        try {
          var result = new constructor();
          if (result !== element) {
            throw new Error('The custom element constructor did not produce the element being upgraded.');
          }
        } finally {
          definition.constructionStack.pop();
        }
      } catch (e) {
        element.__CE_state = CustomElementState.failed;
        throw e;
      }

      element.__CE_state = CustomElementState.custom;
      element.__CE_definition = definition;

      if (definition.attributeChangedCallback) {
        var observedAttributes = definition.observedAttributes;
        for (var i = 0; i < observedAttributes.length; i++) {
          var name = observedAttributes[i];
          var value = element.getAttribute(name);
          if (value !== null) {
            this.attributeChangedCallback(element, name, null, value, null);
          }
        }
      }

      if (isConnected(element)) {
        this.connectedCallback(element);
      }
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback(element) {
      var definition = element.__CE_definition;
      if (definition.connectedCallback) {
        definition.connectedCallback.call(element);
      }

      element.__CE_isConnectedCallbackCalled = true;
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback(element) {
      if (!element.__CE_isConnectedCallbackCalled) {
        this.connectedCallback(element);
      }

      var definition = element.__CE_definition;
      if (definition.disconnectedCallback) {
        definition.disconnectedCallback.call(element);
      }

      element.__CE_isConnectedCallbackCalled = undefined;
    }

    /**
     * @param {!Element} element
     * @param {string} name
     * @param {?string} oldValue
     * @param {?string} newValue
     * @param {?string} namespace
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(element, name, oldValue, newValue, namespace) {
      var definition = element.__CE_definition;
      if (definition.attributeChangedCallback && definition.observedAttributes.indexOf(name) > -1) {
        definition.attributeChangedCallback.call(element, name, oldValue, newValue, namespace);
      }
    }
  }]);
  return CustomElementInternals;
}();

var DocumentConstructionObserver = function () {
  function DocumentConstructionObserver(internals, doc) {
    classCallCheck(this, DocumentConstructionObserver);

    /**
     * @type {!CustomElementInternals}
     */
    this._internals = internals;

    /**
     * @type {!Document}
     */
    this._document = doc;

    /**
     * @type {MutationObserver|undefined}
     */
    this._observer = undefined;

    // Simulate tree construction for all currently accessible nodes in the
    // document.
    this._internals.patchAndUpgradeTree(this._document);

    if (this._document.readyState === 'loading') {
      this._observer = new MutationObserver(this._handleMutations.bind(this));

      // Nodes created by the parser are given to the observer *before* the next
      // task runs. Inline scripts are run in a new task. This means that the
      // observer will be able to handle the newly parsed nodes before the inline
      // script is run.
      this._observer.observe(this._document, {
        childList: true,
        subtree: true
      });
    }
  }

  createClass(DocumentConstructionObserver, [{
    key: 'disconnect',
    value: function disconnect() {
      if (this._observer) {
        this._observer.disconnect();
      }
    }

    /**
     * @param {!Array<!MutationRecord>} mutations
     */

  }, {
    key: '_handleMutations',
    value: function _handleMutations(mutations) {
      // Once the document's `readyState` is 'interactive' or 'complete', all new
      // nodes created within that document will be the result of script and
      // should be handled by patching.
      var readyState = this._document.readyState;
      if (readyState === 'interactive' || readyState === 'complete') {
        this.disconnect();
      }

      for (var i = 0; i < mutations.length; i++) {
        var addedNodes = mutations[i].addedNodes;
        for (var j = 0; j < addedNodes.length; j++) {
          var node = addedNodes[j];
          this._internals.patchAndUpgradeTree(node);
        }
      }
    }
  }]);
  return DocumentConstructionObserver;
}();

/**
 * @template T
 */
var Deferred = function () {
  function Deferred() {
    var _this = this;

    classCallCheck(this, Deferred);

    /**
     * @private
     * @type {T|undefined}
     */
    this._value = undefined;

    /**
     * @private
     * @type {Function|undefined}
     */
    this._resolve = undefined;

    /**
     * @private
     * @type {!Promise<T>}
     */
    this._promise = new Promise(function (resolve) {
      _this._resolve = resolve;

      if (_this._value) {
        resolve(_this._value);
      }
    });
  }

  /**
   * @param {T} value
   */


  createClass(Deferred, [{
    key: 'resolve',
    value: function resolve(value) {
      if (this._value) {
        throw new Error('Already resolved.');
      }

      this._value = value;

      if (this._resolve) {
        this._resolve(value);
      }
    }

    /**
     * @return {!Promise<T>}
     */

  }, {
    key: 'toPromise',
    value: function toPromise() {
      return this._promise;
    }
  }]);
  return Deferred;
}();

/**
 * @unrestricted
 */

var CustomElementRegistry = function () {

  /**
   * @param {!CustomElementInternals} internals
   */
  function CustomElementRegistry(internals) {
    classCallCheck(this, CustomElementRegistry);

    /**
     * @private
     * @type {boolean}
     */
    this._elementDefinitionIsRunning = false;

    /**
     * @private
     * @type {!CustomElementInternals}
     */
    this._internals = internals;

    /**
     * @private
     * @type {!Map<string, !Deferred<undefined>>}
     */
    this._whenDefinedDeferred = new Map();

    /**
     * The default flush callback triggers the document walk synchronously.
     * @private
     * @type {!Function}
     */
    this._flushCallback = function (fn) {
      return fn();
    };

    /**
     * @private
     * @type {boolean}
     */
    this._flushPending = false;

    /**
     * @private
     * @type {!Array<string>}
     */
    this._unflushedLocalNames = [];

    /**
     * @private
     * @type {!DocumentConstructionObserver}
     */
    this._documentConstructionObserver = new DocumentConstructionObserver(internals, document);
  }

  /**
   * @param {string} localName
   * @param {!Function} constructor
   */


  createClass(CustomElementRegistry, [{
    key: 'define',
    value: function define(localName, constructor) {
      var _this = this;

      if (!(constructor instanceof Function)) {
        throw new TypeError('Custom element constructors must be functions.');
      }

      if (!isValidCustomElementName(localName)) {
        throw new SyntaxError('The element name \'' + localName + '\' is not valid.');
      }

      if (this._internals.localNameToDefinition(localName)) {
        throw new Error('A custom element with name \'' + localName + '\' has already been defined.');
      }

      if (this._elementDefinitionIsRunning) {
        throw new Error('A custom element is already being defined.');
      }
      this._elementDefinitionIsRunning = true;

      var connectedCallback = void 0;
      var disconnectedCallback = void 0;
      var adoptedCallback = void 0;
      var attributeChangedCallback = void 0;
      var observedAttributes = void 0;
      try {
        var getCallback = function getCallback(name) {
          var callbackValue = prototype[name];
          if (callbackValue !== undefined && !(callbackValue instanceof Function)) {
            throw new Error('The \'' + name + '\' callback must be a function.');
          }
          return callbackValue;
        };

        /** @type {!Object} */
        var prototype = constructor.prototype;
        if (!(prototype instanceof Object)) {
          throw new TypeError('The custom element constructor\'s prototype is not an object.');
        }

        connectedCallback = getCallback('connectedCallback');
        disconnectedCallback = getCallback('disconnectedCallback');
        adoptedCallback = getCallback('adoptedCallback');
        attributeChangedCallback = getCallback('attributeChangedCallback');
        observedAttributes = constructor['observedAttributes'] || [];
      } catch (e) {
        return;
      } finally {
        this._elementDefinitionIsRunning = false;
      }

      var definition = {
        localName: localName,
        constructor: constructor,
        connectedCallback: connectedCallback,
        disconnectedCallback: disconnectedCallback,
        adoptedCallback: adoptedCallback,
        attributeChangedCallback: attributeChangedCallback,
        observedAttributes: observedAttributes,
        constructionStack: []
      };

      this._internals.setDefinition(localName, definition);

      this._unflushedLocalNames.push(localName);

      // If we've already called the flush callback and it hasn't called back yet,
      // don't call it again.
      if (!this._flushPending) {
        this._flushPending = true;
        this._flushCallback(function () {
          return _this._flush();
        });
      }
    }
  }, {
    key: '_flush',
    value: function _flush() {
      // If no new definitions were defined, don't attempt to flush. This could
      // happen if a flush callback keeps the function it is given and calls it
      // multiple times.
      if (this._flushPending === false) return;

      this._flushPending = false;
      this._internals.patchAndUpgradeTree(document);

      while (this._unflushedLocalNames.length > 0) {
        var localName = this._unflushedLocalNames.shift();
        var deferred = this._whenDefinedDeferred.get(localName);
        if (deferred) {
          deferred.resolve(undefined);
        }
      }
    }

    /**
     * @param {string} localName
     * @return {Function|undefined}
     */

  }, {
    key: 'get',
    value: function get$$1(localName) {
      var definition = this._internals.localNameToDefinition(localName);
      if (definition) {
        return definition.constructor;
      }

      return undefined;
    }

    /**
     * @param {string} localName
     * @return {!Promise<undefined>}
     */

  }, {
    key: 'whenDefined',
    value: function whenDefined(localName) {
      if (!isValidCustomElementName(localName)) {
        return Promise.reject(new SyntaxError('\'' + localName + '\' is not a valid custom element name.'));
      }

      var prior = this._whenDefinedDeferred.get(localName);
      if (prior) {
        return prior.toPromise();
      }

      var deferred = new Deferred();
      this._whenDefinedDeferred.set(localName, deferred);

      var definition = this._internals.localNameToDefinition(localName);
      // Resolve immediately only if the given local name has a definition *and*
      // the full document walk to upgrade elements with that local name has
      // already happened.
      if (definition && this._unflushedLocalNames.indexOf(localName) === -1) {
        deferred.resolve(undefined);
      }

      return deferred.toPromise();
    }
  }, {
    key: 'polyfillWrapFlushCallback',
    value: function polyfillWrapFlushCallback(outer) {
      this._documentConstructionObserver.disconnect();
      var inner = this._flushCallback;
      this._flushCallback = function (flush) {
        return outer(function () {
          return inner(flush);
        });
      };
    }
  }]);
  return CustomElementRegistry;
}();

window['CustomElementRegistry'] = CustomElementRegistry;
CustomElementRegistry.prototype['define'] = CustomElementRegistry.prototype.define;
CustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;
CustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry.prototype.whenDefined;
CustomElementRegistry.prototype['polyfillWrapFlushCallback'] = CustomElementRegistry.prototype.polyfillWrapFlushCallback;

var Native = {
  Document_createElement: window.Document.prototype.createElement,
  Document_createElementNS: window.Document.prototype.createElementNS,
  Document_importNode: window.Document.prototype.importNode,
  Document_prepend: window.Document.prototype['prepend'],
  Document_append: window.Document.prototype['append'],
  Node_cloneNode: window.Node.prototype.cloneNode,
  Node_appendChild: window.Node.prototype.appendChild,
  Node_insertBefore: window.Node.prototype.insertBefore,
  Node_removeChild: window.Node.prototype.removeChild,
  Node_replaceChild: window.Node.prototype.replaceChild,
  Node_textContent: Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent'),
  Element_attachShadow: window.Element.prototype['attachShadow'],
  Element_innerHTML: Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML'),
  Element_getAttribute: window.Element.prototype.getAttribute,
  Element_setAttribute: window.Element.prototype.setAttribute,
  Element_removeAttribute: window.Element.prototype.removeAttribute,
  Element_getAttributeNS: window.Element.prototype.getAttributeNS,
  Element_setAttributeNS: window.Element.prototype.setAttributeNS,
  Element_removeAttributeNS: window.Element.prototype.removeAttributeNS,
  Element_insertAdjacentElement: window.Element.prototype['insertAdjacentElement'],
  Element_prepend: window.Element.prototype['prepend'],
  Element_append: window.Element.prototype['append'],
  Element_before: window.Element.prototype['before'],
  Element_after: window.Element.prototype['after'],
  Element_replaceWith: window.Element.prototype['replaceWith'],
  Element_remove: window.Element.prototype['remove'],
  HTMLElement: window.HTMLElement,
  HTMLElement_innerHTML: Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML'),
  HTMLElement_insertAdjacentElement: window.HTMLElement.prototype['insertAdjacentElement']
};

/**
 * This class exists only to work around Closure's lack of a way to describe
 * singletons. It represents the 'already constructed marker' used in custom
 * element construction stacks.
 *
 * https://html.spec.whatwg.org/#concept-already-constructed-marker
 */
var AlreadyConstructedMarker = function AlreadyConstructedMarker() {
  classCallCheck(this, AlreadyConstructedMarker);
};

var AlreadyConstructedMarker$1 = new AlreadyConstructedMarker();

/**
 * @param {!CustomElementInternals} internals
 */
var PatchHTMLElement = function (internals) {
  window['HTMLElement'] = function () {
    /**
     * @type {function(new: HTMLElement): !HTMLElement}
     */
    function HTMLElement() {
      // This should really be `new.target` but `new.target` can't be emulated
      // in ES5. Assuming the user keeps the default value of the constructor's
      // prototype's `constructor` property, this is equivalent.
      /** @type {!Function} */
      var constructor = this.constructor;

      var definition = internals.constructorToDefinition(constructor);
      if (!definition) {
        throw new Error('The custom element being constructed was not registered with `customElements`.');
      }

      var constructionStack = definition.constructionStack;

      if (constructionStack.length === 0) {
        var _element = Native.Document_createElement.call(document, definition.localName);
        Object.setPrototypeOf(_element, constructor.prototype);
        _element.__CE_state = CustomElementState.custom;
        _element.__CE_definition = definition;
        internals.patch(_element);
        return _element;
      }

      var lastIndex = constructionStack.length - 1;
      var element = constructionStack[lastIndex];
      if (element === AlreadyConstructedMarker$1) {
        throw new Error('The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.');
      }
      constructionStack[lastIndex] = AlreadyConstructedMarker$1;

      Object.setPrototypeOf(element, constructor.prototype);
      internals.patch( /** @type {!HTMLElement} */element);

      return element;
    }

    HTMLElement.prototype = Native.HTMLElement.prototype;

    return HTMLElement;
  }();
};

/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ParentNodeNativeMethods} builtIn
 */
var PatchParentNode = function (internals, destination, builtIn) {
  /**
   * @param {...(!Node|string)} nodes
   */
  destination['prepend'] = function () {
    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.prepend.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i = 0; _i < nodes.length; _i++) {
        var node = nodes[_i];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['append'] = function () {
    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      nodes[_key2] = arguments[_key2];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.append.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var node = nodes[_i2];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchDocument = function (internals) {
  setPropertyUnchecked(Document.prototype, 'createElement',
  /**
   * @this {Document}
   * @param {string} localName
   * @return {!Element}
   */
  function (localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry) {
      var definition = internals.localNameToDefinition(localName);
      if (definition) {
        return new definition.constructor();
      }
    }

    var result = /** @type {!Element} */
    Native.Document_createElement.call(this, localName);
    internals.patch(result);
    return result;
  });

  setPropertyUnchecked(Document.prototype, 'importNode',
  /**
   * @this {Document}
   * @param {!Node} node
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (node, deep) {
    var clone = Native.Document_importNode.call(this, node, deep);
    // Only create custom elements if this document is associated with the registry.
    if (!this.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }
    return clone;
  });

  var NS_HTML = "http://www.w3.org/1999/xhtml";

  setPropertyUnchecked(Document.prototype, 'createElementNS',
  /**
   * @this {Document}
   * @param {?string} namespace
   * @param {string} localName
   * @return {!Element}
   */
  function (namespace, localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry && (namespace === null || namespace === NS_HTML)) {
      var definition = internals.localNameToDefinition(localName);
      if (definition) {
        return new definition.constructor();
      }
    }

    var result = /** @type {!Element} */
    Native.Document_createElementNS.call(this, namespace, localName);
    internals.patch(result);
    return result;
  });

  PatchParentNode(internals, Document.prototype, {
    prepend: Native.Document_prepend,
    append: Native.Document_append
  });
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchNode = function (internals) {
  // `Node#nodeValue` is implemented on `Attr`.
  // `Node#textContent` is implemented on `Attr`, `Element`.

  setPropertyUnchecked(Node.prototype, 'insertBefore',
  /**
   * @this {Node}
   * @param {!Node} node
   * @param {?Node} refNode
   * @return {!Node}
   */
  function (node, refNode) {
    if (node instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
      var _nativeResult = Native.Node_insertBefore.call(this, node, refNode);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult;
    }

    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_insertBefore.call(this, node, refNode);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'appendChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    if (node instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
      var _nativeResult2 = Native.Node_appendChild.call(this, node);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult2;
    }

    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_appendChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'cloneNode',
  /**
   * @this {Node}
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (deep) {
    var clone = Native.Node_cloneNode.call(this, deep);
    // Only create custom elements if this element's owner document is
    // associated with the registry.
    if (!this.ownerDocument.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }
    return clone;
  });

  setPropertyUnchecked(Node.prototype, 'removeChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_removeChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'replaceChild',
  /**
   * @this {Node}
   * @param {!Node} nodeToInsert
   * @param {!Node} nodeToRemove
   * @return {!Node}
   */
  function (nodeToInsert, nodeToRemove) {
    if (nodeToInsert instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(nodeToInsert.childNodes);
      var _nativeResult3 = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        internals.disconnectTree(nodeToRemove);
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult3;
    }

    var nodeToInsertWasConnected = isConnected(nodeToInsert);
    var nativeResult = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);
    var thisIsConnected = isConnected(this);

    if (thisIsConnected) {
      internals.disconnectTree(nodeToRemove);
    }

    if (nodeToInsertWasConnected) {
      internals.disconnectTree(nodeToInsert);
    }

    if (thisIsConnected) {
      internals.connectTree(nodeToInsert);
    }

    return nativeResult;
  });

  function patch_textContent(destination, baseDescriptor) {
    Object.defineProperty(destination, 'textContent', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set: /** @this {Node} */function set(assignedValue) {
        // If this is a text node then there are no nodes to disconnect.
        if (this.nodeType === Node.TEXT_NODE) {
          baseDescriptor.set.call(this, assignedValue);
          return;
        }

        var removedNodes = undefined;
        // Checking for `firstChild` is faster than reading `childNodes.length`
        // to compare with 0.
        if (this.firstChild) {
          // Using `childNodes` is faster than `children`, even though we only
          // care about elements.
          var childNodes = this.childNodes;
          var childNodesLength = childNodes.length;
          if (childNodesLength > 0 && isConnected(this)) {
            // Copying an array by iterating is faster than using slice.
            removedNodes = new Array(childNodesLength);
            for (var i = 0; i < childNodesLength; i++) {
              removedNodes[i] = childNodes[i];
            }
          }
        }

        baseDescriptor.set.call(this, assignedValue);

        if (removedNodes) {
          for (var _i = 0; _i < removedNodes.length; _i++) {
            internals.disconnectTree(removedNodes[_i]);
          }
        }
      }
    });
  }

  if (Native.Node_textContent && Native.Node_textContent.get) {
    patch_textContent(Node.prototype, Native.Node_textContent);
  } else {
    internals.addPatch(function (element) {
      patch_textContent(element, {
        enumerable: true,
        configurable: true,
        // NOTE: This implementation of the `textContent` getter assumes that
        // text nodes' `textContent` getter will not be patched.
        get: /** @this {Node} */function get() {
          /** @type {!Array<string>} */
          var parts = [];

          for (var i = 0; i < this.childNodes.length; i++) {
            parts.push(this.childNodes[i].textContent);
          }

          return parts.join('');
        },
        set: /** @this {Node} */function set(assignedValue) {
          while (this.firstChild) {
            Native.Node_removeChild.call(this, this.firstChild);
          }
          Native.Node_appendChild.call(this, document.createTextNode(assignedValue));
        }
      });
    });
  }
};

/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ChildNodeNativeMethods} builtIn
 */
var PatchChildNode = function (internals, destination, builtIn) {
  /**
   * @param {...(!Node|string)} nodes
   */
  destination['before'] = function () {
    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.before.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i = 0; _i < nodes.length; _i++) {
        var node = nodes[_i];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['after'] = function () {
    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      nodes[_key2] = arguments[_key2];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.after.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var node = nodes[_i2];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['replaceWith'] = function () {
    for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      nodes[_key3] = arguments[_key3];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    var wasConnected = isConnected(this);

    builtIn.replaceWith.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (wasConnected) {
      internals.disconnectTree(this);
      for (var _i3 = 0; _i3 < nodes.length; _i3++) {
        var node = nodes[_i3];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  destination['remove'] = function () {
    var wasConnected = isConnected(this);

    builtIn.remove.call(this);

    if (wasConnected) {
      internals.disconnectTree(this);
    }
  };
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchElement = function (internals) {
  if (Native.Element_attachShadow) {
    setPropertyUnchecked(Element.prototype, 'attachShadow',
    /**
     * @this {Element}
     * @param {!{mode: string}} init
     * @return {ShadowRoot}
     */
    function (init) {
      var shadowRoot = Native.Element_attachShadow.call(this, init);
      this.__CE_shadowRoot = shadowRoot;
      return shadowRoot;
    });
  } else {
    console.warn('Custom Elements: `Element#attachShadow` was not patched.');
  }

  function patch_innerHTML(destination, baseDescriptor) {
    Object.defineProperty(destination, 'innerHTML', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set: /** @this {Element} */function set(htmlString) {
        var _this = this;

        var isConnected$$1 = isConnected(this);

        // NOTE: In IE11, when using the native `innerHTML` setter, all nodes
        // that were previously descendants of the context element have all of
        // their children removed as part of the set - the entire subtree is
        // 'disassembled'. This work around walks the subtree *before* using the
        // native setter.
        /** @type {!Array<!Element>|undefined} */
        var removedElements = undefined;
        if (isConnected$$1) {
          removedElements = [];
          walkDeepDescendantElements(this, function (element) {
            if (element !== _this) {
              removedElements.push(element);
            }
          });
        }

        baseDescriptor.set.call(this, htmlString);

        if (removedElements) {
          for (var i = 0; i < removedElements.length; i++) {
            var element = removedElements[i];
            if (element.__CE_state === CustomElementState.custom) {
              internals.disconnectedCallback(element);
            }
          }
        }

        // Only create custom elements if this element's owner document is
        // associated with the registry.
        if (!this.ownerDocument.__CE_hasRegistry) {
          internals.patchTree(this);
        } else {
          internals.patchAndUpgradeTree(this);
        }
        return htmlString;
      }
    });
  }

  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {
    patch_innerHTML(Element.prototype, Native.Element_innerHTML);
  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {
    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);
  } else {

    /** @type {HTMLDivElement} */
    var rawDiv = Native.Document_createElement.call(document, 'div');

    internals.addPatch(function (element) {
      patch_innerHTML(element, {
        enumerable: true,
        configurable: true,
        // Implements getting `innerHTML` by performing an unpatched `cloneNode`
        // of the element and returning the resulting element's `innerHTML`.
        // TODO: Is this too expensive?
        get: /** @this {Element} */function get() {
          return Native.Node_cloneNode.call(this, true).innerHTML;
        },
        // Implements setting `innerHTML` by creating an unpatched element,
        // setting `innerHTML` of that element and replacing the target
        // element's children with those of the unpatched element.
        set: /** @this {Element} */function set(assignedValue) {
          // NOTE: re-route to `content` for `template` elements.
          // We need to do this because `template.appendChild` does not
          // route into `template.content`.
          /** @type {!Node} */
          var content = this.localName === 'template' ? /** @type {!HTMLTemplateElement} */this.content : this;
          rawDiv.innerHTML = assignedValue;

          while (content.childNodes.length > 0) {
            Native.Node_removeChild.call(content, content.childNodes[0]);
          }
          while (rawDiv.childNodes.length > 0) {
            Native.Node_appendChild.call(content, rawDiv.childNodes[0]);
          }
        }
      });
    });
  }

  setPropertyUnchecked(Element.prototype, 'setAttribute',
  /**
   * @this {Element}
   * @param {string} name
   * @param {string} newValue
   */
  function (name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_setAttribute.call(this, name, newValue);
    }

    var oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_setAttribute.call(this, name, newValue);
    newValue = Native.Element_getAttribute.call(this, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, null);
  });

  setPropertyUnchecked(Element.prototype, 'setAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   * @param {string} newValue
   */
  function (namespace, name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    }

    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    newValue = Native.Element_getAttributeNS.call(this, namespace, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
  });

  setPropertyUnchecked(Element.prototype, 'removeAttribute',
  /**
   * @this {Element}
   * @param {string} name
   */
  function (name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_removeAttribute.call(this, name);
    }

    var oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_removeAttribute.call(this, name);
    if (oldValue !== null) {
      internals.attributeChangedCallback(this, name, oldValue, null, null);
    }
  });

  setPropertyUnchecked(Element.prototype, 'removeAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   */
  function (namespace, name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_removeAttributeNS.call(this, namespace, name);
    }

    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_removeAttributeNS.call(this, namespace, name);
    // In older browsers, `Element#getAttributeNS` may return the empty string
    // instead of null if the attribute does not exist. For details, see;
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes
    var newValue = Native.Element_getAttributeNS.call(this, namespace, name);
    if (oldValue !== newValue) {
      internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
    }
  });

  function patch_insertAdjacentElement(destination, baseMethod) {
    setPropertyUnchecked(destination, 'insertAdjacentElement',
    /**
     * @this {Element}
     * @param {string} where
     * @param {!Element} element
     * @return {?Element}
     */
    function (where, element) {
      var wasConnected = isConnected(element);
      var insertedElement = /** @type {!Element} */
      baseMethod.call(this, where, element);

      if (wasConnected) {
        internals.disconnectTree(element);
      }

      if (isConnected(insertedElement)) {
        internals.connectTree(element);
      }
      return insertedElement;
    });
  }

  if (Native.HTMLElement_insertAdjacentElement) {
    patch_insertAdjacentElement(HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);
  } else if (Native.Element_insertAdjacentElement) {
    patch_insertAdjacentElement(Element.prototype, Native.Element_insertAdjacentElement);
  } else {
    console.warn('Custom Elements: `Element#insertAdjacentElement` was not patched.');
  }

  PatchParentNode(internals, Element.prototype, {
    prepend: Native.Element_prepend,
    append: Native.Element_append
  });

  PatchChildNode(internals, Element.prototype, {
    before: Native.Element_before,
    after: Native.Element_after,
    replaceWith: Native.Element_replaceWith,
    remove: Native.Element_remove
  });
};

/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

var priorCustomElements = window['customElements'];

if (!priorCustomElements || priorCustomElements['forcePolyfill'] || typeof priorCustomElements['define'] != 'function' || typeof priorCustomElements['get'] != 'function') {
  /** @type {!CustomElementInternals} */
  var internals = new CustomElementInternals();

  PatchHTMLElement(internals);
  PatchDocument(internals);
  PatchNode(internals);
  PatchElement(internals);

  // The main document is always associated with the registry.
  document.__CE_hasRegistry = true;

  /** @type {!CustomElementRegistry} */
  var customElements$1 = new CustomElementRegistry(internals);

  Object.defineProperty(window, 'customElements', {
    configurable: true,
    enumerable: true,
    value: customElements$1
  });
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function () {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function WeakMap() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function set(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value;else defineProperty(key, this.name, {
          value: [key, value],
          writable: true
        });
        return this;
      },
      get: function get(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function _delete(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function has(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function (global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function (e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function (func) {
          func();
        });
      }
    });
    setImmediate = function setImmediate(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function (o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function (observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function (node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function (registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function observe(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function disconnect() {
      this.nodes_.forEach(function (node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function takeRecords() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function enqueue(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function addListeners() {
      this.addListeners_(this.target);
    },
    addListeners_: function addListeners_(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function removeListeners() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function removeListeners_(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function addTransientObserver(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function removeTransientObservers() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function (node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function handleEvent(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
        case "DOMAttrModified":
          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;
          var record = new getRecord("attributes", target);
          record.attributeName = name;
          record.attributeNamespace = namespace;
          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
            if (!options.attributes) return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;

        case "DOMCharacterDataModified":
          var target = e.target;
          var record = getRecord("characterData", target);
          var oldValue = e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
            if (!options.characterData) return;
            if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;

        case "DOMNodeRemoved":
          this.addTransientObserver(e.target);

        case "DOMNodeInserted":
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === "DOMNodeInserted") {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          var record = getRecord("childList", e.target.parentNode);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function (options) {
            if (!options.childList) return;
            return record;
          });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function () {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                new Function("" + handler)();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(self);

// Caution:
// Do not replace this import statement with codes.
//
// If you replace this import statement with codes,
// the codes will be executed after the following polyfills are imported
// because import statements are hoisted during compilation.
// Polyfill ECMAScript standard features with global namespace pollution
// Polyfill Custom Elements v1 with global namespace pollution
// Polyfill MutationObserver with global namespace pollution
// Polyfill setImmediate with global namespace pollution

(function () {
	'use strict';

	/**
  * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
  *
  * @codingstandard ftlabs-jsv2
  * @copyright The Financial Times Limited [All Rights Reserved]
  * @license MIT License (see LICENSE.txt)
  */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/

	/**
  * Instantiate fast-clicking listeners on the specified layer.
  *
  * @constructor
  * @param {Element} layer The layer to listen on
  * @param {Object} [options={}] The options to override the defaults
  */

	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
   * Whether a click is currently being tracked.
   *
   * @type boolean
   */
		this.trackingClick = false;

		/**
   * Timestamp for when click tracking started.
   *
   * @type number
   */
		this.trackingClickStart = 0;

		/**
   * The element being tracked for a click.
   *
   * @type EventTarget
   */
		this.targetElement = null;

		/**
   * X-coordinate of touch start event.
   *
   * @type number
   */
		this.touchStartX = 0;

		/**
   * Y-coordinate of touch start event.
   *
   * @type number
   */
		this.touchStartY = 0;

		/**
   * ID of the last touch, retrieved from Touch.identifier.
   *
   * @type number
   */
		this.lastTouchIdentifier = 0;

		/**
   * Touchmove boundary, beyond which a click will be cancelled.
   *
   * @type number
   */
		this.touchBoundary = options.touchBoundary || 10;

		/**
   * The FastClick layer.
   *
   * @type Element
   */
		this.layer = layer;

		/**
   * The minimum time between tap(touchstart and touchend) events
   *
   * @type number
   */
		this.tapDelay = options.tapDelay || 200;

		/**
   * The maximum time for a tap
   *
   * @type number
   */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function () {
				return method.apply(context, arguments);
			};
		}

		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function (type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function (type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function (event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
 * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
 *
 * @type boolean
 */
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
  * Android requires exceptions.
  *
  * @type boolean
  */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;

	/**
  * iOS requires exceptions.
  *
  * @type boolean
  */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;

	/**
  * iOS 4 requires an exception for select elements.
  *
  * @type boolean
  */
	var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);

	/**
  * iOS 6.0-7.* requires the target element to be manually derived
  *
  * @type boolean
  */
	var deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);

	/**
  * BlackBerry requires exceptions.
  *
  * @type boolean
  */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
  * Determine whether a given element requires a native click.
  *
  * @param {EventTarget|Element} target Target DOM element
  * @returns {boolean} Returns true if the element needs a native click
  */
	FastClick.prototype.needsClick = function (target) {
		switch (target.nodeName.toLowerCase()) {

			// Don't send a synthetic click to disabled inputs (issue #62)
			case 'button':
			case 'select':
			case 'textarea':
				if (target.disabled) {
					return true;
				}

				break;
			case 'input':

				// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
				if (deviceIsIOS && target.type === 'file' || target.disabled) {
					return true;
				}

				break;
			case 'label':
			case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
			case 'video':
				return true;
		}

		return (/\bneedsclick\b/.test(target.className)
		);
	};

	/**
  * Determine whether a given element requires a call to focus to simulate click into element.
  *
  * @param {EventTarget|Element} target Target DOM element
  * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
  */
	FastClick.prototype.needsFocus = function (target) {
		switch (target.nodeName.toLowerCase()) {
			case 'textarea':
				return true;
			case 'select':
				return !deviceIsAndroid;
			case 'input':
				switch (target.type) {
					case 'button':
					case 'checkbox':
					case 'file':
					case 'image':
					case 'radio':
					case 'submit':
						return false;
				}

				// No point in attempting to focus disabled inputs
				return !target.disabled && !target.readOnly;
			default:
				return (/\bneedsfocus\b/.test(target.className)
				);
		}
	};

	/**
  * Send a click event to the specified element.
  *
  * @param {EventTarget|Element} targetElement
  * @param {Event} event
  */
	FastClick.prototype.sendClick = function (targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function (targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};

	/**
  * @param {EventTarget|Element} targetElement
  */
	FastClick.prototype.focus = function (targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};

	/**
  * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
  *
  * @param {EventTarget|Element} targetElement
  */
	FastClick.prototype.updateScrollParent = function (targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};

	/**
  * @param {EventTarget} targetElement
  * @returns {Element|EventTarget}
  */
	FastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};

	/**
  * On touch start, record the position and scroll offset.
  *
  * @param {Event} event
  * @returns {boolean}
  */
	FastClick.prototype.onTouchStart = function (event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		// Ignore touches on contenteditable elements to prevent conflict with text selection.
		// (For details: https://github.com/ftlabs/fastclick/pull/211 )
		if (targetElement.isContentEditable) {
			return true;
		}

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
			event.preventDefault();
		}

		return true;
	};

	/**
  * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
  *
  * @param {Event} event
  * @returns {boolean}
  */
	FastClick.prototype.touchHasMoved = function (event) {
		var touch = event.changedTouches[0],
		    boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};

	/**
  * Update the last position.
  *
  * @param {Event} event
  * @returns {boolean}
  */
	FastClick.prototype.onTouchMove = function (event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};

	/**
  * Attempt to find the labelled control for the given label element.
  *
  * @param {EventTarget|HTMLLabelElement} labelElement
  * @returns {Element|null}
  */
	FastClick.prototype.findControl = function (labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};

	/**
  * On touch end, determine whether to send a click event at once.
  *
  * @param {Event} event
  * @returns {boolean}
  */
	FastClick.prototype.onTouchEnd = function (event) {
		var forElement,
		    trackingClickStart,
		    targetTagName,
		    scrollParent,
		    touch,
		    targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === 'input') {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};

	/**
  * On touch cancel, stop tracking the click.
  *
  * @returns {void}
  */
	FastClick.prototype.onTouchCancel = function () {
		this.trackingClick = false;
		this.targetElement = null;
	};

	/**
  * Determine mouse events which should be permitted.
  *
  * @param {Event} event
  * @returns {boolean}
  */
	FastClick.prototype.onMouse = function (event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};

	/**
  * On actual clicks, determine whether this is a touch-generated click, a click action occurring
  * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
  * an actual click which should be permitted.
  *
  * @param {Event} event
  * @returns {boolean}
  */
	FastClick.prototype.onClick = function (event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};

	/**
  * Remove all FastClick's event listeners.
  *
  * @returns {void}
  */
	FastClick.prototype.destroy = function () {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};

	/**
  * Check whether FastClick is needed.
  *
  * @param {Element} layer The layer to listen on
  */
	FastClick.notNeeded = function (layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

				// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};

	/**
  * Factory method for creating a FastClick object
  *
  * @param {Element} layer The layer to listen on
  * @param {Object} [options={}] The options to override the defaults
  */
	FastClick.attach = function (layer, options) {
		return new FastClick(layer, options);
	};

	window.FastClick = FastClick;
})();

(function () {
  var DEFAULT_VIEWPORT = 'width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no';

  var Viewport = {
    ensureViewportElement: function ensureViewportElement() {
      var viewportElement = document.querySelector('meta[name=viewport]');

      if (!viewportElement) {
        viewportElement = document.createElement('meta');
        viewportElement.name = 'viewport';
        document.head.appendChild(viewportElement);
      }

      return viewportElement;
    },

    setup: function setup() {
      var viewportElement = Viewport.ensureViewportElement();

      if (!viewportElement) {
        return;
      }

      if (!viewportElement.hasAttribute('content')) {
        viewportElement.setAttribute('content', DEFAULT_VIEWPORT);
      }
    }
  };

  window.Viewport = Viewport;
})();

// Load non-polyfill libraries
// import './microevent.js@47cbc14+mod/microevent.js';

function setup$1(ons) {
  if (window.ons) {
    ons._util.warn('Onsen UI is loaded more than once.');
  }

  // fastclick
  window.addEventListener('load', function () {
    ons.fastClick = FastClick.attach(document.body);

    var supportTouchAction = 'touch-action' in document.body.style;

    ons.platform._runOnActualPlatform(function () {
      if (ons.platform.isAndroid()) {
        // In Android4.4+, correct viewport settings can remove click delay.
        // So disable FastClick on Android.
        ons.fastClick.destroy();
      } else if (ons.platform.isIOS()) {
        if (supportTouchAction && (ons.platform.isIOSSafari() || ons.platform.isWKWebView())) {
          // If 'touch-action' supported in iOS Safari or WKWebView, disable FastClick.
          ons.fastClick.destroy();
        } else {
          // Do nothing. 'touch-action: manipulation' has no effect on UIWebView.
        }
      }
    });
  }, false);

  ons.ready(function () {
    ons.enableDeviceBackButtonHandler();
    ons._defaultDeviceBackButtonHandler = ons._internal.dbbDispatcher.createHandler(window.document.body, function () {
      if (Object.hasOwnProperty.call(navigator, 'app')) {
        navigator.app.exitApp();
      } else {
        console.warn('Could not close the app. Is \'cordova.js\' included?\nError: \'window.navigator.app\' is undefined.');
      }
    });
    document.body._gestureDetector = new ons.GestureDetector(document.body);

    // Simulate Device Back Button on ESC press
    if (!ons.platform.isWebView()) {
      document.body.addEventListener('keydown', function (event) {
        if (event.keyCode === 27) {
          ons.fireDeviceBackButtonEvent();
        }
      });
    }

    // setup loading placeholder
    ons._setupLoadingPlaceHolders();
  });

  // viewport.js
  Viewport.setup();
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

function getElementClass() {
  if (typeof HTMLElement !== 'function') {
    // case of Safari
    var _BaseElement = function _BaseElement() {};
    _BaseElement.prototype = document.createElement('div');
    return _BaseElement;
  } else {
    return HTMLElement;
  }
}

var BaseElement = function (_getElementClass) {
  inherits(BaseElement, _getElementClass);

  function BaseElement() {
    classCallCheck(this, BaseElement);
    return possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this));
  }

  return BaseElement;
}(getElementClass());

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-template
 * @category util
 * @description
 *   [en]
 *     Define a separate HTML fragment and use as a template. These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs. Since Onsen UI 2.4.0, the native `<template>` element can be used instead of `<ons-template>` for better performance and features. `<ons-template>` is still supported for backward compatibility.
 *   [/en]
 *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
 * @seealso ons-navigator
 *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-tabbar
 *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-splitter
 *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
 *   [ja][/ja]
 * @example
 * <ons-template id="foobar.html">
 *   <ons-page>
 *     Page content
 *   </ons-page>
 * </ons-template>
 *
 * <ons-navigator page="foobar.html"></ons-navigator>
 */

var TemplateElement = function (_BaseElement) {
  inherits(TemplateElement, _BaseElement);

  /**
   * @property template
   * @type {String}
   * @description
   *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
   *  [ja][/ja]
   */

  function TemplateElement() {
    classCallCheck(this, TemplateElement);

    var _this = possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).call(this));

    _this.template = _this.innerHTML;

    while (_this.firstChild) {
      _this.removeChild(_this.firstChild);
    }
    return _this;
  }

  createClass(TemplateElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (this.parentNode) {
        // Note: this.parentNode is not set in some CE0/CE1 polyfills.
        // Show warning when the ons-template is not located just under document.body
        if (this.parentNode !== document.body) {
          // if the parent is not document.body
          util.warn('ons-template (id = ' + this.getAttribute('id') + ') must be located just under document.body' + (this.parentNode.outerHTML ? ':\n\n' + this.parentNode.outerHTML : '.'));
        }
      }

      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
      event.template = this.template;
      event.templateId = this.getAttribute('id');

      this.dispatchEvent(event);
    }
  }]);
  return TemplateElement;
}(BaseElement);

ons$1.elements.Template = TemplateElement;
customElements.define('ons-template', TemplateElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-if
 * @category conditional
 * @tutorial vanilla/Reference/if
 * @description
 *   [en]
 *     Conditionally display content depending on the platform, device orientation or both.
 *
 *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
 *   [/en]
 *   [ja][/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-page>
 *   <ons-if orientation="landscape">
 *     Landscape view!
 *   </ons-if>
 *   <ons-if platform="android">
 *     This is Android.
 *   </ons-if>
 *   <ons-if platform="ios other">
 *     This is not Android.
 *   </ons-if>
 * </ons-page>
 */

var IfElement = function (_BaseElement) {
  inherits(IfElement, _BaseElement);

  /**
   * @attribute platform
   * @initonly
   * @type {string}
   * @description
   *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute orientation
   * @type {string}
   * @description
   *  [en]Either `"portrait"` or `"landscape"`.[/en]
   *  [ja]portraitもしくはlandscapeを指定します[/ja]
   */

  function IfElement() {
    classCallCheck(this, IfElement);

    var _this = possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).call(this));

    contentReady(_this, function () {
      if (platform._getSelectedPlatform() !== null) {
        _this._platformUpdate();
      } else if (!_this._isAllowedPlatform()) {
        while (_this.childNodes[0]) {
          _this.childNodes[0].remove();
        }
        _this._platformUpdate();
      }
    });

    _this._onOrientationChange();
    return _this;
  }

  createClass(IfElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      orientation.on('change', this._onOrientationChange.bind(this));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name) {
      if (name === 'orientation') {
        this._onOrientationChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      orientation.off('change', this._onOrientationChange);
    }
  }, {
    key: '_platformUpdate',
    value: function _platformUpdate() {
      this.style.display = this._isAllowedPlatform() ? '' : 'none';
    }
  }, {
    key: '_isAllowedPlatform',
    value: function _isAllowedPlatform() {
      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
    }
  }, {
    key: '_onOrientationChange',
    value: function _onOrientationChange() {
      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['orientation'];
    }
  }]);
  return IfElement;
}(BaseElement);

ons$1.elements.If = IfElement;
customElements.define('ons-if', IfElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function BaseAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, BaseAnimator);

    this.timing = options.timing || 'linear';
    this.duration = options.duration || 0;
    this.delay = options.delay || 0;
  }

  createClass(BaseAnimator, null, [{
    key: 'extend',
    value: function extend() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var extendedAnimator = this;
      var newAnimator = function newAnimator() {
        extendedAnimator.apply(this, arguments);
        util.extend(this, properties);
      };

      newAnimator.prototype = this.prototype;
      return newAnimator;
    }
  }]);
  return BaseAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ActionSheetAnimator = function (_BaseAnimator) {
  inherits(ActionSheetAnimator, _BaseAnimator);

  function ActionSheetAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ActionSheetAnimator);
    return possibleConstructorReturn(this, (ActionSheetAnimator.__proto__ || Object.getPrototypeOf(ActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(ActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return ActionSheetAnimator;
}(BaseAnimator);

/**
 * Android style animator for Action Sheet.
 */
var MDActionSheetAnimator = function (_ActionSheetAnimator) {
  inherits(MDActionSheetAnimator, _ActionSheetAnimator);

  function MDActionSheetAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.4 : _ref2$duration;

    classCallCheck(this, MDActionSheetAnimator);

    var _this2 = possibleConstructorReturn(this, (MDActionSheetAnimator.__proto__ || Object.getPrototypeOf(MDActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this2.maskTiming = 'linear';
    _this2.maskDuration = 0.2;
    return _this2;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(MDActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet).saveStyle().queue({
        css: {
          transform: 'translate3d(0, 80%, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet).saveStyle().queue({
        css: {
          transform: 'translate3d(0, 0, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(0, 80%, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }]);
  return MDActionSheetAnimator;
}(ActionSheetAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSActionSheetAnimator = function (_ActionSheetAnimator2) {
  inherits(IOSActionSheetAnimator, _ActionSheetAnimator2);

  function IOSActionSheetAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;

    classCallCheck(this, IOSActionSheetAnimator);

    var _this3 = possibleConstructorReturn(this, (IOSActionSheetAnimator.__proto__ || Object.getPrototypeOf(IOSActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this3.maskTiming = 'linear';
    _this3.maskDuration = 0.2;
    _this3.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this3;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet).saveStyle().queue({
        css: {
          transform: 'translate3d(0, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet).saveStyle().queue({
        css: {
          transform: 'translate3d(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }]);
  return IOSActionSheetAnimator;
}(ActionSheetAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseDialogElement = function (_BaseElement) {
  inherits(BaseDialogElement, _BaseElement);
  createClass(BaseDialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      throw new Error('_updateAnimatorFactory method must be implemented.');
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      this.style.display = shouldShow ? 'block' : 'none';
    }
  }, {
    key: '_scheme',
    get: function get$$1() {
      throw new Error('_scheme getter must be implemented.');
    }
  }]);

  function BaseDialogElement() {
    classCallCheck(this, BaseDialogElement);

    var _this = possibleConstructorReturn(this, (BaseDialogElement.__proto__ || Object.getPrototypeOf(BaseDialogElement)).call(this));

    _this._visible = false;
    _this._doorLock = new DoorLock();
    _this._cancel = _this._cancel.bind(_this);
    _this._selfCamelName = util.camelize(_this.tagName.slice(4));
    _this._defaultDBB = function (e) {
      return _this.cancelable ? _this._cancel() : e.callParentHandler();
    };
    _this._animatorFactory = _this._updateAnimatorFactory();
    return _this;
  }

  createClass(BaseDialogElement, [{
    key: '_cancel',
    value: function _cancel() {
      var _this2 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this2._running = false;
          util.triggerElementEvent(_this2, 'dialog-cancel');
        }, function () {
          return _this2._running = false;
        });
      }
    }
  }, {
    key: '_preventScroll',
    value: function _preventScroll(event) {
      event.cancelable && event.preventDefault();
    }
  }, {
    key: 'show',
    value: function show() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this._setVisible.apply(this, [true].concat(args));
    }
  }, {
    key: 'hide',
    value: function hide() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this._setVisible.apply(this, [false].concat(args));
    }
  }, {
    key: 'toggle',
    value: function toggle() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this._setVisible.apply(this, [!this.visible].concat(args));
    }
  }, {
    key: '_setVisible',
    value: function _setVisible(shouldShow) {
      var _util$triggerElementE,
          _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var action = shouldShow ? 'show' : 'hide';

      options = _extends({}, options);
      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var canceled = false;
      util.triggerElementEvent(this, 'pre' + action, (_util$triggerElementE = {}, defineProperty(_util$triggerElementE, this._selfCamelName, this), defineProperty(_util$triggerElementE, 'cancel', function cancel() {
        return canceled = true;
      }), _util$triggerElementE));

      if (canceled) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      return new Promise(function (resolve) {
        _this3._doorLock.waitUnlock(function () {
          var unlock = _this3._doorLock.lock();
          var animator = _this3._animatorFactory.newAnimator(options);

          shouldShow && _this3._toggleStyle(true, options);

          contentReady(_this3, function () {
            animator[action](_this3, function () {
              !shouldShow && _this3._toggleStyle(false, options);
              _this3._visible = shouldShow;

              unlock();

              util.propagateAction(_this3, '_' + action);
              util.triggerElementEvent(_this3, 'post' + action, defineProperty({}, _this3._selfCamelName, _this3)); // postshow posthide

              if (options.callback instanceof Function) {
                options.callback(_this3);
              }

              resolve(_this3);
            });
          });
        });
      });
    }
  }, {
    key: '_updateMask',
    value: function _updateMask() {
      var _this4 = this;

      contentReady(this, function () {
        if (_this4._mask && _this4.getAttribute('mask-color')) {
          _this4._mask.style.backgroundColor = _this4.getAttribute('mask-color');
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this5 = this;

      this.onDeviceBackButton = this._defaultDBB.bind(this);

      contentReady(this, function () {
        if (_this5._mask) {
          _this5._mask.addEventListener('click', _this5._cancel, false);
          _this5._mask.addEventListener('touchmove', _this5._preventScroll, false); // iOS fix
        }
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      if (this._mask) {
        this._mask.removeEventListener('click', this._cancel, false);
        this._mask.removeEventListener('touchmove', this._preventScroll, false);
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, this._scheme);
          break;
        case 'animation':
          this._animatorFactory = this._updateAnimatorFactory();
          break;
        case 'mask-color':
          this._updateMask();
          break;
      }
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      return this._visible;
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: 'cancelable',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'cancelable', value);
    },
    get: function get$$1() {
      return this.hasAttribute('cancelable');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'animation', 'mask-color'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];
    }
  }]);
  return BaseDialogElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme = {
  '.action-sheet': 'action-sheet--*',
  '.action-sheet-mask': 'action-sheet-mask--*',
  '.action-sheet-title': 'action-sheet-title--*'
};

var _animatorDict = {
  'default': function _default() {
    return platform.isAndroid() ? MDActionSheetAnimator : IOSActionSheetAnimator;
  },
  'none': ActionSheetAnimator
};

/**
 * @element ons-action-sheet
 * @category dialog
 * @description
 *   [en]
 *     Action/bottom sheet that is displayed on top of current screen.
 *
 *     This element can either be attached directly to the `<body>` or dynamically created from a template using the `ons.createElement(template, { append: true })` utility function and the `<ons-template>` tag.
 *
 *     The action sheet is useful for displaying a list of options and asking the user to make a decision. A `ons-action-sheet-button` is provided for this purpose, although it can contain any type of content.
 *
 *     It will automatically be displayed as Material Design (bottom sheet) when running on an Android device.
 *   [/en]
 *   [ja]
 *     アクションシート、もしくはボトムシートを現在のスクリーン上に表示します。
 *
 *     この要素は、`<body>`要素に直接アタッチされるか、もしくは`ons.createElement(template, { append: true })`と`<ons-template>`タグを使ってテンプレートから動的に生成されます。
 *
 *     アクションシートは、選択肢のリストを表示してユーザーに尋ねるのに便利です。`ons-action-sheet-button`は、この要素の中に置くために提供されていますが、それ以外にも他のどのような要素を含むことができます。
 *
 *     Androidデバイスで実行されるときには、自動的にマテリアルデザイン(ボトムシート)として表示されます。
 *   [/ja]
 * @modifier material
 *   [en]Display a Material Design bottom sheet.[/en]
 *   [ja]マテリアルデザインのボトムシートを表示します。[/ja]
 * @tutorial vanilla/reference/action-sheet
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-action-sheet id="sheet">
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 * </ons-action-sheet>
 *
 * <script>
 *   document.getElementById('sheet').show();
 * </script>
 */

var ActionSheetElement = function (_BaseDialogElement) {
  inherits(ActionSheetElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the action sheet is displayed.[/en]
   * [ja]ダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the action sheet from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the action sheet is displayed.[/en]
   * [ja]ダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the action sheet is hidden.[/en]
   * [ja]ダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the action sheet from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the action sheet is hidden.[/en]
   * [ja]ダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute title
   * @type {String}
   * @description
   *  [en]Optional title of the action sheet. A new element will be created containing this string.[/en]
   *  [ja]アクションシートのタイトルを指定します。ここで指定した文字列を含む新しい要素が作成されます。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the action sheet.[/en]
   *  [ja]ダイアログの表現を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja]この属性が設定されると、アクションシートの背景やAndroidデバイスのバックボタンを推すことでアクションシートが閉じるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the action sheet is disabled.[/en]
   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the action sheet. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function ActionSheetElement() {
    classCallCheck(this, ActionSheetElement);

    var _this = possibleConstructorReturn(this, (ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ActionSheetElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict,
        baseClass: ActionSheetAnimator,
        baseClassName: 'ActionSheetAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-action-sheet>
       *     <div class="action-sheet-mask"></div>
       *     <div class="action-sheet">
       *       <div class="action-sheet-title></div>
       *       ...
       *     </div>
       *   </ons-action-sheet>
       */

      if (!this._sheet) {
        var sheet = document.createElement('div');
        sheet.classList.add('action-sheet');

        while (this.firstChild) {
          sheet.appendChild(this.firstChild);
        }

        this.appendChild(sheet);
      }

      if (!this._title && this.hasAttribute('title')) {
        var title = document.createElement('div');
        title.innerHTML = this.getAttribute('title');
        title.classList.add('action-sheet-title');
        this._sheet.insertBefore(title, this._sheet.firstChild);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('action-sheet-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._sheet.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateTitle',
    value: function _updateTitle() {
      if (this._title) {
        this._title.innerHTML = this.getAttribute('title');
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the action sheet has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the action sheet.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the action sheet has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the action sheet.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja]隠れた要素を解決します。[/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is cancelable or not. A cancelable action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja]アクションシートがキャンセル可能かどうかを設定します。キャンセル可能なアクションシートは、背景をタップしたりAndroidデバイスのバックボタンを推すことで閉じるようになります。[/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'title') {
        this._updateTitle();
      } else {
        get(ActionSheetElement.prototype.__proto__ || Object.getPrototypeOf(ActionSheetElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @param {String} name
     * @param {ActionSheetAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util.findChild(this, '.action-sheet-mask');
    }
  }, {
    key: '_sheet',
    get: function get$$1() {
      return util.findChild(this, '.action-sheet');
    }
  }, {
    key: '_title',
    get: function get$$1() {
      return this.querySelector('.action-sheet-title');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ActionSheetAnimator)) {
        throw new Error('"Animator" param must inherit OnsActionSheetElement.ActionSheetAnimator');
      }
      _animatorDict[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement), 'observedAttributes', this)), ['title']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict;
    }
  }, {
    key: 'ActionSheetAnimator',
    get: function get$$1() {
      return ActionSheetAnimator;
    }
  }]);
  return ActionSheetElement;
}(BaseDialogElement);

ons$1.elements.ActionSheet = ActionSheetElement;
customElements.define('ons-action-sheet', ActionSheetElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName = 'action-sheet-button';
var scheme$1 = {
  '': 'action-sheet-button--*',
  '.action-sheet-icon': 'action-sheet-icon--*'
};

/**
 * @element ons-action-sheet-button
 * @category dialog
 * @modifier destructive
 *   [en]Shows a "destructive" button (only for iOS).[/en]
 *   [ja]"destructive"なボタンを表示します(iOSでのみ有効)。[/ja]
 * @description
 *   [en]Component that represent each button of the action sheet.[/en]
 *   [ja]アクションシートに表示される各ボタンを表現するコンポーネントです。[/ja]
 * @seealso ons-action-sheet
 *   [en]The `<ons-action-sheet>` component[/en]
 *   [ja]ons-action-sheetコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]The `<ons-icon>` component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @tutorial vanilla/Reference/action-sheet
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @modifier material
 *   [en]Display a Material Design action sheet button.[/en]
 *   [ja]マテリアルデザインのアクションシート用のボタンを表示します。[/ja]
 * @example
 * <ons-action-sheet id="sheet">
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 * </ons-action-sheet>
 *
 * <script>
 *   document.getElementById('sheet').show();
 * </script>
 */

var ActionSheetButtonElement = function (_BaseElement) {
  inherits(ActionSheetButtonElement, _BaseElement);

  /**
   * @attribute icon
   * @type {String}
   * @description
   *  [en]Creates an `ons-icon` component with this string. Only visible on Android. Check [See also](#seealso) section for more information.[/en]
   *  [ja]`ons-icon`コンポーネントを悪性します。Androidでのみ表示されます。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the action sheet button.[/en]
   *   [ja]アクションシートボタンの見た目を設定します。[/ja]
   */

  function ActionSheetButtonElement() {
    classCallCheck(this, ActionSheetButtonElement);

    var _this = possibleConstructorReturn(this, (ActionSheetButtonElement.__proto__ || Object.getPrototypeOf(ActionSheetButtonElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ActionSheetButtonElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName);

      if (!this._icon && this.hasAttribute('icon')) {
        var icon = util.createElement('<ons-icon icon="' + this.getAttribute('icon') + '"></ons-icon>');
        icon.classList.add('action-sheet-icon');
        this.insertBefore(icon, this.firstChild);
      }

      ModifierUtil.initModifier(this, scheme$1);
    }
  }, {
    key: '_updateIcon',
    value: function _updateIcon() {
      if (this._icon) {
        this._icon.setAttribute('icon', this.getAttribute('icon'));
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName, scheme$1);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$1);
          break;
        case 'icon':
          this._updateIcon();
          break;
      }
    }
  }, {
    key: '_icon',
    get: function get$$1() {
      return util.findChild(this, '.action-sheet-icon');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class', 'icon'];
    }
  }]);
  return ActionSheetButtonElement;
}(BaseElement);

ons$1.elements.ActionSheetButton = ActionSheetButtonElement;
customElements.define('ons-action-sheet-button', ActionSheetButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AlertDialogAnimator = function (_BaseAnimator) {
  inherits(AlertDialogAnimator, _BaseAnimator);

  function AlertDialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, AlertDialogAnimator);
    return possibleConstructorReturn(this, (AlertDialogAnimator.__proto__ || Object.getPrototypeOf(AlertDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(AlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return AlertDialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for alert dialog.
 */
var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

  function AndroidAlertDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, AndroidAlertDialogAnimator);
    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidAlertDialogAnimator;
}(AlertDialogAnimator);

/**
 * iOS style animator for alert dialog.
 */
var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

  function IOSAlertDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay;

    classCallCheck(this, IOSAlertDialogAnimator);
    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /*
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSAlertDialogAnimator;
}(AlertDialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$2 = {
  '.alert-dialog': 'alert-dialog--*',
  '.alert-dialog-container': 'alert-dialog-container--*',
  '.alert-dialog-title': 'alert-dialog-title--*',
  '.alert-dialog-content': 'alert-dialog-content--*',
  '.alert-dialog-footer': 'alert-dialog-footer--*',
  '.alert-dialog-footer--rowfooter': 'alert-dialog-footer--rowfooter--*',
  '.alert-dialog-button--rowfooter': 'alert-dialog-button--rowfooter--*',
  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
  '.alert-dialog-button': 'alert-dialog-button--*',
  'ons-alert-dialog-button': 'alert-dialog-button--*',
  '.alert-dialog-mask': 'alert-dialog-mask--*',
  '.text-input': 'text-input--*'
};

var _animatorDict$1 = {
  'none': AlertDialogAnimator,
  'default': function _default() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  }
};

/**
 * @element ons-alert-dialog
 * @category dialog
 * @description
 *   [en]
 *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
 *   [/en]
 *   [ja]
 *     現在のスクリーンの上に表示するアラートダイアログです。ユーザに対する問いかけ、警告、エラーメッセージを表示するのに利用できます。タイトルやコンテンツやボタンは簡単にカスタマイズでき、実行しているプラットフォームに併せてスタイルが自動的に切り替わります。
 *   [/ja]
 * @codepen Qwwxyp
 * @tutorial vanilla/Reference/dialog
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja]マテリアルデザインのスタイル[/ja]
 * @modifier rowfooter
 *   [en]Horizontally aligns the footer buttons.[/en]
 *   [ja]フッターの複数のボタンを水平に配置[/ja]
 * @seealso ons-dialog
 *   [en]ons-dialog component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]ons-popover component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons.notification
 *   [en]Using ons.notification utility functions.[/en]
 *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
 * @example
 * <ons-alert-dialog id="alert-dialog">
 *   <div class="alert-dialog-title">Warning!</div>
 *   <div class="alert-dialog-content">
 *     An error has occurred!
 *   </div>
 *   <div class="alert-dialog-footer">
 *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
 *   </div>
 * </ons-alert-dialog>
 * <script>
 *   document.getElementById('alert-dialog').show();
 * </script>
 */

var AlertDialogElement = function (_BaseDialogElement) {
  inherits(AlertDialogElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   *   [en]Fired just before the alert dialog is displayed.[/en]
   *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute to stop the dialog from showing.[/en]
   *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
   */

  /**
   * @event postshow
   * @description
   *   [en]Fired just after the alert dialog is displayed.[/en]
   *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   *   [en]Fired just before the alert dialog is hidden.[/en]
   *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute to stop the dialog from hiding.[/en]
   *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the alert dialog is hidden.[/en]
   * [ja]アラートダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the dialog.[/en]
   *  [ja]ダイアログの見た目を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja]この属性を設定すると、ダイアログの背景をタップしたりAndroidデバイスのバックボタンを押すとダイアログが閉じるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the dialog is disabled.[/en]
   *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function AlertDialogElement() {
    classCallCheck(this, AlertDialogElement);

    var _this = possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(AlertDialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$1,
        baseClass: AlertDialogAnimator,
        baseClassName: 'AlertDialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /**
       * Expected result after compile:
       *
       * <ons-alert-dialog style="none">
       *   <div class="alert-dialog-mask"></div>
       *   <div class="alert-dialog">
       *     <div class="alert-dialog-container">...</div>
       *   </div>
       * </ons-alert-dialog>
       */

      var content = document.createDocumentFragment();

      if (!this._mask && !this._dialog) {
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('alert-dialog-mask');
        this.insertBefore(mask, this.children[0]);
      }

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('alert-dialog');
        this.insertBefore(dialog, null);
      }

      if (!util.findChild(this._dialog, '.alert-dialog-container')) {
        var container = document.createElement('div');
        container.classList.add('alert-dialog-container');
        this._dialog.appendChild(container);
      }

      this._dialog.children[0].appendChild(content);

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja]そのダイアログがキャンセル可能かどうかを表します。キャンセル可能なダイアログは、背景をタップするかAndroidデバイスのバックボタンを押すことで閉じることが出来るようになります。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクトです。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。指定できるのは、"fade", "none"のいずれかです。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Show the alert dialog.[/en]
     *   [ja]ダイアログを表示します。[/ja]
     * @return {Promise}
     *   [en]A `Promise` object that resolves to the displayed element.[/en]
     *   [ja]表示される要素を解決する`Promise`オブジェクトを返します。[/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。"fade", "none"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been hidden.[/en]
     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Hide the alert dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja]隠れた要素を解決する`Promise`オブジェクトを返します。[/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$2;
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_mask',
    get: function get$$1() {
      return util.findChild(this, '.alert-dialog-mask');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_dialog',
    get: function get$$1() {
      return util.findChild(this, '.alert-dialog');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_titleElement',
    get: function get$$1() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-title');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_contentElement',
    get: function get$$1() {
      return util.findChild(this._dialog.children[0], '.alert-dialog-content');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof AlertDialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
      }
      _animatorDict$1[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$1;
    }
  }, {
    key: 'AlertDialogAnimator',
    get: function get$$1() {
      return AlertDialogAnimator;
    }
  }]);
  return AlertDialogElement;
}(BaseDialogElement);

ons$1.elements.AlertDialog = AlertDialogElement;
customElements.define('ons-alert-dialog', AlertDialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$1 = 'alert-dialog-button';

var scheme$3 = { '': 'alert-dialog-button--*' };

/**
 * @element ons-alert-dialog-button
 * @modifier material
 *   [en]Material Design alert-dialog button.[/en]
 *   [ja]マテリアルデザインのボタンを表示します。[/ja]
 * @description
 *   [en][/en]
 *   [ja][/ja]
 * @seealso ons-alert-dialog
 *   [en]The `<ons-alert-dialog>` component displays a alert dialog.[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @example
 *  <ons-alert-dialog>
 *    <div class="alert-dialog-title">Warning!</div>
 *    <div class="alert-dialog-content">
 *      An error has occurred!
 *    </div>
 *    <div class="alert-dialog-footer">
 *      <alert-dialog-button onclick="app.close()">Cancel</alert-dialog-button>
 *      <alert-dialog-button class="alert-dialog-button" onclick="app.close()">OK</alert-dialog-button>
 *    </div>
 *  </ons-alert-dialog>
 */

var AlertDialogButtonElement = function (_BaseElement) {
  inherits(AlertDialogButtonElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the button.[/en]
   *   [ja]ボタンの表現を指定します。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定してください。[/ja]
   */

  function AlertDialogButtonElement() {
    classCallCheck(this, AlertDialogButtonElement);

    var _this = possibleConstructorReturn(this, (AlertDialogButtonElement.__proto__ || Object.getPrototypeOf(AlertDialogButtonElement)).call(this));

    _this._compile();
    return _this;
  }

  /**
   * @property disabled
   * @type {Boolean}
   * @description
   *   [en]Whether the element is disabled or not.[/en]
   *   [ja]無効化されている場合に`true`。[/ja]
   */


  createClass(AlertDialogButtonElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$1);

      util.updateRipple(this, undefined, { 'modifier': 'light-gray' });

      ModifierUtil.initModifier(this, scheme$3);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$1, scheme$3);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return AlertDialogButtonElement;
}(BaseElement);

ons$1.elements.AlertDialogButton = AlertDialogButtonElement;
customElements.define('ons-alert-dialog-button', AlertDialogButtonElement);

var iosBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"13px\" height=\"21px\" viewBox=\"0 0 13 21\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>ios-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"ios\" transform=\"translate(-34.000000, -30.000000)\">\n            <polygon id=\"ios-back-button-icon\" points=\"34 40.5 44.5 30 46.5 32 38 40.5 46.5 49 44.5 51\"></polygon>\n        </g>\n    </g>\n</svg>\n";

var mdBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>md-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"android\" transform=\"translate(-32.000000, -32.000000)\" fill-rule=\"nonzero\">\n            <polygon id=\"md-back-button-icon\" points=\"48 39 35.83 39 41.42 33.41 40 32 32 40 40 48 41.41 46.59 35.83 41 48 41\"></polygon>\n        </g>\n    </g>\n</svg>\n";

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$2 = 'back-button';

var scheme$4 = {
  '': 'back-button--*',
  '.back-button__icon': 'back-button--*__icon',
  '.back-button__label': 'back-button--*__label'
};

/**
 * @element ons-back-button
 * @category navigation
 * @description
 *   [en]
 *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
 *
 *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
 *   [/en]
 *   [ja][/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/navigator
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar
 *   [en]ons-toolbar component[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-navigator
 *   [en]ons-navigator component[/en]
 *   [ja]ons-navigatorコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-back-button>Back</ons-back-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   <div>
 * </ons-toolbar>
 */

var BackButtonElement = function (_BaseElement) {
  inherits(BackButtonElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the back button.[/en]
   *  [ja]バックボタンの見た目を指定します。[/ja]
   */

  function BackButtonElement() {
    classCallCheck(this, BackButtonElement);

    var _this = possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });

    _this._options = {};
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(BackButtonElement, [{
    key: '_updateIcon',
    value: function _updateIcon() {
      var icon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : util.findChild(this, '.back-button__icon');

      icon.innerHTML = autoStyle.getPlatform(this) === 'android' || util.hasModifier(this, 'material') ? mdBackButtonIcon : iosBackButtonIcon;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$2);

      if (!util.findChild(this, '.back-button__label')) {
        var label = util.create('span.back-button__label');

        while (this.childNodes[0]) {
          label.appendChild(this.childNodes[0]);
        }
        this.appendChild(label);
      }

      if (!util.findChild(this, '.back-button__icon')) {
        var icon = util.create('span.back-button__icon');
        this._updateIcon(icon);

        this.insertBefore(icon, this.children[0]);
      }

      util.updateRipple(this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' });

      ModifierUtil.initModifier(this, scheme$4);
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Options object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

  }, {
    key: '_onClick',


    /**
     * @property onClick
     * @type {Function}
     * @description
     *   [en]Used to override the default back button behavior.[/en]
     *   [ja][/ja]
     */
    value: function _onClick() {
      if (this.onClick) {
        this.onClick.apply(this);
      } else {
        var navigator = util.findParent(this, 'ons-navigator');
        if (navigator) {
          navigator.popPage(this.options);
        }
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$2, scheme$4);
          break;

        case 'modifier':
          {
            ModifierUtil.onModifierChanged(last, current, this, scheme$4) && this._updateIcon();
            break;
          }
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'show',
    value: function show() {
      this.style.display = 'inline-block';
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.style.display = 'none';
    }
  }, {
    key: 'options',
    get: function get$$1() {
      return this._options;
    },
    set: function set$$1(object) {
      this._options = object;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return BackButtonElement;
}(BaseElement);

ons$1.elements.BackButton = BackButtonElement;
customElements.define('ons-back-button', BackButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$3 = 'bottom-bar';
var scheme$5 = { '': 'bottom-bar--*' };

/**
 * @element ons-bottom-toolbar
 * @category page
 * @description
 *   [en]Toolbar component that is positioned at the bottom of the page. Since bottom toolbars are very versatile elements, `ons-bottom-toolbar` does not provide any specific layout syntax for its children. Modifiers or custom CSS must be used.[/en]
 *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
 * @modifier transparent
 *   [en]Make the toolbar transparent.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @modifier aligned
 *   [en]Vertically aligns its children and applies flexbox for block elements. `justify-content` CSS rule can be used to change horizontal align.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
 * @example
 * <ons-bottom-toolbar>
 *   Content
 * </ons-bottom-toolbar>
 */

var BottomToolbarElement = function (_BaseElement) {
  inherits(BottomToolbarElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the toolbar.[/en]
   *   [ja]ツールバーの見た目の表現を指定します。[/ja]
   */

  function BottomToolbarElement() {
    classCallCheck(this, BottomToolbarElement);

    var _this = possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).call(this));

    _this.classList.add(defaultClassName$3);
    ModifierUtil.initModifier(_this, scheme$5);
    return _this;
  }

  createClass(BottomToolbarElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (util.match(this.parentNode, 'ons-page')) {
        this.parentNode.classList.add('page-with-bottom-toolbar');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$3, scheme$5);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$5);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return BottomToolbarElement;
}(BaseElement);

ons$1.elements.BottomToolbar = BottomToolbarElement;
customElements.define('ons-bottom-toolbar', BottomToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$6 = { '': 'button--*' };

var defaultClassName$4 = 'button';

/**
 * @element ons-button
 * @category form
 * @modifier outline
 *   [en]Button with outline and transparent background[/en]
 *   [ja]アウトラインを持ったボタンを表示します。[/ja]
 * @modifier light
 *   [en]Button that doesn't stand out.[/en]
 *   [ja]目立たないボタンを表示します。[/ja]
 * @modifier quiet
 *   [en]Button with no outline and or background..[/en]
 *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
 * @modifier cta
 *   [en]Button that really stands out.[/en]
 *   [ja]目立つボタンを表示します。[/ja]
 * @modifier large
 *   [en]Large button that covers the width of the screen.[/en]
 *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
 * @modifier large--quiet
 *   [en]Large quiet button.[/en]
 *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
 * @modifier large--cta
 *   [en]Large call to action button.[/en]
 *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
 * @modifier material
 *   [en]Material Design button[/en]
 *   [ja]マテリアルデザインのボタン[/ja]
 * @modifier material--flat
 *   [en]Material Design flat button[/en]
 *   [ja]マテリアルデザインのフラットボタン[/ja]
 * @description
 *   [en]
 *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
 *
 *     Will automatically display as a Material Design button with a ripple effect on Android.
 *   [/en]
 *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/button
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-button modifier="large--cta">
 *   Tap Me
 * </ons-button>
 */

var ButtonElement = function (_BaseElement) {
  inherits(ButtonElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the button.[/en]
   *  [ja]ボタンの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定します。[/ja]
   */

  function ButtonElement() {
    classCallCheck(this, ButtonElement);

    var _this = possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ButtonElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$4, scheme$6);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$6);
          break;
        case 'ripple':
          this._updateRipple();
      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$4);

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$6);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return ButtonElement;
}(BaseElement);

ons$1.elements.Button = ButtonElement;
customElements.define('ons-button', ButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$5 = 'card';
var scheme$7 = {
  '': 'card--*',
  '.card__title': 'card--*__title',
  '.card__content': 'card--*__content'
};

/**
 * @element ons-card
 * @category visual
 * @modifier material
 *   [en]A card with material design.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]
 *    Component to create a card that displays some information.
 *
 *    The card may be composed by divs with specially prepared classes `title` and/or `content`. You can also add your own content as you please.[/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/card
 * @example
 * <ons-card>
 *   <p>Some content</p>
 * </ons-card>
 */

var CardElement = function (_BaseElement) {
  inherits(CardElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the card.[/en]
   *   [ja]リストの表現を指定します。[/ja]
   */

  function CardElement() {
    classCallCheck(this, CardElement);

    var _this = possibleConstructorReturn(this, (CardElement.__proto__ || Object.getPrototypeOf(CardElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(CardElement, [{
    key: '_compile',
    value: function _compile() {
      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('title')) {
          el.classList.add('card__title');
          
        } else if (el.classList.contains('content')) {
          el.classList.add('card__content');
          
        }
      }

      autoStyle.prepare(this);
      this.classList.add(defaultClassName$5);
      ModifierUtil.initModifier(this, scheme$7);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$5, scheme$7);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$7);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return CardElement;
}(BaseElement);

ons$1.elements.Card = CardElement;
customElements.define('ons-card', CardElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$8 = { '': 'carousel-item--*' };

/**
 * @element ons-carousel-item
 * @category carousel
 * @description
 *   [en]
 *     Carousel item component. Used as a child of the `<ons-carousel>` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel
 *   [en]`<ons-carousel>` components[/en]
 *   [ja]<ons-carousel>コンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselItemElement = function (_BaseElement) {
  inherits(CarouselItemElement, _BaseElement);

  function CarouselItemElement() {
    classCallCheck(this, CarouselItemElement);

    var _this = possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).call(this));

    _this.style.width = '100%';
    ModifierUtil.initModifier(_this, scheme$8);
    return _this;
  }

  createClass(CarouselItemElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$8);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier'];
    }
  }]);
  return CarouselItemElement;
}(BaseElement);

ons$1.elements.CarouselItem = CarouselItemElement;
customElements.define('ons-carousel-item', CarouselItemElement);

var directionMap = {
  vertical: {
    axis: 'Y',
    size: 'Height',
    dir: ['up', 'down'],
    t3d: ['0px, ', 'px, 0px']
  },
  horizontal: {
    axis: 'X',
    size: 'Width',
    dir: ['left', 'right'],
    t3d: ['', 'px, 0px, 0px']
  }
};

var Swiper = function () {
  function Swiper(params) {
    var _this = this;

    classCallCheck(this, Swiper);

    // Parameters
    var FALSE = function FALSE() {
      return false;
    };
    'getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook'.split(/\s+/).forEach(function (key) {
      return _this[key] = params[key] || FALSE;
    });

    this.getElement = params.getElement; // Required
    this.scrollHook = params.scrollHook; // Optional
    this.itemSize = params.itemSize || '100%';

    this.getAutoScrollRatio = function () {
      var ratio = params.getAutoScrollRatio && params.getAutoScrollRatio.apply(params, arguments);
      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;
      if (ratio < 0.0 || ratio > 1.0) {
        throw new Error('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');
      }
      return ratio;
    };

    // Bind handlers
    this.onDragStart = this.onDragStart.bind(this);
    this.onDrag = this.onDrag.bind(this);
    this.onDragEnd = this.onDragEnd.bind(this);
    this.onResize = this.onResize.bind(this);
  }

  createClass(Swiper, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          swipeable = _ref.swipeable,
          autoRefresh = _ref.autoRefresh;

      this.initialized = true;
      this.target = this.getElement().children[0];
      this.blocker = this.getElement().children[1];
      if (!this.target || !this.blocker) {
        throw new Error('Expected "target" and "blocker" elements to exist before initializing Swiper.');
      }

      // Add classes
      this.getElement().classList.add('ons-swiper');
      this.target.classList.add('ons-swiper-target');
      this.blocker.classList.add('ons-swiper-blocker');

      // Setup listeners
      this._gestureDetector = new GestureDetector(this.getElement(), { dragMinDistance: 1, dragLockToAxis: true });
      this._mutationObserver = new MutationObserver(function () {
        return _this2.refresh();
      });
      this.updateSwipeable(swipeable);
      this.updateAutoRefresh(autoRefresh);

      // Setup initial layout
      this._scroll = this._offset = this._lastActiveIndex = 0;
      this._updateLayout();
      this._setupInitialIndex();
      setImmediate(function () {
        return _this2.initialized && _this2._setupInitialIndex();
      });

      // Fix rendering glitch on Android 4.1
      if (this.offsetHeight === 0) {
        setImmediate(function () {
          return _this2.refresh();
        });
      }
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this.initialized = false;
      this.updateSwipeable(false);
      this.updateAutoRefresh(false);

      this._gestureDetector && this._gestureDetector.dispose();
      this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;

      this.setupResize(false);
    }
  }, {
    key: 'onResize',
    value: function onResize() {
      var i = this._scroll / this.targetSize;
      this._reset();
      this.setActiveIndex(i);
      this.refresh();
    }
  }, {
    key: '_calculateItemSize',
    value: function _calculateItemSize() {
      var matches = this.itemSize.match(/^(\d+)(px|%)/);

      if (!matches) {
        throw new Error('Invalid state: swiper\'s size unit must be \'%\' or \'px\'');
      }

      var value = parseInt(matches[1], 10);
      return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;
    }
  }, {
    key: '_setupInitialIndex',
    value: function _setupInitialIndex() {
      this._reset();
      this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);
      this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;
      this._scrollTo(this._scroll);
    }
  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      index = Math.max(0, Math.min(index, this.itemCount - 1));
      var scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));

      if (platform.isUIWebView()) {
        /* Dirty fix for #2231(https://github.com/OnsenUI/OnsenUI/issues/2231). begin */
        var concat = function concat(arrayOfArray) {
          return Array.prototype.concat.apply([], arrayOfArray);
        };
        var contents = concat(util.arrayFrom(this.target.children).map(function (page) {
          return util.arrayFrom(page.children).filter(function (child) {
            return child.classList.contains('page__content');
          });
        }));

        var map = new Map();
        return new Promise(function (resolve) {
          contents.forEach(function (content) {
            map.set(content, content.getAttribute('class'));
            content.classList.add('page__content--suppress-layer-creation');
          });
          requestAnimationFrame(resolve);
        }).then(function () {
          return _this3._changeTo(scroll, options);
        }).then(function () {
          return new Promise(function (resolve) {
            contents.forEach(function (content) {
              content.setAttribute('class', map.get(content));
            });
            requestAnimationFrame(resolve);
          });
        });
        /* end */
      } else {
        return this._changeTo(scroll, options);
      }
    }
  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      var scroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._scroll;

      scroll -= this._offset;
      var count = this.itemCount,
          size = this.itemNumSize;

      if (scroll <= 0) {
        return 0;
      }

      for (var i = 0; i < count; i++) {
        if (size * i <= scroll && size * (i + 1) > scroll) {
          return i;
        }
      }

      return count - 1;
    }
  }, {
    key: 'setupResize',
    value: function setupResize(add) {
      window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);
    }
  }, {
    key: 'show',
    value: function show() {
      this.setupResize(true);
      this.onResize();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setupResize(false);
    }
  }, {
    key: 'updateSwipeable',
    value: function updateSwipeable(shouldUpdate) {
      if (this._gestureDetector) {
        var action = shouldUpdate ? 'on' : 'off';
        this._gestureDetector[action]('drag', this.onDrag);
        this._gestureDetector[action]('dragstart', this.onDragStart);
        this._gestureDetector[action]('dragend', this.onDragEnd);
      }
    }
  }, {
    key: 'updateAutoRefresh',
    value: function updateAutoRefresh(shouldWatch) {
      if (this._mutationObserver) {
        shouldWatch ? this._mutationObserver.observe(this.target, { childList: true }) : this._mutationObserver.disconnect();
      }
    }
  }, {
    key: 'updateItemSize',
    value: function updateItemSize(newSize) {
      this.itemSize = newSize || '100%';
      this.refresh();
    }
  }, {
    key: 'toggleBlocker',
    value: function toggleBlocker(block) {
      this.blocker.style.pointerEvents = block ? 'auto' : 'none';
    }
  }, {
    key: '_canConsumeGesture',
    value: function _canConsumeGesture(gesture) {
      var d = gesture.direction;
      var isFirst = this._scroll === 0 && !this.isOverScrollable();
      var isLast = this._scroll === this.maxScroll && !this.isOverScrollable();

      return this.isVertical() ? d === 'down' && !isFirst || d === 'up' && !isLast : d === 'right' && !isFirst || d === 'left' && !isLast;
    }
  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      var _this4 = this;

      this._ignoreDrag = event.consumed || !util.isValidGesture(event);

      if (!this._ignoreDrag) {
        var consume = event.consume;
        event.consume = function () {
          consume && consume();_this4._ignoreDrag = true;
        };

        if (this._canConsumeGesture(event.gesture)) {
          var startX = event.gesture.center && event.gesture.center.clientX || 0,
              distFromEdge = this.getBubbleWidth() || 0,
              start = function start() {
            consume && consume();
            event.consumed = true;
            _this4._started = true; // Avoid starting drag from outside
            _this4.toggleBlocker(true);
            util.preventScroll(_this4._gestureDetector);
          };

          // Let parent elements consume the gesture or consume it right away
          startX < distFromEdge || startX > this.targetSize - distFromEdge ? setImmediate(function () {
            return !_this4._ignoreDrag && start();
          }) : start();
        }
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(event) {
      if (!event.gesture || this._ignoreDrag || !this._started) {
        return;
      }

      this._continued = true; // Fix for random 'dragend' without 'drag'
      event.stopPropagation();

      this._scrollTo(this._scroll - this._getDelta(event), { throttle: true });
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(event) {
      this._started = false;
      if (!event.gesture || this._ignoreDrag || !this._continued) {
        this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate
        return;
      }

      this._continued = false;
      event.stopPropagation();

      var scroll = this._scroll - this._getDelta(event);
      var normalizedScroll = this._normalizeScroll(scroll);
      scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);
      this.toggleBlocker(false);
    }
  }, {
    key: '_startMomentumScroll',
    value: function _startMomentumScroll(scroll, event) {
      var velocity = this._getVelocity(event),
          matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];

      var nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);
      var duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;
      duration = Math.min(.25, Math.max(.1, duration));

      this._changeTo(nextScroll, { swipe: true, animationOptions: { duration: duration, timing: 'cubic-bezier(.4, .7, .5, 1)' } });
    }
  }, {
    key: '_killOverScroll',
    value: function _killOverScroll(scroll) {
      var _this5 = this;

      this._scroll = scroll;
      var direction = this.dM.dir[Number(scroll > 0)];
      var killOverScroll = function killOverScroll() {
        return _this5._changeTo(scroll, { animationOptions: { duration: .4, timing: 'cubic-bezier(.1, .4, .1, 1)' } });
      };
      this.overScrollHook({ direction: direction, killOverScroll: killOverScroll }) || killOverScroll();
    }
  }, {
    key: '_changeTo',
    value: function _changeTo(scroll) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var e = { activeIndex: this.getActiveIndex(scroll), lastActiveIndex: this._lastActiveIndex, swipe: options.swipe || false };
      var change = e.activeIndex !== e.lastActiveIndex;
      var canceled = change ? this.preChangeHook(e) : false;

      this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;
      this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;

      return this._scrollTo(this._scroll, options).then(function () {
        if (scroll === _this6._scroll && !canceled) {
          change && _this6.postChangeHook(e);
        } else if (options.reject) {
          return Promise.reject('Canceled');
        }
      });
    }
  }, {
    key: '_scrollTo',
    value: function _scrollTo(scroll) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.throttle) {
        var ratio = 0.35;
        if (scroll < 0) {
          scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;
        } else {
          var maxScroll = this.maxScroll;
          if (maxScroll < scroll) {
            scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
          }
        }
      }

      var opt = options.animation === 'none' ? {} : options.animationOptions;
      this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});

      return new Promise(function (resolve) {
        return Animit(_this7.target).queue({ transform: _this7._getTransform(scroll) }, opt).play(resolve);
      });
    }
  }, {
    key: '_getAutoScroll',
    value: function _getAutoScroll(scroll, velocity, matchesDirection) {
      var max = this.maxScroll,
          offset = this._offset,
          size = this.itemNumSize;

      if (!this.isAutoScrollable()) {
        return Math.max(0, Math.min(max, scroll));
      }

      var arr = [];
      for (var s = offset; s < max; s += size) {
        arr.push(s);
      }
      arr.push(max);

      arr = arr.sort(function (left, right) {
        return Math.abs(left - scroll) - Math.abs(right - scroll);
      }).filter(function (item, pos) {
        return !pos || item !== arr[pos - 1];
      });

      var result = arr[0];
      var lastScroll = this._lastActiveIndex * size + offset;
      var scrollRatio = Math.abs(scroll - lastScroll) / size;

      if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {
        result = lastScroll;
      } else {
        if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {
          result = arr[1];
        }
      }
      return Math.max(0, Math.min(max, result));
    }
  }, {
    key: '_reset',
    value: function _reset() {
      this._targetSize = this._itemNumSize = undefined;
    }
  }, {
    key: '_normalizeScroll',
    value: function _normalizeScroll(scroll) {
      return Math.max(Math.min(scroll, this.maxScroll), 0);
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      this._reset();
      this._updateLayout();

      var scroll = this._normalizeScroll(this._scroll);
      scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);

      this.refreshHook();
    }
  }, {
    key: '_getDelta',
    value: function _getDelta(event) {
      return event.gesture['delta' + this.dM.axis];
    }
  }, {
    key: '_getVelocity',
    value: function _getVelocity(event) {
      return event.gesture['velocity' + this.dM.axis];
    }
  }, {
    key: '_getTransform',
    value: function _getTransform(scroll) {
      return 'translate3d(' + this.dM.t3d[0] + -scroll + this.dM.t3d[1] + ')';
    }
  }, {
    key: '_updateLayout',
    value: function _updateLayout() {
      this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];
      this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());

      for (var c = this.target.children[0]; c; c = c.nextElementSibling) {
        c.style[this.dM.size.toLowerCase()] = this.itemSize;
      }

      if (this.isCentered()) {
        this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;
      }
    }
  }, {
    key: 'itemCount',
    get: function get$$1() {
      return this.target.children.length;
    }
  }, {
    key: 'itemNumSize',
    get: function get$$1() {
      if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {
        this._itemNumSize = this._calculateItemSize();
      }
      return this._itemNumSize;
    }
  }, {
    key: 'maxScroll',
    get: function get$$1() {
      var max = this.itemCount * this.itemNumSize - this.targetSize;
      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
    }
  }, {
    key: 'targetSize',
    get: function get$$1() {
      if (!this._targetSize) {
        this._targetSize = this.target['offset' + this.dM.size];
      }
      return this._targetSize;
    }
  }]);
  return Swiper;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-carousel
 * @category carousel
 * @description
 *   [en]
 *     Carousel component. A carousel can be used to display several items in the same space.
 *
 *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel-item
 *   [en]`<ons-carousel-item>` component[/en]
 *   [ja]ons-carousel-itemコンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselElement = function (_BaseElement) {
  inherits(CarouselElement, _BaseElement);

  /**
   * @event postchange
   * @description
   *   [en]Fired just after the current carousel item has changed.[/en]
   *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Carousel object.[/en]
   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
   * @param {Number} event.activeIndex
   *   [en]Current active index.[/en]
   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
   * @param {Number} event.lastActiveIndex
   *   [en]Previous active index.[/en]
   *   [ja]以前アクティブだった要素のインデックス。[/ja]
   */

  /**
   * @event refresh
   * @description
   *   [en]Fired when the carousel has been refreshed.[/en]
   *   [ja]カルーセルが更新された時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Carousel object.[/en]
   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
   */

  /**
   * @event overscroll
   * @description
   *   [en]Fired when the carousel has been overscrolled.[/en]
   *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Fired when the carousel has been refreshed.[/en]
   *   [ja]カルーセルが更新された時に発火します。[/ja]
   * @param {Number} event.activeIndex
   *   [en]Current active index.[/en]
   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
   * @param {String} event.direction
   *   [en]Can be one of either "up", "down", "left" or "right".[/en]
   *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
   * @param {Function} event.waitToReturn
   *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
   *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
   *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
   */

  /**
   * @attribute fullscreen
   * @description
   *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
   *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
   */

  /**
   * @attribute overscrollable
   * @description
   *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
   *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
   */

  /**
   * @attribute centered
   * @description
   *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
   *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
   */

  /**
   * @attribute item-width
   * @type {String}
   * @description
   *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
   *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
   */

  /**
   * @attribute item-height
   * @type {String}
   * @description
   *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
   *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
   */

  /**
   * @attribute auto-scroll
   * @description
   *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
   *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
   */

  /**
   * @attribute auto-scroll-ratio
   * @type {Number}
   * @description
   *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
   *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
   */

  /**
   * @attribute swipeable
   * @description
   *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
   *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set the carousel is disabled.[/en]
   *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
   */

  /**
   * @attribute initial-index
   * @initonly
   * @default 0
   * @type {Number}
   * @description
   *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
   *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
   */

  /**
   * @attribute auto-refresh
   * @description
   *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
   *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @description
   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  function CarouselElement() {
    classCallCheck(this, CarouselElement);

    var _this = possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(CarouselElement, [{
    key: '_compile',
    value: function _compile() {
      var target = this.children[0] && this.children[0].tagName !== 'ONS-CAROUSEL-ITEM' && this.children[0] || document.createElement('div');
      if (!target.parentNode) {
        while (this.firstChild) {
          target.appendChild(this.firstChild);
        }
        this.appendChild(target);
      }

      !this.children[1] && this.appendChild(document.createElement('div'));

      this.appendChild = this.appendChild.bind(target);
      this.insertBefore = this.insertBefore.bind(target);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!this._swiper) {
        this._swiper = new Swiper({
          getElement: function getElement() {
            return _this2;
          },
          getInitialIndex: function getInitialIndex() {
            return _this2.getAttribute('initial-index');
          },
          getAutoScrollRatio: function getAutoScrollRatio() {
            return _this2.autoScrollRatio;
          },
          isVertical: function isVertical() {
            return _this2.vertical;
          },
          isOverScrollable: function isOverScrollable() {
            return _this2.overscrollable;
          },
          isCentered: function isCentered() {
            return _this2.centered;
          },
          isAutoScrollable: function isAutoScrollable() {
            return _this2.autoScroll;
          },
          itemSize: this.itemSize,
          overScrollHook: this._onOverScroll.bind(this),
          preChangeHook: this._onChange.bind(this, 'prechange'),
          postChangeHook: this._onChange.bind(this, 'postchange'),
          refreshHook: this._onRefresh.bind(this),
          scrollHook: this._onSwipe
        });

        contentReady(this, function () {
          return _this2._swiper.init({
            swipeable: _this2.hasAttribute('swipeable'),
            autoRefresh: _this2.hasAttribute('auto-refresh')
          });
        });
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._swiper && this._swiper.initialized) {
        this._swiper.dispose();
        this._swiper = null;
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (!this._swiper) {
        return;
      }

      switch (name) {
        case 'swipeable':
          this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
          break;
        case 'auto-refresh':
          this._swiper.updateAutoRefresh(this.hasAttribute('auto-refresh'));
          break;
        case 'item-height':
          this.vertical && this._swiper.updateItemSize(this.itemSize);
          break;
        case 'item-width':
          this.vertical || this._swiper.updateItemSize(this.itemSize);
          break;
        case 'direction':
          this._swiper.refresh();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this._swiper.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._swiper.hide();
    }
  }, {
    key: '_onOverScroll',
    value: function _onOverScroll(_ref) {
      var direction = _ref.direction,
          killOverScroll = _ref.killOverScroll;

      var waitForAction = false;
      util.triggerElementEvent(this, 'overscroll', {
        carousel: this,
        activeIndex: this.getActiveIndex(),
        direction: direction,
        waitToReturn: function waitToReturn(promise) {
          waitForAction = true;
          promise.then(killOverScroll);
        }
      });

      return waitForAction;
    }
  }, {
    key: '_onChange',
    value: function _onChange(eventName, _ref2) {
      var activeIndex = _ref2.activeIndex,
          lastActiveIndex = _ref2.lastActiveIndex;

      util.triggerElementEvent(this, eventName, { carousel: this, activeIndex: activeIndex, lastActiveIndex: lastActiveIndex });
    }
  }, {
    key: '_onRefresh',
    value: function _onRefresh() {
      util.triggerElementEvent(this, 'refresh', { carousel: this });
    }

    /**
     * @method setActiveIndex
     * @signature setActiveIndex(index, [options])
     * @param {Number} index
     *   [en]The index that the carousel should be set to.[/en]
     *   [ja]carousel要素のインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be called after the animation is finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      options.animation = options.animation || this.getAttribute('animation');
      options.animationOptions = util.extend({ duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

      return this._swiper.setActiveIndex(index, options).then(function () {
        options.callback instanceof Function && options.callback(_this3);
        return Promise.resolve(_this3);
      });
    }

    /**
     * @method getActiveIndex
     * @signature getActiveIndex()
     * @return {Number}
     *   [en]The current carousel item index.[/en]
     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
     * @description
     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
     */

  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      return this._swiper.getActiveIndex();
    }

    /**
     * @method next
     * @signature next([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show next `<ons-carousel-item>`.[/en]
     *   [ja]次のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'next',
    value: function next(options) {
      return this.setActiveIndex(this.getActiveIndex() + 1, options);
    }

    /**
     * @method prev
     * @signature prev([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show previous `<ons-carousel-item>`.[/en]
     *   [ja]前のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'prev',
    value: function prev(options) {
      return this.setActiveIndex(this.getActiveIndex() - 1, options);
    }

    /**
     * @method first
     * @signature first()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this is set to `"none"`, the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show first `<ons-carousel-item>`.[/en]
     *   [ja]最初のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'first',
    value: function first(options) {
      return this.setActiveIndex(0, options);
    }

    /**
     * @method last
     * @signature last()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja]Resolves to the carousel element[/ja]
     * @description
     *   [en]Show last ons-carousel item.[/en]
     *   [ja]最後のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'last',
    value: function last(options) {
      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
    }

    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
     */

  }, {
    key: 'refresh',
    value: function refresh() {
      this._swiper.refresh();
    }

    /**
     * @property itemCount
     * @readonly
     * @type {Number}
     * @description
     *   [en]The number of carousel items.[/en]
     *   [ja]カルーセル要素の数です。[/ja]
     */

  }, {
    key: 'itemCount',
    get: function get$$1() {
      return this._swiper.itemCount;
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]true if the carousel is swipeable.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get$$1() {
      return this.hasAttribute('swipeable');
    },
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the carousel. It gets a decimal index and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throw new Error('\'onSwipe\' must be a function.');
      }
      this._onSwipe = value;
    }

    /**
     * @property autoScroll
     * @type {Boolean}
     * @description
     *   [en]true if auto scroll is enabled.[/en]
     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
     */

  }, {
    key: 'autoScroll',
    get: function get$$1() {
      return this.hasAttribute('auto-scroll');
    },
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'auto-scroll', value);
    }
  }, {
    key: 'vertical',
    get: function get$$1() {
      return this.getAttribute('direction') === 'vertical';
    }
  }, {
    key: 'itemSize',
    get: function get$$1() {
      var itemSizeAttr = (this.getAttribute('item-' + (this.vertical ? 'height' : 'width')) || '').trim();
      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
    }

    /**
     * @property autoScrollRatio
     * @type {Number}
     * @description
     *   [en]The current auto scroll ratio. [/en]
     *   [ja]現在のオートスクロールのratio値。[/ja]
     */

  }, {
    key: 'autoScrollRatio',
    get: function get$$1() {
      return parseFloat(this.getAttribute('auto-scroll-ratio'));
    },
    set: function set$$1(ratio) {
      this.setAttribute('auto-scroll-ratio', ratio);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    get: function get$$1() {
      return this.hasAttribute('disabled');
    },
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    }

    /**
     * @property overscrollable
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is overscrollable or not.[/en]
     *   [ja]overscrollできればtrueを返します。[/ja]
     */

  }, {
    key: 'overscrollable',
    get: function get$$1() {
      return this.hasAttribute('overscrollable');
    },
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'overscrollable', value);
    }

    /**
     * @property centered
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is centered or not.[/en]
     *   [ja]centered状態になっていればtrueを返します。[/ja]
     */

  }, {
    key: 'centered',
    get: function get$$1() {
      return this.hasAttribute('centered');
    },
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'centered', value);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['swipeable', 'auto-refresh', 'direction', 'item-height', 'item-width'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['postchange', 'refresh', 'overscroll'];
    }
  }]);
  return CarouselElement;
}(BaseElement);

ons$1.elements.Carousel = CarouselElement;
customElements.define('ons-carousel', CarouselElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-col
 * @category grid
 * @description
 *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
 *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
 * @codepen GgujC {wide}
 * @guide theming.html [en]Layouting guide[/en][ja]レイアウト機能[/ja]
 * @seealso ons-row
 *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
 *   [ja]ons-rowコンポーネント[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
 *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
 */

/**
 * @attribute width
 * @type {String}
 * @description
 *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
 *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
 */

var ColElement = function (_BaseElement) {
  inherits(ColElement, _BaseElement);

  function ColElement() {
    classCallCheck(this, ColElement);

    var _this = possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).call(this));

    if (_this.getAttribute('width')) {
      _this._updateWidth();
    }
    return _this;
  }

  createClass(ColElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'width') {
        this._updateWidth();
      }
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      var width = this.getAttribute('width');
      if (!width) {
        styler.clear(this, 'flex maxWidth');
      } else {
        width = width.trim().match(/^\d+$/) ? width + '%' : width;

        styler(this, {
          flex: '0 0 ' + width,
          maxWidth: width
        });
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['width'];
    }
  }]);
  return ColElement;
}(BaseElement);

ons$1.elements.Col = ColElement;
customElements.define('ons-col', ColElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var DialogAnimator = function (_BaseAnimator) {
  inherits(DialogAnimator, _BaseAnimator);

  function DialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, DialogAnimator);
    return possibleConstructorReturn(this, (DialogAnimator.__proto__ || Object.getPrototypeOf(DialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(DialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return DialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for dialog.
 */
var AndroidDialogAnimator = function (_DialogAnimator) {
  inherits(AndroidDialogAnimator, _DialogAnimator);

  function AndroidDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;

    classCallCheck(this, AndroidDialogAnimator);
    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -60%, 0)',
          opacity: 0.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidDialogAnimator;
}(DialogAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSDialogAnimator = function (_DialogAnimator2) {
  inherits(IOSDialogAnimator, _DialogAnimator2);

  function IOSDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;

    classCallCheck(this, IOSDialogAnimator);

    var _this3 = possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this3.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this3;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3d(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSDialogAnimator;
}(DialogAnimator);

/**
 * Slide animator for dialog.
 */
var SlideDialogAnimator = function (_DialogAnimator3) {
  inherits(SlideDialogAnimator, _DialogAnimator3);

  function SlideDialogAnimator() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$timing = _ref4.timing,
        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === undefined ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;

    classCallCheck(this, SlideDialogAnimator);

    var _this4 = possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this4.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this4;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(SlideDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
          transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask).queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(dialog._dialog).saveStyle().queue({
        css: {
          transform: 'translate3D(-50%, -50%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
          transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return SlideDialogAnimator;
}(DialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$9 = {
  '.dialog': 'dialog--*',
  '.dialog-container': 'dialog-container--*',
  '.dialog-mask': 'dialog-mask--*'
};

var _animatorDict$2 = {
  'default': function _default() {
    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
  },
  'slide': SlideDialogAnimator,
  'none': DialogAnimator
};

/**
 * @element ons-dialog
 * @category dialog
 * @description
 *   [en]
 *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<ons-template>` tag.
 *
 *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
 *
 *     It will automatically be displayed as Material Design when running on an Android device.
 *   [/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design dialog.[/en]
 *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
 * @codepen zxxaGa
 * @tutorial vanilla/Reference/dialog
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-alert-dialog
 *   [en]`<ons-alert-dialog>` component[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-dialog id="dialog">
 *   <p>This is a dialog!</p>
 * </ons-dialog>
 *
 * <script>
 *   document.getElementById('dialog').show();
 * </script>
 */

var DialogElement = function (_BaseDialogElement) {
  inherits(DialogElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the dialog is displayed.[/en]
   * [ja]ダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the dialog from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the dialog is displayed.[/en]
   * [ja]ダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the dialog is hidden.[/en]
   * [ja]ダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the dialog from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the dialog is hidden.[/en]
   * [ja]ダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the dialog.[/en]
   *  [ja]ダイアログの表現を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the dialog is disabled.[/en]
   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function DialogElement() {
    classCallCheck(this, DialogElement);

    var _this = possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(DialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$2,
        baseClass: DialogAnimator,
        baseClassName: 'DialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-dialog>
       *     <div class="dialog-mask"></div>
       *     <div class="dialog">
       *       <div class="dialog-container">...</div>
       *     </div>
       *   </ons-dialog>
       */

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('dialog');

        var container = document.createElement('div');
        container.classList.add('dialog-container');
        while (this.firstChild) {
          container.appendChild(this.firstChild);
        }
        dialog.appendChild(container);

        this.appendChild(dialog);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('dialog-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      this.setAttribute('status-bar-fill', '');

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the dialog.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the dialog has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$9;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util.findChild(this, '.dialog-mask');
    }
  }, {
    key: '_dialog',
    get: function get$$1() {
      return util.findChild(this, '.dialog');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof DialogAnimator)) {
        throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
      }
      _animatorDict$2[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$2;
    }
  }, {
    key: 'DialogAnimator',
    get: function get$$1() {
      return DialogAnimator;
    }
  }]);
  return DialogElement;
}(BaseDialogElement);

ons$1.elements.Dialog = DialogElement;
customElements.define('ons-dialog', DialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$6 = 'fab';

var scheme$10 = {
  '': 'fab--*',
  '.fab__icon': 'fab--*__icon'
};

/**
 * @element ons-fab
 * @category form
 * @description
 *   [en]
 *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
 *
 *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/fab
 * @modifier mini
 *   [en]Makes the `ons-fab` smaller.[/en]
 *   [ja][/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
 *   [ja][/ja]
 */

var FabElement = function (_BaseElement) {
  inherits(FabElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the button.[/en]
   *  [ja]ボタンの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute position
   * @type {String}
   * @description
   *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定します。[/ja]
   */

  function FabElement() {
    classCallCheck(this, FabElement);

    // The following statements can be executed before contentReady
    // since these do not access the children
    var _this = possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).call(this));

    _this.hide();
    _this.classList.add(defaultClassName$6);

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(FabElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (!util.findChild(this, '.fab__icon')) {
        var content = document.createElement('span');
        content.classList.add('fab__icon');

        util.arrayFrom(this.childNodes).forEach(function (element) {
          if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
            content.appendChild(element);
          }
        });
        this.appendChild(content);
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$10);

      this._updatePosition();
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      setImmediate(function () {
        return _this2.show();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$6, scheme$10);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$10);
          break;
        case 'ripple':
          this._updateRipple();
          break;
        case 'position':
          this._updatePosition();
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this3 = this;

      setImmediate(function () {
        return _this3.hide();
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *  [en]Show the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this.toggle(true);
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *  [en]Hide the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      this.toggle(false);
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle the visibility of the button.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.visible;

      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
      var translate = isBottom ? 'translate3d(0px, -' + (util.globals.fabOffset || 0) + 'px, 0px)' : '';

      styler(this, { transform: translate + ' scale(' + Number(action) + ')' });
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return this.style.transform.indexOf('scale(0)') === -1 && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'position', 'class'];
    }
  }]);
  return FabElement;
}(BaseElement);

ons$1.elements.Fab = FabElement;
customElements.define('ons-fab', FabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-gesture-detector
 * @category gesture
 * @description
 *   [en]
 *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
 *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
 *     - Hold gestures: `hold`, `release`
 *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
 *     - Tap gestures: `tap`, `doubletap`
 *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
 *     - Other gestures: `touch`, `transform`, `rotate`
 *   [/en]
 *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
 * @guide features.html#gesture-detection
 *   [en]Detecting finger gestures[/en]
 *   [ja]ジェスチャー操作の検知[/ja]
 * @example
 * <ons-gesture-detector>
 *   <div id="detect-area" style="width: 100px; height: 100px;">
 *     Swipe Here
 *   </div>
 * </ons-gesture-detector>
 *
 * <script>
 *   document.addEventListener('swipeleft', function(event) {
 *     if (event.target.matches('#detect-area')) {
 *       console.log('Swipe left is detected.');
 *     }
 *   });
 * </script>
 */

var GestureDetectorElement = function (_BaseElement) {
  inherits(GestureDetectorElement, _BaseElement);

  function GestureDetectorElement() {
    classCallCheck(this, GestureDetectorElement);

    var _this = possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).call(this));

    _this._gestureDetector = new GestureDetector(_this);
    return _this;
  }

  return GestureDetectorElement;
}(BaseElement);

ons$1.elements.GestureDetector = GestureDetectorElement;
customElements.define('ons-gesture-detector', GestureDetectorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoPrefix = 'fa'; // FIXME: To be removed in v3

/**
 * @element ons-icon
 * @category visual
 * @description
 *   [en]
 *     Displays an icon. The following icon suites are available:
 *
 *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
 *     * [Ionicons](http://ionicons.com/)
 *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
 *   [/en]
 *   [ja][/ja]
 * @codepen xAhvg
 * @tutorial vanilla/Reference/icon
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja][/ja]
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @example
 * <ons-icon
 *   icon="md-car"
 *   size="20px"
 *   style="color: red">
 * </ons-icon>
 *
 * <ons-button>
 *   <ons-icon icon="md-car"></ons-icon>
 *   Car
 * </ons-button>
 */

var IconElement = function (_BaseElement) {
  inherits(IconElement, _BaseElement);

  /**
   * @attribute icon
   * @type {String}
   * @description
   *   [en]
   *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
   *
   *     See all available icons on the element description (at the top).
   *
   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
   *
   *     The code `<ons-icon icon="ion-edit, material:md-edit"></ons-icon>` will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
   *
   *     `fa-` prefix is added automatically if none is provided. Check [See also](#seealso) section for more information.
   *   [/en]
   *   [ja][/ja]
   */

  /**
   * @attribute size
   * @type {String}
   * @description
   *   [en]
   *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
   *
   *     The code:
   *
   *     ```
   *     <ons-icon
   *       icon="ion-edit"
   *       size="32px, material:24px">
   *     </ons-icon>
   *     ```
   *
   *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
   *   [/en]
   *   [ja][/ja]
   */

  /**
   * @attribute rotate
   * @type {Number}
   * @description
   *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
   *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
   */

  /**
   * @attribute fixed-width
   * @type {Boolean}
   * @default false
   * @description
   *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute spin
   * @description
   *   [en]Specify whether the icon should be spinning.[/en]
   *   [ja]アイコンを回転するかどうかを指定します。[/ja]
   */

  function IconElement() {
    classCallCheck(this, IconElement);

    var _this = possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(IconElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      this._cleanClassAttribute(name === 'icon' ? last : this.getAttribute('icon'), name === 'modifier' ? last : undefined);
      this._update();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._update();
    }
  }, {
    key: '_update',
    value: function _update() {
      var _this2 = this;

      var _buildClassAndStyle2 = this._buildClassAndStyle(this._parseAttr('icon'), this._parseAttr('size')),
          classList = _buildClassAndStyle2.classList,
          style = _buildClassAndStyle2.style;

      util.extend(this.style, style);

      classList.forEach(function (className) {
        return _this2.classList.add(className);
      });
    }
  }, {
    key: '_parseAttr',
    value: function _parseAttr(attrName) {
      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getAttribute('modifier') || '';

      var attr = this.getAttribute(attrName) || attrName || '';
      var parts = attr.split(/\s*,\s*/);
      var def = parts[0];
      var md = parts[1];
      md = (md || '').split(/\s*:\s*/);

      return (modifier && RegExp('(^|\\s+)' + md[0] + '($|\\s+)', 'i').test(modifier) ? md[1] : def) || '';
    }

    /**
     * Remove unneeded class value.
     */

  }, {
    key: '_cleanClassAttribute',
    value: function _cleanClassAttribute(lastIcon, lastModifier) {
      var _this3 = this;

      var _prefixIcon2 = this._prefixIcon(this._parseAttr(lastIcon, lastModifier)),
          className = _prefixIcon2.className,
          prefix = _prefixIcon2.prefix;

      var customPrefixRE = className !== prefix ? '|' + prefix + '$|' + prefix + '-' : '|' + className + '$' || '';
      var re = new RegExp('^(fa$|fa-|ion-|zmdi$|zmdi-|ons-icon--' + customPrefixRE + ')');

      util.arrayFrom(this.classList).filter(function (className) {
        return re.test(className);
      }).forEach(function (className) {
        return _this3.classList.remove(className);
      });
    }
  }, {
    key: '_prefixIcon',
    value: function _prefixIcon(iconName) {
      var className = autoPrefix + (autoPrefix ? '-' : '') + iconName;
      return { className: className, prefix: className.split('-')[0] };
    }
  }, {
    key: '_buildClassAndStyle',
    value: function _buildClassAndStyle(iconName, size) {
      var classList = ['ons-icon'];
      var style = {};

      // Icon
      if (iconName.indexOf('ion-') === 0) {
        classList.push(iconName);
        classList.push('ons-icon--ion');
      } else if (iconName.indexOf('fa-') === 0) {
        classList.push(iconName);
        classList.push('fa');
      } else if (iconName.indexOf('md-') === 0) {
        classList.push('zmdi');
        classList.push('zmdi-' + iconName.split(/-(.+)?/)[1]);
      } else {
        var _prefixIcon3 = this._prefixIcon(iconName),
            className = _prefixIcon3.className,
            prefix = _prefixIcon3.prefix;

        prefix && classList.push(prefix);
        className && classList.push(className);
      }

      // Size
      if (size.match(/^[1-5]x|lg$/)) {
        classList.push('ons-icon--' + size);
        this.style.removeProperty('font-size');
      } else {
        style.fontSize = size;
      }

      return {
        classList: classList,
        style: style
      };
    }
  }], [{
    key: 'setAutoPrefix',
    value: function setAutoPrefix(prefix) {
      autoPrefix = prefix ? typeof prefix === 'string' && prefix || 'fa' : '';
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return ['icon', 'size', 'modifier', 'class'];
    }
  }]);
  return IconElement;
}(BaseElement);

ons$1.elements.Icon = IconElement;
customElements.define('ons-icon', IconElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var LazyRepeatDelegate = function () {
  function LazyRepeatDelegate(userDelegate) {
    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, LazyRepeatDelegate);

    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {
      throw Error('"delegate" parameter must be an object.');
    }
    this._userDelegate = userDelegate;

    if (!(templateElement instanceof Element) && templateElement !== null) {
      throw Error('"templateElement" parameter must be an instance of Element or null.');
    }
    this._templateElement = templateElement;
  }

  createClass(LazyRepeatDelegate, [{
    key: 'hasRenderFunction',


    /**
     * @return {Boolean}
     */
    value: function hasRenderFunction() {
      return this._userDelegate._render instanceof Function;
    }

    /**
     * @return {void}
     */

  }, {
    key: '_render',
    value: function _render() {
      this._userDelegate._render.apply(this._userDelegate, arguments);
    }

    /**
     * @param {Number} index
     * @param {Function} done A function that take item object as parameter.
     */

  }, {
    key: 'loadItemElement',
    value: function loadItemElement(index, done) {
      if (this._userDelegate.loadItemElement instanceof Function) {
        this._userDelegate.loadItemElement(index, done);
      } else {
        var element = this._userDelegate.createItemContent(index, this._templateElement);
        if (!(element instanceof Element)) {
          throw Error('createItemContent() must return an instance of Element.');
        }

        done({ element: element });
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'countItems',
    value: function countItems() {
      var count = this._userDelegate.countItems();
      if (typeof count !== 'number') {
        throw Error('countItems() must return a number.');
      }
      return count;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     * @param {Element} item.element
     */

  }, {
    key: 'updateItem',
    value: function updateItem(index, item) {
      if (this._userDelegate.updateItemContent instanceof Function) {
        this._userDelegate.updateItemContent(index, item);
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'calculateItemHeight',
    value: function calculateItemHeight(index) {
      if (this._userDelegate.calculateItemHeight instanceof Function) {
        var height = this._userDelegate.calculateItemHeight(index);

        if (typeof height !== 'number') {
          throw Error('calculateItemHeight() must return a number.');
        }

        return height;
      }

      return 0;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     */

  }, {
    key: 'destroyItem',
    value: function destroyItem(index, item) {
      if (this._userDelegate.destroyItem instanceof Function) {
        this._userDelegate.destroyItem(index, item);
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._userDelegate.destroy instanceof Function) {
        this._userDelegate.destroy();
      }

      this._userDelegate = this._templateElement = null;
    }
  }, {
    key: 'itemHeight',
    get: function get$$1() {
      return this._userDelegate.itemHeight;
    }
  }]);
  return LazyRepeatDelegate;
}();

/**
 * This class provide core functions for ons-lazy-repeat.
 */
var LazyRepeatProvider = function () {

  /**
   * @param {Element} wrapperElement
   * @param {LazyRepeatDelegate} delegate
   */
  function LazyRepeatProvider(wrapperElement, delegate) {
    classCallCheck(this, LazyRepeatProvider);

    if (!(delegate instanceof LazyRepeatDelegate)) {
      throw Error('"delegate" parameter must be an instance of LazyRepeatDelegate.');
    }

    this._wrapperElement = wrapperElement;
    this._delegate = delegate;
    this._insertIndex = this._wrapperElement.children[0] && this._wrapperElement.children[0].tagName === 'ONS-LAZY-REPEAT' ? 1 : 0;

    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
      wrapperElement.classList.add('lazy-list');
    }

    this._pageContent = this._findPageContentElement(wrapperElement);

    if (!this._pageContent) {
      throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
    }

    this.lastScrollTop = this._pageContent.scrollTop;
    this.padding = 0;
    this._topPositions = [0];
    this._renderedItems = {};

    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
      this._unknownItemHeight = true;
    }

    this._addEventListeners();
    this._onChange();
  }

  createClass(LazyRepeatProvider, [{
    key: '_findPageContentElement',
    value: function _findPageContentElement(wrapperElement) {
      var pageContent = util.findParent(wrapperElement, '.page__content');

      if (pageContent) {
        return pageContent;
      }

      var page = util.findParent(wrapperElement, 'ons-page');
      if (page) {
        var content = util.findChild(page, '.content');
        if (content) {
          return content;
        }
      }

      return null;
    }
  }, {
    key: '_checkItemHeight',
    value: function _checkItemHeight(callback) {
      var _this = this;

      this._delegate.loadItemElement(0, function (item) {
        if (!_this._unknownItemHeight) {
          throw Error('Invalid state');
        }

        _this._wrapperElement.appendChild(item.element);

        var done = function done() {
          _this._delegate.destroyItem(0, item);
          item.element && item.element.remove();
          delete _this._unknownItemHeight;
          callback();
        };

        _this._itemHeight = item.element.offsetHeight;

        if (_this._itemHeight > 0) {
          done();
          return;
        }

        // retry to measure offset height
        // dirty fix for angular2 directive
        _this._wrapperElement.style.visibility = 'hidden';
        item.element.style.visibility = 'hidden';

        setImmediate(function () {
          _this._itemHeight = item.element.offsetHeight;
          if (_this._itemHeight == 0) {
            throw Error('Invalid state: this._itemHeight must be greater than zero.');
          }
          _this._wrapperElement.style.visibility = '';
          done();
        });
      });
    }
  }, {
    key: '_countItems',
    value: function _countItems() {
      return this._delegate.countItems();
    }
  }, {
    key: '_getItemHeight',
    value: function _getItemHeight(i) {
      // Item is rendered
      if (this._renderedItems.hasOwnProperty(i)) {
        if (!this._renderedItems[i].hasOwnProperty('height')) {
          this._renderedItems[i].height = this._renderedItems[i].element.offsetHeight;
        }
        return this._renderedItems[i].height;
      }

      // Item is not rendered, scroll up
      if (this._topPositions[i + 1] && this._topPositions[i]) {
        return this._topPositions[i + 1] - this._topPositions[i];
      }
      // Item is not rendered, scroll down
      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
    }
  }, {
    key: '_calculateRenderedHeight',
    value: function _calculateRenderedHeight() {
      var _this2 = this;

      return Object.keys(this._renderedItems).reduce(function (a, b) {
        return a + _this2._getItemHeight(+b);
      }, 0);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._render();
    }
  }, {
    key: '_lastItemRendered',
    value: function _lastItemRendered() {
      return Math.max.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: '_firstItemRendered',
    value: function _firstItemRendered() {
      return Math.min.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      var forceRender = { forceScrollDown: true };
      var lastItemIndex = Math.min(this._lastItemRendered(), this._countItems() - 1);
      var firstItemIndex = this._firstItemRendered();

      if (util.isInteger(lastItemIndex)) {
        forceRender.forceLastIndex = lastItemIndex;
      }

      if (util.isInteger(firstItemIndex)) {
        this._wrapperElement.style.height = this._topPositions[firstItemIndex] + this._calculateRenderedHeight() + 'px';
        this.padding = this._topPositions[firstItemIndex];
        forceRender.forceFirstIndex = firstItemIndex;
      }

      this._removeAllElements();
      this._render(forceRender);
      this._wrapperElement.style.height = 'inherit';
    }
  }, {
    key: '_render',
    value: function _render() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$forceScrollDown = _ref.forceScrollDown,
          forceScrollDown = _ref$forceScrollDown === undefined ? false : _ref$forceScrollDown,
          forceFirstIndex = _ref.forceFirstIndex,
          forceLastIndex = _ref.forceLastIndex;

      if (this._unknownItemHeight) {
        return this._checkItemHeight(this._render.bind(this, arguments[0]));
      }

      var isScrollUp = !forceScrollDown && this.lastScrollTop > this._pageContent.scrollTop;
      this.lastScrollTop = this._pageContent.scrollTop;
      var keep = {};

      var offset = this._wrapperElement.getBoundingClientRect().top;
      var limit = 4 * window.innerHeight - offset;
      var count = this._countItems();

      var start = forceFirstIndex || Math.max(0, this._calculateStartIndex(offset) - 30); // Recalculate for 0 or undefined
      var i = start;

      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
        if (i >= this._topPositions.length) {
          // perf optimization
          this._topPositions.length += 100;
        }

        this._topPositions[i] = top;
        top += this._getItemHeight(i);
      }

      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
        return this._delegate._render(start, i, function () {
          _this3.padding = _this3._topPositions[start];
        });
      }

      if (isScrollUp) {
        for (var j = i - 1; j >= start; j--) {
          keep[j] = true;
          this._renderElement(j, isScrollUp);
        }
      } else {
        var lastIndex = forceLastIndex || Math.max.apply(Math, [i - 1].concat(toConsumableArray(Object.keys(this._renderedItems)))); // Recalculate for 0 or undefined
        for (var _j = start; _j <= lastIndex; _j++) {
          keep[_j] = true;
          this._renderElement(_j, isScrollUp);
        }
      }

      Object.keys(this._renderedItems).forEach(function (key) {
        return keep[key] || _this3._removeElement(key, isScrollUp);
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_renderElement',
    value: function _renderElement(index, isScrollUp) {
      var _this4 = this;

      var item = this._renderedItems[index];
      if (item) {
        this._delegate.updateItem(index, item); // update if it exists
        return;
      }

      this._delegate.loadItemElement(index, function (item) {
        if (isScrollUp) {
          _this4._wrapperElement.insertBefore(item.element, _this4._wrapperElement.children[_this4._insertIndex]);
          _this4.padding = _this4._topPositions[index];
          item.height = _this4._topPositions[index + 1] - _this4._topPositions[index];
        } else {
          _this4._wrapperElement.appendChild(item.element);
        }

        _this4._renderedItems[index] = item;
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_removeElement',
    value: function _removeElement(index) {
      var isScrollUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      index = +index;
      var item = this._renderedItems[index];
      this._delegate.destroyItem(index, item);

      if (isScrollUp) {
        this._topPositions[index + 1] = undefined;
      } else {
        this.padding = this.padding + this._getItemHeight(index);
      }

      if (item.element.parentElement) {
        item.element.parentElement.removeChild(item.element);
      }

      delete this._renderedItems[index];
    }
  }, {
    key: '_removeAllElements',
    value: function _removeAllElements() {
      var _this5 = this;

      Object.keys(this._renderedItems).forEach(function (key) {
        return _this5._removeElement(key);
      });
    }
  }, {
    key: '_recalculateTopPositions',
    value: function _recalculateTopPositions(start, end) {
      for (var i = start; i <= end; i++) {
        this._topPositions[i + 1] = this._topPositions[i] + this._getItemHeight(i);
      }
    }
  }, {
    key: '_calculateStartIndex',
    value: function _calculateStartIndex(current) {
      var firstItemIndex = this._firstItemRendered();
      var lastItemIndex = this._lastItemRendered();

      // Fix for Safari scroll and Angular 2
      this._recalculateTopPositions(firstItemIndex, lastItemIndex);

      var start = 0;
      var end = this._countItems() - 1;

      // Binary search for index at top of screen so we can speed up rendering.
      for (;;) {
        var middle = Math.floor((start + end) / 2);
        var value = current + this._topPositions[middle];

        if (end < start) {
          return 0;
        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
          return middle;
        } else if (isNaN(value) || value >= 0) {
          end = middle - 1;
        } else {
          start = middle + 1;
        }
      }
    }
  }, {
    key: '_debounce',
    value: function _debounce(func, wait, immediate) {
      var timeout = void 0;
      return function () {
        var _this6 = this,
            _arguments = arguments;

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        if (callNow) {
          func.apply(this, arguments);
        } else {
          timeout = setTimeout(function () {
            timeout = null;
            func.apply(_this6, _arguments);
          }, wait);
        }
      };
    }
  }, {
    key: '_doubleFireOnTouchend',
    value: function _doubleFireOnTouchend() {
      this._render();
      this._debounce(this._render.bind(this), 100);
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

      if (platform.isIOS()) {
        this._boundOnChange = this._debounce(this._boundOnChange, 30);
      }

      this._pageContent.addEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.addEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.removeEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._removeAllElements();
      this._delegate.destroy();
      this._parentElement = this._delegate = this._renderedItems = null;
      this._removeEventListeners();
    }
  }, {
    key: 'padding',
    get: function get$$1() {
      return parseInt(this._wrapperElement.style.paddingTop, 10);
    },
    set: function set$$1(newValue) {
      this._wrapperElement.style.paddingTop = newValue + 'px';
    }
  }, {
    key: 'staticItemHeight',
    get: function get$$1() {
      return this._delegate.itemHeight || this._itemHeight;
    }
  }]);
  return LazyRepeatProvider;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @element ons-lazy-repeat
 * @category list
 * @description
 *   [en]
 *     Using this component a list with millions of items can be rendered without a drop in performance.
 *     It does that by "lazily" loading elements into the DOM when they come into view and
 *     removing items from the DOM when they are not visible.
 *   [/en]
 *   [ja]
 *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
 *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
 *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
 *   [/ja]
 * @codepen QwrGBm
 * @tutorial vanilla/Reference/lazy-repeat
 * @seealso ons-list
 *   [en]The `<ons-list>` element is used to render a list.[/en]
 *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]
 * @example
 * <script>
 *   window.addEventListener('load', function() {
 *     var lazyRepeat = document.querySelector('#list');
 *     lazyRepeat.delegate = {
 *      createItemContent: function(i, template) {
 *        var dom = template.cloneNode(true);
 *        dom.innerText = i;
 *
 *        return dom;
 *      },
 *      countItems: function() {
 *        return 10000000;
 *      },
 *      destroyItem: function(index, item) {
 *        console.log('Destroyed item with index: ' + index);
 *      }
 *     };
 *   });
 * </script>
 *
 * <ons-list id="list">
 *   <ons-lazy-repeat>
 *     <ons-list-item></ons-list-item>
 *   </ons-lazy-repeat>
 * </ons-list>
 */

var LazyRepeatElement = function (_BaseElement) {
  inherits(LazyRepeatElement, _BaseElement);

  function LazyRepeatElement() {
    classCallCheck(this, LazyRepeatElement);
    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));
  }

  createClass(LazyRepeatElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      // not very good idea and also not documented
      if (this.hasAttribute('delegate')) {
        this.delegate = window[this.getAttribute('delegate')];
      }
    }

    /**
     * @property delegate
     * @type {Object}
     * @description
     *  [en]Specify a delegate object to load and unload item elements.[/en]
     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
     */

    /**
     * @property delegate.createItemContent
     * @type {Function}
     * @description
     *   [en]
     *     This function should return a `HTMLElement`.
     *
     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
     *   [/en]
     *   [ja]
     *     この関数は`HTMLElement`を返してください。
     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。
     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。
     *   [/ja]
     */

    /**
     * @property delegate.countItems
     * @type {Function}
     * @description
     *   [en]Should return the number of items in the list.[/en]
     *   [ja]リスト内のアイテム数を返してください。[/ja]
     */

    /**
     * @property delegate.calculateItemHeight
     * @type {Function}
     * @description
     *   [en]
     *     Should return the height of an item. The index is provided as an argument.
     *
     *     This is important when rendering lists where the items have different height.
     *
     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
     *   [/en]
     *   [ja]
     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。
     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。
     *     この関数はオプショナルです。もしこの関数が無い場合には、
     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。
     *   [/ja]
     */

    /**
     * @property delegate.destroyItem
     * @type {Function}
     * @description
     *   [en]
     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
     *
     *     The function is optional but may be important in order to avoid memory leaks.
     *   [/en]
     *   [ja]
     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。
     *     アイテムのインデックス値とDOM要素が引数として渡されます。
     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。
     *   [/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Refresh the list. Use this method when the data has changed.[/en]
     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]
     */
    value: function refresh() {
      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._lazyRepeatProvider) {
        this._lazyRepeatProvider.destroy();
        this._lazyRepeatProvider = null;
      }
    }
  }, {
    key: 'delegate',
    set: function set$$1(userDelegate) {
      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

      if (!this._templateElement && this.children[0]) {
        this._templateElement = this.removeChild(this.children[0]);
      }

      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
    },
    get: function get$$1() {
      throw new Error('This property can only be used to set the delegate object.');
    }
  }]);
  return LazyRepeatElement;
}(BaseElement);

internal$1.LazyRepeatDelegate = LazyRepeatDelegate;
internal$1.LazyRepeatProvider = LazyRepeatProvider;

ons$1.elements.LazyRepeat = LazyRepeatElement;
customElements.define('ons-lazy-repeat', LazyRepeatElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$7 = 'list-header';
var scheme$11 = { '': 'list-header--*' };

/**
 * @element ons-list-header
 * @category list
 * @description
 *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
 *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
 * @seealso ons-list
 *   [en]The `<ons-list>` component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @modifier material
 *   [en]Display a Material Design list header.[/en]
 *   [ja][/ja]
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListHeaderElement = function (_BaseElement) {
  inherits(ListHeaderElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list header.[/en]
   *   [ja]ヘッダーの表現を指定します。[/ja]
   */

  function ListHeaderElement() {
    classCallCheck(this, ListHeaderElement);

    var _this = possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListHeaderElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$7);
      ModifierUtil.initModifier(this, scheme$11);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$7, scheme$11);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$11);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListHeaderElement;
}(BaseElement);

ons$1.elements.ListHeader = ListHeaderElement;
customElements.define('ons-list-header', ListHeaderElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$8 = 'list-title';
var scheme$12 = { '': 'list-title--*' };

/**
 * @element ons-list-title
 * @category list
 * @description
 *   [en]Represents a list title.[/en]
 *   [ja]リストのタイトルを表現します。[/ja]
 * @example
 * <ons-list-title>List Title</ons-list-title>
 * <ons-list>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 * @modifier material
 *   [en]Display a Material Design list title.[/en]
 *   [ja][/ja]
 */

var ListTitleElement = function (_BaseElement) {
  inherits(ListTitleElement, _BaseElement);

  function ListTitleElement() {
    classCallCheck(this, ListTitleElement);

    var _this = possibleConstructorReturn(this, (ListTitleElement.__proto__ || Object.getPrototypeOf(ListTitleElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListTitleElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$8);
      ModifierUtil.initModifier(this, scheme$12);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$8, scheme$12);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$12);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListTitleElement;
}(BaseElement);

ons$1.elements.ListTitle = ListTitleElement;
customElements.define('ons-list-title', ListTitleElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$9 = 'list-item';
var scheme$13 = {
  '.list-item': 'list-item--*',
  '.list-item__left': 'list-item--*__left',
  '.list-item__center': 'list-item--*__center',
  '.list-item__right': 'list-item--*__right',
  '.list-item__label': 'list-item--*__label',
  '.list-item__title': 'list-item--*__title',
  '.list-item__subtitle': 'list-item--*__subtitle',
  '.list-item__thumbnail': 'list-item--*__thumbnail',
  '.list-item__icon': 'list-item--*__icon'
};

/**
 * @element ons-list-item
 * @category list
 * @modifier tappable
 *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
 *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
 * @modifier chevron
 *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped.[/en]
 *   [ja][/ja]
 * @modifier longdivider
 *   [en]Displays a long horizontal divider between items.[/en]
 *   [ja][/ja]
 * @modifier nodivider
 *   [en]Removes the divider between list items.[/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design list item.[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Component that represents each item in a list. The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
 *
 *     ```
 *     <ons-list-item>
 *       <div class="left">Left</div>
 *       <div class="center">Center</div>
 *       <div class="right">Right</div>
 *     </ons-list-item>
 *     ```
 *
 *     There is also a number of classes (prefixed with `list-item__*`) that help when putting things like icons and thumbnails into the list items.
 *   [/en]
 *   [ja][/ja]
 * @seealso ons-list
 *   [en]ons-list component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list-item>
 *   <div class="left">
 *     <ons-icon icon="md-face" class="list-item__icon"></ons-icon>
 *   </div>
 *   <div class="center">
 *     <div class="list-item__title">Title</div>
 *     <div class="list-item__subtitle">Subtitle</div>
 *   </div>
 *   <div class="right">
 *     <ons-switch></ons-switch>
 *   </div>
 * </ons-list-item>
 */

var ListItemElement = function (_BaseElement) {
  inherits(ListItemElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list item.[/en]
   *   [ja]各要素の表現を指定します。[/ja]
   */

  /**
   * @attribute lock-on-drag
   * @type {String}
   * @description
   *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
   *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
   */

  /**
   * @attribute tappable
   * @type {Boolean}
   * @description
   *   [en]Makes the element react to taps.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute tap-background-color
   * @type {Color}
   * @description
   *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
   *   [ja][/ja]
   */

  function ListItemElement() {
    classCallCheck(this, ListItemElement);

    var _this = possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(ListItemElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$9);

      var left = void 0,
          center = void 0,
          right = void 0;

      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('left')) {
          el.classList.add('list-item__left');
          left = el;
        } else if (el.classList.contains('center')) {
          center = el;
        } else if (el.classList.contains('right')) {
          el.classList.add('list-item__right');
          right = el;
        }
      }

      if (!center) {
        center = document.createElement('div');

        if (!left && !right) {
          while (this.childNodes[0]) {
            center.appendChild(this.childNodes[0]);
          }
        } else {
          for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
            var _el = this.childNodes[_i];
            if (_el !== left && _el !== right) {
              center.insertBefore(_el, center.firstChild);
            }
          }
        }

        this.insertBefore(center, right || null);
      }

      center.classList.add('center');
      center.classList.add('list-item__center');

      util.updateRipple(this);

      ModifierUtil.initModifier(this, scheme$13);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$9, scheme$13);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$13);
          break;
        case 'ripple':
          util.updateRipple(this);
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._setupListeners(true);
      this._originalBackgroundColor = this.style.backgroundColor;
      this.tapped = false;
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._setupListeners(false);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var action = (add ? 'add' : 'remove') + 'EventListener';
      this[action]('drag', this._onDrag);
      this[action]('touchstart', this._onTouch);
      this[action]('mousedown', this._onTouch);
      this[action]('touchend', this._onRelease);
      this[action]('touchmove', this._onRelease);
      this[action]('touchcancel', this._onRelease);
      this[action]('mouseup', this._onRelease);
      this[action]('mouseout', this._onRelease);
      this[action]('touchleave', this._onRelease);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var gesture = event.gesture;
      // Prevent vertical scrolling if the users pans left or right.
      if (this.hasAttribute('lock-on-drag') && ['left', 'right'].indexOf(gesture.direction) > -1) {
        gesture.preventDefault();
      }
    }
  }, {
    key: '_onTouch',
    value: function _onTouch() {
      if (this.tapped) {
        return;
      }

      this.tapped = true;
      var touchStyle = { transition: 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s' };

      if (this.hasAttribute('tappable')) {
        if (this.style.backgroundColor) {
          this._originalBackgroundColor = this.style.backgroundColor;
        }

        touchStyle.backgroundColor = this.getAttribute('tap-background-color') || '#d9d9d9';
        touchStyle.boxShadow = '0px -1px 0px 0px ' + touchStyle.backgroundColor;
      }

      styler(this, touchStyle);
    }
  }, {
    key: '_onRelease',
    value: function _onRelease() {
      this.tapped = false;
      this.style.backgroundColor = this._originalBackgroundColor || '';
      styler.clear(this, 'transition boxShadow');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class', 'ripple'];
    }
  }]);
  return ListItemElement;
}(BaseElement);

ons$1.elements.ListItem = ListItemElement;
customElements.define('ons-list-item', ListItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$10 = 'list';
var scheme$14 = { '': 'list--*' };

/**
 * @element ons-list
 * @category list
 * @modifier inset
 *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
 *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
 * @modifier noborder
 *   [en]A list with no borders at the top and bottom.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
 *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
 * @seealso ons-list-item
 *   [en]ons-list-item component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @seealso ons-lazy-repeat
 *   [en]ons-lazy-repeat component[/en]
 *   [ja]ons-lazy-repeatコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListElement = function (_BaseElement) {
  inherits(ListElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list.[/en]
   *   [ja]リストの表現を指定します。[/ja]
   */

  function ListElement() {
    classCallCheck(this, ListElement);

    var _this = possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$10);
      ModifierUtil.initModifier(this, scheme$14);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$10, scheme$14);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$14);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListElement;
}(BaseElement);

ons$1.elements.List = ListElement;
customElements.define('ons-list', ListElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'step', 'validator', 'value'];

var BaseInputElement = function (_BaseElement) {
  inherits(BaseInputElement, _BaseElement);
  createClass(BaseInputElement, [{
    key: '_update',
    value: function _update() {} // Optionally implemented

  }, {
    key: '_scheme',
    get: function get$$1() {
      throw new Error('_scheme getter must be implemented.');
    }
  }, {
    key: '_template',
    get: function get$$1() {
      throw new Error('_template getter must be implemented.');
    }
  }, {
    key: 'type',
    get: function get$$1() {
      throw new Error('type getter must be implemented.');
    }
  }]);

  function BaseInputElement() {
    classCallCheck(this, BaseInputElement);

    var _this = possibleConstructorReturn(this, (BaseInputElement.__proto__ || Object.getPrototypeOf(BaseInputElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    _this._boundDelegateEvent = _this._delegateEvent.bind(_this);
    return _this;
  }

  createClass(BaseInputElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._defaultClassName && this.classList.add(this._defaultClassName);

      if (this.children.length !== 0) {
        return;
      }

      this.appendChild(util.createFragment(this._template));

      this._setInputId();
      this._updateBoundAttributes();

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this2 = this;

      INPUT_ATTRIBUTES.forEach(function (attr) {
        if (_this2.hasAttribute(attr)) {
          _this2._input.setAttribute(attr, _this2.getAttribute(attr));
        } else {
          _this2._input.removeAttribute(attr);
        }
      });

      this._update();
    }
  }, {
    key: '_delegateEvent',
    value: function _delegateEvent(event) {
      var e = new CustomEvent(event.type, {
        bubbles: false,
        cancelable: true
      });

      return this.dispatchEvent(e);
    }
  }, {
    key: '_setInputId',
    value: function _setInputId() {
      if (this.hasAttribute('input-id')) {
        this._input.id = this.getAttribute('input-id');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._input.addEventListener('focus', _this3._boundDelegateEvent);
        _this3._input.addEventListener('blur', _this3._boundDelegateEvent);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._input.removeEventListener('focus', _this4._boundDelegateEvent);
        _this4._input.removeEventListener('blur', _this4._boundDelegateEvent);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, _this5._scheme);
          });
          break;
        case 'input-id':
          contentReady(this, function () {
            return _this5._setInputId();
          });
          break;
        case 'class':
          util.restoreClass(this, this._defaultClassName, this._scheme);
          break;
      }

      if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this5._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return '';
    }
  }, {
    key: '_input',
    get: function get$$1() {
      return this.querySelector('input');
    }
  }, {
    key: 'value',
    get: function get$$1() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set$$1(val) {
      var _this6 = this;

      contentReady(this, function () {
        if (val instanceof Date) {
          val = val.toISOString().substring(0, 10);
        }
        _this6._input.value = val;
        _this6._update();
      });
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'input-id', 'class'].concat(INPUT_ATTRIBUTES);
    }
  }]);
  return BaseInputElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$15 = {
  '.text-input': 'text-input--*',
  '.text-input__label': 'text-input--*__label'
};

/**
 * @element ons-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a text input.[/en]
 *  [ja][/ja]
 * @modifier transparent
 *  [en]Displays a transparent input. Works for Material Design.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    An input element. The `type` attribute can be used to change the input type. All text input types are supported.
 *
 *    The component will automatically render as a Material Design input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/input
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-input placeholder="Username" float></ons-input>
 */

var InputElement = function (_BaseInputElement) {
  inherits(InputElement, _BaseInputElement);

  function InputElement() {
    classCallCheck(this, InputElement);

    var _this = possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).call(this));

    _this._boundOnInput = _this._update.bind(_this);
    _this._boundOnFocusin = _this._update.bind(_this);
    return _this;
  }

  /* Inherited props */

  createClass(InputElement, [{
    key: '_update',
    value: function _update() {
      this._updateLabel();
      this._updateLabelClass();
    }
  }, {
    key: '_updateLabel',


    /* Own props */

    value: function _updateLabel() {
      var label = this.getAttribute('placeholder') || '';

      if (typeof this._helper.textContent !== 'undefined') {
        this._helper.textContent = label;
      } else {
        this._helper.innerText = label;
      }
    }
  }, {
    key: '_updateLabelClass',
    value: function _updateLabelClass() {
      if (this.value === '') {
        this._helper.classList.remove('text-input--material__label--active');
      } else {
        this._helper.classList.add('text-input--material__label--active');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'connectedCallback', this).call(this);

      contentReady(this, function () {
        _this2._input.addEventListener('input', _this2._boundOnInput);
        _this2._input.addEventListener('focusin', _this2._boundOnFocusin);
      });

      var type = this.getAttribute('type');
      if (['checkbox', 'radio'].indexOf(type) >= 0) {
        util.warn('Warn: <ons-input type="' + type + '"> is deprecated since v2.4.0. Use <ons-' + type + '> instead.');
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'disconnectedCallback', this).call(this);

      contentReady(this, function () {
        _this3._input.removeEventListener('input', _this3._boundOnInput);
        _this3._input.removeEventListener('focusin', _this3._boundOnFocusin);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this4 = this;

      switch (name) {
        case 'type':
          contentReady(this, function () {
            return _this4._input.setAttribute('type', _this4.type);
          });
          break;
        default:
          get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @attribute placeholder
     * @type {String}
     * @description
     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute float
     * @description
     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]
     */

    /**
     * @attribute type
     * @type {String}
     * @description
     *  [en]
     *    Specify the input type. This is the same as the "type" attribute for normal inputs. It expects strict text types such as `text`, `password`, etc. For checkbox, radio button, select or range, please have a look at the corresponding elements.
     *
     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
     *  [/en]
     *  [ja][/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$15;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="text-input">\n      <span class="text-input__label"></span>\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      var type = this.getAttribute('type');
      return ['checkbox', 'radio'].indexOf(type) < 0 && type || 'text';
    }
  }, {
    key: '_helper',
    get: function get$$1() {
      return this.querySelector('span');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(InputElement.__proto__ || Object.getPrototypeOf(InputElement), 'observedAttributes', this)), ['type']);
    }
  }]);
  return InputElement;
}(BaseInputElement);

ons$1.elements.Input = InputElement;
customElements.define('ons-input', InputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var BaseCheckboxElement = function (_BaseInputElement) {
  inherits(BaseCheckboxElement, _BaseInputElement);

  function BaseCheckboxElement() {
    classCallCheck(this, BaseCheckboxElement);

    var _this = possibleConstructorReturn(this, (BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement)).call(this));

    contentReady(_this, function () {
      _this.attributeChangedCallback('checked', null, _this.getAttribute('checked'));
    });
    return _this;
  }

  /* Inherited props */

  createClass(BaseCheckboxElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'checked':
          this.checked = current !== null;
          break;
        default:
          get(BaseCheckboxElement.prototype.__proto__ || Object.getPrototypeOf(BaseCheckboxElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <span class="' + this._defaultClassName + '__checkmark"></span>\n    ';
    }

    /* Own props */

  }, {
    key: '_helper',
    get: function get$$1() {
      return this.querySelector('span');
    }
  }, {
    key: 'checked',
    get: function get$$1() {
      return this._input.checked;
    },
    set: function set$$1(val) {
      var _this2 = this;

      contentReady(this, function () {
        _this2._input.checked = val;
      });
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement), 'observedAttributes', this)), ['checked']);
    }
  }]);
  return BaseCheckboxElement;
}(BaseInputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$16 = {
  '.checkbox': 'checkbox--*',
  '.checkbox__input': 'checkbox--*__input',
  '.checkbox__checkmark': 'checkbox--*__checkmark'
};

/**
 * @element ons-checkbox
 * @category form
 * @modifier material
 *  [en]Displays a Material Design checkbox.[/en]
 *  [ja][/ja]
 * @modifier noborder
 *  [en]iOS borderless checkbox.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A checkbox element. The component will automatically render as a Material Design checkbox on Android devices.
 *
 *    Most attributes that can be used for a normal `<input type="checkbox">` element can also be used on the `<ons-checkbox>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/input
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-search-input
 *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-checkbox checked></ons-checkbox>
 */

var CheckboxElement = function (_BaseCheckboxElement) {
  inherits(CheckboxElement, _BaseCheckboxElement);

  function CheckboxElement() {
    classCallCheck(this, CheckboxElement);
    return possibleConstructorReturn(this, (CheckboxElement.__proto__ || Object.getPrototypeOf(CheckboxElement)).apply(this, arguments));
  }

  createClass(CheckboxElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$16;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'checkbox';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'checkbox';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the checkbox.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the checkbox is checked or not.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the checkbox is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return CheckboxElement;
}(BaseCheckboxElement);

ons$1.elements.Checkbox = CheckboxElement;
customElements.define('ons-checkbox', CheckboxElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$17 = {
  '.radio-button': 'radio-button--*',
  '.radio-button__input': 'radio-button--*__input',
  '.radio-button__checkmark': 'radio-button--*__checkmark'
};

/**
 * @element ons-radio
 * @category form
 * @modifier material
 *  [en]Displays a Material Design radio button.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A radio button element. The component will automatically render as a Material Design radio button on Android devices.
 *
 *    Most attributes that can be used for a normal `<input type="radio">` element can also be used on the `<ons-radio>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/input
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-search-input
 *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-radio checked></ons-radio>
 */

var RadioElement = function (_BaseCheckboxElement) {
  inherits(RadioElement, _BaseCheckboxElement);

  function RadioElement() {
    classCallCheck(this, RadioElement);
    return possibleConstructorReturn(this, (RadioElement.__proto__ || Object.getPrototypeOf(RadioElement)).apply(this, arguments));
  }

  createClass(RadioElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$17;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'radio-button';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'radio';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the radio button.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the radio button is checked or not.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the radio button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return RadioElement;
}(BaseCheckboxElement);

ons$1.elements.Radio = RadioElement;
customElements.define('ons-radio', RadioElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$18 = {
  '.search-input': 'search-input--*'
};

/**
 * @element ons-search-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design search input.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A search input element. The component will automatically render as a Material Design search input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-search-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/input
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-search-input placeholder="Search"></ons-search-input>
 */

var SearchInputElement = function (_BaseInputElement) {
  inherits(SearchInputElement, _BaseInputElement);

  function SearchInputElement() {
    classCallCheck(this, SearchInputElement);
    return possibleConstructorReturn(this, (SearchInputElement.__proto__ || Object.getPrototypeOf(SearchInputElement)).apply(this, arguments));
  }

  createClass(SearchInputElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$18;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="search-input">\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'search';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return SearchInputElement;
}(BaseInputElement);

ons$1.elements.SearchInput = SearchInputElement;
customElements.define('ons-search-input', SearchInputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModalAnimator = function (_BaseAnimator) {
  inherits(ModalAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ModalAnimator);
    return possibleConstructorReturn(this, (ModalAnimator.__proto__ || Object.getPrototypeOf(ModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ModalAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeModalAnimator = function (_ModalAnimator) {
  inherits(FadeModalAnimator, _ModalAnimator);

  function FadeModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeModalAnimator);
    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(FadeModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).queue({
        opacity: 1
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for modal.
 */

var LiftModalAnimator = function (_ModalAnimator) {
  inherits(LiftModalAnimator, _ModalAnimator);

  function LiftModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier( .1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, LiftModalAnimator);
    return possibleConstructorReturn(this, (LiftModalAnimator.__proto__ || Object.getPrototypeOf(LiftModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(LiftModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return LiftModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$19 = {
  '': 'modal--*',
  'modal__content': 'modal--*__content'
};

var defaultClassName$11 = 'modal';

var _animatorDict$3 = {
  'default': ModalAnimator,
  'fade': FadeModalAnimator,
  'lift': LiftModalAnimator,
  'none': ModalAnimator
};

/**
 * @element ons-modal
 * @category dialog
 * @description
 *   [en]
 *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
 *
 *     This component can be used to block user input while some operation is running or to show some information to the user.
 *   [/en]
 *   [ja]
 *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
 *     モーダルが表示されている間はイベント通知が行われません。
 *   [/ja]
 * @seealso ons-dialog
 *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
 *   [ja][/ja]
 * @codepen devIg
 * @tutorial vanilla/reference/modal
 * @example
 * <ons-modal id="modal">
 *   Modal content
 * </ons-modal>
 * <script>
 *   var modal = document.getElementById('modal');
 *   modal.show();
 * </script>
 */

var ModalElement = function (_BaseDialogElement) {
  inherits(ModalElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the modal is displayed.[/en]
   * [ja]モーダルが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the modal from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the modal is displayed.[/en]
   * [ja]モーダルが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the modal is hidden.[/en]
   * [ja]モーダルが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the modal from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the modal is hidden.[/en]
   * [ja]モーダルが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the modal. Can be either `"none"`, `"fade"` or `"lift"`.[/en]
   *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade","lift"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
   */

  function ModalElement() {
    classCallCheck(this, ModalElement);

    var _this = possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).call(this));

    _this._defaultDBB = function () {
      return undefined;
    };
    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ModalElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$3,
        baseClass: ModalAnimator,
        baseClassName: 'ModalAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      this.style.display = 'none';
      this.style.zIndex = 10001;
      this.classList.add(defaultClassName$11);

      if (!util.findChild(this, '.modal__content')) {
        var content = document.createElement('div');
        content.classList.add('modal__content');

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          content.insertBefore(node, null);
        }

        this.appendChild(content);
      }

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      this.style.display = shouldShow ? 'table' : 'none';
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'connectedCallback', this).call(this);
      this.addEventListener('touchmove', get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), '_preventScroll', this), false); // iOS fix
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'disconnectedCallback', this).call(this);
      this.removeEventListener('touchmove', get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), '_preventScroll', this), false);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Show modal.[/en]
     *   [ja]モーダルを表示します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Toggle modal visibility.[/en]
     *   [ja]モーダルの表示を切り替えます。[/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide modal.[/en]
     *   [ja]モーダルを非表示にします。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'class') {
        util.restoreClass(this, defaultClassName$11, scheme$19);
      } else {
        get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$19;
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ModalAnimator)) {
        throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
      }
      _animatorDict$3[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(ModalElement.__proto__ || Object.getPrototypeOf(ModalElement), 'observedAttributes', this)), ['class']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$3;
    }
  }, {
    key: 'ModalAnimator',
    get: function get$$1() {
      return ModalAnimator;
    }
  }]);
  return ModalElement;
}(BaseDialogElement);

ons$1.elements.Modal = ModalElement;
customElements.define('ons-modal', ModalElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var widthToPx = function widthToPx(width) {
  var _ref = [parseInt(width, 10), /px/.test(width)],
      value = _ref[0],
      px = _ref[1];

  return px ? value : Math.round(document.body.offsetWidth * value / 100);
};

var SwipeReveal = function () {
  function SwipeReveal(params) {
    var _this = this;

    classCallCheck(this, SwipeReveal);

    'element ignoreSwipe isInitialState onDragCallback swipeMax swipeMin swipeMid'.split(/\s+/).forEach(function (key) {
      return _this[key] = params[key];
    });

    this.elementHandler = params.elementHandler || params.element;
    this.getThreshold = params.getThreshold || function () {
      return .5;
    };
    this.getSide = params.getSide || function () {
      return 'left';
    };

    this.handleGesture = this.handleGesture.bind(this);
  }

  createClass(SwipeReveal, [{
    key: 'update',
    value: function update() {
      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element.hasAttribute('swipeable');

      if (!this.gestureDetector) {
        this.gestureDetector = new GestureDetector(this.elementHandler, { dragMinDistance: 1 });
      }

      var action = swipeable ? 'on' : 'off';
      this.gestureDetector[action]('drag dragstart dragend', this.handleGesture);
    }
  }, {
    key: 'handleGesture',
    value: function handleGesture(e) {
      if (e.gesture) {
        if (e.type === 'dragstart') {
          this.onDragStart(e);
        } else if (!this._ignoreDrag) {
          e.type === 'dragend' ? this.onDragEnd(e) : this.onDrag(e);
        }
      }
    }
  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      var _this2 = this;

      var getDistance = function getDistance() {
        return _this2.getSide() === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
      };
      this._ignoreDrag = event.consumed || !util.isValidGesture(event) || this.ignoreSwipe(event, getDistance());

      if (!this._ignoreDrag) {
        event.consume && event.consume();
        event.consumed = true;

        this._width = widthToPx(this.element.style.width || '100%');
        this._startDistance = this._distance = !(this.isInitialState instanceof Function) || this.isInitialState() ? 0 : this._width;

        util.preventScroll(this.gestureDetector);
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(event) {
      event.stopPropagation();
      event.gesture.preventDefault();

      var delta = this.getSide() === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
      if (distance !== this._distance) {
        this._distance = distance;
        this.swipeMid(this._distance, this._width);
      }
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(event) {
      event.stopPropagation();

      var direction = event.gesture.interimDirection;
      var isSwipeMax = this.getSide() !== direction && this._distance > this._width * this.getThreshold();
      isSwipeMax ? this.swipeMax() : this.swipeMin();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this.gestureDetector && this.gestureDetector.dispose();
      this.gestureDetector = this.element = this.elementHandler = null;
    }
  }]);
  return SwipeReveal;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NavigatorAnimator = function (_BaseAnimator) {
  inherits(NavigatorAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function NavigatorAnimator(options) {
    classCallCheck(this, NavigatorAnimator);

    options = util.extend({
      timing: 'linear',
      duration: '0.4',
      delay: '0'
    }, options || {});

    return possibleConstructorReturn(this, (NavigatorAnimator.__proto__ || Object.getPrototypeOf(NavigatorAnimator)).call(this, options));
  }

  createClass(NavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'block',
    value: function block(page) {
      var blocker = util.createElement('\n      <div style="position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000"></div>\n    ');
      page.parentNode.appendChild(blocker);
      return function () {
        return blocker.remove();
      };
    }
  }]);
  return NavigatorAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition like iOS's screen slide transition.
 */

var IOSSlideNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSSlideNavigatorAnimator, _NavigatorAnimator);

  function IOSSlideNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(0.3, .4, 0, .9)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSSlideNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; z-index: 2"></div>\n    ');

    return _this;
  }

  createClass(IOSSlideNavigatorAnimator, [{
    key: '_decompose',
    value: function _decompose(page) {
      var toolbar = page._getToolbarElement();
      var left = toolbar._getToolbarLeftItemsElement();
      var right = toolbar._getToolbarRightItemsElement();

      var excludeBackButton = function excludeBackButton(elements) {
        var result = [];

        for (var i = 0; i < elements.length; i++) {
          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
            result.push(elements[i]);
          }
        }

        return result;
      };

      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));

      return {
        toolbarCenter: toolbar._getToolbarCenterItemsElement(),
        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
        other: other,
        content: page._getContentElement(),
        background: page._getBackgroundElement(),
        toolbar: toolbar,
        bottomToolbar: page._getBottomToolbarElement()
      };
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar(enterPage, leavePage) {
      var enterToolbar = enterPage._getToolbarElement();
      var leaveToolbar = leavePage._getToolbarElement();

      var toolbars = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();
      var material = util.hasModifier(enterToolbar, 'material') || util.hasModifier(leaveToolbar, 'material');
      var transparent = util.hasModifier(enterToolbar, 'transparent') || util.hasModifier(leaveToolbar, 'transparent');

      return toolbars && !material && !transparent;
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta(element, decomposition) {
      var title = void 0,
          label = void 0;

      var pageRect = element.getBoundingClientRect();
      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
      } else {
        title = Math.round(pageRect.width / 2 * 0.6);
      }

      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
      }

      return { title: title, label: label };
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      contentReady(enterPage, function () {
        var enterPageTarget = util.findToolbarPage(enterPage) || enterPage;
        var leavePageTarget = util.findToolbarPage(leavePage) || leavePage;
        var enterPageDecomposition = _this2._decompose(enterPageTarget);
        var leavePageDecomposition = _this2._decompose(leavePageTarget);

        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);

        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

        if (shouldAnimateToolbar) {

          Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.toolbar).saveStyle().queue({
            css: {
              opacity: 0
            },
            duration: 0
          }).queue({
            css: {
              opacity: 1
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(125%, 0, 0)',
              opacity: 1
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(' + delta.title + 'px, 0, 0)',
              opacity: 0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0,
              transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
            },
            duration: _this2.duration
          }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({
            css: { opacity: 0 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 1 },
            duration: _this2.duration,
            timing: 'linear'
          }).restoreStyle(), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)',
              opacity: 1
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)',
              opacity: 0.9
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            _this2.backgroundMask.remove();
            unblock();
            callback();
            done();
          }), Animit(leavePageDecomposition.toolbarCenter).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
              opacity: 0,
              transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
            },
            duration: _this2.duration
          }).restoreStyle(), Animit(leavePageDecomposition.backButtonLabel).saveStyle().queue({
            css: {
              transform: 'translate3d(0, 0, 0)',
              opacity: 1.0
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3d(-' + delta.label + 'px, 0, 0)',
              opacity: 0
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePageDecomposition.other).saveStyle().queue({
            css: { opacity: 1 },
            duration: 0
          }).wait(_this2.delay).queue({
            css: { opacity: 0 },
            duration: _this2.duration,
            timing: 'linear'
          }).restoreStyle());
        } else {

          Animit.runAll(Animit(enterPage).saveStyle().queue({
            css: {
              transform: 'translate3D(100%, 0px, 0px)'
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(0px, 0px, 0px)'
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle(), Animit(leavePage).saveStyle().queue({
            css: {
              transform: 'translate3D(0, 0, 0)',
              opacity: 1
            },
            duration: 0
          }).wait(_this2.delay).queue({
            css: {
              transform: 'translate3D(-25%, 0px, 0px)',
              opacity: 0.9
            },
            duration: _this2.duration,
            timing: _this2.timing
          }).restoreStyle().queue(function (done) {
            _this2.backgroundMask.remove();
            unblock();
            callback();
            done();
          }));
        }
      });
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      var enterPageTarget = util.findToolbarPage(enterPage) || enterPage;
      var leavePageTarget = util.findToolbarPage(leavePage) || leavePage;
      var enterPageDecomposition = this._decompose(enterPageTarget);
      var leavePageDecomposition = this._decompose(leavePageTarget);

      var delta = this._calculateDelta(leavePage, leavePageDecomposition);

      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

      if (shouldAnimateToolbar) {
        Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
            opacity: 0
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1.0,
            transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
          },
          duration: this.duration
        }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
          css: {
            transform: 'translate3d(-' + delta.label + 'px, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({
          css: { opacity: 0 },
          duration: 0
        }).wait(this.delay).queue({
          css: { opacity: 1 },
          duration: this.duration,
          timing: 'linear'
        }).restoreStyle(), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).wait(0).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }), Animit(leavePageDecomposition.toolbar).queue({
          css: {
            opacity: 1
          },
          duration: 0
        }).queue({
          css: {
            opacity: 0
          },
          duration: this.duration,
          timing: this.timing
        }), Animit(leavePageDecomposition.toolbarCenter).queue({
          css: {
            transform: 'translate3d(0, 0, 0)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(125%, 0, 0)'
          },
          duration: this.duration,
          timing: this.timing
        }), Animit(leavePageDecomposition.backButtonLabel).queue({
          css: {
            transform: 'translate3d(0, 0, 0)',
            opacity: 1
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3d(' + delta.title + 'px, 0, 0)',
            opacity: 0,
            transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
          },
          duration: this.duration
        }));
      } else {
        Animit.runAll(Animit(enterPage).saveStyle().queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }).restoreStyle(), Animit(leavePage).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          duration: 0
        }).wait(this.delay).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }));
      }
    }
  }]);
  return IOSSlideNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Swipe animator for iOS navigator transition.
 */

var IOSSwipeNavigatorAnimator = function (_IOSSlideNavigatorAni) {
  inherits(IOSSwipeNavigatorAnimator, _IOSSlideNavigatorAni);

  function IOSSwipeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.15 : _ref$duration,
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, IOSSwipeNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSSwipeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));

    _this.durationRestore = 0.1;

    _this.swipeShadow = util.createElement('\n      <div style="position: absolute; height: 100%; width: 12px; right: 100%; top: 0; bottom: 0; z-index: -1;\n        background: linear-gradient(to right, transparent 0, rgba(0,0,0,.04) 40%, rgba(0,0,0,.12) 80%, rgba(0,0,0,.16) 100%);"></div>\n    ');

    _this.isDragStart = true;
    return _this;
  }

  createClass(IOSSwipeNavigatorAnimator, [{
    key: '_dragStartSetup',
    value: function _dragStartSetup(enterPage, leavePage) {
      this.isDragStart = false;

      // Avoid content clicks
      this.unblock = get(IOSSwipeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator.prototype), 'block', this).call(this, leavePage);

      // Mask
      enterPage.parentElement.insertBefore(this.backgroundMask, enterPage);

      // Decomposition
      this.target = {
        enter: util.findToolbarPage(enterPage) || enterPage,
        leave: util.findToolbarPage(leavePage) || leavePage
      };
      this.decomp = {
        enter: this._decompose(this.target.enter),
        leave: this._decompose(this.target.leave)
      };

      // Animation values
      this.delta = this._calculateDelta(leavePage, this.decomp.leave);
      this.shouldAnimateToolbar = this._shouldAnimateToolbar(this.target.enter, this.target.leave);

      // Shadow && styles
      if (this.shouldAnimateToolbar) {
        this.swipeShadow.style.top = this.decomp.leave.toolbar.offsetHeight + 'px';
        this.target.leave.appendChild(this.swipeShadow);
        this._saveStyle(this.target.enter, this.target.leave);
      } else {
        leavePage.appendChild(this.swipeShadow);
        this._saveStyle(enterPage, leavePage);
      }
      leavePage.classList.add('overflow-visible');
      this.overflowElement = leavePage;
      this.decomp.leave.content.classList.add('content-swiping');
    }
  }, {
    key: 'translate',
    value: function translate(distance, maxWidth, enterPage, leavePage) {
      if (this.isDragStart) {
        this.maxWidth = maxWidth;
        this._dragStartSetup(enterPage, leavePage);
      }

      var swipeRatio = (distance - maxWidth) / maxWidth;

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
        }), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(' + this.delta.title * swipeRatio + 'px, 0, 0)',
          opacity: 1 + swipeRatio // 0 -> 1
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          opacity: 1 + swipeRatio * 10 / 100, // 0.9 -> 1
          transform: 'translate3d(' + this.delta.label * swipeRatio + 'px, 0, 0)'
        }), Animit(this.decomp.enter.other).queue({
          opacity: 1 + swipeRatio // 0 -> 1
        }),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
          transform: 'translate3d(' + distance + 'px, 0px, 0px)'
        }), Animit(this.decomp.leave.toolbar).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(' + (1 + swipeRatio) * 125 + '%, 0, 0)'
        }), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: -1 * swipeRatio, // 1 -> 0
          transform: 'translate3d(' + this.delta.title * (1 + swipeRatio) + 'px, 0, 0)'
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }));
      } else {
        Animit.runAll(Animit(leavePage).queue({
          transform: 'translate3d(' + distance + 'px, 0px, 0px)'
        }), Animit(enterPage).queue({
          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
        }), Animit(this.swipeShadow).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }));
      }
    }
  }, {
    key: 'restore',
    value: function restore(enterPage, leavePage, callback) {
      var _this2 = this;

      if (this.isDragStart) {
        return;
      }

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(-25%, 0, 0)',
          opacity: 0.9
        }, {
          timing: this.timing,
          duration: this.durationRestore
        }), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(-' + this.delta.title + 'px, 0, 0)',
          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timing,
          opacity: 0
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          transform: 'translate3d(-' + this.delta.label + 'px, 0, 0)'
        }, {
          timing: this.timing,
          duration: this.durationRestore
        }), Animit(this.decomp.enter.other).queue({
          opacity: 0
        }, {
          timing: this.timing,
          duration: this.durationRestore
        }),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
          transform: 'translate3d(0, 0px, 0px)'
        }, {
          timing: this.timing,
          duration: this.durationRestore
        }), Animit(this.decomp.leave.toolbar).queue({
          opacity: 1
        }, {
          timing: this.timing,
          duration: this.durationRestore
        }), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(0, 0, 0)'
        }, {
          timing: this.timing,
          duration: this.durationRestore
        }), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: 1,
          transform: 'translate3d(0, 0, 0)',
          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timing
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: 0
        }, {
          timing: this.timing,
          duration: this.durationRestore
        }).queue(function (done) {
          _this2._reset(_this2.target.enter, _this2.target.leave);
          callback && callback();
          done();
        }));
      } else {
        Animit.runAll(Animit(enterPage).queue({
          css: {
            transform: 'translate3D(-25%, 0px, 0px)',
            opacity: 0.9
          },
          timing: this.timing,
          duration: this.durationRestore
        }), Animit(leavePage).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)'
          },
          timing: this.timing,
          duration: this.durationRestore
        }).queue(function (done) {
          _this2._reset(enterPage, leavePage);
          callback && callback();
          done();
        }));
      }
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      if (this.isDragStart) {
        return;
      }

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(0, 0, 0)',
          opacity: 1
        }, {
          timing: this.timing,
          duration: this.duration
        }), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(0, 0, 0)',
          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing,
          opacity: 1
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          transform: 'translate3d(0, 0, 0)'
        }, {
          timing: this.timing,
          duration: this.duration
        }), Animit(this.decomp.enter.other).queue({
          opacity: 1
        }, {
          timing: this.timing,
          duration: this.duration
        }),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background]).queue({
          transform: 'translate3d(100%, 0px, 0px)'
        }, {
          timing: this.timing,
          duration: this.duration
        }), Animit(this.decomp.leave.toolbar).queue({
          opacity: 0
        }, {
          timing: this.timing,
          duration: this.duration
        }), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(125%, 0, 0)'
        }, {
          timing: this.timing,
          duration: this.duration
        }), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: 0,
          transform: 'translate3d(' + this.delta.title + 'px, 0, 0)',
          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: 0,
          transform: 'translate3d(' + this.maxWidth + 'px, 0px, 0px)'
        }, {
          timing: this.timing,
          duration: this.duration
        }).queue(function (done) {
          _this3._reset(_this3.target.enter, _this3.target.leave);
          callback && callback();
          done();
        }));
      } else {
        Animit.runAll(Animit(enterPage).queue({
          css: {
            transform: 'translate3D(0px, 0px, 0px)',
            opacity: 1.0
          },
          duration: this.duration,
          timing: this.timing
        }), Animit(leavePage).queue({
          css: {
            transform: 'translate3D(100%, 0px, 0px)'
          },
          duration: this.duration,
          timing: this.timing
        }).queue(function (done) {
          _this3._reset(enterPage, leavePage);
          callback && callback();
          done();
        }));
      }
    }
  }, {
    key: '_saveStyle',
    value: function _saveStyle() {
      var _this4 = this;

      this._savedStyle = new WeakMap();
      var save = function save(el) {
        return _this4._savedStyle.set(el, el.getAttribute('style'));
      };

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.forEach(save);

      Object.keys(this.decomp).forEach(function (p) {
        Object.keys(_this4.decomp[p]).forEach(function (k) {
          (_this4.decomp[p][k] instanceof Array ? _this4.decomp[p][k] : [_this4.decomp[p][k]]).forEach(save);
        });
      });
    }
  }, {
    key: '_restoreStyle',
    value: function _restoreStyle() {
      var _this5 = this;

      var restore = function restore(el) {
        _this5._savedStyle.get(el) === null ? el.removeAttribute('style') : el.setAttribute('style', _this5._savedStyle.get(el));
        _this5._savedStyle.delete(el);
      };

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(restore);

      Object.keys(this.decomp).forEach(function (p) {
        Object.keys(_this5.decomp[p]).forEach(function (k) {
          (_this5.decomp[p][k] instanceof Array ? _this5.decomp[p][k] : [_this5.decomp[p][k]]).forEach(restore);
        });
      });
    }
  }, {
    key: '_reset',
    value: function _reset() {
      this._savedStyle && this._restoreStyle.apply(this, arguments);
      this.unblock && this.unblock();
      this.swipeShadow.remove();
      this.backgroundMask.remove();
      this.overflowElement.classList.remove('overflow-visible');
      this.decomp.leave.content.classList.remove('content-swiping');
      this.decomp = this.target = this.overflowElement = this._savedStyle = null;
      this.isDragStart = true;
    }
  }]);
  return IOSSwipeNavigatorAnimator;
}(IOSSlideNavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var IOSLiftNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSLiftNavigatorAnimator, _NavigatorAnimator);

  function IOSLiftNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSLiftNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSLiftNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this2.backgroundMask.remove();
        unblock();
        callback();
        done();
      }), Animit(leavePage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, -10%, 0)',
          opacity: 0.9
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, -43px, 0)', // Smaller than iOS toolbar - fixes glitch
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this3.backgroundMask.remove();
        unblock();
        callback();
        done();
      }), Animit(leavePage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }
  }]);
  return IOSLiftNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in screen transition.
 */

var IOSFadeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSFadeNavigatorAnimator, _NavigatorAnimator);

  function IOSFadeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSFadeNavigatorAnimator);
    return possibleConstructorReturn(this, (IOSFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSFadeNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(enterPage._getToolbarElement()).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage._getToolbarElement()).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return IOSFadeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition.
 */

var MDSlideNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDSlideNavigatorAnimator, _NavigatorAnimator);

  function MDSlideNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, MDSlideNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
    _this.blackMaskOpacity = 0.4;
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDSlideNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({
        opacity: 0,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: this.blackMaskOpacity
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      }), Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(100%, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), Animit(leavePage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().wait(0.2).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({
        opacity: this.blackMaskOpacity,
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(-45%, 0px, 0px)',
          opacity: 0.9
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle(), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0px, 0px, 0px)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(100%, 0px, 0px)'
        },
        duration: this.duration,
        timing: this.timing
      }).wait(0.2).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDSlideNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var MDLiftNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDLiftNavigatorAnimator, _NavigatorAnimator);

  function MDLiftNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0.05 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, MDLiftNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDLiftNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          opacity: 1.0
        },
        duration: 0
      }).queue({
        css: {
          opacity: 0.4
        },
        duration: this.duration,
        timing: this.timing
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 0.4
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        },
        duration: this.duration,
        timing: this.timing
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)'
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 100%, 0)'
        },
        duration: this.duration,
        timing: this.timing
      }));
    }
  }]);
  return MDLiftNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in + Lift screen transition.
 */

var MDFadeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDFadeNavigatorAnimator, _NavigatorAnimator);

  function MDFadeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(0.4, 0.0, 0.2, 1)' : _ref$timing,
        _ref$timingOnPop = _ref.timingOnPop,
        timingOnPop = _ref$timingOnPop === undefined ? 'cubic-bezier(0.4, 0.0, 1, 1)' : _ref$timingOnPop,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, MDFadeNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.timingOnPop = timingOnPop;
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDFadeNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage).saveStyle().queue({
        css: {
          transform: 'translate3D(0, 42px, 0)',
          opacity: 0
        },
        duration: 0
      }).wait(this.delay).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(leavePage).queue({
        css: {
          transform: 'translate3D(0, 0, 0)',
          opacity: 1
        },
        duration: 0
      }).wait(0.15).queue({
        css: {
          transform: 'translate3D(0, 38px, 0)',
          opacity: 0
        },
        duration: this.duration,
        timing: this.timingOnPop
      }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDFadeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NoneNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(NoneNavigatorAnimator, _NavigatorAnimator);

  function NoneNavigatorAnimator(options) {
    classCallCheck(this, NoneNavigatorAnimator);
    return possibleConstructorReturn(this, (NoneNavigatorAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorAnimator)).call(this, options));
  }

  createClass(NoneNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }]);
  return NoneNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$4 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSSlideNavigatorAnimator;
  },
  'slide': function slide() {
    return platform.isAndroid() ? MDSlideNavigatorAnimator : IOSSlideNavigatorAnimator;
  },
  'lift': function lift() {
    return platform.isAndroid() ? MDLiftNavigatorAnimator : IOSLiftNavigatorAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSFadeNavigatorAnimator;
  },
  'slide-ios': IOSSlideNavigatorAnimator,
  'slide-md': MDSlideNavigatorAnimator,
  'lift-ios': IOSLiftNavigatorAnimator,
  'lift-md': MDLiftNavigatorAnimator,
  'fade-ios': IOSFadeNavigatorAnimator,
  'fade-md': MDFadeNavigatorAnimator,
  'none': NoneNavigatorAnimator
};

var rewritables = {
  /**
   * @param {Element} navigatorSideElement
   * @param {Function} callback
   */
  ready: function ready(navigatorElement, callback) {
    callback();
  }
};

/**
 * @element ons-navigator
 * @category navigation
 * @description
 *   [en]
 *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
 *
 *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
 *   [/en]
 *   [ja][/ja]
 * @codepen yrhtv
 * @tutorial vanilla/Reference/navigator
 * @guide lifecycle.html#events
 *   [en]Overview of page events[/en]
 *   [ja]Overview of page events[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
 *   [ja][/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-navigator id="navigator">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="center">
 *         Title
 *       </div>
 *     </ons-toolbar>
 *     <p>
 *       <ons-button
 *         onclick="document.getElementById('navigator').pushPage('page.html')">
 *         Push page
 *       </ons-button>
 *     </p>
 *   </ons-page>
 * </ons-navigator>
 *
 * <ons-template id="page.html">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="left">
 *         <ons-back-button>Back</ons-back-button>
 *       </div>
 *       <div class="center">
 *         Another page
 *       </div>
 *     </ons-toolbar>
 *   </ons-page>
 * </ons-template>
 */

var NavigatorElement = function (_BaseElement) {
  inherits(NavigatorElement, _BaseElement);
  createClass(NavigatorElement, [{
    key: 'animatorFactory',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]First page to show when navigator is initialized.[/en]
     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
     */

    /**
     * @attribute swipeable
     * @type {Boolean}
     * @description
     *   [en]Enable iOS "swipe to pop" feature.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute swipe-target-width
     * @type {String}
     * @default 20px
     * @description
     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
     */

    /**
     * @attribute swipe-threshold
     * @type {Number}
     * @default 0.2
     * @description
     *  [en]Specify how much the page needs to be swiped before popping. A value between `0` and `1`.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @event prepush
     * @description
     *   [en]Fired just before a page is pushed.[/en]
     *   [ja]pageがpushされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the push.[/en]
     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
     */

    /**
     * @event prepop
     * @description
     *   [en]Fired just before a page is popped.[/en]
     *   [ja]pageがpopされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the pop.[/en]
     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
     */

    /**
     * @event postpush
     * @description
     *   [en]Fired just after a page is pushed.[/en]
     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]pushされたpageオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]以前のpageオブジェクト。[/ja]
     */

    /**
     * @event postpop
     * @description
     *   [en]Fired just after a page is popped.[/en]
     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]popされて表示されるページのオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]popされて消えるページのオブジェクト。[/ja]
     */

    get: function get$$1() {
      return this._animatorFactory;
    }
  }]);

  function NavigatorElement() {
    classCallCheck(this, NavigatorElement);

    var _this = possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).call(this));

    _this._isRunning = false;
    _this._initialized = false;
    _this._pageLoader = defaultPageLoader;
    _this._pageMap = new WeakMap();

    _this._updateAnimatorFactory();
    return _this;
  }

  /**
   * @property pageLoader
   * @type {PageLoader}
   * @description
   *   [en]PageLoader instance. It can be overriden to change the way pages are loaded by this element. Useful for lib developers.[/en]
   *   [ja]PageLoaderインスタンスを格納しています。[/ja]
   */


  createClass(NavigatorElement, [{
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Specify the page to be loaded during initialization. This value takes precedence over the `page` attribute. Useful for lib developers.[/en]
     *   [ja]初期化時に読み込むページを指定します。`page`属性で指定した値よりも`page`プロパティに指定した値を優先します。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

      if (!platform.isAndroid() || this.getAttribute('swipeable') === 'force') {
        this._swipeAnimator = new IOSSwipeNavigatorAnimator();

        this._swipe = new SwipeReveal({
          element: this,
          swipeMax: function swipeMax() {
            return _this2[_this2.swipeMax ? 'swipeMax' : 'popPage']({ animator: _this2._swipeAnimator });
          },
          swipeMid: function swipeMid(distance, width) {
            return _this2._swipeAnimator.translate(distance, width, _this2.topPage.previousElementSibling, _this2.topPage);
          },
          swipeMin: function swipeMin() {
            return _this2._swipeAnimator.restore(_this2.topPage.previousElementSibling, _this2.topPage);
          },
          getThreshold: function getThreshold() {
            return Math.max(0.2, parseFloat(_this2.getAttribute('swipe-threshold')) || 0);
          },
          ignoreSwipe: function ignoreSwipe(event, distance) {
            if (/ons-back-button/i.test(event.target.tagName) || util.findParent(event.target, 'ons-back-button', function (p) {
              return (/ons-page/i.test(p.tagName)
              );
            })) {
              return true;
            }
            var area = parseInt(_this2.getAttribute('swipe-target-width') || 25, 10);
            return event.gesture.direction !== 'right' || area <= distance || _this2._isRunning || _this2.children.length <= 1;
          }
        });

        this.attributeChangedCallback('swipeable');
      }

      if (this._initialized) {
        return;
      }

      this._initialized = true;

      var deferred = util.defer();
      this.loaded = deferred.promise;

      rewritables.ready(this, function () {
        var show = !util.hasAnyComponentAsParent(_this2);
        var options = { animation: 'none', show: show };

        if (_this2.pages.length === 0 && _this2._getPageTarget()) {
          _this2.pushPage(_this2._getPageTarget(), options).then(function () {
            return deferred.resolve();
          });
        } else if (_this2.pages.length > 0) {
          for (var i = 0; i < _this2.pages.length; i++) {
            if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
              throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
            }
          }

          if (_this2.topPage) {
            contentReady(_this2.topPage, function () {
              return setTimeout(function () {
                deferred.resolve();
                show && _this2.topPage._show();
                _this2._updateLastPageBackButton();
              }, 0);
            });
          }
        } else {
          contentReady(_this2, function () {
            if (_this2.pages.length === 0 && _this2._getPageTarget()) {
              _this2.pushPage(_this2._getPageTarget(), options).then(function () {
                return deferred.resolve();
              });
            } else {
              deferred.resolve();
            }
          });
        }
      });
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$4,
        baseClass: NavigatorAnimator,
        baseClassName: 'NavigatorAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._swipe && this._swipe.dispose();
      this._swipe = this._swipeAnimator = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'animation':
          this._updateAnimatorFactory();
          break;
        case 'swipeable':
          this._swipe && this._swipe.update();
          break;
      }
    }

    /**
     * @method popPage
     * @signature popPage([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
     */

  }, {
    key: 'popPage',
    value: function popPage() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _preparePageAndOption = this._preparePageAndOptions(null, options);

      options = _preparePageAndOption.options;


      var popUpdate = function popUpdate() {
        return new Promise(function (resolve) {
          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);
          resolve();
        });
      };

      return this._popPage(options, popUpdate);
    }
  }, {
    key: '_popPage',
    value: function _popPage(options) {
      var _this4 = this;

      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('popPage is already running.');
      }

      if (this.pages.length <= 1) {
        return Promise.reject('ons-navigator\'s page stack is empty.');
      }

      if (this._emitPrePopEvent()) {
        return Promise.reject('Canceled in prepop event.');
      }

      var length = this.pages.length;

      this._isRunning = true;

      this.pages[length - 2].updateBackButton(length - 2 > 0);

      return new Promise(function (resolve) {
        var leavePage = _this4.pages[length - 1];
        var enterPage = _this4.pages[length - 2];

        options.animation = options.animation || (leavePage.pushedOptions ? leavePage.pushedOptions.animation : undefined);
        options.animationOptions = util.extend({}, leavePage.pushedOptions ? leavePage.pushedOptions.animationOptions : {}, options.animationOptions || {});

        if (options.data) {
          enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        }

        var callback = function callback() {
          update().then(function () {
            _this4._isRunning = false;

            enterPage._show();
            util.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          });
        };

        leavePage._hide();
        var animator = options.animator || _this4._animatorFactory.newAnimator(options);
        animator.pop(_this4.pages[length - 2], _this4.pages[length - 1], callback);
      }).catch(function () {
        return _this4._isRunning = false;
      });
    }

    /**
     * @method pushPage
     * @signature pushPage(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
     *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.page]
     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
     *   [ja][/ja]
     * @param {String} [options.pageHTML]
     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the pushed page.[/en]
     *   [ja]追加したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pushes the specified page into the stack.[/en]
     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]
     */

  }, {
    key: 'pushPage',
    value: function pushPage(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption2.page;
      options = _preparePageAndOption2.options;


      var prepare = function prepare(pageElement) {
        _this5._verifyPageElement(pageElement);
        _this5._pageMap.set(pageElement, page);
        pageElement = util.extend(pageElement, {
          data: options.data
        });
        pageElement.style.visibility = 'hidden';
      };

      if (options.pageHTML) {
        return this._pushPage(options, function () {
          return new Promise(function (resolve) {
            instantPageLoader.load({ page: options.pageHTML, parent: _this5, params: options.data }, function (pageElement) {
              prepare(pageElement);
              resolve();
            });
          });
        });
      }

      return this._pushPage(options, function () {
        return new Promise(function (resolve) {
          _this5._pageLoader.load({ page: page, parent: _this5, params: options.data }, function (pageElement) {
            prepare(pageElement);
            resolve();
          });
        });
      });
    }
  }, {
    key: '_pushPage',
    value: function _pushPage() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }

      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      this._isRunning = true;

      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
      options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

      var animator = this._animatorFactory.newAnimator(options);

      return update().then(function () {
        var pageLength = _this6.pages.length;

        var enterPage = _this6.pages[pageLength - 1];
        var leavePage = options.leavePage || _this6.pages[pageLength - 2];

        if (enterPage.nodeName !== 'ONS-PAGE') {
          throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
        }

        enterPage.updateBackButton(pageLength > (options._replacePage ? 2 : 1));

        enterPage.pushedOptions = util.extend({}, enterPage.pushedOptions || {}, options || {});
        enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
        enterPage.unload = enterPage.unload || options.unload;

        return new Promise(function (resolve) {
          var done = function done() {
            _this6._isRunning = false;

            options.show !== false && setImmediate(function () {
              return enterPage._show();
            });
            util.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

            if (typeof options.callback === 'function') {
              options.callback();
            }

            resolve(enterPage);
          };

          enterPage.style.visibility = '';
          if (leavePage) {
            leavePage._hide();
            animator.push(enterPage, leavePage, done);
          } else {
            done();
          }
        });
      }).catch(function (error) {
        _this6._isRunning = false;
        throw error;
      });
    }

    /**
     * @method replacePage
     * @signature replacePage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new page.[/en]
     *   [ja]新しいページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
     */

  }, {
    key: 'replacePage',
    value: function replacePage(page) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.pushPage(page, options).then(function (resolvedValue) {
        if (_this7.pages.length > 1) {
          _this7._pageLoader.unload(_this7.pages[_this7.pages.length - 2]);
        }
        _this7._updateLastPageBackButton();

        return Promise.resolve(resolvedValue);
      });
    }

    /**
     * @method insertPage
     * @signature insertPage(index, page, [options])
     * @param {Number} index
     *   [en]The index where it should be inserted.[/en]
     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the inserted page.[/en]
     *   [ja]指定したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]
     */

  }, {
    key: 'insertPage',
    value: function insertPage(index, page) {
      var _this8 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption3.page;
      options = _preparePageAndOption3.options;

      index = this._normalizeIndex(index);

      if (index >= this.pages.length) {
        return this.pushPage(page, options);
      }

      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;

      return new Promise(function (resolve) {
        loader.load({ page: page, parent: _this8 }, function (pageElement) {
          _this8._verifyPageElement(pageElement);
          _this8._pageMap.set(pageElement, page);
          pageElement = util.extend(pageElement, {
            data: options.data,
            pushedOptions: options
          });

          options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

          _this8.insertBefore(pageElement, _this8.pages[index]);
          _this8.topPage.updateBackButton(true);

          setTimeout(function () {
            pageElement = null;
            resolve(_this8.pages[index]);
          }, 1000 / 60);
        });
      });
    }

    /**
     * @method removePage
     * @signature removePage(index, [options])
     * @param {Number} index
     *   [en]The index where it should be removed.[/en]
     *   [ja]スタックから削除するページのインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]削除によって表示されたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Remove the specified page at a position in the stack defined by the `index` argument. Extends `popPage()` parameters.[/en]
     *   [ja]指定したインデックスにあるページを削除します。[/ja]
     */

  }, {
    key: 'removePage',
    value: function removePage(index) {
      var _this9 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      index = this._normalizeIndex(index);

      if (index < this.pages.length - 1) {
        return new Promise(function (resolve) {
          var leavePage = _this9.pages[index];
          var enterPage = _this9.topPage;

          _this9._pageMap.delete(leavePage);
          _this9._pageLoader.unload(leavePage);
          if (_this9.pages.length === 1) {
            // edge case
            _this9.topPage.updateBackButton(false);
          }

          resolve(enterPage);
        });
      } else {
        return this.popPage(options);
      }
    }

    /**
     * @method resetToPage
     * @signature resetToPage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
     */

  }, {
    key: 'resetToPage',
    value: function resetToPage(page) {
      var _this10 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption4.page;
      options = _preparePageAndOption4.options;


      if (!options.animator && !options.animation) {
        options.animation = 'none';
      }

      var callback = options.callback;

      options.callback = function () {
        while (_this10.pages.length > 1) {
          _this10._pageLoader.unload(_this10.pages[0]);
        }

        _this10.pages[0].updateBackButton(false);
        callback && callback();
      };

      if (!options.page && !options.pageHTML && this._getPageTarget()) {
        page = options.page = this._getPageTarget();
      }

      return this.pushPage(page, options);
    }

    /**
     * @method bringPageTop
     * @signature bringPageTop(item, [options])
     * @param {String|Number} item
     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
     */

  }, {
    key: 'bringPageTop',
    value: function bringPageTop(item) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {
        throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
      }
      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
      var page = this.pages[index];

      if (index < 0) {
        return this.pushPage(item, options);
      }

      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);

      options = _preparePageAndOption5.options;


      if (index === this.pages.length - 1) {
        return Promise.resolve(page);
      }
      if (!page) {
        throw new Error('Failed to find item ' + item);
      }
      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }
      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      page.style.visibility = 'hidden';
      page.parentNode.appendChild(page);
      return this._pushPage(options);
    }
  }, {
    key: '_preparePageAndOptions',
    value: function _preparePageAndOptions(page) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        throw new Error('options must be an object. You supplied ' + options);
      }

      if ((page === null || page === undefined) && options.page) {
        page = options.page;
      }

      options = util.extend({}, this.options || {}, options, { page: page });

      return { page: page, options: options };
    }
  }, {
    key: '_updateLastPageBackButton',
    value: function _updateLastPageBackButton() {
      var index = this.pages.length - 1;
      if (index >= 0) {
        this.pages[index].updateBackButton(index > 0);
      }
    }
  }, {
    key: '_normalizeIndex',
    value: function _normalizeIndex(index) {
      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
    }
  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      if (this.pages.length > 1) {
        this.popPage();
      } else {
        event.callParentHandler();
      }
    }
  }, {
    key: '_lastIndexOfPage',
    value: function _lastIndexOfPage(pageName) {
      var index = void 0;
      for (index = this.pages.length - 1; index >= 0; index--) {
        if (!this._pageMap.has(this.pages[index])) {
          throw Error('This is bug.');
        }

        if (pageName === this._pageMap.get(this.pages[index])) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_emitPreEvent',
    value: function _emitPreEvent(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isCanceled = false;

      util.triggerElementEvent(this, 'pre' + name, util.extend({
        navigator: this,
        currentPage: this.pages[this.pages.length - 1],
        cancel: function cancel() {
          return isCanceled = true;
        }
      }, data));

      return isCanceled;
    }
  }, {
    key: '_emitPrePushEvent',
    value: function _emitPrePushEvent() {
      return this._emitPreEvent('push');
    }
  }, {
    key: '_emitPrePopEvent',
    value: function _emitPrePopEvent() {
      var l = this.pages.length;
      return this._emitPreEvent('pop', {
        leavePage: this.pages[l - 1],
        enterPage: this.pages[l - 2]
      });
    }

    // TODO: 書き直す

  }, {
    key: '_createPageElement',
    value: function _createPageElement(templateHTML) {
      var pageElement = util.createElement(internal$1.normalizePageHTML(templateHTML));
      this._verifyPageElement(pageElement);
      return pageElement;
    }

    /**
     * @param {Element} element
     */

  }, {
    key: '_verifyPageElement',
    value: function _verifyPageElement(element) {
      if (element.nodeName.toLowerCase() !== 'ons-page') {
        throw new Error('You must supply an "ons-page" element to "ons-navigator".');
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      var _this11 = this;

      this.loaded.then(function () {
        return _this11.topPage && _this11.topPage._show();
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.topPage && this.topPage._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      for (var i = this.pages.length - 1; i >= 0; i--) {
        this._pageLoader.unload(this.pages[i]);
      }

      this.remove();
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(pageLoader) {
      if (!(pageLoader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = pageLoader;
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    },
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }

    /**
     * @property topPage
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
     */

  }, {
    key: 'topPage',
    get: function get$$1() {
      var last = this.lastElementChild;
      while (last && last.tagName !== 'ONS-PAGE') {
        last = last.previousElementSibling;
      }
      return last;
    }

    /**
     * @property pages
     * @readonly
     * @type {Array}
     * @description
     *   [en]Copy of the navigator's page stack.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pages',
    get: function get$$1() {
      return util.arrayFrom(this.children).filter(function (element) {
        return element.tagName === 'ONS-PAGE';
      });
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Default options object. Attributes have priority over this property.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

  }, {
    key: 'options',
    get: function get$$1() {
      return this._options;
    },
    set: function set$$1(object) {
      this._options = object;
    }
  }, {
    key: '_isRunning',
    set: function set$$1(value) {
      this.setAttribute('_is-running', value ? 'true' : 'false');
    },
    get: function get$$1() {
      return JSON.parse(this.getAttribute('_is-running'));
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof NavigatorAnimator)) {
        throw new Error('"Animator" param must inherit NavigatorElement.NavigatorAnimator');
      }

      _animatorDict$4[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return ['animation', 'swipeable'];
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$4;
    }
  }, {
    key: 'NavigatorAnimator',
    get: function get$$1() {
      return NavigatorAnimator;
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['prepush', 'postpush', 'prepop', 'postpop'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables;
    }
  }]);
  return NavigatorElement;
}(BaseElement);

ons$1.elements.Navigator = NavigatorElement;
customElements.define('ons-navigator', NavigatorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$13 = 'toolbar';

var scheme$21 = {
  '': 'toolbar--*',
  '.toolbar__left': 'toolbar--*__left',
  '.toolbar__center': 'toolbar--*__center',
  '.toolbar__right': 'toolbar--*__right'
};

/**
 * @element ons-toolbar
 * @category page
 * @modifier material
 *   [en]Material Design toolbar.[/en]
 *   [ja][/ja]
 * @modifier transparent
 *   [en]Transparent toolbar.[/en]
 *   [ja]透明な背景を持つツールバーを表示します。[/ja]
 * @modifier cover-content
 *   [en]Displays the toolbar on top of the page's content. Should be combined with `transparent` modifier.[/en]
 *   [ja][/ja]
 * @modifier noshadow
 *   [en]Toolbar without shadow.[/en]
 *   [ja]ツールバーに影を付けずに表示します。[/ja]
 * @description
 *   [en]
 *     Toolbar component that can be used with navigation.
 *
 *     Left, center and right container can be specified by class names.
 *
 *     This component will automatically displays as a Material Design toolbar when running on Android devices.
 *   [/en]
 *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide compilation.html#toolbar-compilation [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
 * @seealso ons-bottom-toolbar
 *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
 *   [ja]ons-bottom-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @seealso ons-toolbar-button
 *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
 *   [ja]ons-toolbar-buttonコンポーネント[/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>
 *         Back
 *       </ons-back-button>
 *     </div>
 *     <div class="center">
 *       Title
 *     </div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 * </ons-page>
 */

var ToolbarElement = function (_BaseElement) {
  inherits(ToolbarElement, _BaseElement);

  /**
   * @attribute inline
   * @initonly
   * @description
   *   [en]Display the toolbar as an inline element.[/en]
   *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
   */

  /**
   * @attribute modifier
   * @description
   *   [en]The appearance of the toolbar.[/en]
   *   [ja]ツールバーの表現を指定します。[/ja]
   */

  function ToolbarElement() {
    classCallCheck(this, ToolbarElement);

    var _this = possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(ToolbarElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$13, scheme$21);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$21);
          break;
      }
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarLeftItemsElement',
    value: function _getToolbarLeftItemsElement() {
      return this.querySelector('.left') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarCenterItemsElement',
    value: function _getToolbarCenterItemsElement() {
      return this.querySelector('.center') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarRightItemsElement',
    value: function _getToolbarRightItemsElement() {
      return this.querySelector('.right') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonLabelElement',
    value: function _getToolbarBackButtonLabelElement() {
      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonIconElement',
    value: function _getToolbarBackButtonIconElement() {
      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$13);
      this._ensureToolbarItemElements();
      ModifierUtil.initModifier(this, scheme$21);
    }
  }, {
    key: '_ensureToolbarItemElements',
    value: function _ensureToolbarItemElements() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        // case of not element
        if (this.childNodes[i].nodeType != 1) {
          this.removeChild(this.childNodes[i]);
        }
      }

      var center = this._ensureToolbarElement('center');
      center.classList.add('toolbar__title');

      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
        var left = this._ensureToolbarElement('left');
        var right = this._ensureToolbarElement('right');

        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
          this.appendChild(left);
          this.appendChild(center);
          this.appendChild(right);
        }
      }
    }
  }, {
    key: '_ensureToolbarElement',
    value: function _ensureToolbarElement(name) {
      if (util.findChild(this, '.toolbar__' + name)) {
        var _element = util.findChild(this, '.toolbar__' + name);
        _element.classList.add(name);
        return _element;
      }

      var element = util.findChild(this, '.' + name) || util.create('.' + name);
      element.classList.add('toolbar__' + name);

      return element;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarElement;
}(BaseElement);

ons$1.elements.Toolbar = ToolbarElement;
customElements.define('ons-toolbar', ToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$12 = 'page';
var scheme$20 = {
  '': 'page--*',
  '.page__content': 'page--*__content',
  '.page__background': 'page--*__background'
};

/**
 * @element ons-page
 * @category page
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     This component defines the root of each page. If the content is large it will become scrollable.
 *
 *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
 *   [/en]
 *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
 * @tutorial vanilla/Reference/page
 * @guide lifecycle.html#events
 *   [en]Overview of page events[/en]
 *   [ja]Overview of page events[/ja]
 * @guide fundamentals.html#managing-pages
 *   [en]Managing multiple pages[/en]
 *   [ja]複数のページを管理する[/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-toolbar
 *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>Back</ons-back-button>
 *     </div>
 *     <div class="center">Title</div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 *
 *   <p>Page content</p>
 * </ons-page>
 *
 * @example
 * <script>
 *   myApp.handler = function(done) {
 *     loadMore().then(done);
 *   }
 * </script>
 *
 * <ons-page on-infinite-scroll="myApp.handler">
 *   <ons-toolbar>
 *     <div class="center">List</div>
 *   </ons-toolbar>
 *
 *   <ons-list>
 *     <ons-list-item>#1</ons-list-item>
 *     <ons-list-item>#2</ons-list-item>
 *     <ons-list-item>#3</ons-list-item>
 *     ...
 *   </ons-list>
 * </ons-page>
 */

var PageElement = function (_BaseElement) {
  inherits(PageElement, _BaseElement);

  /**
   * @event init
   * @description
   *   [en]Fired right after the page is attached.[/en]
   *   [ja]ページがアタッチされた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event show
   * @description
   *   [en]Fired right after the page is shown.[/en]
   *   [ja]ページが表示された後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event hide
   * @description
   *   [en]Fired right after the page is hidden.[/en]
   *   [ja]ページが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event destroy
   * @description
   *   [en]Fired right before the page is destroyed.[/en]
   *   [ja]ページが破棄される前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Specify modifier name to specify custom styles.[/en]
   *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
   */

  /**
   * @attribute on-infinite-scroll
   * @type {String}
   * @description
   *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
   *   [ja][/ja]
   */

  function PageElement() {
    classCallCheck(this, PageElement);

    var _this = possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).call(this));

    _this._deriveHooks();

    _this.classList.add(defaultClassName$12);
    _this._initialized = false;

    _this._contentObserver = new MutationObserver(function () {
      _this._tryToSuppressLayerCreation();
    });

    contentReady(_this, function () {
      _this._compile();

      _this._isShown = false;
      _this._contentElement = _this._getContentElement();
      _this._backgroundElement = _this._getBackgroundElement();

      _this._contentObserver.observe(_this._contentElement, { childList: true });
      _this._tryToSuppressLayerCreation();
    });
    return _this;
  }

  createClass(PageElement, [{
    key: '_tryToSuppressLayerCreation',
    value: function _tryToSuppressLayerCreation() {
      if (!this._contentElement) {
        return;
      }

      var content = this._contentElement;
      var scrollerSet = new Set(['ons-navigator', 'ons-page', 'ons-tabbar', 'ons-splitter']);

      var shouldSuppress = content.children.length === 1 && scrollerSet.has(content.children[0].nodeName.toLowerCase());

      // If content element has only one element and the element has scroll content, there is no need for layer creation in this content element.
      if (shouldSuppress) {
        content.classList.add('page__content--suppress-layer-creation');
      } else {
        content.classList.remove('page__content--suppress-layer-creation');
      }
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this2 = this;

      autoStyle.prepare(this);

      var toolbar = util.findChild(this, 'ons-toolbar');

      var background = util.findChild(this, '.page__background') || util.findChild(this, '.background') || document.createElement('div');
      background.classList.add('page__background');
      this.insertBefore(background, !toolbar && this.firstChild || toolbar && toolbar.nextSibling);

      var content = util.findChild(this, '.page__content') || util.findChild(this, '.content') || document.createElement('div');
      content.classList.add('page__content');
      if (!content.parentElement) {
        util.arrayFrom(this.childNodes).forEach(function (node) {
          if (node.nodeType !== 1 || _this2._elementShouldBeMoved(node)) {
            content.appendChild(node); // Can trigger detached connectedCallbacks
          }
        });
      }

      this._tryToFillStatusBar(content); // Must run before child pages try to fill status bar.
      this.insertBefore(content, background.nextSibling); // Can trigger attached connectedCallbacks

      // Make wrapper pages transparent for animations
      if (!background.style.backgroundColor && (!toolbar || !util.hasModifier(toolbar, 'transparent')) && content.children.length === 1 && util.isPageControl(content.children[0])) {
        background.style.backgroundColor = 'transparent';
      }

      ModifierUtil.initModifier(this, scheme$20);
    }
  }, {
    key: '_elementShouldBeMoved',
    value: function _elementShouldBeMoved(el) {
      if (el.classList.contains('page__background')) {
        return false;
      }
      var tagName = el.tagName.toLowerCase();
      if (tagName === 'ons-fab') {
        return !el.hasAttribute('position');
      }
      var fixedElements = ['script', 'ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial', 'ons-dialog', 'ons-alert-dialog', 'ons-popover', 'ons-action-sheet'];
      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
    }
  }, {
    key: '_tryToFillStatusBar',
    value: function _tryToFillStatusBar() {
      var _this3 = this;

      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;

      internal$1.autoStatusBarFill(function () {
        util.toggleAttribute(_this3, 'status-bar-fill', !util.findParent(_this3, function (e) {
          return e.hasAttribute('status-bar-fill');
        }) // Not already filled
        && (_this3._canAnimateToolbar(content) || !util.findChild(content, util.isPageControl)) // Has toolbar or cannot delegate
        );
      });
    }
  }, {
    key: '_canAnimateToolbar',
    value: function _canAnimateToolbar() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;

      if (util.findChild(this, 'ons-toolbar')) {
        return true;
      }
      return !!util.findChild(content, function (el) {
        return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      if (!util.isAttached(this)) {
        // Avoid detached calls
        return;
      }

      contentReady(this, function () {
        _this4._tryToFillStatusBar(); // Ensure status bar when the element was compiled before connected

        if (_this4.hasAttribute('on-infinite-scroll')) {
          _this4.attributeChangedCallback('on-infinite-scroll', null, _this4.getAttribute('on-infinite-scroll'));
        }

        if (!_this4._initialized) {
          _this4._initialized = true;

          setImmediate(function () {
            _this4.onInit && _this4.onInit();
            util.triggerElementEvent(_this4, 'init');
          });

          if (!util.hasAnyComponentAsParent(_this4)) {
            setImmediate(function () {
              return _this4._show();
            });
          }
        }
      });
    }
  }, {
    key: 'updateBackButton',
    value: function updateBackButton(show) {
      if (this.backButton) {
        show ? this.backButton.show() : this.backButton.hide();
      }
    }
  }, {
    key: '_onScroll',
    value: function _onScroll() {
      var _this5 = this;

      var c = this._contentElement,
          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
        this._loadingContent = true;
        this._onInfiniteScroll(function () {
          return _this5._loadingContent = false;
        });
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_getContentElement',
    value: function _getContentElement() {
      var result = util.findChild(this, '.page__content');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__content" element.');
    }
  }, {
    key: '_getBackgroundElement',
    value: function _getBackgroundElement() {
      var result = util.findChild(this, '.page__background');
      if (result) {
        return result;
      }
      throw Error('fail to get ".page__background" element.');
    }
  }, {
    key: '_getBottomToolbarElement',
    value: function _getBottomToolbarElement() {
      return util.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;
    }
  }, {
    key: '_getToolbarElement',
    value: function _getToolbarElement() {
      return util.findChild(this, 'ons-toolbar') || document.createElement('ons-toolbar');
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this6 = this;

      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$12, scheme$20);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$20);
          break;
        case 'on-infinite-scroll':
          if (current === null) {
            this.onInfiniteScroll = null;
          } else {
            this.onInfiniteScroll = function (done) {
              var f = util.findFromPath(current);
              _this6.onInfiniteScroll = f;
              f(done);
            };
          }
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this._isShown && util.isAttached(this)) {
        this._isShown = true;
        this.onShow && this.onShow();
        util.triggerElementEvent(this, 'show');
        util.propagateAction(this, '_show');
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._isShown) {
        this._isShown = false;
        this.onHide && this.onHide();
        util.triggerElementEvent(this, 'hide');
        util.propagateAction(this, '_hide');
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._hide();

      this.onDestroy && this.onDestroy();
      util.triggerElementEvent(this, 'destroy');

      if (this.onDeviceBackButton) {
        this.onDeviceBackButton.destroy();
      }

      util.propagateAction(this, '_destroy');

      this.remove();
    }
  }, {
    key: '_deriveHooks',
    value: function _deriveHooks() {
      var _this7 = this;

      this.constructor.events.forEach(function (event) {
        var key = 'on' + event.charAt(0).toUpperCase() + event.slice(1);
        Object.defineProperty(_this7, key, {
          enumerable: true,
          get: function get$$1() {
            return _this7['_' + key];
          },
          set: function set$$1(value) {
            if (!(value instanceof Function)) {
              throw new Error(key + ' hook must be a function');
            }
            _this7['_' + key] = value.bind(_this7);
          }
        });
      });
    }
  }, {
    key: 'name',
    set: function set$$1(str) {
      this.setAttribute('name', str);
    },
    get: function get$$1() {
      return this.getAttribute('name');
    }
  }, {
    key: 'backButton',
    get: function get$$1() {
      return this.querySelector('ons-back-button');
    }

    /**
     * @property onInfiniteScroll
     * @description
     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'onInfiniteScroll',
    set: function set$$1(value) {
      var _this8 = this;

      if (value && !(value instanceof Function)) {
        throw new Error('onInfiniteScroll must be a function or null');
      }

      contentReady(this, function () {
        if (!value) {
          _this8._contentElement.removeEventListener('scroll', _this8._boundOnScroll);
        } else if (!_this8._onInfiniteScroll) {
          _this8._infiniteScrollLimit = 0.9;
          _this8._boundOnScroll = _this8._onScroll.bind(_this8);
          setImmediate(function () {
            return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);
          });
        }
        _this8._onInfiniteScroll = value;
      });
    },
    get: function get$$1() {
      return this._onInfiniteScroll;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'scrollTop',
    get: function get$$1() {
      return this._contentElement.scrollTop;
    },
    set: function set$$1(newValue) {
      this._contentElement.scrollTop = newValue;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'on-infinite-scroll', 'class'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['init', 'show', 'hide', 'destroy'];
    }

    /**
     * @property data
     * @type {*}
     * @description
     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
     *   [ja][/ja]
     */

  }]);
  return PageElement;
}(BaseElement);

ons$1.elements.Page = PageElement;
customElements.define('ons-page', PageElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var PopoverAnimator = function (_BaseAnimator) {
  inherits(PopoverAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function PopoverAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, PopoverAnimator);
    return possibleConstructorReturn(this, (PopoverAnimator.__proto__ || Object.getPrototypeOf(PopoverAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  createClass(PopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      callback();
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      callback();
    }
  }, {
    key: '_animate',
    value: function _animate(element, _ref2) {
      var from = _ref2.from,
          to = _ref2.to,
          options = _ref2.options,
          callback = _ref2.callback,
          _ref2$restore = _ref2.restore,
          restore = _ref2$restore === undefined ? false : _ref2$restore,
          animation = _ref2.animation;

      options = util.extend({}, this.options, options);

      if (animation) {
        from = animation.from;
        to = animation.to;
      }

      animation = Animit(element);
      if (restore) {
        animation = animation.saveStyle();
      }
      animation = animation.queue(from).wait(this.delay).queue({
        css: to,
        duration: this.duration,
        timing: this.timing
      });
      if (restore) {
        animation = animation.restoreStyle();
      }
      if (callback) {
        animation = animation.queue(function (done) {
          callback();
          done();
        });
      }
      return animation;
    }
  }, {
    key: '_animateAll',
    value: function _animateAll(element, animations) {
      var _this2 = this;

      Object.keys(animations).forEach(function (key) {
        return _this2._animate(element[key], animations[key]).play();
      });
    }
  }]);
  return PopoverAnimator;
}(BaseAnimator);

var fade = {
  out: {
    from: { opacity: 1.0 },
    to: { opacity: 0 }
  },
  in: {
    from: { opacity: 0 },
    to: { opacity: 1.0 }
  }
};

var MDFadePopoverAnimator = function (_PopoverAnimator) {
  inherits(MDFadePopoverAnimator, _PopoverAnimator);

  function MDFadePopoverAnimator() {
    classCallCheck(this, MDFadePopoverAnimator);
    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(MDFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.in,
        _popover: { animation: fade.in, restore: true, callback: callback }
      });
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.out,
        _popover: { animation: fade.out, restore: true, callback: callback }
      });
    }
  }]);
  return MDFadePopoverAnimator;
}(PopoverAnimator);

var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

  function IOSFadePopoverAnimator() {
    classCallCheck(this, IOSFadePopoverAnimator);
    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(IOSFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.in,
        _popover: {
          from: {
            transform: 'scale3d(1.3, 1.3, 1.0)',
            opacity: 0
          },
          to: {
            transform: 'scale3d(1.0, 1.0,  1.0)',
            opacity: 1.0
          },
          restore: true,
          callback: callback
        }
      });
    }
  }]);
  return IOSFadePopoverAnimator;
}(MDFadePopoverAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// This object should not be exposed to users. Please keep this private.
var iPhoneXPatch = {};

iPhoneXPatch.isIPhoneXPortraitPatchActive = function () {
  return document.documentElement.getAttribute('onsflag-iphonex-portrait') != null && window.innerWidth < window.innerHeight;
};

iPhoneXPatch.isIPhoneXLandscapePatchActive = function () {
  // If width === height, treat it as landscape
  return document.documentElement.getAttribute('onsflag-iphonex-landscape') != null && window.innerWidth >= window.innerHeight;
};

/**
 * Returns the safe area lengths based on the current state of the safe areas.
 */
iPhoneXPatch.getSafeAreaLengths = function () {
  var safeAreaLengths = void 0;
  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
    safeAreaLengths = {
      top: 44,
      right: 0,
      bottom: 34,
      left: 0
    };
  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
    safeAreaLengths = {
      top: 0,
      right: 44,
      bottom: 21,
      left: 44
    };
  } else {
    safeAreaLengths = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  return safeAreaLengths;
};

/**
 * Returns the safe area rect based on the current state of the safe areas.
 */
iPhoneXPatch.getSafeAreaDOMRect = function () {
  var safeAreaRect = void 0;
  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
    safeAreaRect = {
      x: 0,
      y: 44, /* 0 + 44 (top safe area) */
      width: window.innerWidth,
      height: window.innerHeight - 78 /* height - 44 (top safe area) - 34 (bottom safe area) */
    };
  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
    safeAreaRect = {
      x: 44, /* 0 + 44 (left safe area) */
      y: 0,
      width: window.innerWidth - 88, /* width - 44 (left safe area) - 34 (right safe area) */
      height: window.innerHeight - 21 /* height - 21 (bottom safe area) */
    };
  } else {
    safeAreaRect = {
      x: 0,
      y: 0,
      width: window.innerWidth,
      height: window.innerHeight
    };
  }

  return _extends({}, safeAreaRect, {
    left: safeAreaRect.x,
    top: safeAreaRect.y,
    right: safeAreaRect.x + safeAreaRect.width,
    bottom: safeAreaRect.y + safeAreaRect.height
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$22 = {
  '.popover': 'popover--*',
  '.popover-mask': 'popover-mask--*',
  '.popover__content': 'popover--*__content',
  '.popover__arrow': 'popover--*__arrow'
};

var _animatorDict$5 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
  },
  'none': PopoverAnimator,
  'fade-ios': IOSFadePopoverAnimator,
  'fade-md': MDFadePopoverAnimator
};

var positions = {
  up: 'bottom',
  left: 'right',
  down: 'top',
  right: 'left'
};

/**
 * @element ons-popover
 * @category dialog
 * @description
 *  [en]
 *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
 *
 *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<ons-template>` tag.
 *
 *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
 *  [/en]
 *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
 * @codepen ZYYRKo
 * @tutorial vanilla/Reference/popover
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-button onclick="showPopover(this)">
 *   Click me!
 * </ons-button>
 *
 * <ons-popover direction="down" id="popover">
 *   <p>This is a popover!</p>
 * </ons-popover>
 *
 * <script>
 *   var showPopover = function(element) {
 *     var popover = document.getElementById('popover');
 *     popover.show(element);
 *   };
 * </script>
 */

var PopoverElement = function (_BaseDialogElement) {
  inherits(PopoverElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   *   [en]Fired just before the popover is displayed.[/en]
   *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to stop the popover from being shown.[/en]
   *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   *   [en]Fired just after the popover is displayed.[/en]
   *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   *   [en]Fired just before the popover is hidden.[/en]
   *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to stop the popover from being hidden.[/en]
   *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
   */

  /**
   * @event posthide
   * @description
   *   [en]Fired just after the popover is hidden.[/en]
   *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the popover.[/en]
   *  [ja]ポップオーバーの表現を指定します。[/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *  [en]
   *    A space separated list of directions. If more than one direction is specified,
   *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
   *  [/en]
   *  [ja]
   *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
   *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
   *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
   *  [/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
   *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
   */

  /**
   * @attribute cover-target
   * @description
   *   [en]If set the popover will cover the target on the screen.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @description
   *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
   *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute mask-color
   * @type {Color}
   * @description
   *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
   */

  function PopoverElement() {
    classCallCheck(this, PopoverElement);

    var _this = possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).call(this));

    _this._boundOnChange = _this._onChange.bind(_this);

    contentReady(_this, function () {
      _this._compile();
      _this.style.display = 'none';
    });
    return _this;
  }

  createClass(PopoverElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$5,
        baseClass: PopoverAnimator,
        baseClassName: 'PopoverAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (shouldShow) {
        this.style.display = 'block';
        this._currentTarget = options.target;
        this._positionPopover(options.target);
      } else {
        this.style.display = 'none';
        this._clearStyles();
      }
    }
  }, {
    key: '_positionPopover',
    value: function _positionPopover(target) {
      var radius = this._radius,
          contentElement = this._content,
          margin = this._margin;

      var safeAreaLengths = iPhoneXPatch.getSafeAreaLengths();
      var safeAreaRect = iPhoneXPatch.getSafeAreaDOMRect();
      var targetRect = target.getBoundingClientRect();
      var isMD = util.hasModifier(this, 'material');
      var cover = isMD && this.hasAttribute('cover-target');

      // Distance from each side of the safe area (with margin) to the target element
      var targetDistance = {
        top: targetRect.top - (safeAreaRect.top + margin),
        left: targetRect.left - (safeAreaRect.left + margin),
        bottom: safeAreaRect.bottom - margin - targetRect.bottom,
        right: safeAreaRect.right - margin - targetRect.right
      };

      // Distance from each side of the safe area (with margin) to the geometric center of the target element
      var targetCenterDistanceFrom = {
        top: targetRect.top + Math.round(targetRect.height / 2) - (safeAreaRect.top + margin),
        left: targetRect.left + Math.round(targetRect.width / 2) - (safeAreaRect.left + margin),
        bottom: safeAreaRect.bottom - margin - targetRect.bottom + Math.round(targetRect.height / 2),
        right: safeAreaRect.right - margin - targetRect.right + Math.round(targetRect.width / 2)
      };

      var _calculateDirections2 = this._calculateDirections(targetDistance),
          vertical = _calculateDirections2.vertical,
          primaryDirection = _calculateDirections2.primary,
          secondaryDirection = _calculateDirections2.secondary;

      this._currentDirection = primaryDirection;
      util.addModifier(this, primaryDirection);

      var sizeName = vertical ? 'width' : 'height';
      // Get .popover__content size
      var contentSize = function (style) {
        return {
          width: parseInt(style.getPropertyValue('width'), 10),
          height: parseInt(style.getPropertyValue('height'), 10)
        };
      }(window.getComputedStyle(contentElement));

      // Setting .popover position.
      var targetAndArrowLength = cover ? 0 : (vertical ? targetRect.height : targetRect.width) + (isMD ? 0 : 14);
      var primaryOffset = Math.max(safeAreaLengths[primaryDirection] + margin, safeAreaLengths[primaryDirection] + margin + targetDistance[primaryDirection] + targetAndArrowLength);
      var secondaryOffset = Math.max(safeAreaLengths[secondaryDirection] + margin, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - contentSize[sizeName] / 2);
      this._popover.style[primaryDirection] = primaryOffset + 'px';
      this._popover.style[secondaryDirection] = secondaryOffset + 'px';

      // Setting .popover__arrow position.
      this._arrow.style[secondaryDirection] = Math.max(radius, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - secondaryOffset) + 'px';
    }
  }, {
    key: '_calculateDirections',
    value: function _calculateDirections(distance) {
      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
        return positions[e];
      });
      var primary = options.sort(function (a, b) {
        return distance[a] - distance[b];
      })[0];
      var vertical = 'top' == primary || 'bottom' == primary;
      var secondary = void 0;

      if (vertical) {
        secondary = distance.left < distance.right ? 'left' : 'right';
      } else {
        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
      }

      return { vertical: vertical, primary: primary, secondary: secondary };
    }
  }, {
    key: '_clearStyles',
    value: function _clearStyles() {
      var _this2 = this;

      this._currentDirection = null;
      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
        _this2._arrow.style[e] = _this2._content.style[e] = _this2._popover.style[e] = '';
        util.removeModifier(_this2, e);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      var _this3 = this;

      setImmediate(function () {
        if (_this3._currentTarget) {
          _this3._positionPopover(_this3._currentTarget);
        }
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this._popover && this._mask) {
        return;
      }

      var hasDefaultContainer = this._popover && this._content;

      if (hasDefaultContainer) {

        if (!this._mask) {
          var mask = document.createElement('div');
          mask.classList.add('popover-mask');
          this.insertBefore(mask, this.firstChild);
        }

        if (!this._arrow) {
          var arrow = document.createElement('div');
          arrow.classList.add('popover__arrow');
          this._popover.appendChild(arrow);
        }
      } else {

        var template = util.createFragment('\n        <div class="popover-mask"></div>\n        <div class="popover">\n          <div class="popover__content"></div>\n          <div class="popover__arrow"></div>\n        </div>\n      ');
        var content = template.querySelector('.popover__content');

        while (this.childNodes[0]) {
          content.appendChild(this.childNodes[0]);
        }

        this.appendChild(template);
      }

      // FIXME!
      if (this.hasAttribute('style')) {
        this._popover.setAttribute('style', this.getAttribute('style'));
        this.removeAttribute('style');
      }

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @method show
     * @signature show(target, [options])
     * @param {String|Event|HTMLElement} target
     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element. It can be also provided as 'options.target' instead. [/en]
     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the popover has been revealed.[/en]
     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show(target) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Copy options and include options.target
      if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && !(target instanceof Event) && !(target instanceof HTMLElement)) {
        options = _extends({}, target);
      } else {
        options = _extends({}, options, { target: target });
      }

      if (typeof options.target === 'string') {
        options.target = document.querySelector(options.target);
      } else if (options.target instanceof Event) {
        options.target = options.target.target;
      }

      if (typeof options.target === 'undefined') {
        throw new Error('A target or options.target argument must be defined for the popover.');
      }

      if (!(options.target instanceof HTMLElement)) {
        throw new Error('Invalid target for popover.');
      }

      return get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'show', this).call(this, options);
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the popover has been hidden.[/en]
     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close the popover.[/en]
     *   [ja]ポップオーバーを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]
     *     A boolean value that specifies whether the popover is cancelable or not.
     *
     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'connectedCallback', this).call(this);

      window.addEventListener('resize', this._boundOnChange, false);
      this._margin = this._margin || parseInt(window.getComputedStyle(this).getPropertyValue('top'));
      this._margin = this._margin || 6; // Fix for iframes

      contentReady(this, function () {
        _this4._radius = parseInt(window.getComputedStyle(_this4._content).getPropertyValue('border-top-left-radius'));
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'disconnectedCallback', this).call(this);
      window.removeEventListener('resize', this._boundOnChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'direction') {
        return this._boundOnChange();
      } else if (name === 'modifier') {
        this._currentDirection && util.addModifier(this, this._currentDirection);
      }
      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @param {String} name
     * @param {PopoverAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$22;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util.findChild(this, '.popover-mask');
    }
  }, {
    key: '_popover',
    get: function get$$1() {
      return util.findChild(this, '.popover');
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return util.findChild(this._popover, '.popover__content');
    }
  }, {
    key: '_arrow',
    get: function get$$1() {
      return util.findChild(this._popover, '.popover__arrow');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof PopoverAnimator)) {
        throw new Error('"Animator" param must inherit PopoverAnimator');
      }
      _animatorDict$5[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement), 'observedAttributes', this)), ['direction']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$5;
    }
  }, {
    key: 'PopoverAnimator',
    get: function get$$1() {
      return PopoverAnimator;
    }
  }]);
  return PopoverElement;
}(BaseDialogElement);

ons$1.elements.Popover = PopoverElement;
customElements.define('ons-popover', PopoverElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$23 = {
  '.progress-bar': 'progress-bar--*',
  '.progress-bar__primary': 'progress-bar--*__primary',
  '.progress-bar__secondary': 'progress-bar--*__secondary'
};

var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

var INDET = 'indeterminate';

/**
 * @element ons-progress-bar
 * @category visual
 * @description
 *   [en]
 *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
 *   [/en]
 *   [ja][/ja]
 * @codepen zvQbGj
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-circular
 *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-bar
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-bar>
 *
 * <ons-progress-bar
 *  indeterminate>
 * </ons-progress-bar>
 */

var ProgressBarElement = function (_BaseElement) {
  inherits(ProgressBarElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Change the appearance of the progress indicator.[/en]
   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
   */

  /**
   * @attribute value
   * @type {Number}
   * @description
   *   [en]Current progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute secondary-value
   * @type {Number}
   * @description
   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute indeterminate
   * @description
   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
   */

  function ProgressBarElement() {
    classCallCheck(this, ProgressBarElement);

    var _this = possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ProgressBarElement, [{
    key: '_compile',
    value: function _compile() {
      if (!this._isCompiled()) {
        this._template = template.cloneNode(true);
      } else {
        this._template = util.findChild(this, '.progress-bar');
      }

      this._primary = util.findChild(this._template, '.progress-bar__primary');
      this._secondary = util.findChild(this._template, '.progress-bar__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      autoStyle.prepare(this);
      ModifierUtil.initModifier(this, scheme$23);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-bar')) {
        return false;
      }

      var barElement = util.findChild(this, '.progress-bar');

      if (!util.findChild(barElement, '.progress-bar__secondary')) {
        return false;
      }

      if (!util.findChild(barElement, '.progress-bar__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$23);
        this.hasAttribute(INDET) && this._updateDeterminate();
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === INDET) {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this2 = this;

      contentReady(this, function () {
        return util.toggleModifier(_this2, INDET, { force: _this2.hasAttribute(INDET) });
      });
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._primary.style.width = _this3.hasAttribute('value') ? _this3.getAttribute('value') + '%' : '0%';
        _this3._secondary.style.width = _this3.hasAttribute('secondary-value') ? _this3.getAttribute('secondary-value') + '%' : '0%';
      });
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'value',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set$$1(value) {
      if (value) {
        this.setAttribute(INDET, '');
      } else {
        this.removeAttribute(INDET);
      }
    },
    get: function get$$1() {
      return this.hasAttribute(INDET);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'value', 'secondary-value', INDET];
    }
  }]);
  return ProgressBarElement;
}(BaseElement);

ons$1.elements.ProgressBar = ProgressBarElement;
customElements.define('ons-progress-bar', ProgressBarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$24 = {
  '.progress-circular': 'progress-circular--*',
  '.progress-circular__background': 'progress-circular--*__background',
  '.progress-circular__primary': 'progress-circular--*__primary',
  '.progress-circular__secondary': 'progress-circular--*__secondary'
};

var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__background" />\n    <circle class="progress-circular__secondary" />\n    <circle class="progress-circular__primary" />\n  </svg>\n');

var INDET$1 = 'indeterminate';

/**
 * @element ons-progress-circular
 * @category visual
 * @description
 *   [en]
 *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
 *   [/en]
 *   [ja][/ja]
 * @codepen EVzMjR
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-bar
 *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-circular
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-circular>
 *
 * <ons-progress-circular
 *  indeterminate>
 * </ons-progress-circular>
 */

var ProgressCircularElement = function (_BaseElement) {
  inherits(ProgressCircularElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Change the appearance of the progress indicator.[/en]
   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
   */

  /**
   * @attribute value
   * @type {Number}
   * @description
   *   [en]Current progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute secondary-value
   * @type {Number}
   * @description
   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute indeterminate
   * @description
   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
   */

  function ProgressCircularElement() {
    classCallCheck(this, ProgressCircularElement);

    var _this = possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ProgressCircularElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$24);
        this.hasAttribute(INDET$1) && this._updateDeterminate();
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === INDET$1) {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this2 = this;

      contentReady(this, function () {
        return util.toggleModifier(_this2, INDET$1, { force: _this2.hasAttribute(INDET$1) });
      });
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this3 = this;

      if (this.hasAttribute('value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this3.getAttribute('value') * 251.32 * 0.01);
          _this3._primary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
      if (this.hasAttribute('secondary-value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this3.getAttribute('secondary-value') * 251.32 * 0.01);
          _this3._secondary.style.display = null;
          _this3._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      } else {
        contentReady(this, function () {
          _this3._secondary.style.display = 'none';
        });
      }
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      if (this._isCompiled()) {
        this._template = util.findChild(this, '.progress-circular');
      } else {
        this._template = template$1.cloneNode(true);
      }

      this._primary = util.findChild(this._template, '.progress-circular__primary');
      this._secondary = util.findChild(this._template, '.progress-circular__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      autoStyle.prepare(this);
      ModifierUtil.initModifier(this, scheme$24);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util.findChild(this, '.progress-circular')) {
        return false;
      }

      var svg = util.findChild(this, '.progress-circular');

      if (!util.findChild(svg, '.progress-circular__secondary')) {
        return false;
      }

      if (!util.findChild(svg, '.progress-circular__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'value',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        throw new Error('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set$$1(value) {
      if (value) {
        this.setAttribute(INDET$1, '');
      } else {
        this.removeAttribute(INDET$1);
      }
    },
    get: function get$$1() {
      return this.hasAttribute(INDET$1);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'value', 'secondary-value', INDET$1];
    }
  }]);
  return ProgressCircularElement;
}(BaseElement);

ons$1.elements.ProgressCircular = ProgressCircularElement;
customElements.define('ons-progress-circular', ProgressCircularElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var STATE_INITIAL = 'initial';
var STATE_PREACTION = 'preaction';
var STATE_ACTION = 'action';

/**
 * @element ons-pull-hook
 * @category control
 * @description
 *   [en]
 *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
 *
 *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
 *   [/en]
 *   [ja][/ja]
 * @codepen WbJogM
 * @tutorial vanilla/Reference/pull-hook
 * @example
 * <ons-page>
 *   <ons-pull-hook>
 *     Release to refresh
 *   </ons-pull-hook>
 * </ons-page>
 *
 * <script>
 *   document.querySelector('ons-pull-hook').onAction = function(done) {
 *     setTimeout(done, 1000);
 *   };
 * </script>
 */

var PullHookElement = function (_BaseElement) {
  inherits(PullHookElement, _BaseElement);

  /**
   * @event changestate
   * @description
   *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
   *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Object} event.pullHook
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {String} event.state
   *   [en]Current state.[/en]
   *   [ja]現在の状態名を参照できます。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
   *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
   */

  /**
   * @attribute height
   * @type {String}
   * @description
   *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
   *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
   */

  /**
   * @attribute threshold-height
   * @type {String}
   * @description
   *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
   *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
   */

  /**
   * @attribute fixed-content
   * @description
   *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
   *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
   */

  function PullHookElement() {
    classCallCheck(this, PullHookElement);

    var _this = possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).call(this));

    _this._onDrag = _this._onDrag.bind(_this);
    _this._onDragStart = _this._onDragStart.bind(_this);
    _this._onDragEnd = _this._onDragEnd.bind(_this);
    _this._onScroll = _this._onScroll.bind(_this);
    _this._preventScroll = _this._preventScroll.bind(_this);

    _this._setState(STATE_INITIAL, true);
    _this._hide(); // Fix for transparent toolbar transitions
    return _this;
  }

  createClass(PullHookElement, [{
    key: '_setStyle',
    value: function _setStyle() {
      var height = this.height + 'px';
      styler(this, { height: height, lineHeight: height });
      this.style.display === '' && this._show();
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      var element = this._pageElement;

      if (element.scrollTop < 0) {
        element.scrollTop = 0;
      }
    }
  }, {
    key: '_canConsumeGesture',
    value: function _canConsumeGesture(gesture) {
      return gesture.direction === 'up' || gesture.direction === 'down';
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      var _this2 = this;

      if (!event.gesture || this.disabled) {
        return;
      }

      this._ignoreDrag = event.consumed;

      if (!this._ignoreDrag) {
        var consume = event.consume;
        event.consume = function () {
          consume && consume();
          _this2._ignoreDrag = true;
          // This elements resizes .page__content so it is safer
          // to hide it when other components are dragged.
          _this2._hide();
        };

        if (this._canConsumeGesture(event.gesture)) {
          consume && consume();
          event.consumed = true;
          this._show(); // Not enough due to 'dragLockAxis'
        }
      }

      this._startScroll = this._pageElement.scrollTop;
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var _this3 = this;

      if (!event.gesture || this.disabled || this._ignoreDrag || !this._canConsumeGesture(event.gesture)) {
        return;
      }

      // Necessary due to 'dragLockAxis' (25px)
      if (this.style.display === 'none') {
        this._show();
      }

      event.stopPropagation();

      // Hack to make it work on Android 4.4 WebView and iOS UIWebView. Scrolls manually
      // near the top of the page so there will be no inertial scroll when scrolling down.
      // Allowing default scrolling will kill all 'touchmove' events.
      this._pageElement.scrollTop = this._startScroll - event.gesture.deltaY;
      if (this._pageElement.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
        event.gesture.preventDefault();
      }

      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);
      if (scroll !== this._currentTranslation) {
        if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
          event.gesture.stopDetect();
          setImmediate(function () {
            return _this3._finish();
          });
        } else if (scroll >= this.height) {
          this._setState(STATE_PREACTION);
        } else {
          this._setState(STATE_INITIAL);
        }

        this._pulling = true;
        this._translateTo(scroll);
      }
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      this._pulling = false;
      if (!event.gesture || this.disabled || this._ignoreDrag) {
        return;
      }

      event.stopPropagation();

      if (this._currentTranslation > 0) {
        var scroll = this._currentTranslation;

        if (scroll > this.height) {
          this._finish();
        } else {
          this._translateTo(0, { animate: true });
        }
      }
    }
  }, {
    key: '_preventScroll',
    value: function _preventScroll(event) {
      // Fix for Android & iOS when starting from scrollTop > 0 or pulling back
      this._pulling && event.cancelable && event.preventDefault();
    }

    /**
     * @property onAction
     * @type {Function}
     * @description
     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_finish',
    value: function _finish() {
      var _this4 = this;

      this._setState(STATE_ACTION);
      this._translateTo(this.height, { animate: true });
      var action = this.onAction || function (done) {
        return done();
      };
      action(function () {
        _this4._translateTo(0, { animate: true });
        _this4._setState(STATE_INITIAL);
      });
    }

    /**
     * @property height
     * @type {Number}
     * @description
     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_thresholdHeightEnabled',
    value: function _thresholdHeightEnabled() {
      var th = this.thresholdHeight;
      return th > 0 && th >= this.height;
    }
  }, {
    key: '_setState',
    value: function _setState(state, noEvent) {
      var lastState = this.state;

      this.setAttribute('state', state);

      if (!noEvent && lastState !== this.state) {
        util.triggerElementEvent(this, 'changestate', {
          pullHook: this,
          state: state,
          lastState: lastState
        });
      }
    }

    /**
     * @property state
     * @readonly
     * @type {String}
     * @description
     *   [en]Current state of the element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      var _this5 = this;

      // Run asyncrhonously to avoid conflicts with Animit's style clean
      setImmediate(function () {
        _this5.style.display = '';
        if (_this5._pageElement) {
          _this5._pageElement.style.marginTop = '-' + _this5.height + 'px';
        }
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.style.display = 'none';
      if (this._pageElement) {
        this._pageElement.style.marginTop = '';
      }
    }

    /**
     * @param {Number} scroll
     * @param {Object} options
     * @param {Function} [options.callback]
     */

  }, {
    key: '_translateTo',
    value: function _translateTo(scroll) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._currentTranslation == 0 && scroll == 0) {
        return;
      }

      this._currentTranslation = scroll;
      var opt = options.animate ? { duration: .3, timing: 'cubic-bezier(.1, .7, .1, 1)' } : {};
      this._onPull && this._onPull((scroll / this.height).toFixed(2), opt);
      var scrollElement = this.hasAttribute('fixed-content') ? this : this._pageElement;

      Animit(scrollElement).queue({ transform: 'translate3d(0px, ' + scroll + 'px, 0px)' }, opt).play(function () {
        scroll === 0 && styler.clear(scrollElement, 'transition transform');
        options.callback instanceof Function && options.callback();
      });
    }
  }, {
    key: '_disableDragLock',
    value: function _disableDragLock() {
      // e2e tests need it
      this._dragLockDisabled = true;
      this._setupListeners(true);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var _this6 = this;

      var scrollToggle = function scrollToggle(action) {
        return _this6._pageElement[action + 'EventListener']('scroll', _this6._onScroll, false);
      };
      var gdToggle = function gdToggle(action) {
        _this6._gestureDetector[action]('drag', _this6._onDrag);
        _this6._gestureDetector[action]('dragstart', _this6._onDragStart);
        _this6._gestureDetector[action]('dragend', _this6._onDragEnd);
        _this6._gestureDetector[action]('touchmove', _this6._preventScroll);
      };

      if (this._gestureDetector) {
        gdToggle('off');
        this._gestureDetector.dispose();
        this._gestureDetector = null;
      }
      scrollToggle('remove');

      if (add) {
        this._gestureDetector = new GestureDetector(this._pageElement, {
          dragMinDistance: 1,
          dragDistanceCorrection: false,
          dragLockToAxis: !this._dragLockDisabled
        });

        gdToggle('on');
        scrollToggle('add');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._currentTranslation = 0;
      this._pageElement = this.parentNode;

      this._setupListeners(true);
      this._setStyle();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._hide();
      this._setupListeners(false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'height' && this._pageElement) {
        this._setStyle();
      }
    }
  }, {
    key: 'onAction',
    get: function get$$1() {
      return this._onAction;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throw new Error('\'onAction\' must be a function or null');
      }
      this._onAction = value;
    }

    /**
     * @property onPull
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user pulls the element. It gets the pulled distance ratio (scroll / height) and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onPull',
    get: function get$$1() {
      return this._onPull;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throw new Error('\'onPull\' must be a function or null.');
      }
      this._onPull = value;
    }
  }, {
    key: 'height',
    set: function set$$1(value) {
      if (!util.isInteger(value)) {
        throw new Error('The height must be an integer');
      }

      this.setAttribute('height', value + 'px');
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('height') || '64', 10);
    }

    /**
     * @property thresholdHeight
     * @type {Number}
     * @description
     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'thresholdHeight',
    set: function set$$1(value) {
      if (!util.isInteger(value)) {
        throw new Error('The threshold height must be an integer');
      }

      this.setAttribute('threshold-height', value + 'px');
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('threshold-height') || '96', 10);
    }
  }, {
    key: 'state',
    get: function get$$1() {
      return this.getAttribute('state');
    }

    /**
     * @property pullDistance
     * @readonly
     * @type {Number}
     * @description
     *   [en]The current number of pixels the pull hook has moved.[/en]
     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]
     */

  }, {
    key: 'pullDistance',
    get: function get$$1() {
      return this._currentTranslation;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['height'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['changestate'];
    }
  }]);
  return PullHookElement;
}(BaseElement);

ons$1.elements.PullHook = PullHookElement;
customElements.define('ons-pull-hook', PullHookElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$25 = {
  '': 'range--*',
  '.range__input': 'range--*__input',
  '.range__focus-ring': 'range--*__focus-ring'
};

var activeClassToken = 'range__input--active';

/**
 * @element ons-range
 * @category form
 * @modifier material
 *   [en]Material Design slider[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Range input component. Used to display a draggable slider.
 *
 *     Works very similar to the `<input type="range">` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xZQomM
 * @tutorial vanilla/Reference/range
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
 *   [ja][/ja]
 * @example
 * <ons-range value="20"></ons-range>
 * <ons-range modifier="material" value="10"></range>
 */

var RangeElement = function (_BaseInputElement) {
  inherits(RangeElement, _BaseInputElement);

  function RangeElement() {
    classCallCheck(this, RangeElement);

    var _this = possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).call(this));

    _this._boundOnMouseDown = _this._onMouseDown.bind(_this);
    _this._boundOnMouseUp = _this._onMouseUp.bind(_this);
    _this._boundOnTouchStart = _this._onTouchStart.bind(_this);
    _this._boundOnTouchEnd = _this._onTouchEnd.bind(_this);
    _this._boundOnInput = _this._update.bind(_this);
    _this._boundOnDragstart = _this._onDragstart.bind(_this);
    _this._boundOnDragend = _this._onDragend.bind(_this);
    return _this;
  }

  createClass(RangeElement, [{
    key: '_compile',
    value: function _compile() {
      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), '_compile', this).call(this);
      this._updateDisabled(this.hasAttribute('disabled'));
    }

    /* Inherited props */

  }, {
    key: '_update',
    value: function _update() {
      var input = this._input;
      var focusRing = this._focusRing;

      input.style.backgroundSize = 100 * this._ratio + '% 2px';
      focusRing.value = this.value;

      // NOTE: "_zero" attribute is used for CSS styling.
      if (input.min === '' && input.value === '0' || input.min === input.value) {
        input.setAttribute('_zero', '');
      } else {
        input.removeAttribute('_zero');
      }

      ['min', 'max'].forEach(function (attr) {
        return focusRing[attr] = input[attr];
      });
    }
  }, {
    key: '_onMouseDown',


    /* Own props */

    value: function _onMouseDown(e) {
      var _this2 = this;

      this._input.classList.add(activeClassToken);
      setImmediate(function () {
        return _this2._input.focus();
      });
    }
  }, {
    key: '_onTouchStart',
    value: function _onTouchStart(e) {
      this._onMouseDown();
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(e) {
      this._input.classList.remove(activeClassToken);
    }
  }, {
    key: '_onTouchEnd',
    value: function _onTouchEnd(e) {
      this._onMouseUp(e);
    }
  }, {
    key: '_onDragstart',
    value: function _onDragstart(e) {
      e.consumed = true;
      e.gesture.stopPropagation();
      this._input.classList.add(activeClassToken);
      this.addEventListener('drag', this._onDrag);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.stopPropagation();
    }
  }, {
    key: '_onDragend',
    value: function _onDragend(e) {
      this._input.classList.remove(activeClassToken);
      this.removeEventListener('drag', this._onDrag);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'disabled') {
        this._updateDisabled(current);
      }
      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @param {boolean} disabled
     */

  }, {
    key: '_updateDisabled',
    value: function _updateDisabled(disabled) {
      if (disabled) {
        this.classList.add('range--disabled');
      } else {
        this.classList.remove('range--disabled');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('mousedown', this._boundOnMouseDown);
      this.addEventListener('mouseup', this._boundOnMouseUp);
      this.addEventListener('touchstart', this._boundOnTouchStart);
      this.addEventListener('touchend', this._boundOnTouchEnd);
      this.addEventListener('dragstart', this._boundOnDragstart);
      this.addEventListener('dragend', this._boundOnDragend);
      this.addEventListener('input', this._boundOnInput);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('mousedown', this._boundOnMouseDown);
      this.removeEventListener('mouseup', this._boundOnMouseUp);
      this.removeEventListener('touchstart', this._boundOnTouchStart);
      this.removeEventListener('touchend', this._boundOnTouchEnd);
      this.removeEventListener('dragstart', this._boundOnDragstart);
      this.removeEventListener('dragend', this._boundOnDragend);
      this.removeEventListener('input', this._boundOnInput);
    }

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current value.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$25;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <input type="range" class="range__focus-ring" tabIndex="-1">\n    ';
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'range';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'range';
    }
  }, {
    key: '_focusRing',
    get: function get$$1() {
      return this.children[1];
    }
  }, {
    key: '_ratio',
    get: function get$$1() {
      // Returns the current ratio.
      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
      var max = this._input.max === '' ? 100 : parseInt(this._input.max);

      return (this.value - min) / (max - min);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['disabled'].concat(toConsumableArray(BaseInputElement.observedAttributes));
    }
  }]);
  return RangeElement;
}(BaseInputElement);

ons$1.elements.Range = RangeElement;
customElements.define('ons-range', RangeElement);

/*
Copyright 2013-2016 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @class AnimatorCSS - implementation of Animator class using css transitions
 */

var AnimatorCSS = function () {
  createClass(AnimatorCSS, [{
    key: 'animate',


    /**
     * @method animate
     * @desc main animation function
     * @param {Element} element
     * @param {Object} finalCSS
     * @param {number} [duration=200] - duration in milliseconds
     * @return {Object} result
     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
     * @example
     * ````
     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
     *
     *  el.addEventListener('click', function(e){
     *    result.speed(200).then(function(){
     *      console.log('done');
     *    });
     *  }, 300);
     * ````
     */
    value: function animate(el, final) {
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var start = new Date().getTime(),
          initial = {},
          stopped = false,
          next = false,
          timeout = false,
          properties = Object.keys(final);

      var updateStyles = function updateStyles() {
        var s = window.getComputedStyle(el);
        properties.forEach(s.getPropertyValue.bind(s));
        s = el.offsetHeight;
      };

      var result = {
        stop: function stop() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          timeout && clearTimeout(timeout);
          var k = Math.min(1, (new Date().getTime() - start) / duration);
          properties.forEach(function (i) {
            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
          });
          el.style.transitionDuration = '0s';

          if (options.stopNext) {
            next = false;
          } else if (!stopped) {
            stopped = true;
            next && next();
          }
          return result;
        },
        then: function then(cb) {
          next = cb;
          if (stopped) {
            next && next();
          }
          return result;
        },
        speed: function speed(newDuration) {
          if (internal$1.config.animationsDisabled) {
            newDuration = 0;
          }
          if (!stopped) {
            timeout && clearTimeout(timeout);

            var passed = new Date().getTime() - start;
            var k = passed / duration;
            var remaining = newDuration * (1 - k);

            properties.forEach(function (i) {
              el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
            });

            updateStyles();

            start = el.speedUpTime;
            duration = remaining;

            el.style.transitionDuration = duration / 1000 + 's';

            properties.forEach(function (i) {
              el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
            });

            timeout = setTimeout(result.stop, remaining);
          }
          return result;
        },
        finish: function finish() {
          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

          var k = (new Date().getTime() - start) / duration;

          result.speed(milliseconds / (1 - k));
          return result;
        }
      };

      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {
        return result;
      }

      var style = window.getComputedStyle(el);
      properties.forEach(function (e) {
        var v = parseFloat(style.getPropertyValue(e));
        initial[e] = isNaN(v) ? 0 : v;
      });

      if (!stopped) {
        el.style.transitionProperty = properties.join(',');
        el.style.transitionDuration = duration / 1000 + 's';

        properties.forEach(function (e) {
          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
        });
      }

      timeout = setTimeout(result.stop, duration);
      this._onStopAnimations(el, result.stop);

      return result;
    }
  }]);

  function AnimatorCSS() {
    classCallCheck(this, AnimatorCSS);

    this._queue = [];
    this._index = 0;
  }

  createClass(AnimatorCSS, [{
    key: '_onStopAnimations',
    value: function _onStopAnimations(el, listener) {
      var queue = this._queue;
      var i = this._index++;
      queue[el] = queue[el] || [];
      queue[el][i] = function (options) {
        delete queue[el][i];
        if (queue[el] && queue[el].length == 0) {
          delete queue[el];
        }
        return listener(options);
      };
    }

    /**
    * @method stopAnimations
    * @desc stops active animations on a specified element
    * @param {Element|Array} element - element or array of elements
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAnimations',
    value: function stopAnimations(el) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Array.isArray(el)) {
        return el.forEach(function (el) {
          _this.stopAnimations(el, options);
        });
      }

      (this._queue[el] || []).forEach(function (e) {
        e(options || {});
      });
    }

    /**
    * @method stopAll
    * @desc stops all active animations
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAll',
    value: function stopAll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.stopAnimations(Object.keys(this._queue), options);
    }

    /**
    * @method fade
    * @desc fades the element (short version for animate(el, {opacity: 0}))
    * @param {Element} element
    * @param {number} [duration=200]
    */

  }, {
    key: 'fade',
    value: function fade(el) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

      return this.animate(el, { opacity: 0 }, duration);
    }
  }]);
  return AnimatorCSS;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$14 = 'ripple';
var scheme$26 = {
  '': 'ripple--*',
  '.ripple__wave': 'ripple--*__wave',
  '.ripple__background': 'ripple--*__background'
};

/**
 * @element ons-ripple
 * @category visual
 * @description
 *   [en]
 *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
 *
 *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
 *   [/en]
 *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
 * @codepen wKQWdZ
 * @tutorial vanilla/Reference/ripple
 * @modifier light-gray
 *   [en]Change the color of effects to light gray.[/en]
 *   [ja]エフェクトの色が明るい灰色になります。[/ja]
 * @guide theming.html#cross-platform-styling-autostyling
 *  [en]Cross platform styling[/en]
 *  [ja]Cross platform styling[/ja]
 * @example
 * <div class="my-div">
 *  <ons-ripple></ons-ripple>
 * </div>
 *
 * @example
 * <ons-button ripple>Click me!</ons-button>
 */

var RippleElement = function (_BaseElement) {
  inherits(RippleElement, _BaseElement);

  /**
   * @attribute color
   * @type {String}
   * @description
   *   [en]Color of the ripple effect.[/en]
   *   [ja]リップルエフェクトの色を指定します。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the ripple effect.[/en]
   *   [ja]エフェクトの表現を指定します。[/ja]
   */

  /**
   * @attribute background
   * @type {String}
   * @description
   *   [en]Color of the background.[/en]
   *   [ja]背景の色を設定します。[/ja]
   */

  /**
   * @attribute size
   * @type {String}
   * @description
   *   [en]Sizing of the wave on ripple effect. Set "cover" or "contain". Default is "cover".[/en]
   *   [ja]エフェクトのサイズを指定します。"cover"もしくは"contain"を指定します。デフォルトは"cover"です。[/ja]
   */

  /**
   * @attribute center
   * @type {Boolean}
   * @description
   *   [en]If this attribute presents, change the position of wave effect to center of the target element.[/en]
   *   [ja]この要素を設定すると、エフェクトの位置が要素の真ん中から始まります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
   *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
   */

  function RippleElement() {
    classCallCheck(this, RippleElement);

    var _this = possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });

    _this._animator = new AnimatorCSS();

    ['color', 'center', 'start-radius', 'background', 'modifier'].forEach(function (e) {
      _this.attributeChangedCallback(e, null, _this.getAttribute(e));
    });
    return _this;
  }

  createClass(RippleElement, [{
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$14);

      this._wave = this.getElementsByClassName('ripple__wave')[0];
      this._background = this.getElementsByClassName('ripple__background')[0];

      if (!(this._background && this._wave)) {
        this._wave = util.create('.ripple__wave');
        this._background = util.create('.ripple__background');

        this.appendChild(this._wave);
        this.appendChild(this._background);
      }

      ModifierUtil.initModifier(this, scheme$26);
    }
  }, {
    key: '_getEffectSize',
    value: function _getEffectSize() {
      var sizes = ['cover', 'contain'];
      if (this.hasAttribute('size')) {
        var size = this.getAttribute('size');
        if (sizes.indexOf(size) !== -1) {
          return size;
        }
      }

      return 'cover';
    }
  }, {
    key: '_calculateCoords',
    value: function _calculateCoords(e) {
      var x = void 0,
          y = void 0,
          h = void 0,
          w = void 0,
          r = void 0;
      var b = this.getBoundingClientRect();
      var size = this._getEffectSize();

      if (this._center) {
        x = b.width / 2;
        y = b.height / 2;

        if (size === 'cover') {
          r = Math.sqrt(x * x + y * y);
        } else if (size === 'contain') {
          r = Math.min(x, y);
        } else {
          throw Error('Invalid state. If this errors is shown, leport to GitHub issues.');
        }
      } else {
        x = (typeof e.clientX === 'number' ? e.clientX : e.changedTouches[0].clientX) - b.left;
        y = (typeof e.clientY === 'number' ? e.clientY : e.changedTouches[0].clientY) - b.top;
        h = Math.max(y, b.height - y);
        w = Math.max(x, b.width - x);

        if (size === 'cover') {
          r = Math.sqrt(h * h + w * w);
        } else if (size === 'contain') {
          r = Math.min(Math.round(h / 2), Math.round(w / 2));
        } else {
          throw Error('Invalid state. If this errors is shown, leport to GitHub issues.');
        }
      }

      return { x: x, y: y, r: r };
    }
  }, {
    key: '_rippleAnimation',
    value: function _rippleAnimation(e) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
      var _animator = this._animator,
          _wave = this._wave,
          _background = this._background,
          _minR = this._minR;

      var _calculateCoords2 = this._calculateCoords(e),
          x = _calculateCoords2.x,
          y = _calculateCoords2.y,
          r = _calculateCoords2.r;

      _animator.stopAll({ stopNext: 1 });
      _animator.animate(_background, { opacity: 1 }, duration);

      util.extend(_wave.style, {
        opacity: 1,
        top: y - _minR + 'px',
        left: x - _minR + 'px',
        width: 2 * _minR + 'px',
        height: 2 * _minR + 'px'
      });

      return _animator.animate(_wave, {
        top: y - r,
        left: x - r,
        height: 2 * r,
        width: 2 * r
      }, duration);
    }
  }, {
    key: '_updateParent',
    value: function _updateParent() {
      if (!this._parentUpdated && this.parentNode) {
        var computedStyle = window.getComputedStyle(this.parentNode);
        if (computedStyle.getPropertyValue('position') === 'static') {
          this.parentNode.style.position = 'relative';
        }
        this._parentUpdated = true;
      }
    }
  }, {
    key: '_onTap',
    value: function _onTap(e) {
      var _this2 = this;

      if (!this.disabled) {
        this._updateParent();
        this._rippleAnimation(e.gesture.srcEvent).then(function () {
          _this2._animator.fade(_this2._wave);
          _this2._animator.fade(_this2._background);
        });
      }
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        this._updateParent();
        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var _this3 = this;

      if (this._holding) {
        this._holding.speed(300).then(function () {
          _this3._animator.stopAll({ stopNext: true });
          _this3._animator.fade(_this3._wave);
          _this3._animator.fade(_this3._background);
        });

        this._holding = false;
      }

      document.removeEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this._holding) {
        return this._onRelease(e);
      }
      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
        this._onTap(e);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._parentNode = this.parentNode;
      this._boundOnTap = this._onTap.bind(this);
      this._boundOnHold = this._onHold.bind(this);
      this._boundOnDragStart = this._onDragStart.bind(this);
      this._boundOnRelease = this._onRelease.bind(this);

      if (internal$1.config.animationsDisabled) {
        this.disabled = true;
      } else {
        this._parentNode.addEventListener('tap', this._boundOnTap);
        this._parentNode.addEventListener('hold', this._boundOnHold);
        this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var pn = this._parentNode || this.parentNode;
      pn.removeEventListener('tap', this._boundOnTap);
      pn.removeEventListener('hold', this._boundOnHold);
      pn.removeEventListener('dragstart', this._boundOnDragStart);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this4 = this;

      switch (name) {

        case 'class':
          util.restoreClass(this, defaultClassName$14, scheme$26);
          break;

        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$26);
          break;

        case 'start-radius':
          this._minR = Math.max(0, parseFloat(current) || 0);
          break;

        case 'color':
          if (current) {
            contentReady(this, function () {
              _this4._wave.style.background = current;
              if (!_this4.hasAttribute('background')) {
                _this4._background.style.background = current;
              }
            });
          }
          break;

        case 'background':
          if (current || last) {
            if (current === 'none') {
              contentReady(this, function () {
                _this4._background.setAttribute('disabled', 'disabled');
                _this4._background.style.background = 'transparent';
              });
            } else {
              contentReady(this, function () {
                if (_this4._background.hasAttribute('disabled')) {
                  _this4._background.removeAttribute('disabled');
                }
                _this4._background.style.background = current;
              });
            }
          }
          break;

        case 'center':
          if (name === 'center') {
            this._center = current != null && current != 'false';
          }
          break;

      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['start-radius', 'color', 'background', 'center', 'class', 'modifier'];
    }
  }]);
  return RippleElement;
}(BaseElement);

ons$1.elements.Ripple = RippleElement;
customElements.define('ons-ripple', RippleElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-row
 * @category grid
 * @description
 *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
 *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
 * @codepen GgujC {wide}
 * @guide theming.html
 *   [en]Layouting guide[/en]
 *   [ja]レイアウト調整[/ja]
 * @seealso ons-col
 *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
 *   [ja]ons-colコンポーネント[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
 *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
 */

var RowElement = function (_BaseElement) {
  inherits(RowElement, _BaseElement);

  function RowElement() {
    classCallCheck(this, RowElement);
    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));
  }

  return RowElement;
}(BaseElement);

ons$1.elements.Row = RowElement;
customElements.define('ons-row', RowElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$15 = 'segment';
var scheme$27 = {
  '': 'segment--*',
  '.segment__item': 'segment--*__item',
  '.segment__input': 'segment--*__input',
  '.segment__button': 'segment--*__button'
};

var generateId$1 = function () {
  var i = 0;
  return function () {
    return 'ons-segment-gen-' + i++;
  };
}();

/**
 * @element ons-segment
 * @category control
 * @modifier material
 *   [en]Material Design segment[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Segment component. Use this component to have a button bar with automatic styles that switch on click of another button.
 *
 *     Will automatically display as a Material Design segment on Android.
 *   [/en]
 *   [ja][/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/segment
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-segment>
 *   <ons-button>Label 1</ons-button>
 *   <ons-button>Label 2</ons-button>
 *   <ons-button>Label 3</ons-button>
 * </ons-segment>
 */

var SegmentElement = function (_BaseElement) {
  inherits(SegmentElement, _BaseElement);

  /**
   * @event postchange
   * @description
   *   [en]Fires after the active button is changed.[/en]
   *   [ja][/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja][/ja]
   * @param {Number} event.index
   *   [en]Tapped button index.[/en]
   *   [ja][/ja]
   * @param {Object} event.segmentItem
   *   [en]Segment item object.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the segment.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute tabbar-id
   * @initonly
   * @type {String}
   * @description
   *  [en]ID of the tabbar element to "connect" to the segment. Must be inside the same page.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute active-index
   * @initonly
   * @default 0
   * @type {Number}
   * @description
   *  [en]Index of the first active button, only works if there is no connected tabbar (in which case the active tab sets the active button).[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if segment should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定します。[/ja]
   */

  function SegmentElement() {
    classCallCheck(this, SegmentElement);

    var _this = possibleConstructorReturn(this, (SegmentElement.__proto__ || Object.getPrototypeOf(SegmentElement)).call(this));

    _this._segmentId = generateId$1();
    _this._tabbar = null;
    _this._onChange = _this._onChange.bind(_this);
    _this._onTabbarPreChange = _this._onTabbarPreChange.bind(_this);

    contentReady(_this, function () {
      _this._compile();
      setImmediate(function () {
        return _this._lastActiveIndex = _this._tabbar ? _this._tabbar.getActiveTabIndex() : _this.getActiveButtonIndex();
      });
    });
    return _this;
  }

  createClass(SegmentElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$15);

      for (var index = this.children.length - 1; index >= 0; index--) {
        var item = this.children[index];
        item.classList.add('segment__item');

        var input = util.findChild(item, '.segment__input') || util.create('input.segment__input');
        input.type = 'radio';
        input.value = index;
        input.name = input.name || this._segmentId;
        input.checked = !this.hasAttribute('tabbar-id') && index === (parseInt(this.getAttribute('active-index')) || 0);

        var button = util.findChild(item, '.segment__button') || util.create('.segment__button');
        if (button.parentElement !== item) {
          while (item.firstChild) {
            button.appendChild(item.firstChild);
          }
        }

        item.appendChild(input);
        item.appendChild(button);
      }

      ModifierUtil.initModifier(this, scheme$27);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (this.hasAttribute('tabbar-id')) {
        contentReady(this, function () {
          var page = util.findParent(_this2, 'ons-page');
          _this2._tabbar = page && page.querySelector('#' + _this2.getAttribute('tabbar-id'));
          if (!_this2._tabbar || _this2._tabbar.tagName !== 'ONS-TABBAR') {
            throw new Error('<ons-segment> error: no tabbar with id ' + _this2.getAttribute('tabbar-id') + ' was found.');
          }

          _this2._tabbar.setAttribute('hide-tabs', '');
          setImmediate(function () {
            return _this2._setChecked(_this2._tabbar.getActiveTabIndex());
          });

          _this2._tabbar.addEventListener('prechange', _this2._onTabbarPreChange);
        });
      }

      this.addEventListener('change', this._onChange);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        if (_this3._tabbar) {
          _this3._tabbar.removeEventListener('prechange', _this3._onTabbarPreChange);
          _this3._tabbar = null;
        }
      });
      this.removeEventListener('change', this._onChange);
    }
  }, {
    key: '_setChecked',
    value: function _setChecked(index) {
      this.children[index].firstElementChild.checked = true;
    }

    /**
     * @method setActiveButton
     * @signature setActiveButton(index, [options])
     * @param {Number} index
     *   [en]Button index.[/en]
     *   [ja][/ja]
     * @param {Object} [options]
     *   [en]Parameter object, works only if there is a connected tabbar. Supports the same options as `ons-tabbar`'s `setActiveTab` method.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Make button with the specified index active. If there is a connected tabbar it shows the corresponding tab page. In this case animations and their options can be specified by the second parameter.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the selected index or to the new page element if there is a connected tabbar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveButton',
    value: function setActiveButton(index, options) {
      if (this._tabbar) {
        return this._tabbar.setActiveTab(index, options);
      }

      this._setChecked(index);
      this._postChange(index);
      return Promise.resolve(index);
    }

    /**
     * @method getActiveButtonIndex
     * @signature getActiveButtonIndex()
     * @return {Number}
     *   [en]The index of the currently active button.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Returns button index of current active button. If active button is not found, returns -1.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'getActiveButtonIndex',
    value: function getActiveButtonIndex() {
      for (var i = this.children.length - 1; i >= 0; i--) {
        // Array.findIndex
        if (this.children[i].firstElementChild.checked) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      event.stopPropagation();
      this._tabbar ? this._tabbar.setActiveTab(this.getActiveButtonIndex(), { reject: false }) : this._postChange(this.getActiveButtonIndex());
    }
  }, {
    key: '_onTabbarPreChange',
    value: function _onTabbarPreChange(event) {
      var _this4 = this;

      setImmediate(function () {
        if (!event.detail.canceled) {
          _this4._setChecked(event.index);
          _this4._postChange(event.index);
        }
      });
    }
  }, {
    key: '_postChange',
    value: function _postChange(index) {
      util.triggerElementEvent(this, 'postchange', {
        index: index,
        activeIndex: index,
        lastActiveIndex: this._lastActiveIndex,
        segmentItem: this.children[index]
      });
      this._lastActiveIndex = index;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the segment is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$15, scheme$27);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$27);
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['class', 'modifier'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['postchange'];
    }
  }]);
  return SegmentElement;
}(BaseElement);

ons$1.elements.Segment = SegmentElement;
customElements.define('ons-segment', SegmentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$28 = {
  '': 'select-*',
  '.select-input': 'select-input--*'
};

var defaultClassName$16 = 'select';

var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'];

/**
 * @element ons-select
 * @category form
 * @modifier material
 *  [en]Displays a Material Design select input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a select input.[/en]
 *  [ja][/ja]
 * @description
 *   [en]
 *     Select component. If you want to place a select with an ID of `my-id` on a page, use `<ons-select select-id="my-id">`.
 *
 *     The component will automatically display as a Material Design select on Android.
 *
 *     Most attributes that can be used for a normal `<select>` element can also be used on the `<ons-select>` element.
 *   [/en]
 *   [ja]セレクトボックスを表示するコンポーネントです。`select` 要素に使用できる属性の多くが `ons-select` 要素でも利用できます。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/select
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-select>
 *   <option value="1">1</option>
 *   <option value="2">2nd</option>
 *   <option value="3">3rd option</option>
 * </ons-select>
 */

var SelectElement = function (_BaseElement) {
  inherits(SelectElement, _BaseElement);

  /**
   * @attribute autofocus
   * @type {Boolean}
   * @default false
   * @description
   *  [en]Element automatically gains focus on page load.[/en]
   *  [ja]ページロード時にこのセレクトボックスにフォーカスが移るようにします。[/ja]
   */

  /**
   * @attribute disabled
   * @type {Boolean}
   * @default false
   * @description
   *   [en]Specify if select input should be disabled.[/en]
   *   [ja]このセレクトボックスを無効化する場合に指定します。[/ja]
   */

  /**
   * @attribute form
   * @type {String}
   * @description
   *   [en]Associate a select element to an existing form on the page, even if not nested.[/en]
   *   [ja]このセレクトボックスを、指定した `form` 要素に紐付けます。セレクトボックスを `form` 要素の外側に配置する際に使用します。[/ja]
   */

  /**
   * @attribute multiple
   * @type {Boolean}
   * @default false
   * @description
   *  [en]If this attribute is defined, multiple options can be selected at once.[/en]
   *  [ja]選択肢の複数選択を有効にします。[/ja]
   */

  /**
   * @attribute name
   * @type {String}
   * @description
   *   [en]Name the select element, useful for instance if it is part of a form.[/en]
   *   [ja]このセレクトボックスの名前を指定します。通常 `form` 要素と共に使用します。[/ja]
   */

  /**
   * @attribute required
   * @type {Boolean}
   * @description
   *   [en]Make the select input required for submitting the form it is part of.[/en]
   *   [ja]このセレクトボックスを入力必須にする場合に指定します。通常 `form` 要素と共に使用します。[/ja]
   */

  /**
   * @attribute select-id
   * @type {String}
   * @description
   *   [en]ID given to the inner select, useful for dynamic manipulation.[/en]
   *   [ja]このセレクトボックスが内部に持つ select 要素に与える ID を指定します。セレクトボックスの内容を動的に変更する必要がある場合に使用します。[/ja]
   */

  /**
   * @attribute size
   * @type {Number}
   * @default 1
   * @description
   *   [en]How many options are displayed; if there are more than the size then a scroll appears to navigate them.[/en]
   *   [ja]一度に表示する選択肢の個数を指定します。選択肢がこの属性で指定した個数よりも多い場合、スクロールが有効になります。[/ja]
   */

  function SelectElement() {
    classCallCheck(this, SelectElement);

    var _this = possibleConstructorReturn(this, (SelectElement.__proto__ || Object.getPrototypeOf(SelectElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });

    _this._deriveGetters();
    return _this;
  }

  createClass(SelectElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this2 = this;

      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$16, scheme$28);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$28);
          break;
      }

      if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this2._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this3 = this;

      INPUT_ATTRIBUTES$1.forEach(function (attr) {
        if (_this3.hasAttribute(attr)) {
          _this3._select.setAttribute(attr, _this3.getAttribute(attr));
        } else {
          _this3._select.removeAttribute(attr);
        }
      });
    }

    /**
     * @property length
     * @description
     *   [en]Number of options in the select box.[/en]
     *   [ja]このセレクトボックスに含まれる選択肢の個数を返します。 `select` 要素[/ja]
     */

    /**
     * @property options
     * @description
     *   [en]Several options for handling the select DOM object.[/en]
     *   [ja]このセレクトボックスに含まれる `option` 要素の配列を返します。[/ja]
     */

    /**
     * @property selectedIndex
     * @description
     *   [en]Index of the currently selected option.[/en]
     *   [ja]現在選択されている選択肢のインデックスを返します。[/ja]
     */

    /**
     * @property value
     * @description
     *   [en]Value of the currently selected option.[/en]
     *   [ja]現在選択されている選択肢の値を返します。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$16);
      var sel = this._select || document.createElement('select');
      if (!sel.id && this.hasAttribute('select-id')) {
        sel.id = this.getAttribute('select-id');
      }
      sel.classList.add('select-input');
      if (!this._select) {
        util.arrayFrom(this.childNodes).forEach(function (element) {
          return sel.appendChild(element);
        });
        this.appendChild(sel);
      }

      ModifierUtil.initModifier(this, scheme$28);
    }
  }, {
    key: '_deriveGetters',
    value: function _deriveGetters() {
      var _this4 = this;

      ['disabled', 'length', 'multiple', 'name', 'options', 'selectedIndex', 'size', 'value', 'form', 'type'].forEach(function (key) {
        Object.defineProperty(_this4, key, {
          enumerable: true,
          get: function get$$1() {
            return _this4._select[key];
          },
          set: ['form', 'type'].indexOf(key) === -1 ? function (value) {
            return _this4._select[key] = value;
          } : undefined
        });
      });
    }
  }, {
    key: 'add',
    value: function add(option) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._select.add(option, index);
    }
  }, {
    key: 'remove',
    value: function remove(index) {
      this._select.remove(index);
    }
  }, {
    key: '_select',
    get: function get$$1() {
      return this.querySelector('select');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'].concat(INPUT_ATTRIBUTES$1);
    }
  }]);
  return SelectElement;
}(BaseElement);

ons$1.elements.Select = SelectElement;
customElements.define('ons-select', SelectElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$17 = 'fab fab--mini speed-dial__item';

var scheme$29 = {
  '': 'fab--* speed-dial__item--*'
};

/**
 * @element ons-speed-dial-item
 * @category control
 * @description
 *   [en]
 *     This component displays the child elements of the Material Design Speed dial component.
 *   [/en]
 *   [ja]
 *     Material DesignのSpeed dialの子要素を表現する要素です。
 *   [/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component.[/en]
 *   [ja]ons-speed-dialコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialItemElement = function (_BaseElement) {
  inherits(SpeedDialItemElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the component.[/en]
   *   [ja]このコンポーネントの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  function SpeedDialItemElement() {
    classCallCheck(this, SpeedDialItemElement);

    var _this = possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).call(this));

    _this._compile();
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(SpeedDialItemElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$17, scheme$29);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$29);
          util.addModifier(this, 'mini');
          break;
        case 'ripple':
          this._updateRipple();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util.updateRipple(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      e.stopPropagation();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this2 = this;

      autoStyle.prepare(this);

      defaultClassName$17.split(/\s+/).forEach(function (token) {
        return _this2.classList.add(token);
      });

      util.addModifier(this, 'mini');
      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$29);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return SpeedDialItemElement;
}(BaseElement);

ons$1.elements.SpeedDialItem = SpeedDialItemElement;
customElements.define('ons-speed-dial-item', SpeedDialItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$18 = 'speed-dial';
var scheme$30 = {
  '': 'speed-dial--*'
};

/**
 * @element ons-speed-dial
 * @category control
 * @description
 *   [en]
 *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
 *
 *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
 *   [/en]
 *   [ja][/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial-item
 *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
 *   [ja]ons-speed-dial-itemコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialElement = function (_BaseElement) {
  inherits(SpeedDialElement, _BaseElement);

  /**
   * @event open
   * @description
   *   [en]Fired when the menu items are shown.[/en]
   *   [ja][/ja]
   */

  /**
   * @event close
   * @description
   *   [en]Fired when the menu items are hidden.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the component.[/en]
   *   [ja]このコンポーネントの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute position
   * @type {String}
   * @description
   *   [en]
   *     Specify the vertical and horizontal position of the component.
   *     I.e. to display it in the top right corner specify "right top".
   *     Choose from "right", "left", "top" and "bottom".
   *   [/en]
   *   [ja]
   *     この要素を表示する左右と上下の位置を指定します。
   *     例えば、右上に表示する場合には"right top"を指定します。
   *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
   *   [/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
   *   [ja]
   *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
   *   [/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]無効化する場合に指定します。[/ja]
   */

  function SpeedDialElement() {
    classCallCheck(this, SpeedDialElement);

    var _this = possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });

    _this._itemShown = false;
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(SpeedDialElement, [{
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$18);
      autoStyle.prepare(this);
      this._updateRipple();
      ModifierUtil.initModifier(this, scheme$30);

      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      this._updatePosition();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this2 = this;

      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$18, scheme$30);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$30);
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this2._updateRipple();
          });
          break;
        case 'direction':
          contentReady(this, function () {
            return _this2._updateDirection(current);
          });
          break;
        case 'position':
          contentReady(this, function () {
            return _this2._updatePosition();
          });
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      if (this.onClick) {
        this.onClick.apply(this);
        return Promise.resolve();
      } else if (!this.disabled && this.visible) {
        return this.toggleItems();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this.inline) {
        return this.show();
      }
      return Promise.resolve();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this3 = this;

      return new Promise(function (resolve) {
        if (!_this3.inline) {
          setImmediate(function () {
            return _this3.hide().then(resolve);
          });
        } else {
          resolve();
        }
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      if (this._fab) {
        this.hasAttribute('ripple') ? this._fab.setAttribute('ripple', '') : this._fab.removeAttribute('ripple');
      }
    }
  }, {
    key: '_updateDirection',
    value: function _updateDirection(direction) {
      var children = this.items;
      for (var i = 0; i < children.length; i++) {
        styler(children[i], {
          transitionDelay: 25 * i + 'ms',
          bottom: 'auto',
          right: 'auto',
          top: 'auto',
          left: 'auto'
        });
      }
      switch (direction) {
        case 'up':
          for (var _i = 0; _i < children.length; _i++) {
            children[_i].style.bottom = 72 + 56 * _i + 'px';
            children[_i].style.right = '8px';
          }
          break;
        case 'down':
          for (var _i2 = 0; _i2 < children.length; _i2++) {
            children[_i2].style.top = 72 + 56 * _i2 + 'px';
            children[_i2].style.left = '8px';
          }
          break;
        case 'left':
          for (var _i3 = 0; _i3 < children.length; _i3++) {
            children[_i3].style.top = '8px';
            children[_i3].style.right = 72 + 56 * _i3 + 'px';
          }
          break;
        case 'right':
          for (var _i4 = 0; _i4 < children.length; _i4++) {
            children[_i4].style.top = '8px';
            children[_i4].style.left = 72 + 56 * _i4 + 'px';
          }
          break;
        default:
          throw new Error('Argument must be one of up, down, left or right.');
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }
  }, {
    key: '_getTranslate',
    value: function _getTranslate() {
      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
      var translate = isBottom ? 'translate3d(0px, -' + (util.globals.fabOffset || 0) + 'px, 0px) ' : '';
      return translate;
    }

    /**
     * @method show
     * @signature show()
     * @description
     *   [en]Show the speed dial.[/en]
     *   [ja]Speed dialを表示します。[/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this._fab.show();
      styler(this, { transform: this._getTranslate });
      return Promise.resolve();
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *   [en]Hide the speed dial.[/en]
     *   [ja]Speed dialを非表示にします。[/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      return this.hideItems().then(function () {
        return _this4._fab.hide();
      });
    }

    /**
     * @method showItems
     * @signature showItems()
     * @description
     *   [en]Show the speed dial items.[/en]
     *   [ja]Speed dialの子要素を表示します。[/ja]
     */

  }, {
    key: 'showItems',
    value: function showItems() {
      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      var totalDelay = 0;
      if (!this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * i;
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(1)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = true;
        util.triggerElementEvent(this, 'open');
      }

      var deferred = util.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @method hideItems
     * @signature hideItems()
     * @description
     *   [en]Hide the speed dial items.[/en]
     *   [ja]Speed dialの子要素を非表示にします。[/ja]
     */

  }, {
    key: 'hideItems',
    value: function hideItems() {
      var totalDelay = 0;
      if (this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * (children.length - i);
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(0)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = false;
        util.triggerElementEvent(this, 'close');
      }

      var deferred = util.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'isOpen',


    /**
     * @method isOpen
     * @signature isOpen()
     * @description
     *   [en]Returns whether the menu is open or not.[/en]
     *   [ja][/ja]
     */
    value: function isOpen() {
      return this._itemShown;
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle visibility.[/en]
     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      return this.visible ? this.hide() : this.show();
    }

    /**
     * @method toggleItems
     * @signature toggleItems()
     * @description
     *   [en]Toggle item visibility.[/en]
     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggleItems',
    value: function toggleItems() {
      return this.isOpen() ? this.hideItems() : this.showItems();
    }
  }, {
    key: 'items',
    get: function get$$1() {
      return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
    }
  }, {
    key: '_fab',
    get: function get$$1() {
      return util.findChild(this, 'ons-fab');
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      if (value) {
        this.hideItems();
      }
      util.arrayFrom(this.children).forEach(function (e) {
        util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
      });

      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property inline
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is inline or not.[/en]
     *   [ja]インライン要素の場合に`true`。[/ja]
     */

  }, {
    key: 'inline',
    get: function get$$1() {
      return this.hasAttribute('inline');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return this._fab.visible && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['class', 'modifier', 'ripple', 'direction', 'position'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['open', 'close'];
    }
  }]);
  return SpeedDialElement;
}(BaseElement);

ons$1.elements.SpeedDial = SpeedDialElement;
customElements.define('ons-speed-dial', SpeedDialElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var rewritables$1 = {
  /**
   * @param {Element} element
   * @param {Function} callback
   */
  ready: function ready(element, callback) {
    setImmediate(callback);
  }
};

/**
 * @element ons-splitter-content
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
 *
 *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
 *  [/en]
 *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` component is the parent element.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterContentElement = function (_BaseElement) {
  inherits(SplitterContentElement, _BaseElement);

  /**
   * @attribute page
   * @type {String}
   * @description
   *   [en]
   *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
   *
   *     It is also possible to put `<ons-page>` element as a child of the element.
   *   [/en]
   *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]
   */

  function SplitterContentElement() {
    classCallCheck(this, SplitterContentElement);

    var _this = possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).call(this));

    _this._page = null;
    _this._pageLoader = defaultPageLoader;

    contentReady(_this, function () {
      rewritables$1.ready(_this, function () {
        var page = _this._getPageTarget();

        if (page) {
          _this.load(page);
        }
      });
    });
    return _this;
  }

  createClass(SplitterContentElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}

    /**
     * @property page
     * @type {HTMLElement}
     * @description
     *   [en]The page to load in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'load',


    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page, [options]
     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in `page` in the content.[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new `<ons-page>` element[/en]
     *   [ja]`<ons-page>`要素を解決するPromiseオブジェクトを返します。[/ja]
     */
    value: function load(page) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this2._content || null;

        _this2._pageLoader.load({ page: page, parent: _this2 }, function (pageElement) {
          if (oldContent) {
            _this2._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this2._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @type {Function}
     * @description
     *   [en]Page element loaded in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader');
      }
      this._pageLoader = loader;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$1;
    }
  }]);
  return SplitterContentElement;
}(BaseElement);

ons$1.elements.SplitterContent = SplitterContentElement;
customElements.define('ons-splitter-content', SplitterContentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterMaskElement = function (_BaseElement) {
  inherits(SplitterMaskElement, _BaseElement);

  function SplitterMaskElement() {
    classCallCheck(this, SplitterMaskElement);

    var _this = possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).call(this));

    _this._boundOnClick = _this._onClick.bind(_this);
    contentReady(_this, function () {
      if (_this.parentNode._sides.every(function (side) {
        return side.mode === 'split';
      })) {
        _this.setAttribute('style', 'display: none !important');
      }
    });
    return _this;
  }

  createClass(SplitterMaskElement, [{
    key: '_onClick',
    value: function _onClick(event) {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else if (util.match(this.parentNode, 'ons-splitter')) {
        this.parentNode._sides.forEach(function (side) {
          return side.close('left').catch(function () {});
        });
      }
      event.stopPropagation();
    }
  }, {
    key: '_preventScroll',
    value: function _preventScroll(e) {
      e.cancelable && e.preventDefault(); // Fix for iOS. Prevents scrolling content behind mask.
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick);
      this.addEventListener('touchmove', this._preventScroll);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick);
      this.removeEventListener('touchmove', this._preventScroll);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [];
    }
  }]);
  return SplitterMaskElement;
}(BaseElement);

ons$1.elements.SplitterMask = SplitterMaskElement;
customElements.define('ons-splitter-mask', SplitterMaskElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterAnimator$1 = function (_BaseAnimator) {
  inherits(SplitterAnimator, _BaseAnimator);

  function SplitterAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, SplitterAnimator);
    return possibleConstructorReturn(this, (SplitterAnimator.__proto__ || Object.getPrototypeOf(SplitterAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  createClass(SplitterAnimator, [{
    key: 'updateOptions',
    value: function updateOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      util.extend(this, {
        timing: this.timing, duration: this.duration, delay: this.delay
      }, options);
    }

    /**
     * @param {Element} sideElement
     */

  }, {
    key: 'activate',
    value: function activate(sideElement) {
      var _this2 = this;

      var splitter = sideElement.parentNode;

      contentReady(splitter, function () {
        _this2._side = sideElement;
        _this2._oppositeSide = splitter.right !== sideElement && splitter.right || splitter.left !== sideElement && splitter.left;
        _this2._content = splitter.content;
        _this2._mask = splitter.mask;
      });
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.clearTransition();
      this._mask && this.clearMask();
      this._content = this._side = this._oppositeSide = this._mask = null;
    }
  }, {
    key: 'clearTransition',
    value: function clearTransition() {
      var _this3 = this;

      'side mask content'.split(/\s+/).forEach(function (e) {
        return _this3['_' + e] && styler.clear(_this3['_' + e], 'transform transition');
      });
    }
  }, {
    key: 'clearMask',
    value: function clearMask() {
      // Check if the other side needs the mask before clearing
      if (!this._oppositeSide || this._oppositeSide.mode === 'split' || !this._oppositeSide.isOpen) {
        this._mask.style.opacity = '';
        this._mask.style.display = 'none';
      }
    }

    /**
     * @param {Number} distance
     */

  }, {
    key: 'translate',
    value: function translate(distance) {}

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      done();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      done();
    }
  }, {
    key: 'minus',
    get: function get$$1() {
      return this._side.side === 'right' ? '-' : '';
    }
  }]);
  return SplitterAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var OverlaySplitterAnimator = function (_SplitterAnimator) {
  inherits(OverlaySplitterAnimator, _SplitterAnimator);

  function OverlaySplitterAnimator() {
    classCallCheck(this, OverlaySplitterAnimator);
    return possibleConstructorReturn(this, (OverlaySplitterAnimator.__proto__ || Object.getPrototypeOf(OverlaySplitterAnimator)).apply(this, arguments));
  }

  createClass(OverlaySplitterAnimator, [{
    key: 'translate',
    value: function translate(distance) {
      this._mask.style.display = 'block'; // Avoid content clicks

      Animit(this._side).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }).queue({
        opacity: '1'
      }, {
        duration: this.duration,
        timing: 'linear'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {

      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(0px, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        opacity: '0'
      }, {
        duration: this.duration,
        timing: 'linear'
      }).queue({
        display: 'none'
      }));
    }
  }]);
  return OverlaySplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var PushSplitterAnimator = function (_SplitterAnimator) {
  inherits(PushSplitterAnimator, _SplitterAnimator);

  function PushSplitterAnimator() {
    classCallCheck(this, PushSplitterAnimator);
    return possibleConstructorReturn(this, (PushSplitterAnimator.__proto__ || Object.getPrototypeOf(PushSplitterAnimator)).apply(this, arguments));
  }

  createClass(PushSplitterAnimator, [{
    key: '_getSlidingElements',
    value: function _getSlidingElements() {
      var slidingElements = [this._side, this._content];
      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
        slidingElements.push(this._oppositeSide);
      }

      return slidingElements;
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      if (!this._slidingElements) {
        this._slidingElements = this._getSlidingElements();
      }

      this._mask.style.display = 'block'; // Avoid content clicks

      Animit(this._slidingElements).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      var _this2 = this;

      var max = this._side.offsetWidth;
      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(' + (this.minus + max) + 'px, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        _this2._slidingElements = null;
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(0px, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        _this3._slidingElements = null;
        get(PushSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(PushSplitterAnimator.prototype), 'clearTransition', _this3).call(_this3);
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'none'
      }));
    }
  }]);
  return PushSplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var RevealSplitterAnimator = function (_SplitterAnimator) {
  inherits(RevealSplitterAnimator, _SplitterAnimator);

  function RevealSplitterAnimator() {
    classCallCheck(this, RevealSplitterAnimator);
    return possibleConstructorReturn(this, (RevealSplitterAnimator.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator)).apply(this, arguments));
  }

  createClass(RevealSplitterAnimator, [{
    key: '_getSlidingElements',
    value: function _getSlidingElements() {
      var slidingElements = [this._content, this._mask];
      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
        slidingElements.push(this._oppositeSide);
      }

      return slidingElements;
    }
  }, {
    key: 'activate',
    value: function activate(sideElement) {
      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'activate', this).call(this, sideElement);
      this.maxWidth = this._getMaxWidth();
      if (sideElement.mode === 'collapse') {
        this._setStyles(sideElement);
      }
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this._side && this._unsetStyles(this._side);
      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'deactivate', this).call(this);
    }
  }, {
    key: '_setStyles',
    value: function _setStyles(sideElement) {
      styler(sideElement, {
        left: sideElement.side === 'right' ? 'auto' : 0,
        right: sideElement.side === 'right' ? 0 : 'auto',
        zIndex: 0,
        backgroundColor: 'black',
        transform: this._generateBehindPageStyle(0).container.transform,
        display: 'none'
      });

      var splitter = sideElement.parentElement;
      contentReady(splitter, function () {
        return splitter.content && styler(splitter.content, { boxShadow: '0 0 12px 0 rgba(0, 0, 0, 0.2)' });
      });
    }
  }, {
    key: '_unsetStyles',
    value: function _unsetStyles(sideElement) {
      styler.clear(sideElement, 'left right zIndex backgroundColor display');
      if (sideElement._content) {
        sideElement._content.style.opacity = '';
      }

      // Check if the other side needs the common styles
      if (!this._oppositeSide || this._oppositeSide.mode === 'split') {
        sideElement.parentElement.content && styler.clear(sideElement.parentElement.content, 'boxShadow');
      }
    }
  }, {
    key: '_generateBehindPageStyle',
    value: function _generateBehindPageStyle(distance) {
      var max = this.maxWidth;

      var behindDistance = (distance - max) / max * 10;
      behindDistance = isNaN(behindDistance) ? 0 : Math.max(Math.min(behindDistance, 0), -10);

      var behindTransform = 'translate3d(' + (this.minus ? -1 : 1) * behindDistance + '%, 0, 0)';
      var opacity = 1 + behindDistance / 100;

      return {
        content: {
          opacity: opacity
        },
        container: {
          transform: behindTransform
        }
      };
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      this._side.style.display = '';
      this._side.style.zIndex = 1;
      this.maxWidth = this.maxWidth || this._getMaxWidth();
      var menuStyle = this._generateBehindPageStyle(Math.min(distance, this.maxWidth));

      if (!this._slidingElements) {
        this._slidingElements = this._getSlidingElements();
      }

      this._mask.style.display = 'block'; // Avoid content clicks

      Animit.runAll(Animit(this._slidingElements).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
      }), Animit(this._side._content).queue(menuStyle.content), Animit(this._side).queue(menuStyle.container));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      var _this2 = this;

      this._side.style.display = '';
      this._side.style.zIndex = 1;
      this.maxWidth = this.maxWidth || this._getMaxWidth();
      var menuStyle = this._generateBehindPageStyle(this.maxWidth);
      this._slidingElements = this._getSlidingElements();

      setTimeout(function () {
        // Fix: Time to update previous translate3d after changing style.display
        Animit.runAll(Animit(_this2._slidingElements).wait(_this2.delay).queue({
          transform: 'translate3d(' + (_this2.minus + _this2.maxWidth) + 'px, 0px, 0px)'
        }, {
          duration: _this2.duration,
          timing: _this2.timing
        }), Animit(_this2._mask).wait(_this2.delay).queue({
          display: 'block'
        }), Animit(_this2._side._content).wait(_this2.delay).queue(menuStyle.content, {
          duration: _this2.duration,
          timing: _this2.timing
        }), Animit(_this2._side).wait(_this2.delay).queue(menuStyle.container, {
          duration: _this2.duration,
          timing: _this2.timing
        }).queue(function (callback) {
          _this2._slidingElements = null;
          callback();
          done && done();
        }));
      }, 0);
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      var menuStyle = this._generateBehindPageStyle(0);
      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(0px, 0px, 0px)'
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'none'
      }), Animit(this._side._content).wait(this.delay).queue(menuStyle.content, {
        duration: this.duration,
        timing: this.timing
      }), Animit(this._side).wait(this.delay).queue(menuStyle.container, {
        duration: this.duration,
        timing: this.timing
      }).queue(function (callback) {
        _this3._slidingElements = null;
        _this3._side.style.zIndex = 0;
        _this3._side.style.display = 'none';
        _this3._side._content.style.opacity = '';
        done && done();
        callback();
      }));
    }
  }, {
    key: '_getMaxWidth',
    value: function _getMaxWidth() {
      return this._side.offsetWidth;
    }
  }]);
  return RevealSplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$6 = {
  default: OverlaySplitterAnimator,
  overlay: OverlaySplitterAnimator,
  push: PushSplitterAnimator,
  reveal: RevealSplitterAnimator
};

/**
 * @element ons-splitter
 * @category menu
 * @description
 *  [en]
 *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
 *
 *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
 *  [/en]
 *  [ja][/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter id="splitter">
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse swipeable>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 *
 * <script>
 *   var splitter = document.getElementById('splitter');
 *   splitter.left.open();
 * </script>
 */

var SplitterElement = function (_BaseElement) {
  inherits(SplitterElement, _BaseElement);
  createClass(SplitterElement, [{
    key: '_getSide',
    value: function _getSide(side) {
      var element = util.findChild(this, function (e) {
        return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
      });
      return element;
    }

    /**
     * @property left
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Left `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      this._sides.some(function (s) {
        return s.isOpen ? s.close() : false;
      }) || event.callParentHandler();
    }
  }, {
    key: '_onModeChange',
    value: function _onModeChange(e) {
      var _this2 = this;

      if (e.target.parentNode) {
        contentReady(this, function () {
          _this2._layout();
        });
      }
    }
  }, {
    key: '_layout',
    value: function _layout() {
      var _this3 = this;

      this._sides.forEach(function (side) {
        if (_this3.content) {
          _this3.content.style[side.side] = side.mode === 'split' ? side.style.width : 0;
        }
      });
    }
  }, {
    key: 'left',
    get: function get$$1() {
      return this._getSide('left');
    }
    /**
     * @property right
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Right `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'right',
    get: function get$$1() {
      return this._getSide('right');
    }

    /**
     * @property side
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]First `<ons-splitter-side>` element regardless the actual side.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'side',
    get: function get$$1() {
      return util.findChild(this, 'ons-splitter-side');
    }
  }, {
    key: '_sides',
    get: function get$$1() {
      return [this.left, this.right].filter(function (e) {
        return e;
      });
    }
    /**
     * @property content
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The `<ons-splitter-content>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'content',
    get: function get$$1() {
      return util.findChild(this, 'ons-splitter-content');
    }
  }, {
    key: 'topPage',
    get: function get$$1() {
      return this.content._content;
    }
  }, {
    key: 'mask',
    get: function get$$1() {
      return util.findChild(this, 'ons-splitter-mask');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }]);

  function SplitterElement() {
    classCallCheck(this, SplitterElement);

    var _this = possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).call(this));

    _this._onModeChange = _this._onModeChange.bind(_this);

    contentReady(_this, function () {
      !_this.mask && _this.appendChild(document.createElement('ons-splitter-mask'));
      _this._layout();
    });
    return _this;
  }

  createClass(SplitterElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
      this.addEventListener('modechange', this._onModeChange, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
      this.removeEventListener('modechange', this._onModeChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: '_show',
    value: function _show() {
      util.propagateAction(this, '_show');
    }
  }, {
    key: '_hide',
    value: function _hide() {
      util.propagateAction(this, '_hide');
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      util.propagateAction(this, '_destroy');
      this.remove();
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator instanceof SplitterAnimator)) {
        throw new Error('Animator parameter must be an instance of SplitterAnimator.');
      }
      _animatorDict$6[name] = Animator;
    }
  }, {
    key: 'SplitterAnimator',
    get: function get$$1() {
      return SplitterAnimator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$6;
    }
  }]);
  return SplitterElement;
}(BaseElement);

ons$1.elements.Splitter = SplitterElement;
customElements.define('ons-splitter', SplitterElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SPLIT_MODE = 'split';
var COLLAPSE_MODE = 'collapse';
var CLOSED_STATE = 'closed';
var OPEN_STATE = 'open';
var CHANGING_STATE = 'changing';

var rewritables$2 = {
  /**
   * @param {Element} splitterSideElement
   * @param {Function} callback
   */
  ready: function ready(splitterSideElement, callback) {
    setImmediate(callback);
  }
};

var CollapseDetection = function () {
  function CollapseDetection(element, target) {
    classCallCheck(this, CollapseDetection);

    this._element = element;
    this._onChange = this._onChange.bind(this);
    target && this.changeTarget(target);
  }

  createClass(CollapseDetection, [{
    key: 'changeTarget',
    value: function changeTarget(target) {
      this.disable();
      this._target = target;
      if (target) {
        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
        this.activate();
      }
    }
  }, {
    key: '_match',
    value: function _match(value) {
      if (this._orientation) {
        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
      }
      return value.matches;
    }
  }, {
    key: '_onChange',
    value: function _onChange(value) {
      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
    }
  }, {
    key: 'activate',
    value: function activate() {
      if (this._orientation) {
        orientation.on('change', this._onChange);
        this._onChange({ isPortrait: orientation.isPortrait() });
      } else {
        this._queryResult = window.matchMedia(this._target);
        this._queryResult.addListener(this._onChange);
        this._onChange(this._queryResult);
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      if (this._orientation) {
        orientation.off('change', this._onChange);
      } else if (this._queryResult) {
        this._queryResult.removeListener(this._onChange);
        this._queryResult = null;
      }
    }
  }]);
  return CollapseDetection;
}();

/**
 * @element ons-splitter-side
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
 *
 *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
 *
 *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
 *  [/en]
 *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` is the parent component.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterSideElement = function (_BaseElement) {
  inherits(SplitterSideElement, _BaseElement);

  /**
   * @event modechange
   * @description
   *   [en]Fired just after the component's mode changes.[/en]
   *   [ja]この要素のモードが変化した際に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {String} event.mode
   *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
   *   [ja]現在のモードを返します。[/ja]
   */

  /**
   * @event preopen
   * @description
   *   [en]Fired just before the sliding menu is opened.[/en]
   *   [ja]スライディングメニューが開く前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Function} event.cancel
   *   [en]Call to cancel opening sliding menu.[/en]
   *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event postopen
   * @description
   *   [en]Fired just after the sliding menu is opened.[/en]
   *   [ja]スライディングメニューが開いた後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event preclose
   * @description
   *   [en]Fired just before the sliding menu is closed.[/en]
   *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call to cancel opening sliding-menu.[/en]
   *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
   */

  /**
   * @event postclose
   * @description
   *   [en]Fired just after the sliding menu is closed.[/en]
   *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default  default
   * @description
   *  [en]Specify the animation. Use one of `overlay`, `push`, `reveal` or  `default`.[/en]
   *  [ja]アニメーションを指定します。"overlay", "push", "reveal", "default"のいずれかを指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute open-threshold
   * @type {Number}
   * @default  0.3
   * @description
   *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
   *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
   */

  /**
   * @attribute collapse
   * @type {String}
   * @description
   *   [en]
   *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
   *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
   *     If the value is a media query, the view will collapse when the media query resolves to `true`.
   *     If the value is not defined, the view always be in `"collapse"` mode.
   *   [/en]
   *   [ja]
   *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
   *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
   *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
   *     値に何も指定しない場合には、常にcollapseモードになります。
   *   [/ja]
   */

  /**
   * @attribute swipe-target-width
   * @type {String}
   * @description
   *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
   *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
   */

  /**
   * @attribute width
   * @type {String}
   * @description
   *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
   *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
   */

  /**
   * @attribute side
   * @type {String}
   * @default left
   * @description
   *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
   *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
   */

  /**
   * @attribute mode
   * @type {String}
   * @description
   *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
   *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
   */

  /**
   * @attribute page
   * @initonly
   * @type {String}
   * @description
   *   [en]The URL of the menu page.[/en]
   *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
   */

  /**
   * @attribute swipeable
   * @type {Boolean}
   * @description
   *   [en]Whether to enable swipe interaction on collapse mode.[/en]
   *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
   */

  function SplitterSideElement() {
    classCallCheck(this, SplitterSideElement);

    var _this = possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).call(this));

    _this._page = null;
    _this._state = CLOSED_STATE;
    _this._lock = new DoorLock();
    _this._pageLoader = defaultPageLoader;
    _this._collapseDetection = new CollapseDetection(_this);

    _this._animatorFactory = new AnimatorFactory({
      animators: SplitterElement.animators,
      baseClass: SplitterAnimator$1,
      baseClassName: 'SplitterAnimator',
      defaultAnimation: _this.getAttribute('animation')
    });

    contentReady(_this, function () {
      // These attributes are used early by the parent element
      _this.attributeChangedCallback('width');
      if (!_this.hasAttribute('side')) {
        _this.setAttribute('side', 'left');
      }

      rewritables$2.ready(_this, function () {
        var page = _this._page || _this.getAttribute('page');
        page && _this.load(page);
      });
    });
    return _this;
  }

  createClass(SplitterSideElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!util.match(this.parentNode, 'ons-splitter')) {
        throw new Error('Parent must be an ons-splitter element.');
      }

      this._swipe = new SwipeReveal({
        element: this,
        elementHandler: this.parentElement,
        swipeMax: this.open.bind(this),
        swipeMid: function swipeMid(distance) {
          return _this2._animator.translate(distance);
        },
        swipeMin: this.close.bind(this),
        getThreshold: function getThreshold() {
          return Math.max(0, Math.min(1, parseFloat(_this2.getAttribute('open-threshold')) || 0.3));
        },
        getSide: function getSide() {
          return _this2.side;
        },
        isInitialState: function isInitialState() {
          var closed = _this2._state === CLOSED_STATE;
          _this2._state = CHANGING_STATE;
          return closed;
        },
        ignoreSwipe: function ignoreSwipe(event, distance) {
          var isOpen = _this2.isOpen;
          var validDrag = function validDrag(d) {
            return _this2.side === 'left' ? d === 'left' && isOpen || d === 'right' && !isOpen : d === 'left' && !isOpen || d === 'right' && isOpen;
          };

          var area = Math.max(0, parseInt(_this2.getAttribute('swipe-target-width'), 10) || 0);

          return _this2._mode === SPLIT_MODE || _this2._lock.isLocked() || _this2._isOtherSideOpen() || !validDrag(event.gesture.direction) || !isOpen && area !== 0 && distance > area;
        }
      });

      this.attributeChangedCallback('swipeable');

      contentReady(this, function () {
        _this2.constructor.observedAttributes.forEach(function (attr) {
          return _this2.attributeChangedCallback(attr, null, _this2.getAttribute(attr));
        });
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._swipe && this._swipe.dispose();
      this._animator = this._swipe = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'swipeable':
          this._swipe && this._swipe.update();
          break;
        case 'width':
          this.style.width = /^\d+(px|%)$/.test(current) ? current : '80%';
          break;
        default:
          this[util.camelize('_update-' + name)](current);
      }
    }
  }, {
    key: '_emitEvent',
    value: function _emitEvent(name) {
      if (name.slice(0, 3) !== 'pre') {
        return util.triggerElementEvent(this, name, { side: this });
      }
      var isCanceled = false;

      util.triggerElementEvent(this, name, {
        side: this,
        cancel: function cancel() {
          return isCanceled = true;
        }
      });

      return isCanceled;
    }
  }, {
    key: '_isOtherSideOpen',
    value: function _isOtherSideOpen() {
      var _this3 = this;

      return !!util.findChild(this.parentElement, function (el) {
        return el instanceof _this3.constructor && el !== _this3 && el._mode === COLLAPSE_MODE && el.isOpen;
      });
    }
  }, {
    key: '_updateCollapse',
    value: function _updateCollapse() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');

      if (value === null || value === 'split') {
        this._collapseDetection.disable();
        return this._updateMode(SPLIT_MODE);
      }
      if (value === '' || value === 'collapse') {
        this._collapseDetection.disable();
        return this._updateMode(COLLAPSE_MODE);
      }

      this._collapseDetection.changeTarget(value);
    }
  }, {
    key: '_updateMode',
    value: function _updateMode(mode) {
      if (mode !== this._mode) {
        this._mode = mode;
        this.setAttribute('mode', mode); // readonly attribute for the users

        if (mode === SPLIT_MODE) {
          this._animator && this._animator.deactivate();
          this._state = CLOSED_STATE;
        } else {
          this._animator && this._animator.activate(this);
          this._state === OPEN_STATE && this._animator.open();
        }

        util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
      }
    }
  }, {
    key: '_updateAnimation',
    value: function _updateAnimation() {
      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');

      this._animator && this._animator.deactivate();
      this._animator = this._animatorFactory.newAnimator({ animation: animation });
      this._animator.activate(this);
    }
  }, {
    key: '_updateAnimationOptions',
    value: function _updateAnimationOptions() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');

      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Page location to load in the splitter side.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'open',


    /**
     * @method open
     * @signature open([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been opened.[/en]
     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */
    value: function open(options) {
      return this.toggle(options, true);
    }

    /**
     * @method close
     * @signature close([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been closed.[/en]
     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'close',
    value: function close(options) {
      return this.toggle(options, false);
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     * @description
     *   [en]Opens if it's closed. Closes if it's open.[/en]
     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var force = arguments[1];

      var shouldOpen = typeof force === 'boolean' ? force : !this.isOpen;
      var action = shouldOpen ? 'open' : 'close',
          FINAL_STATE = shouldOpen ? OPEN_STATE : CLOSED_STATE;

      if (this._mode === SPLIT_MODE) {
        return Promise.resolve(false);
      }
      if (this._state === FINAL_STATE) {
        return Promise.resolve(this);
      }
      if (this._lock.isLocked()) {
        return Promise.reject('Another splitter-side action is already running.');
      }
      if (shouldOpen && this._isOtherSideOpen()) {
        return Promise.reject('Another menu is already open.');
      }
      if (this._emitEvent('pre' + action)) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      var unlock = this._lock.lock();
      this._state = CHANGING_STATE;

      return new Promise(function (resolve) {
        _this4._animator[action](function () {
          _this4._state = FINAL_STATE;
          unlock();
          _this4._emitEvent('post' + action);
          options.callback instanceof Function && options.callback(_this4);
          resolve(_this4);
        });
      });
    }

    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in pageUrl in the right section[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'load',
    value: function load(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this5._content || null;

        _this5._pageLoader.load({ page: page, parent: _this5 }, function (pageElement) {
          if (oldContent) {
            _this5._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this5._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'side',
    get: function get$$1() {
      return this.getAttribute('side') === 'right' ? 'right' : 'left';
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @description
     *   [en][/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    }

    /**
     * @property mode
     * @readonly
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'mode',
    get: function get$$1() {
      return this._mode;
    }

    /**
     * @property isOpen
     * @type {Boolean}
     * @readonly
     * @description
     *   [en]This value is `true` when the menu is open.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'isOpen',
    get: function get$$1() {
      return this._mode === COLLAPSE_MODE && this._state !== CLOSED_STATE;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['animation', 'width', 'collapse', 'swipeable', 'animation-options'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['preopen', 'postopen', 'preclose', 'postclose', 'modechange'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$2;
    }
  }]);
  return SplitterSideElement;
}(BaseElement);

ons$1.elements.SplitterSide = SplitterSideElement;
customElements.define('ons-splitter-side', SplitterSideElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$31 = {
  '': 'switch--*',
  '.switch__input': 'switch--*__input',
  '.switch__handle': 'switch--*__handle',
  '.switch__toggle': 'switch--*__toggle'
};

var locations = {
  ios: [1, 21],
  material: [0, 16]
};

/**
 * @element ons-switch
 * @category form
 * @description
 *   [en]
 *     Switch component. The switch can be toggled both by dragging and tapping.
 *
 *     Will automatically displays a Material Design switch on Android devices.
 *   [/en]
 *   [ja]スイッチを表示するコンポーネントです。[/ja]
 * @modifier material
 *   [en]Material Design switch[/en]
 *   [ja][/ja]
 * @codepen LpXZQQ
 * @tutorial vanilla/Reference/switch
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-switch checked></ons-switch>
 * <ons-switch disabled></ons-switch>
 * <ons-switch modifier="material"></ons-switch>
 */

var SwitchElement = function (_BaseCheckboxElement) {
  inherits(SwitchElement, _BaseCheckboxElement);

  function SwitchElement() {
    classCallCheck(this, SwitchElement);

    var _this = possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).call(this));

    contentReady(_this, function () {
      _this.attributeChangedCallback('modifier', null, _this.getAttribute('modifier'));
    });

    _this._boundOnChange = _this._onChange.bind(_this);
    _this._boundOnRelease = _this._onRelease.bind(_this);
    return _this;
  }

  createClass(SwitchElement, [{
    key: '_getPosition',


    /* Own props */

    value: function _getPosition(e) {
      var l = this._locations;
      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
    }
  }, {
    key: '_emitChangeEvent',
    value: function _emitChangeEvent() {
      util.triggerElementEvent(this, 'change', {
        value: this.checked,
        switch: this,
        isInteractive: true
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      if (event && event.stopPropagation) {
        event.stopPropagation();
      }

      this._emitChangeEvent();
    }
  }, {
    key: '_onClick',
    value: function _onClick(ev) {
      if (ev.target.classList.contains(this.defaultElementClass + '__touch')) {
        ev.preventDefault();
      }
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        ModifierUtil.addModifier(this, 'active');
        document.addEventListener('release', this._boundOnRelease);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
        ModifierUtil.removeModifier(this, 'active');
        return;
      }

      e.consumed = true;

      ModifierUtil.addModifier(this, 'active');
      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

      this.addEventListener('drag', this._onDrag);
      document.addEventListener('release', this._boundOnRelease);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.stopPropagation();
      e.gesture.preventDefault();
      this._handle.style.left = this._getPosition(e) + 'px';
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var l = this._locations;
      var position = this._getPosition(e);
      var previousValue = this.checked;

      this.checked = position >= (l[0] + l[1]) / 2;

      if (this.checked !== previousValue) {
        this._emitChangeEvent();
      }

      this.removeEventListener('drag', this._onDrag);
      document.removeEventListener('release', this._boundOnRelease);

      this._handle.style.left = '';
      ModifierUtil.removeModifier(this, 'active');
    }
  }, {
    key: 'click',
    value: function click() {
      if (!this.disabled) {
        this.checked = !this.checked;
        this._emitChangeEvent();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._input.addEventListener('change', _this2._boundOnChange);
      });

      this.addEventListener('dragstart', this._onDragStart);
      this.addEventListener('hold', this._onHold);
      this.addEventListener('tap', this.click);
      this.addEventListener('click', this._onClick);
      this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251 });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._input.removeEventListener('change', _this3._boundOnChange);
      });

      this.removeEventListener('dragstart', this._onDragStart);
      this.removeEventListener('hold', this._onHold);
      this.removeEventListener('tap', this.click);
      this.removeEventListener('click', this._onClick);
      if (this._gestureDetector) {
        this._gestureDetector.dispose();
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        var md = (current || '').indexOf('material') !== -1;
        this._locations = locations[md ? 'material' : 'ios'];
      }

      get(SwitchElement.prototype.__proto__ || Object.getPrototypeOf(SwitchElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @event change
     * @description
     *   [en]Fired when the switch is toggled.[/en]
     *   [ja]ON/OFFが変わった時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Object} event.switch
     *   [en]Switch object.[/en]
     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
     * @param {Boolean} event.value
     *   [en]Current value.[/en]
     *   [ja]現在の値を返します。[/ja]
     * @param {Boolean} event.isInteractive
     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the switch.[/en]
     *  [ja]スイッチの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the switch is be disabled.[/en]
     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
     */

    /**
     * @attribute checked
     * @description
     *   [en]Whether the switch is checked.[/en]
     *   [ja]スイッチがONの状態にするときに指定します。[/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]This value is `true` if the switch is checked.[/en]
     *   [ja]スイッチがONの場合に`true`。[/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property checkbox
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The underlying checkbox element.[/en]
     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$31;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'switch';
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <div class="' + this._defaultClassName + '__toggle">\n        <div class="' + this._defaultClassName + '__handle">\n          <div class="' + this._defaultClassName + '__touch"></div>\n        </div>\n      </div>\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'checkbox';
    }
  }, {
    key: '_handle',
    get: function get$$1() {
      return this.querySelector('.' + this._defaultClassName + '__handle');
    }
  }, {
    key: 'checkbox',
    get: function get$$1() {
      return this._input;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement), 'observedAttributes', this)), ['modifier']);
    }
  }]);
  return SwitchElement;
}(BaseCheckboxElement);

ons$1.elements.Switch = SwitchElement;
customElements.define('ons-switch', SwitchElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$33 = {
  '.tabbar__content': 'tabbar--*__content',
  '.tabbar__border': 'tabbar--*__border',
  '.tabbar': 'tabbar--*'
};

var rewritables$3 = {
  /**
   * @param {Element} tabbarElement
   * @param {Function} callback
   */
  ready: function ready(tabbarElement, callback) {
    callback();
  }
};

var lerp = function lerp(x0, x1, t) {
  return (1 - t) * x0 + t * x1;
};

/**
 * @element ons-tabbar
 * @category tabbar
 * @description
 *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
 *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @modifier material
 *   [en]A tabbar in Material Design.[/en]
 *   [ja][/ja]
 * @modifier autogrow
 *   [en]Tabs automatically grow depending on their content instead of having a fixed width.[/en]
 *   [ja][/ja]
 * @modifier top-border
 *   [en]Shows a static border-bottom in tabs for iOS top tabbars.[/en]
 *   [ja][/ja]
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-tab
 *   [en]The `<ons-tab>` component.[/en]
 *   [ja]ons-tabコンポーネント[/ja]
 * @seealso ons-page
 *   [en]The `<ons-page>` component.[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>
 */

var TabbarElement = function (_BaseElement) {
  inherits(TabbarElement, _BaseElement);

  /**
   * @event prechange
   * @description
   *   [en]Fires just before the tab is changed.[/en]
   *   [ja]アクティブなタブが変わる前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to cancel the change event.[/en]
   *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
   */

  /**
   * @event postchange
   * @description
   *   [en]Fires just after the tab is changed.[/en]
   *   [ja]アクティブなタブが変わった後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   */

  /**
   * @event reactive
   * @description
   *   [en]Fires if the already open tab is tapped again.[/en]
   *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default none
   * @description
   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute position
   * @initonly
   * @type {String}
   * @default bottom
   * @description
   *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
   *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
   */

  /**
   * @attribute swipeable
   * @description
   *   [en]If this attribute is set the tab bar can be scrolled by drag or swipe.[/en]
   *   [ja]この属性がある時、タブバーをスワイプやドラッグで移動できるようになります。[/ja]
   */

  /**
   * @attribute ignore-edge-width
   * @type {Number}
   * @default 20
   * @description
   *   [en]Distance in pixels from both edges. Swiping on these areas will prioritize parent components such as `ons-splitter` or `ons-navigator`.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute hide-tabs
   * @description
   *   [en]Whether to hide the tabs.[/en]
   *   [ja]タブを非表示にする場合に指定します。[/ja]
   */

  /**
   * @attribute tab-border
   * @description
   *   [en]If this attribute is set the tabs show a dynamic bottom border. Only works for iOS since the border is always visible in Material Design.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the tabbar.[/en]
   *   [ja]タブバーの表現を指定します。[/ja]
   */

  function TabbarElement() {
    classCallCheck(this, TabbarElement);

    var _this = possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(TabbarElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!this._swiper) {
        this._swiper = new Swiper({
          getElement: function getElement() {
            return _this2._contentElement;
          },
          getInitialIndex: function getInitialIndex() {
            return _this2.getAttribute('activeIndex') || _this2.getAttribute('active-index');
          },
          getAutoScrollRatio: this._getAutoScrollRatio.bind(this),
          getBubbleWidth: function getBubbleWidth() {
            return parseInt(_this2.getAttribute('ignore-edge-width') || 25, 10);
          },
          isAutoScrollable: function isAutoScrollable() {
            return true;
          },
          preChangeHook: this._onPreChange.bind(this),
          postChangeHook: this._onPostChange.bind(this),
          refreshHook: this._onRefresh.bind(this),
          scrollHook: this._onScroll.bind(this)
        });

        contentReady(this, function () {
          _this2._tabbarBorder = util.findChild(_this2._tabbarElement, '.tabbar__border');
          _this2._swiper.init({ swipeable: _this2.hasAttribute('swipeable') });
        });
      }

      contentReady(this, function () {
        return _this2._updatePosition();
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._swiper && this._swiper.initialized) {
        this._swiper.dispose();
        this._swiper = null;
        this._tabbarBorder = null;
        this._tabsRect = null;
      }
    }
  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      return _extends({}, event, { index: event.activeIndex, tabItem: this.tabs[event.activeIndex] });
    }
  }, {
    key: '_onPostChange',
    value: function _onPostChange(event) {
      event = this._normalizeEvent(event);
      util.triggerElementEvent(this, 'postchange', event);
      var page = event.tabItem.pageElement;
      page && page._show();
    }
  }, {
    key: '_onPreChange',
    value: function _onPreChange(event) {
      event = this._normalizeEvent(event);
      event.cancel = function () {
        return event.canceled = true;
      };

      util.triggerElementEvent(this, 'prechange', event);

      if (!event.canceled) {
        var _event = event,
            activeIndex = _event.activeIndex,
            lastActiveIndex = _event.lastActiveIndex;

        var tabs = this.tabs;

        tabs[activeIndex].setActive(true);
        if (lastActiveIndex >= 0) {
          var prevTab = tabs[lastActiveIndex];
          prevTab.setActive(false);
          prevTab.pageElement && prevTab.pageElement._hide();
        }
      }

      return event.canceled;
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._tabbarBorder) {
        this._tabbarBorder.style.transition = 'all ' + (options.duration || 0) + 's ' + (options.timing || '');

        if (this._autogrow && this._tabsRect.length > 0) {
          var a = Math.floor(index),
              b = Math.ceil(index),
              r = index % 1;
          this._tabbarBorder.style.width = lerp(this._tabsRect[a].width, this._tabsRect[b].width, r) + 'px';
          this._tabbarBorder.style.transform = 'translate3d(' + lerp(this._tabsRect[a].left, this._tabsRect[b].left, r) + 'px, 0, 0)';
        } else {
          this._tabbarBorder.style.transform = 'translate3d(' + index * 100 + '%, 0, 0)';
        }
      }

      this._onSwipe && this._onSwipe(index, options);
    }
  }, {
    key: '_onRefresh',
    value: function _onRefresh() {
      this._autogrow = util.hasModifier(this, 'autogrow');
      this._tabsRect = this.tabs.map(function (tab) {
        return tab.getBoundingClientRect();
      });
      if (this._tabbarBorder) {
        this._tabbarBorder.style.display = this.hasAttribute('tab-border') || platform.isAndroid() ? 'block' : 'none';
        var index = this.getActiveTabIndex();
        if (this._tabsRect.length > 0 && index >= 0) {
          this._tabbarBorder.style.width = this._tabsRect[index].width + 'px';
        }
      }
    }
  }, {
    key: '_getAutoScrollRatio',
    value: function _getAutoScrollRatio(matches, velocity, size) {
      var ratio = .6; // Base ratio
      var modifier = size / 300 * (matches ? -1 : 1); // Based on screen size
      return Math.min(1, Math.max(0, ratio + velocity * modifier));
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      var content = this._contentElement || util.create('.tabbar__content');
      content.classList.add('ons-tabbar__content');
      var tabbar = this._tabbarElement || util.create('.tabbar');
      tabbar.classList.add('ons-tabbar__footer');

      if (!tabbar.parentNode) {
        while (this.firstChild) {
          tabbar.appendChild(this.firstChild);
        }
      }

      var activeIndex = Number(this.getAttribute('activeIndex')); // 0 by default
      if (tabbar.children.length > activeIndex && !util.findChild(tabbar, '[active]')) {
        tabbar.children[activeIndex].setAttribute('active', '');
      }

      this._tabbarBorder = util.findChild(tabbar, '.tabbar__border') || util.create('.tabbar__border');
      tabbar.appendChild(this._tabbarBorder);
      tabbar.classList.add('ons-swiper-tabbar'); // Hides material border

      !content.children[0] && content.appendChild(document.createElement('div'));
      !content.children[1] && content.appendChild(document.createElement('div'));
      content.appendChild = content.appendChild.bind(content.children[0]);
      content.insertBefore = content.insertBefore.bind(content.children[0]);

      this.appendChild(content);
      this.appendChild(tabbar); // Triggers ons-tab connectedCallback

      ModifierUtil.initModifier(this, scheme$33);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var _this3 = this;

      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');

      var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
      var action = top ? util.addModifier : util.removeModifier;

      action(this, 'top');

      var page = util.findParent(this, 'ons-page');
      if (page) {
        contentReady(page, function () {
          var p = 0;
          if (page.children[0] && util.match(page.children[0], 'ons-toolbar')) {
            action(page.children[0], 'noshadow');
            p = 1; // Visual fix for some devices
          }

          var content = page._getContentElement();
          var cs = window.getComputedStyle(page._getContentElement(), null);

          _this3.style.top = top ? parseInt(cs.getPropertyValue('padding-top'), 10) - p + 'px' : '';

          // Refresh content top - Fix for iOS 8
          content.style.top = cs.top;
          content.style.top = '';
        });
      }

      internal$1.autoStatusBarFill(function () {
        var filled = util.findParent(_this3, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util.toggleAttribute(_this3, 'status-bar-fill', top && !filled);
      });
    }
  }, {
    key: 'setActiveTab',


    /**
     * @method setActiveTab
     * @signature setActiveTab(index, [options])
     * @param {Number} index
     *   [en]Tab index.[/en]
     *   [ja]タブのインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that runs when the new page has loaded.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this option is "none", the transition won't slide.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show specified tab page. Animations and their options can be specified by the second parameter.[/en]
     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
     * @return {Promise}
     *   [en]A promise that resolves to the new page element.[/en]
     *   [ja][/ja]
     */
    value: function setActiveTab(nextIndex) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var prevIndex = this.getActiveTabIndex();
      var prevTab = this.tabs[prevIndex],
          nextTab = this.tabs[nextIndex];

      if (!nextTab) {
        return Promise.reject('Specified index does not match any tab.');
      }

      if (nextIndex === prevIndex) {
        util.triggerElementEvent(this, 'reactive', { index: nextIndex, activeIndex: nextIndex, tabItem: nextTab });
        return Promise.resolve(nextTab.pageElement);
      }

      // FIXME: nextTab.loaded is broken in Zone.js promises (Angular2)
      var nextPage = nextTab.pageElement;
      return (nextPage ? Promise.resolve(nextPage) : nextTab.loaded).then(function (nextPage) {
        return _this4._swiper.setActiveIndex(nextIndex, _extends({
          reject: true
        }, options, {
          animation: prevTab && nextPage ? options.animation || _this4.getAttribute('animation') : 'none',
          animationOptions: util.extend({ duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }, _this4.hasAttribute('animation-options') ? util.animationOptionsParse(_this4.getAttribute('animation-options')) : {}, options.animationOptions || {})
        })).then(function () {
          options.callback instanceof Function && options.callback(nextPage);
          return nextPage;
        });
      });
    }

    /**
     * @method setTabbarVisibility
     * @signature setTabbarVisibility(visible)
     * @param {Boolean} visible
     * @description
     *   [en]Used to hide or show the tab bar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setTabbarVisibility',
    value: function setTabbarVisibility(visible) {
      var _this5 = this;

      contentReady(this, function () {
        _this5._contentElement.style[_this5._top ? 'top' : 'bottom'] = visible ? '' : '0px';
        _this5._tabbarElement.style.display = visible ? '' : 'none';
      });
    }
  }, {
    key: 'show',
    value: function show() {
      this.setTabbarVisibility(true);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setTabbarVisibility(false);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the tabbar is visible or not.[/en]
     *   [ja]タブバーが見える場合に`true`。[/ja]
     */

  }, {
    key: 'getActiveTabIndex',


    /**
     * @method getActiveTabIndex
     * @signature getActiveTabIndex()
     * @return {Number}
     *   [en]The index of the currently active tab.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
     * @description
     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
     */
    value: function getActiveTabIndex() {
      for (var tabs = this.tabs, i = 0; i < tabs.length; i++) {
        if (tabs[i] && tabs[i].tagName === 'ONS-TAB' && tabs[i].isActive()) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: '_show',
    value: function _show() {
      var _this6 = this;

      this._swiper.show();
      setImmediate(function () {
        return _this6.tabs.length > 0 && _this6.tabs[_this6.getActiveTabIndex()].loaded.then(function (el) {
          return el && setImmediate(function () {
            return el._show();
          });
        });
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._swiper.hide();
      var topPage = this.topPage;
      topPage && topPage._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this.tabs.forEach(function (tab) {
        return tab.remove();
      });
      this.remove();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$33);
        var isTop = function isTop(m) {
          return (/(^|\s+)top($|\s+)/i.test(m)
          );
        };
        isTop(last) !== isTop(current) && this._updatePosition();
      } else if (name === 'position') {
        util.isAttached(this) && this._updatePosition();
      } else if (name === 'swipeable') {
        this._swiper && this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
      } else if (name === 'hide-tabs') {
        this.setTabbarVisibility(!this.hasAttribute('hide-tabs') || current === 'false');
      }
    }
  }, {
    key: '_tabbarElement',
    get: function get$$1() {
      return util.findChild(this, '.tabbar');
    }
  }, {
    key: '_contentElement',
    get: function get$$1() {
      return util.findChild(this, '.tabbar__content');
    }
  }, {
    key: '_targetElement',
    get: function get$$1() {
      var content = this._contentElement;
      return content && content.children[0] || null;
    }
  }, {
    key: 'topPage',
    get: function get$$1() {
      var tabs = this.tabs,
          index = this.getActiveTabIndex();
      return tabs[index] ? tabs[index].pageElement || this.pages[0] || null : null;
    }
  }, {
    key: 'pages',
    get: function get$$1() {
      return util.arrayFrom(this._targetElement.children);
    }
  }, {
    key: 'tabs',
    get: function get$$1() {
      return Array.prototype.filter.call(this._tabbarElement.children, function (e) {
        return e.tagName === 'ONS-TAB';
      });
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      return this._tabbarElement.style.display !== 'none';
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]Enable swipe interaction.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get$$1() {
      return this.hasAttribute('swipeable');
    },
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the tabbar. It gets a decimal index and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throw new Error('\'onSwipe\' must be a function.');
      }
      this._onSwipe = value;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'position', 'swipeable', 'tab-border', 'hide-tabs'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$3;
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['prechange', 'postchange', 'reactive'];
    }
  }]);
  return TabbarElement;
}(BaseElement);

ons$1.elements.Tabbar = TabbarElement;
customElements.define('ons-tabbar', TabbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$19 = 'tabbar__item';

var scheme$32 = {
  '': 'tabbar--*__item',
  '.tabbar__button': 'tabbar--*__button'
};

/**
 * @element ons-tab
 * @category tabbar
 * @description
 *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
 *   [ja]
 *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
 *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
 *   [/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide fundamentals.html#managing-pages
 *   [en]Managing multiple pages.[/en]
 *   [ja]複数のページを管理する[/ja]]
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @seealso ons-tabbar
 *   [en]ons-tabbar component[/en]
 *   [ja]ons-tabbarコンポーネント[/ja]
 * @seealso ons-page
 *   [en]ons-page component[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]ons-icon component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <ons-template id="home.html">
 *   ...
 * </ons-template>
 *
 * <ons-template id="settings.html">
 *   ...
 * </ons-template>

 */

var TabElement = function (_BaseElement) {
  inherits(TabElement, _BaseElement);

  /**
   * @attribute page
   * @initonly
   * @type {String}
   * @description
   *   [en]The page that is displayed when the tab is tapped.[/en]
   *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]
   */

  /**
   * @attribute icon
   * @type {String}
   * @description
   *   [en]
   *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`. Check [See also](#seealso) section for more information.
   *   [/en]
   *   [ja]
   *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。
   *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
   *   [/ja]
   */

  /**
   * @attribute active-icon
   * @type {String}
   * @description
   *   [en]The name of the icon when the tab is active.[/en]
   *   [ja]アクティブの際のアイコン名を指定します。[/ja]
   */

  /**
   * @attribute label
   * @type {String}
   * @description
   *   [en]The label of the tab item.[/en]
   *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
   */

  /**
   * @attribute badge
   * @type {String}
   * @description
   *   [en]Display a notification badge on top of the tab.[/en]
   *   [ja]バッジに表示する内容を指定します。[/ja]
   */

  /**
   * @attribute active
   * @description
   *   [en]This attribute should be set to the tab that is active by default.[/en]
   *   [ja][/ja]
   */

  function TabElement() {
    classCallCheck(this, TabElement);

    var _this = possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).call(this));

    if (['label', 'icon', 'badge'].some(_this.hasAttribute.bind(_this))) {
      _this._compile();
    } else {
      contentReady(_this, function () {
        return _this._compile();
      });
    }

    _this._pageLoader = defaultPageLoader;
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(TabElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$19);

      if (this._button) {
        return;
      }

      var button = util.create('button.tabbar__button');
      while (this.childNodes[0]) {
        button.appendChild(this.childNodes[0]);
      }

      var input = util.create('input', { display: 'none' });
      input.type = 'radio';

      this.appendChild(input);
      this.appendChild(button);

      this._updateButtonContent();
      ModifierUtil.initModifier(this, scheme$32);
      this._updateRipple();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      this._button && util.updateRipple(this._button, this.hasAttribute('ripple'));
    }
  }, {
    key: '_updateButtonContent',
    value: function _updateButtonContent() {
      var _this2 = this;

      var button = this._button;

      var iconWrapper = this._icon;
      if (this.hasAttribute('icon')) {
        iconWrapper = iconWrapper || util.createElement('<div class="tabbar__icon"><ons-icon></ons-icon></div>');
        var icon = iconWrapper.children[0];
        var fix = function (last) {
          return function () {
            return icon.attributeChangedCallback('icon', last, _this2.getAttribute('icon'));
          };
        }(icon.getAttribute('icon'));
        icon.setAttribute('icon', this.getAttribute('icon'));
        iconWrapper.parentElement !== button && button.insertBefore(iconWrapper, button.firstChild);

        // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654
        icon.attributeChangedCallback instanceof Function ? fix() : setImmediate(function () {
          return icon.attributeChangedCallback instanceof Function && fix();
        });
      } else {
        iconWrapper && iconWrapper.remove();
      }

      ['label', 'badge'].forEach(function (attr, index) {
        var prop = _this2.querySelector('.tabbar__' + attr);
        if (_this2.hasAttribute(attr)) {
          prop = prop || util.create('.tabbar__' + attr + (attr === 'badge' ? ' notification' : ''));
          prop.textContent = _this2.getAttribute(attr);
          prop.parentElement !== button && button.appendChild(prop);
        } else {
          prop && prop.remove();
        }
      });
    }
  }, {
    key: '_onClick',
    value: function _onClick() {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else {
        this._tabbar.setActiveTab(this.index, { reject: false });
      }
    }
  }, {
    key: 'setActive',
    value: function setActive() {
      var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._input.checked = active;
      this.classList.toggle('active', active);
      util.toggleAttribute(this, 'active', active);

      if (this.hasAttribute('icon') && this.hasAttribute('active-icon')) {
        this._icon.children[0].setAttribute('icon', this.getAttribute(active ? 'active-icon' : 'icon'));
      }
    }
  }, {
    key: '_loadPageElement',
    value: function _loadPageElement(parent, page) {
      var _this3 = this;

      this._hasLoaded = true;
      return new Promise(function (resolve) {
        _this3._pageLoader.load({ parent: parent, page: page }, function (pageElement) {
          parent.replaceChild(pageElement, parent.children[_this3.index]); // Ensure position
          _this3._loadedPage = pageElement;
          resolve(pageElement);
        });
      });
    }
  }, {
    key: 'isActive',


    /**
     * @return {Boolean}
     */
    value: function isActive() {
      return this.classList.contains('active');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.loaded = null;
      this.removeEventListener('click', this._boundOnClick, false);
      if (this._loadedPage) {
        this._pageLoader.unload(this._loadedPage);
        this._loadedPage = null;
        this._hasLoaded = false;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      if (!util.isAttached(this) || this.loaded) {
        return; // ons-tabbar compilation may trigger this
      }

      var deferred = util.defer();
      this.loaded = deferred.promise;

      contentReady(this, function () {
        var index = _this4.index;
        var tabbar = _this4._tabbar;
        if (!tabbar) {
          throw new Error('This ons-tab element must be child of ons-tabbar element.');
        }

        if (tabbar.hasAttribute('modifier')) {
          util.addModifier(_this4, tabbar.getAttribute('modifier'));
        }

        if (!_this4._hasLoaded) {
          if (_this4.hasAttribute('active')) {
            _this4.setActive(true);
            tabbar.setAttribute('activeIndex', index);
          }

          if (index === tabbar.tabs.length - 1) {
            tabbar._onRefresh();
            setImmediate(function () {
              return tabbar._onRefresh();
            });
          }

          TabbarElement.rewritables.ready(tabbar, function () {
            var pageTarget = _this4.page || _this4.getAttribute('page');
            if (!_this4.pageElement && pageTarget) {
              var parentTarget = tabbar._targetElement;
              var dummyPage = util.create('div', { height: '100%', width: '100%', backgroundColor: 'transparent' });
              parentTarget.insertBefore(dummyPage, parentTarget.children[index]); // Ensure position
              return _this4._loadPageElement(parentTarget, pageTarget).then(deferred.resolve);
            }

            return deferred.resolve(_this4.pageElement);
          });
        }

        _this4.addEventListener('click', _this4._boundOnClick, false);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$19, scheme$32);
          break;
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$32);
          });
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this5._updateRipple();
          });
          break;
        case 'icon':
        case 'label':
        case 'badge':
          contentReady(this, function () {
            return _this5._updateButtonContent();
          });
          break;
        case 'page':
          this.page = current || '';
          break;
      }
    }
  }, {
    key: 'pageLoader',
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        throw Error('First parameter must be an instance of PageLoader.');
      }
      this._pageLoader = loader;
    },
    get: function get$$1() {
      return this._pageLoader;
    }
  }, {
    key: '_input',
    get: function get$$1() {
      return util.findChild(this, 'input');
    }
  }, {
    key: '_button',
    get: function get$$1() {
      return util.findChild(this, '.tabbar__button');
    }
  }, {
    key: '_icon',
    get: function get$$1() {
      return this.querySelector('.tabbar__icon');
    }
  }, {
    key: '_tabbar',
    get: function get$$1() {
      return util.findParent(this, 'ons-tabbar');
    }
  }, {
    key: 'index',
    get: function get$$1() {
      return Array.prototype.indexOf.call(this.parentElement.children, this);
    }
  }, {
    key: 'pageElement',
    get: function get$$1() {
      // It has been loaded by ons-tab
      if (this._loadedPage) {
        return this._loadedPage;
      }
      // Manually attached to DOM, 1 per tab
      var tabbar = this._tabbar;
      if (tabbar.pages.length === tabbar.tabs.length) {
        return tabbar.pages[this.index];
      }
      // Loaded in another way
      return null;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge', 'class'];
    }
  }]);
  return TabElement;
}(BaseElement);

ons$1.elements.Tab = TabElement;
customElements.define('ons-tab', TabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ToastAnimator = function (_BaseAnimator) {
  inherits(ToastAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ToastAnimator);
    return possibleConstructorReturn(this, (ToastAnimator.__proto__ || Object.getPrototypeOf(ToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ToastAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ToastAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeToastAnimator = function (_ToastAnimator) {
  inherits(FadeToastAnimator, _ToastAnimator);

  function FadeToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeToastAnimator);
    return possibleConstructorReturn(this, (FadeToastAnimator.__proto__ || Object.getPrototypeOf(FadeToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(FadeToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      callback = callback ? callback : function () {};

      Animit(toast).saveStyle().queue({
        opacity: 0
      }).wait(this.delay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      callback = callback ? callback : function () {};

      Animit(toast).saveStyle().queue({
        opacity: 1
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Ascend Toast Animator.
 */

var AscendToastAnimator = function (_ToastAnimator) {
  inherits(AscendToastAnimator, _ToastAnimator);

  function AscendToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.25 : _ref$duration;

    classCallCheck(this, AscendToastAnimator);

    var _this = possibleConstructorReturn(this, (AscendToastAnimator.__proto__ || Object.getPrototypeOf(AscendToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.messageDelay = _this.duration * 0.4 + _this.delay; // Delay message opacity change
    if (platform.isAndroid()) {
      _this.ascension = 48; // Toasts are always 1 line
    } else {
      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
        _this.ascension = 98; // 64 + 34
      } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
        _this.ascension = 85; // 64 + 21
      } else {
        _this.ascension = 64;
      }
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(AscendToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;
      util.globals.fabOffset = this.ascension;

      Animit.runAll(Animit(toast).saveStyle().queue({
        transform: 'translate3d(0, ' + this.ascension + 'px, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }), Animit(this._getFabs()).wait(this.delay).queue({
        transform: 'translate3d(0, -' + this.ascension + 'px, 0) scale(1)'
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(util.arrayFrom(toast.children)).saveStyle().queue({
        opacity: 0
      }).wait(this.messageDelay).queue({
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      toast = toast._toast;
      util.globals.fabOffset = 0;

      Animit.runAll(Animit(toast).saveStyle().queue({
        transform: 'translate3d(0, 0, 0)'
      }).wait(this.delay).queue({
        transform: 'translate3d(0, ' + this.ascension + 'px, 0)'
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }), Animit(this._getFabs()).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0) scale(1)'
      }, {
        duration: this.duration,
        timing: this.timing
      }), Animit(util.arrayFrom(toast.children)).saveStyle().queue({
        opacity: 1.0
      }).wait(this.delay).queue({
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle());
    }
  }, {
    key: '_getFabs',
    value: function _getFabs() {
      return util.arrayFrom(document.querySelectorAll('ons-fab[position~=bottom], ons-speed-dial[position~=bottom]')).filter(function (fab) {
        return fab.visible;
      });
    }
  }]);
  return AscendToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift-fade Toast Animator
 */

var LiftToastAnimator = function (_ToastAnimator) {
  inherits(LiftToastAnimator, _ToastAnimator);

  function LiftToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.35 : _ref$duration;

    classCallCheck(this, LiftToastAnimator);

    var _this = possibleConstructorReturn(this, (LiftToastAnimator.__proto__ || Object.getPrototypeOf(LiftToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this.liftAmount = 'calc(100% + 34px)';
    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
      _this.liftAmount = 'calc(100% + 21px)';
    } else {
      _this.liftAmount = '100%';
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(LiftToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;

      Animit.runAll(Animit(toast).saveStyle().queue({
        transform: 'translate3d(0, ' + this.liftAmount + ', 0)',
        opacity: 0
      }).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)',
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      toast = toast._toast;

      Animit.runAll(Animit(toast).saveStyle().queue({
        transform: 'translate3d(0, 0, 0)',
        opacity: 1.0
      }).wait(this.delay).queue({
        transform: 'translate3d(0, ' + this.liftAmount + ', 0)',
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(toast) {
      if (parseInt(toast.style.top, 10) === 0) {
        toast.style.top = toast.style.bottom = '';
      }
    }
  }]);
  return LiftToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fall-fade Toast Animator
 */

var FallToastAnimator = function (_ToastAnimator) {
  inherits(FallToastAnimator, _ToastAnimator);

  function FallToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.35 : _ref$duration;

    classCallCheck(this, FallToastAnimator);

    var _this = possibleConstructorReturn(this, (FallToastAnimator.__proto__ || Object.getPrototypeOf(FallToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this.fallAmount = 'calc(-100% - 44px)';
    } else {
      _this.fallAmount = '-100%';
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(FallToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;
      this._updatePosition(toast);

      Animit.runAll(Animit(toast).saveStyle().queue({
        transform: 'translate3d(0, ' + this.fallAmount + ', 0)',
        opacity: 0
      }).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)',
        opacity: 1.0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      var _this2 = this;

      toast = toast._toast;
      this._updatePosition(toast);

      Animit.runAll(Animit(toast).saveStyle().queue({
        transform: 'translate3d(0, 0, 0)',
        opacity: 1.0
      }).wait(this.delay).queue({
        transform: 'translate3d(0, ' + this.fallAmount + ', 0)',
        opacity: 0
      }, {
        duration: this.duration,
        timing: this.timing
      }).restoreStyle().queue(function (done) {
        _this2._updatePosition(toast, true);
        callback && callback();
        done();
      }));
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(toast, cleanUp) {
      var correctTop = void 0;
      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
        correctTop = '44px';
      } else {
        correctTop = '0';
      }

      if (toast.style.top !== correctTop) {
        toast.style.top = correctTop;
        toast.style.bottom = 'initial';
      }
    }
  }]);
  return FallToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$34 = {
  '.toast': 'toast--*',
  '.toast__message': 'toast--*__message',
  '.toast__button': 'toast--*__button'
};

var defaultClassName$20 = 'toast';

var _animatorDict$7 = {
  'default': platform.isAndroid() ? AscendToastAnimator : LiftToastAnimator,
  'fade': FadeToastAnimator,
  'ascend': AscendToastAnimator,
  'lift': LiftToastAnimator,
  'fall': FallToastAnimator,
  'none': ToastAnimator
};

/**
 * @element ons-toast
 * @category dialog
 * @description
 *   [en]
 *     The Toast or Snackbar component is useful for displaying dismissable information or simple actions at (normally) the bottom of the page.
 *
 *     This component does not block user input, allowing the app to continue its flow. For simple toasts, consider `ons.notification.toast` instead.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/dialog
 * @seealso ons-alert-dialog
 *   [en]The `<ons-alert-dialog>` component is preferred for displaying undismissable information.[/en]
 *   [ja][/ja]
 */

var ToastElement = function (_BaseDialogElement) {
  inherits(ToastElement, _BaseDialogElement);

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the toast. Can be either `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
   */

  function ToastElement() {
    classCallCheck(this, ToastElement);

    var _this = possibleConstructorReturn(this, (ToastElement.__proto__ || Object.getPrototypeOf(ToastElement)).call(this));

    _this._defaultDBB = function (e) {
      return e.callParentHandler();
    };
    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ToastElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      // Reset position style
      this._toast && (this._toast.style.top = this._toast.style.bottom = '');

      return new AnimatorFactory({
        animators: _animatorDict$7,
        baseClass: ToastAnimator,
        baseClassName: 'ToastAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10000; // Lower than dialogs

      var messageClassName = 'toast__message';
      var buttonClassName = 'toast__button';

      var toast = util.findChild(this, '.' + defaultClassName$20);
      if (!toast) {
        toast = document.createElement('div');
        toast.classList.add(defaultClassName$20);
        while (this.childNodes[0]) {
          toast.appendChild(this.childNodes[0]);
        }
      }

      var button = util.findChild(toast, '.' + buttonClassName);
      if (!button) {
        button = util.findChild(toast, function (e) {
          return util.match(e, '.button') || util.match(e, 'button');
        });
        if (button) {
          button.classList.remove('button');
          button.classList.add(buttonClassName);
          toast.appendChild(button);
        }
      }

      if (!util.findChild(toast, '.' + messageClassName)) {
        var message = util.findChild(toast, '.message');
        if (!message) {
          message = document.createElement('div');
          for (var i = toast.childNodes.length - 1; i >= 0; i--) {
            if (toast.childNodes[i] !== button) {
              message.insertBefore(toast.childNodes[i], message.firstChild);
            }
          }
        }
        message.classList.add(messageClassName);

        toast.insertBefore(message, toast.firstChild);
      }

      if (toast.parentNode !== this) {
        this.appendChild(toast);
      }

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show the element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Toggle toast visibility.[/en]
     *   [ja][/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Hide toast.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$34;
    }
  }, {
    key: '_toast',
    get: function get$$1() {
      return util.findChild(this, '.' + defaultClassName$20);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ToastAnimator)) {
        throw new Error('"Animator" param must inherit OnsToastElement.ToastAnimator');
      }
      _animatorDict$7[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$7;
    }
  }, {
    key: 'ToastAnimator',
    get: function get$$1() {
      return ToastAnimator;
    }
  }]);
  return ToastElement;
}(BaseDialogElement);

ons$1.elements.Toast = ToastElement;
customElements.define('ons-toast', ToastElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$21 = 'toolbar-button';

var scheme$35 = { '': 'toolbar-button--*' };

/**
 * @element ons-toolbar-button
 * @category page
 * @modifier material
 *   [en]Material Design toolbar button.[/en]
 *   [ja][/ja]
 * @modifier outline
 *   [en]A button with an outline.[/en]
 *   [ja]アウトラインをもったボタンを表示します。[/ja]
 * @description
 *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
 *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide compilation.html#toolbar-compilation
 *   [en]Adding a toolbar[/en]
 *   [ja]ツールバーの追加[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-toolbar-button>
 *       Button
 *     </ons-toolbar-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   </div>
 *   <div class="right">
 *     <ons-toolbar-button>
 *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
 *     </ons-toolbar-button>
 *   </div>
 * </ons-toolbar>
 */

var ToolbarButtonElement = function (_BaseElement) {
  inherits(ToolbarButtonElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the button.[/en]
   *   [ja]ボタンの表現を指定します。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定してください。[/ja]
   */

  function ToolbarButtonElement() {
    classCallCheck(this, ToolbarButtonElement);

    var _this = possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).call(this));

    _this._compile();
    return _this;
  }

  /**
   * @property disabled
   * @type {Boolean}
   * @description
   *   [en]Whether the element is disabled or not.[/en]
   *   [ja]無効化されている場合に`true`。[/ja]
   */


  createClass(ToolbarButtonElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$21);

      util.updateRipple(this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' });

      ModifierUtil.initModifier(this, scheme$35);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util.restoreClass(this, defaultClassName$21, scheme$35);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$35);
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarButtonElement;
}(BaseElement);

ons$1.elements.ToolbarButton = ToolbarButtonElement;
customElements.define('ons-toolbar-button', ToolbarButtonElement);

// Add and register Custom Elements
setup$1(ons$1); // Setup initial listeners
window._superSecretOns = ons$1;

return ons$1;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25zZW51aS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vY29yZS9zcmMvb25zL3N0eWxlci5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wbGF0Zm9ybS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2ludGVybmFsLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnkuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYXV0b3N0eWxlLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3V0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWl0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvY29udGVudC1yZWFkeS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC90b2FzdC1xdWV1ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9ub3RpZmljYXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYWN0aW9uLXNoZWV0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL21pY3JvZXZlbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvb3JpZW50YXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvbW9kaWZpZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvZG9vcmxvY2suanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvcGFnZS1sb2FkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9wb2x5ZmlsbHMvcG9seWZpbGwtc3dpdGNoZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAub2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1V0aWxpdGllcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0N1c3RvbUVsZW1lbnRTdGF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9Eb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvRGVmZXJyZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9DdXN0b21FbGVtZW50UmVnaXN0cnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9OYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9BbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9IVE1MRWxlbWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL0ludGVyZmFjZS9QYXJlbnROb2RlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvRG9jdW1lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9Ob2RlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvSW50ZXJmYWNlL0NoaWxkTm9kZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL0VsZW1lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9jdXN0b20tZWxlbWVudHMuanMiLCIuLi8uLi9jb3JlL3NyYy9wb2x5ZmlsbHMvTXV0YXRpb25PYnNlcnZlckAwLjcuMjIvTXV0YXRpb25PYnNlcnZlci5qcyIsIi4uLy4uL2NvcmUvc3JjL3BvbHlmaWxscy9zZXRJbW1lZGlhdGVAMS4wLjIrbW9kL3NldEltbWVkaWF0ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL3BvbHlmaWxscy9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL3ZlbmRvci9GYXN0Q2xpY2tAMS4wLjYrbW9kL2Zhc3RjbGljay5qcyIsIi4uLy4uL2NvcmUvc3JjL3ZlbmRvci92aWV3cG9ydC5qcyIsIi4uLy4uL2NvcmUvc3JjL3ZlbmRvci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL3NldHVwLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvYmFzZS9iYXNlLWVsZW1lbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdGVtcGxhdGUuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtaWYuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYmFzZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hY3Rpb24tc2hlZXQvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtZGlhbG9nLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1ib3R0b20tdG9vbGJhci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1idXR0b24uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY2FyZC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL3N3aXBlci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1jYXJvdXNlbC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1jb2wuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtZGlhbG9nL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWRpYWxvZy9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1mYWIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtZ2VzdHVyZS1kZXRlY3Rvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1pY29uLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2xhenktcmVwZWF0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxhenktcmVwZWF0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxpc3QtaGVhZGVyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxpc3QtdGl0bGUuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC1pdGVtLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxpc3QuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmFkaW8uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc2VhcmNoLWlucHV0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2ZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbW9kYWwvbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1tb2RhbC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC9zd2lwZS1yZXZlYWwuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc2xpZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1zd2lwZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWxpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1mYWRlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1zbGlkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtZmFkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3Ivbm9uZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wYWdlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXBvcG92ZXIvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaXBob25leC1wYXRjaC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wb3BvdmVyL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXByb2dyZXNzLWJhci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wdWxsLWhvb2suanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmFuZ2UuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmlwcGxlL2FuaW1hdG9yLWNzcy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1yaXBwbGUvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcm93LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNlZ21lbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc2VsZWN0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGVlZC1kaWFsLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzay5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9vdmVybGF5LWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyL3B1c2gtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvcmV2ZWFsLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3dpdGNoLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRhYmJhci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10YWIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvZmFkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9hc2NlbmQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9mYWxsLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvaW5kZXgudW1kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcblxuLyoqXG4gKiBBZGQgdmVuZG9yIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBwcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICBjb25zdCBwcmVmaXggPSAoQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgLmNhbGwoc3R5bGVzKVxuICAgIC5qb2luKCcnKVxuICAgIC5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKSB8fCAoc3R5bGVzLk9MaW5rID09PSAnJyAmJiBbJycsICdvJ10pXG4gIClbMV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gJy0nICsgcHJlZml4ICsgJy0nICsgdXRpbC5oeXBoZW5hdGUobmFtZSk7XG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogTWluaW1hbCB1dGlsaXR5IGxpYnJhcnkgZm9yIG1hbmlwdWxhdGluZyBlbGVtZW50J3Mgc3R5bGUuXG4gKiBTZXQgZWxlbWVudCdzIHN0eWxlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuY29uc3Qgc3R5bGVyID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGUpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGtleSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgIH0gZWxzZSBpZiAocHJlZml4KGtleSkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcmVmaXgoa2V5KV0gPSBzdHlsZVtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLndhcm4oJ05vIHN1Y2ggc3R5bGUgcHJvcGVydHk6ICcgKyBrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZXMgU3BhY2Utc2VwYXJhdGVkIENTUyBwcm9wZXJ0aWVzIHRvIHJlbW92ZVxuICovXG5zdHlsZXIuY2xlYXIgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZXMgPSAnJykge1xuICBjb25zdCBjbGVhcmxpc3QgPSBzdHlsZXMuc3BsaXQoL1xccysvKS5yZWR1Y2UoKHIsIHMpID0+IHIuY29uY2F0KFt1dGlsLmh5cGhlbmF0ZShzKSwgcHJlZml4KHMpXSksIFtdKSxcbiAgICBrZXlzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IGVsZW1lbnQuc3R5bGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBrZXkgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgIGlmIChjbGVhcmxpc3QubGVuZ3RoID09PSAwIHx8IGNsZWFybGlzdC5zb21lKHMgPT4ga2V5LmluZGV4T2YocykgPT09IDApKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTsgLy8gU3RvcmUgdGhlIGtleSB0byBmaXggU2FmYXJpIHN0eWxlIGluZGV4ZXNcbiAgICB9XG4gIH1cblxuICBrZXlzLmZvckVhY2goa2V5ID0+IGVsZW1lbnQuc3R5bGVba2V5XSA9ICcnKTtcbiAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgPT09ICcnICYmIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3R5bGVyO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuLy8gU2F2ZSBIVE1MRWxlbWVudCBvYmplY3QgYmVmb3JlIEN1c3RvbSBFbGVtZW50cyBwb2x5ZmlsbCBwYXRjaCBnbG9iYWwgSFRNTEVsZW1lbnQuXG5jb25zdCBOYXRpdmVIVE1MRWxlbWVudCA9IHdpbmRvdy5IVE1MRWxlbWVudDtcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5wbGF0Zm9ybVxuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVXRpbGl0eSBtZXRob2RzIHRvIGRldGVjdCBjdXJyZW50IHBsYXRmb3JtLlsvZW5dXG4gKiAgIFtqYV3nj77lnKjlrp/ooYzjgZXjgozjgabjgYTjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DjgpLmpJznn6XjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICovXG5jbGFzcyBQbGF0Zm9ybSB7XG5cbiAgLyoqXG4gICAqIEFsbCBlbGVtZW50cyB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIHRoZSBhcHAgd2FzIHJ1bm5pbmcgb24gdGhpcyBwbGF0Zm9ybS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkUGxhdGZvcm0gPSBudWxsO1xuICAgIHRoaXMuX2lnbm9yZVBsYXRmb3JtU2VsZWN0ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZWxlY3RcbiAgICogQHNpZ25hdHVyZSBzZWxlY3QocGxhdGZvcm0pXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGxhdGZvcm0gTmFtZSBvZiB0aGUgcGxhdGZvcm0uXG4gICAqICAgW2VuXVBvc3NpYmxlIHZhbHVlcyBhcmU6IFwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiIG9yIFwid3BcIi5bL2VuXVxuICAgKiAgIFtqYV1cIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiwgXCJ3cFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNldHMgdGhlIHBsYXRmb3JtIHVzZWQgdG8gcmVuZGVyIHRoZSBlbGVtZW50cy4gVXNlZnVsIGZvciB0ZXN0aW5nLlsvZW5dXG4gICAqICAgW2phXeimgee0oOOCkuaPj+eUu+OBmeOCi+OBn+OCgeOBq+WIqeeUqOOBmeOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOWQjeOCkuioreWumuOBl+OBvuOBmeOAguODhuOCueODiOOBq+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAqL1xuICBzZWxlY3QocGxhdGZvcm0pIHtcbiAgICBpZiAodHlwZW9mIHBsYXRmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRQbGF0Zm9ybSA9IHBsYXRmb3JtLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTZWxlY3RlZFBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCA/IG51bGwgOiB0aGlzLl9zZWxlY3RlZFBsYXRmb3JtO1xuICB9XG5cbiAgX3J1bk9uQWN0dWFsUGxhdGZvcm0oZm4pIHtcbiAgICB0aGlzLl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCA9IHRydWU7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgICB0aGlzLl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBHZW5lcmFsXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc1dlYlZpZXdcbiAgICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIGFwcCBpcyBydW5uaW5nIGluIENvcmRvdmEuWy9lbl1cbiAgICogICBbamFdQ29yZG92YeWGheOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dlYlZpZXcoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1dlYlZpZXcoKSBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIGRvbSBjb250ZW50cyBsb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGlPUyBkZXZpY2VzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc0lQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzSVBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIGlQaG9uZS5bL2VuXVxuICAgKiAgIFtqYV1pUGhvbmXkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGhvbmUoKSB7XG4gICAgcmV0dXJuIC9pUGhvbmUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJUGhvbmVYXG4gICAqIEBzaWduYXR1cmUgaXNJUGhvbmVYKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIGlQaG9uZSBYLlsvZW5dXG4gICAqICAgW2phXWlQaG9uZSBY5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBob25lWCgpIHtcbiAgICAvLyBpUGhvbmUgOCBhbmQgaVBob25lIFggaGF2ZSBhIHNhbWUgdXNlciBhZ2VudC4gV2UgY2Fubm90IGF2b2lkIHVzaW5nIHdpbmRvdy5zY3JlZW4uXG4gICAgLy8gVGhpcyB3b3JrcyB3ZWxsIGJvdGggaW4gaU9TIFNhZmFyaSBhbmQgKFVJfFdLKVdlYlZpZXcgb2YgaVBob25lIFguXG4gICAgcmV0dXJuIHRoaXMuaXNJUGhvbmUoKSAmJiB3aW5kb3cuc2NyZWVuLndpZHRoID09PSAzNzUgJiYgd2luZG93LnNjcmVlbi5oZWlnaHQgPT09IDgxMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBhZFxuICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGFkLlsvZW5dXG4gICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGFkKCkge1xuICAgIHJldHVybiAvaVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBvZCgpIHtcbiAgICByZXR1cm4gL2lQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGlPUyB2ZXJzaW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NcbiAgICogQHNpZ25hdHVyZSBpc0lPUygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy5bL2VuXVxuICAgKiAgIFtqYV1pT1PkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1MoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2lvcyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1M3YWJvdmVcbiAgICogQHNpZ25hdHVyZSBpc0lPUzdhYm92ZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGlPUyB2ZXJzaW9uIGlzIDcgb3IgYWJvdmUuWy9lbl1cbiAgICogICBbamFdaU9TN+S7peS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPUzdhYm92ZSgpIHtcbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gKC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkgJiYgKHBhcnNlSW50KGRldmljZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pID49IDcpKTtcbiAgICB9IGVsc2UgaWYoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zdCB2ZXIgPSAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvXFxiWzAtOV0rX1swLTldKyg/Ol9bMC05XSspP1xcYi8pIHx8IFsnJ10pWzBdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgIHJldHVybiAocGFyc2VJbnQodmVyLnNwbGl0KCcuJylbMF0pID49IDcpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gaU9TIGJyb3dzZXJzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPU1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TU2FmYXJpKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBpT1MgU2FmYXJpLlsvZW5dXG4gICAqICAgW2phXWlPUyBTYWZhcmnjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1NTYWZhcmkoKSB7XG4gICAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcbiAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICByZXR1cm4gISEodGhpcy5pc0lPUygpICYmIHVhLmluZGV4T2YoJ1NhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdWZXJzaW9uJykgIT09IC0xICYmICFuYXZpZ2F0b3Iuc3RhbmRhbG9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1dLV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzV0tXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBXS1dlYlZpZXcuWy9lbl1cbiAgICogICBbamFdV0tXZWJWaWV344Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV0tXZWJWaWV3KCkge1xuICAgIGNvbnN0IGx0ZTkgPSAvY29uc3RydWN0b3IvaS50ZXN0KE5hdGl2ZUhUTUxFbGVtZW50KTtcbiAgICByZXR1cm4gISEodGhpcy5pc0lPUygpICYmIHdpbmRvdy53ZWJraXQgJiYgd2luZG93LndlYmtpdC5tZXNzYWdlSGFuZGxlcnMgJiYgd2luZG93LmluZGV4ZWREQiAmJiAhbHRlOSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1VJV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzVUlXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBVSVdlYlZpZXcuWy9lbl1cbiAgICogICBbamFdVUlXZWJWaWV344Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVUlXZWJWaWV3KCkge1xuICAgIHJldHVybiAhISh0aGlzLmlzSU9TKCkgJiYgIXRoaXMuaXNJT1NTYWZhcmkoKSAmJiAhdGhpcy5pc1dLV2ViVmlldygpKTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbmRyb2lkIGRldmljZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQW5kcm9pZFBob25lXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkUGhvbmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCBwaG9uZS5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5pC65biv5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZFBob25lKCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL01vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRUYWJsZXRcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWRUYWJsZXQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCB0YWJsZXQuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOOCv+ODluODrOODg+ODiOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRUYWJsZXQoKSB7XG4gICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL01vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQW5kcm9pZCB2ZXJzaW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZCgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnYW5kcm9pZCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBPdGhlciBkZXZpY2VzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV1AoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ3dwJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL1dpbjMyTlR8V2luQ0UvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvV2luZG93cyBQaG9uZXxJRU1vYmlsZXxXUERlc2t0b3AvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQmxhY2tCZXJyeVxuICAgKiBAc2lnbmF0dXJlIGlzQmxhY2tCZXJyeSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBCbGFja0JlcnJ5LlsvZW5dXG4gICAqICAgW2phXUJsYWNrQmVycnnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNCbGFja0JlcnJ5KCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdibGFja2JlcnJ5JztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL0JsYWNrQmVycnkvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeXxSSU0gVGFibGV0IE9TfEJCMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBPdGhlciBicm93c2Vyc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVyYVxuICAgKiBAc2lnbmF0dXJlIGlzT3BlcmEoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIE9wZXJhLlsvZW5dXG4gICAqICAgW2phXU9wZXJh5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzT3BlcmEoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ29wZXJhJztcbiAgICB9XG5cbiAgICByZXR1cm4gKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRmlyZWZveFxuICAgKiBAc2lnbmF0dXJlIGlzRmlyZWZveCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRmlyZWZveC5bL2VuXVxuICAgKiAgIFtqYV1GaXJlZm945LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRmlyZWZveCgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnZmlyZWZveCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzU2FmYXJpXG4gICAqIEBzaWduYXR1cmUgaXNTYWZhcmkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIFNhZmFyaS5bL2VuXVxuICAgKiAgIFtqYV1TYWZhcmnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNTYWZhcmkoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ3NhZmFyaSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMCkgfHwgKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl0nIH0pKCF3aW5kb3dbJ3NhZmFyaSddIHx8IHNhZmFyaS5wdXNoTm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQ2hyb21lXG4gICAqIEBzaWduYXR1cmUgaXNDaHJvbWUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIENocm9tZS5bL2VuXVxuICAgKiAgIFtqYV1DaHJvbWXkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNDaHJvbWUoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2Nocm9tZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICghIXdpbmRvdy5jaHJvbWUgJiYgISghIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMCkgJiYgIShuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBFZGdlLycpID49IDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSUVcbiAgICogQHNpZ25hdHVyZSBpc0lFKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3Jlci5bL2VuXVxuICAgKiAgIFtqYV1JbnRlcm5ldCBFeHBsb3JlcuS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lFKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdpZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNFZGdlXG4gICAqIEBzaWduYXR1cmUgaXNFZGdlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBFZGdlLlsvZW5dXG4gICAqICAgW2phXUVkZ2XkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNFZGdlKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdlZGdlJztcbiAgICB9XG5cbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0TW9iaWxlT1MoKSB7XG4gICAgaWYgKHRoaXMuaXNBbmRyb2lkKCkpIHtcbiAgICAgIHJldHVybiAnYW5kcm9pZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJT1MoKSkge1xuICAgICAgcmV0dXJuICdpb3MnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzV1AoKSkge1xuICAgICAgcmV0dXJuICd3cCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldElPU0RldmljZSgpIHtcbiAgICBpZiAodGhpcy5pc0lQaG9uZSgpKSB7XG4gICAgICByZXR1cm4gJ2lwaG9uZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUGFkKCkpIHtcbiAgICAgIHJldHVybiAnaXBhZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUG9kKCkpIHtcbiAgICAgIHJldHVybiAnaXBvZCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICduYSc7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFBsYXRmb3JtKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5cbmNvbnN0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0ge1xuICBfdmFyaWFibGVzOiB7fSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSBWYWx1ZSBvZiB0aGUgdmFyaWFibGUuIENhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIGRlZmluZSBhIHZhcmlhYmxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlxuICAgKi9cbiAgZGVmaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWQuYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZ2V0VmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmFpYmxlLlxuICAgKi9cbiAgcmVtb3ZlVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QWxsVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xuICB9LFxuICBfcGFyc2VQYXJ0OiBmdW5jdGlvbihwYXJ0KSB7XG4gICAgbGV0IGMsXG4gICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcblxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IHBhcnQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gJyQnICYmIHBhcnQuY2hhckF0KGkgKyAxKSA9PT0gJ3snKSB7XG4gICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RlZCBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBpO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgIGlmICghaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd9IG11c3QgYmUgcHJlY2VlZGVkIGJ5ICR7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBpbnRlcnBvbGF0aW9uLicpO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgcGFydC5sZW5ndGgpKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH0sXG4gIF9yZXBsYWNlVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgY29uc3QgcmUgPSAvXlxcJHsoLio/KX0kLyxcbiAgICAgIG1hdGNoID0gdG9rZW4ubWF0Y2gocmUpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmdldFZhcmlhYmxlKG5hbWUpO1xuXG4gICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gdmFyaWFibGUoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCByZXR1cm4gYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VUb2tlbnM6IGZ1bmN0aW9uKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAoKHBhcnQpID0+IHBhcnQuam9pbignJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBBbiBwYWdlIGF0dHJpYnV0ZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGV2YWx1YXRlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGRlZmF1bHQgdmFyaWFibGVzLlxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnaU9TRGV2aWNlJywgcGxhdGZvcm0uZ2V0SU9TRGV2aWNlKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ3J1bnRpbWUnLCAoKSA9PiB7XG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcblxuY29uc3QgaW50ZXJuYWwgPSB7fTtcblxuaW50ZXJuYWwuY29uZmlnID0ge1xuICBhdXRvU3RhdHVzQmFyRmlsbDogdHJ1ZSxcbiAgYW5pbWF0aW9uc0Rpc2FibGVkOiBmYWxzZSxcbiAgd2FybmluZ3NEaXNhYmxlZDogZmFsc2Vcbn07XG5cbmludGVybmFsLm51bGxFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICByZXR1cm4gISFpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MID0gaHRtbCA9PiAoJycgKyBodG1sKS50cmltKCk7XG5cbmludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICBpZiAod2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgIH07XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkQ2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsID0gYWN0aW9uID0+IHtcbiAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHtcbiAgICBpZiAoaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhcigpKSB7XG4gICAgICBhY3Rpb24oKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBvblJlYWR5KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICB9IGVsc2UgaWYgKFsnY29tcGxldGUnLCAnaW50ZXJhY3RpdmUnXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID09PSAtMSkge1xuICAgIGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKG9uUmVhZHkpO1xuICB9IGVsc2Uge1xuICAgIG9uUmVhZHkoKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhciA9ICgpID0+IGludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsKCkgJiZcbiAgKHBsYXRmb3JtLmlzV2ViVmlldygpICYmIHBsYXRmb3JtLmlzSU9TN2Fib3ZlKCkgJiYgIXBsYXRmb3JtLmlzSVBob25lWCgpIHx8IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignLm9ucy1zdGF0dXMtYmFyLW1vY2suaW9zJykpO1xuXG5pbnRlcm5hbC50ZW1wbGF0ZVN0b3JlID0ge1xuICBfc3RvcmFnZToge30sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7U3RyaW5nL251bGx9IHRlbXBsYXRlXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICAgKi9cbiAgc2V0KGtleSwgdGVtcGxhdGUpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLl9zdG9yYWdlW2tleV0gPSB0ZW1wbGF0ZTtcbiAgfVxufTtcblxud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ190ZW1wbGF0ZWxvYWRlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGVtcGxhdGUnKSB7XG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5zZXQoZS50ZW1wbGF0ZUlkLCBlLnRlbXBsYXRlKTtcbiAgfVxufSwgZmFsc2UpO1xuXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZChmdW5jdGlvbigpIHtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9vbnMtdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC90ZW1wbGF0ZVwiXScpO1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCd0ZW1wbGF0ZScpO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHF1ZXJ5KSB7XG4gICAgY29uc3QgdGVtcGxhdGVzID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldCh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCB0ZW1wbGF0ZXNbaV0udGV4dENvbnRlbnQgfHwgdGVtcGxhdGVzW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKCgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlID0gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5nZXQocGFnZSk7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaWYgKGNhY2hlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGNhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGh0bWwgPSB0eXBlb2YgY2FjaGUgPT09ICdzdHJpbmcnID8gY2FjaGUgOiBjYWNoZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwoaHRtbCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbCA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYWdlKTtcbiAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICBjb25zdCBodG1sID0gbG9jYWwudGV4dENvbnRlbnQgfHwgbG9jYWwuY29udGVudDtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhZ2UsIHRydWUpO1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBodG1sID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgICByZWplY3QoaHRtbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVmcmVzaCBzY3JpcHQgdGFnc1xuICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdXRpbC5jcmVhdGVGcmFnbWVudChodG1sKTtcbiAgICAgICAgICB1dGlsLmFycmF5RnJvbShmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC50eXBlID0gZWwudHlwZSB8fCAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlbC50ZXh0IHx8IGVsLnRleHRDb250ZW50IHx8IGVsLmlubmVySFRNTCkpO1xuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoc2NyaXB0LCBlbCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChwYWdlLCBmcmFnbWVudCk7XG4gICAgICAgICAgcmVzb2x2ZShmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYWdlIGlzIG5vdCBmb3VuZDogJHtwYWdlfWApO1xuICAgICAgfTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMgPSBmdW5jdGlvbihwYWdlKSB7XG4gIGNvbnN0IHBhZ2VzID0gcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZXZhbHVhdGUocGFnZSk7XG5cbiAgY29uc3QgZ2V0UGFnZSA9IChwYWdlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdNdXN0IHNwZWNpZnkgYSBwYWdlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyhwYWdlKVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChwYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG4gICAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvckZhY3Rvcnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5hbmltYXRvcnMgVGhlIGRpY3Rpb25hcnkgZm9yIGFuaW1hdG9yIGNsYXNzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5iYXNlQ2xhc3MgVGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5iYXNlQ2xhc3NOYW1lXSBUaGUgbmFtZSBvZiB0aGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25dIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9uc10gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLl9hbmltYXRvcnMgPSBvcHRzLmFuaW1hdG9ycztcbiAgICB0aGlzLl9iYXNlQ2xhc3MgPSBvcHRzLmJhc2VDbGFzcztcbiAgICB0aGlzLl9iYXNlQ2xhc3NOYW1lID0gb3B0cy5iYXNlQ2xhc3NOYW1lIHx8IG9wdHMuYmFzZUNsYXNzLm5hbWU7XG4gICAgdGhpcy5fYW5pbWF0aW9uID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uIHx8ICdkZWZhdWx0JztcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBhbmltYXRpb246ICcgKyB0aGlzLl9hbmltYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3QvbnVsbH1cbiAgICovXG4gIHN0YXRpYyBwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcoanNvblN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGpzb25TdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdcImFuaW1hdGlvbi1vcHRpb25zXCIgYXR0cmlidXRlIG11c3QgYmUgYSBKU09OIG9iamVjdCBzdHJpbmc6ICcgKyBqc29uU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgc2V0QW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl0gVGhlIGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXSBUaGUgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRBbmltYXRvciBUaGUgZGVmYXVsdCBhbmltYXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFuaW1hdG9yIGluc3RhbmNlXG4gICAqL1xuICBuZXdBbmltYXRvcihvcHRpb25zID0ge30sIGRlZmF1bHRBbmltYXRvcikge1xuXG4gICAgbGV0IGFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiBpbnN0YW5jZW9mIHRoaXMuX2Jhc2VDbGFzcykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIH1cblxuICAgIGxldCBBbmltYXRvciA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgQW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvcnNbb3B0aW9ucy5hbmltYXRpb25dO1xuICAgIH1cblxuICAgIGlmICghQW5pbWF0b3IgJiYgZGVmYXVsdEFuaW1hdG9yKSB7XG4gICAgICBhbmltYXRvciA9IGRlZmF1bHRBbmltYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQW5pbWF0b3IgPSBBbmltYXRvciB8fCB0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID8ge2R1cmF0aW9uOiAwLCBkZWxheTogMH0gOiB7fVxuICAgICAgKTtcblxuICAgICAgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgYW5pbWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYW5pbWF0b3IgPSBuZXcgYW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKGFuaW1hdG9yIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImFuaW1hdG9yXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mICcgKyB0aGlzLl9iYXNlQ2xhc3NOYW1lICsgJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmxldCBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZTtcblxuLy8gTW9kaWZpZXJzXG5jb25zdCBtb2RpZmllcnNNYXAgPSB7XG4gICdxdWlldCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdsaWdodCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdvdXRsaW5lJzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2N0YSc6ICcnLFxuICAnbGFyZ2UtLXF1aWV0JzogJ21hdGVyaWFsLS1mbGF0IGxhcmdlJyxcbiAgJ2xhcmdlLS1jdGEnOiAnbGFyZ2UnLFxuICAnbm9ib3JkZXInOiAnJyxcbiAgJ3RhcHBhYmxlJzogJydcbn07XG5cbmNvbnN0IHBsYXRmb3JtcyA9IHt9O1xuXG5wbGF0Zm9ybXMuYW5kcm9pZCA9IGVsZW1lbnQgPT4ge1xuXG4gIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKCF1dGlsLmhhc01vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpKSB7XG4gICAgY29uc3Qgb2xkTW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcblxuICAgIGNvbnN0IG5ld01vZGlmaWVyID0gb2xkTW9kaWZpZXIudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGUgPT4gbW9kaWZpZXJzTWFwLmhhc093blByb3BlcnR5KGUpID8gbW9kaWZpZXJzTWFwW2VdIDogZSk7XG4gICAgbmV3TW9kaWZpZXIudW5zaGlmdCgnbWF0ZXJpYWwnKTtcblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVyLmpvaW4oJyAnKS50cmltKCkpO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudHMgPSBbXG4gICAgJ29ucy1hbGVydC1kaWFsb2ctYnV0dG9uJyxcbiAgICAnb25zLXRvb2xiYXItYnV0dG9uJyxcbiAgICAnb25zLWJhY2stYnV0dG9uJyxcbiAgICAnb25zLWJ1dHRvbicsXG4gICAgJ29ucy1saXN0LWl0ZW0nLFxuICAgICdvbnMtZmFiJyxcbiAgICAnb25zLXNwZWVkLWRpYWwnLFxuICAgICdvbnMtc3BlZWQtZGlhbC1pdGVtJyxcbiAgICAnb25zLXRhYidcbiAgXTtcblxuXG4gIC8vIEVmZmVjdHNcbiAgaWYgKGVsZW1lbnRzLmluZGV4T2YoZWxlbWVudE5hbWUpICE9PSAtMVxuICAgICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJylcbiAgICAmJiAhZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdvbnMtcmlwcGxlJykpIHtcblxuICAgIGlmIChlbGVtZW50TmFtZSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJyk7XG4gICAgfVxuICB9XG59O1xuXG5wbGF0Zm9ybXMuaW9zID0gZWxlbWVudCA9PiB7XG5cbiAvLyBNb2RpZmllcnNcbiBpZiAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwnKSkge1xuICAgaWYgKHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsLS1mbGF0JykpIHtcbiAgICAgdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbGFyZ2UnKSkgPyAnbGFyZ2UtLXF1aWV0JyA6ICdxdWlldCcpO1xuICAgfVxuXG4gICBpZiAoIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgfVxuIH1cblxuIC8vIEVmZmVjdHNcbiBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKSB7XG4gICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdC1pdGVtJykge1xuICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFwcGFibGUnLCAnJyk7XG4gICB9XG5cbiAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcbiB9XG59O1xuXG5jb25zdCB1bmxvY2tlZCA9IHtcbiAgYW5kcm9pZDogdHJ1ZVxufTtcblxuY29uc3QgZ2V0UGxhdGZvcm0gPSAoZWxlbWVudCwgZm9yY2UpID0+IHtcbiAgaWYgKGF1dG9TdHlsZUVuYWJsZWQgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlLWF1dG8tc3R5bGluZycpKSB7XG4gICAgY29uc3QgbW9iaWxlT1MgPSBvbnNQbGF0Zm9ybS5nZXRNb2JpbGVPUygpO1xuICAgIGlmIChwbGF0Zm9ybXMuaGFzT3duUHJvcGVydHkobW9iaWxlT1MpICYmICh1bmxvY2tlZC5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgfHwgZm9yY2UpKSB7XG4gICAgICByZXR1cm4gbW9iaWxlT1M7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgcHJlcGFyZSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBjb25zdCBwID0gZ2V0UGxhdGZvcm0oZWxlbWVudCwgZm9yY2UpO1xuICBwICYmIHBsYXRmb3Jtc1twXShlbGVtZW50KTtcbn07XG5cbmNvbnN0IG1hcE1vZGlmaWVyID0gKG1vZGlmaWVyLCBlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoZ2V0UGxhdGZvcm0oZWxlbWVudCwgZm9yY2UpKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLnNwbGl0KC9cXHMrLykubWFwKG0gPT4gbW9kaWZpZXJzTWFwLmhhc093blByb3BlcnR5KG0pID8gbW9kaWZpZXJzTWFwW21dIDogbSkuam9pbignICcpO1xuICB9XG4gIHJldHVybiBtb2RpZmllcjtcbn07XG5cbmNvbnN0IHJlc3RvcmVNb2RpZmllciA9IGVsZW1lbnQgPT4ge1xuICBpZiAoZ2V0UGxhdGZvcm0oZWxlbWVudCkgPT09ICdhbmRyb2lkJykge1xuICAgIGNvbnN0IG1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG4gICAgbGV0IG5ld01vZGlmaWVyID0gbWFwTW9kaWZpZXIobW9kaWZpZXIsIGVsZW1lbnQpO1xuXG4gICAgaWYgKCEvKF58XFxzKyltYXRlcmlhbCgkfFxccyspL2kudGVzdChtb2RpZmllcikpIHtcbiAgICAgIG5ld01vZGlmaWVyID0gJ21hdGVyaWFsICcgKyBuZXdNb2RpZmllcjtcbiAgICB9XG5cbiAgICBpZiAobmV3TW9kaWZpZXIgIT09IG1vZGlmaWVyKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllci50cmltKCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNFbmFibGVkOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkLFxuICBlbmFibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlLFxuICBkaXNhYmxlOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkID0gZmFsc2UsXG4gIHByZXBhcmUsXG4gIG1hcE1vZGlmaWVyLFxuICBnZXRQbGF0Zm9ybSxcbiAgcmVzdG9yZU1vZGlmaWVyXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL2F1dG9zdHlsZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGlmaWVyVXRpbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxuICAgKi9cbiAgc3RhdGljIGRpZmYobGFzdCwgY3VycmVudCkge1xuICAgIGxhc3QgPSBtYWtlRGljdCgoJycgKyBsYXN0KS50cmltKCkpO1xuICAgIGN1cnJlbnQgPSBtYWtlRGljdCgoJycgKyBjdXJyZW50KS50cmltKCkpO1xuXG4gICAgY29uc3QgcmVtb3ZlZCA9IE9iamVjdC5rZXlzKGxhc3QpLnJlZHVjZSgocmVzdWx0LCB0b2tlbikgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50W3Rva2VuXSkge1xuICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGFkZGVkID0gT2JqZWN0LmtleXMoY3VycmVudCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWxhc3RbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHthZGRlZCwgcmVtb3ZlZH07XG5cbiAgICBmdW5jdGlvbiBtYWtlRGljdChtb2RpZmllcikge1xuICAgICAgY29uc3QgZGljdCA9IHt9O1xuICAgICAgTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKS5mb3JFYWNoKHRva2VuID0+IGRpY3RbdG9rZW5dID0gdG9rZW4pO1xuICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYucmVtb3ZlZFxuICAgKiBAcGFyYW0ge0FycmF5fSBkaWZmLmFkZGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc0xpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgY2xhc3NMaXN0LCB0ZW1wbGF0ZSkge1xuICAgIGRpZmYuYWRkZWRcbiAgICAgIC5tYXAobW9kaWZpZXIgPT4gdGVtcGxhdGUucmVwbGFjZSgvXFwqL2csIG1vZGlmaWVyKSlcbiAgICAgIC5mb3JFYWNoKGtsYXNzID0+IGtsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChrID0+IGNsYXNzTGlzdC5hZGQoaykpKTtcblxuICAgIGRpZmYucmVtb3ZlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4ga2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGsgPT4gY2xhc3NMaXN0LnJlbW92ZShrKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYucmVtb3ZlZFxuICAgKiBAcGFyYW0ge0FycmF5fSBkaWZmLmFkZGVkXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGFwcGx5RGlmZlRvRWxlbWVudChkaWZmLCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBPYmplY3Qua2V5cyhzY2hlbWUpLmZvckVhY2goc2VsZWN0b3IgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHMgPSAhc2VsZWN0b3IgfHwgdXRpbC5tYXRjaChlbGVtZW50LCBzZWxlY3RvcilcbiAgICAgICAgPyBbZWxlbWVudF1cbiAgICAgICAgOiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoXG4gICAgICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9PiAhdXRpbC5maW5kUGFyZW50KHRhcmdldEVsZW1lbnQsIGVsZW1lbnQudGFnTmFtZSwgcGFyZW50ID0+IHBhcmVudCA9PT0gZWxlbWVudClcbiAgICAgICAgICApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCB0YXJnZXRFbGVtZW50c1tpXS5jbGFzc0xpc3QsIHNjaGVtZVtzZWxlY3Rvcl0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIG9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoTW9kaWZpZXJVdGlsLmRpZmYobGFzdCwgY3VycmVudCksIGVsZW1lbnQsIHNjaGVtZSk7XG4gICAgYXV0b1N0eWxlLnJlc3RvcmVNb2RpZmllcihlbGVtZW50KTtcbiAgfVxuXG4gIHN0YXRpYyByZWZyZXNoKGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoTW9kaWZpZXJVdGlsLmRpZmYoJycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnKSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBpbml0TW9kaWZpZXIoZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoe1xuICAgICAgcmVtb3ZlZDogW10sXG4gICAgICBhZGRlZDogTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKVxuICAgIH0sIGVsZW1lbnQsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgc3BsaXQobW9kaWZpZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllci50cmltKCkuc3BsaXQoLyArLykuZmlsdGVyKHRva2VuID0+IHRva2VuICE9PSAnJyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG1vZGlmaWVyIHRva2VuIHRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICBzdGF0aWMgYWRkTW9kaWZpZXIoZWxlbWVudCwgbW9kaWZpZXJUb2tlbikge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG1vZGlmaWVyVG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBNb2RpZmllclV0aWwuc3BsaXQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgaWYgKHRva2Vucy5pbmRleE9mKG1vZGlmaWVyVG9rZW4pID09IC0xKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKG1vZGlmaWVyVG9rZW4pO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCB0b2tlbnMuam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG1vZGlmaWVyIHRva2VuIGZyb20gYW4gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyByZW1vdmVNb2RpZmllcihlbGVtZW50LCBtb2RpZmllclRva2VuKSB7XG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBNb2RpZmllclV0aWwuc3BsaXQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgY29uc3QgaW5kZXggPSB0b2tlbnMuaW5kZXhPZihtb2RpZmllclRva2VuKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIHRva2Vucy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcblxuY29uc3QgdXRpbCA9IHtcbiAgX3JlYWR5OiBmYWxzZSxcblxuICBfZG9tQ29udGVudExvYWRlZDogZmFsc2UsXG5cbiAgX29uRE9NQ29udGVudExvYWRlZDogKCkgPT4ge1xuICAgIHV0aWwuX2RvbUNvbnRlbnRMb2FkZWQgPSB0cnVlO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzV2ViVmlldygpKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHV0aWwuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBhZGRCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbihmbikge1xuICAgIGlmICghdGhpcy5fZG9tQ29udGVudExvYWRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgRE9NQ29udGVudExvYWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB1dGlsLl9vbkRPTUNvbnRlbnRMb2FkZWQoKSwgZmFsc2UpO1xuXG5jb25zdCBIYW5kbGVyUmVwb3NpdG9yeSA9IHtcbiAgX3N0b3JlOiB7fSxcblxuICBfZ2VuSWQ6ICgoKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiAoKSA9PiBpKys7XG4gIH0pKCksXG5cbiAgc2V0OiBmdW5jdGlvbihlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCA9IEhhbmRsZXJSZXBvc2l0b3J5Ll9nZW5JZCgpO1xuICAgIHRoaXMuX3N0b3JlW2lkXSA9IGhhbmRsZXI7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWRdO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuICAgIH1cbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG5cbiAgICBpZiAoIXRoaXMuX3N0b3JlW2lkXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlW2lkXTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG5cbiAgICByZXR1cm4gISF0aGlzLl9zdG9yZVtpZF07XG4gIH1cbn07XG5cbmNsYXNzIERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRDYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gaGFuZGxlICdiYWNrYnV0dG9uJyBldmVudHMuXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHV0aWwuYWRkQmFja0J1dHRvbkxpc3RlbmVyKHRoaXMuX2JvdW5kQ2FsbGJhY2spO1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5yZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZSBhICdiYWNrYnV0dG9uJyBldmVudCBtYW51YWxseS5cbiAgICovXG4gIGZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2JhY2tidXR0b24nLCB0cnVlLCB0cnVlKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIF9jYWxsYmFjaygpIHtcbiAgICB0aGlzLl9kaXNwYXRjaERldmljZUJhY2tCdXR0b25FdmVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGNyZWF0ZUhhbmRsZXIoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudCcpO1xuICAgIH1cblxuICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgX2NhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgc2V0TGlzdGVuZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9LFxuXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5zZXQoZWxlbWVudCwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpID09PSB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFuZGxlci5lbmFibGUoKTtcblxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9XG5cbiAgX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCkge1xuICAgIGNvbnN0IHRyZWUgPSB0aGlzLl9jYXB0dXJlVHJlZSgpO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2ZpbmRIYW5kbGVyTGVhZkVsZW1lbnQodHJlZSk7XG5cbiAgICBsZXQgaGFuZGxlciA9IEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KTtcbiAgICBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChlbGVtZW50KSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgY2FsbFBhcmVudEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQocGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9jYXB0dXJlVHJlZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlVHJlZShkb2N1bWVudC5ib2R5KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRyZWUoZWxlbWVudCkge1xuICAgICAgY29uc3QgdHJlZSA9IHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgY2hpbGRyZW46IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5T2YoZWxlbWVudC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uKGNoaWxkRWxlbWVudCkge1xuXG4gICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgY2hpbGRFbGVtZW50Ll9pc1Nob3duID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMoY2hpbGRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRyZWUoY2hpbGRFbGVtZW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMocmVzdWx0LmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgICAgICB9KSlcbiAgICAgIH07XG5cbiAgICAgIGlmICghSGFuZGxlclJlcG9zaXRvcnkuaGFzKHRyZWUuZWxlbWVudCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICBpZiAoSGFuZGxlclJlcG9zaXRvcnkuaGFzKHN1YlRyZWUuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJUcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheU9mKHRhcmdldCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh0YXJnZXRbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKSB7XG4gICAgcmV0dXJuIGZpbmQodHJlZSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZpbmQobm9kZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5lbGVtZW50O1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlZnRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobGVmdCwgJycpLnpJbmRleCwgMTApO1xuICAgICAgICBjb25zdCByaWdodFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyaWdodCwgJycpLnpJbmRleCwgMTApO1xuXG4gICAgICAgIGlmICghaXNOYU4obGVmdFopICYmICFpc05hTihyaWdodFopKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnRaID4gcmlnaHRaID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXB0dXJpbmcgYmFja2J1dHRvbi1oYW5kbGVyIGlzIGZhaWx1cmUuJyk7XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4vZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuXG5pbnRlcm5hbC5BbmltYXRvckZhY3RvcnkgPSBBbmltYXRvckZhY3Rvcnk7XG5pbnRlcm5hbC5Nb2RpZmllclV0aWwgPSBNb2RpZmllclV0aWw7XG5pbnRlcm5hbC5kYmJEaXNwYXRjaGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN0YXJ0c1dpdGggPSAocywgYykgPT4gcy5zdWJzdHIoMCwgYy5sZW5ndGgpID09PSBjO1xuY29uc3QgZW5kc1dpdGggPSAocywgYykgPT4gcy5zdWJzdHIocy5sZW5ndGggLSBjLmxlbmd0aCwgYy5sZW5ndGgpID09PSBjO1xuY29uc3QgdW53cmFwID0gcyA9PiBzLnNsaWNlKDEsIC0xKTtcbmNvbnN0IGlzT2JqZWN0U3RyaW5nID0gcyA9PiBzdGFydHNXaXRoKHMsICd7JykgJiYgZW5kc1dpdGgocywgJ30nKTtcbmNvbnN0IGlzQXJyYXlTdHJpbmcgPSBzID0+IHN0YXJ0c1dpdGgocywgJ1snKSAmJiBlbmRzV2l0aChzLCAnXScpO1xuY29uc3QgaXNRdW90ZWRTdHJpbmcgPSBzID0+IChzdGFydHNXaXRoKHMsICdcXCcnKSAmJiBlbmRzV2l0aChzLCAnXFwnJykpIHx8IChzdGFydHNXaXRoKHMsICdcIicpICYmIGVuZHNXaXRoKHMsICdcIicpKTtcblxuY29uc3QgZXJyb3IgPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIFxcJycgKyB0b2tlbiArICdcXCcgYXQgcG9zaXRpb24gJyArIChvcmlnaW5hbFN0cmluZy5sZW5ndGggLSBzdHJpbmcubGVuZ3RoIC0gMSkgKyAnIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xufTtcblxuY29uc3QgcHJvY2Vzc1Rva2VuID0gKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSA9PiB7XG4gIGlmICh0b2tlbiA9PT0gJ3RydWUnIHx8IHRva2VuID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIHRva2VuID09PSAndHJ1ZSc7XG4gIH0gZWxzZSBpZiAoaXNRdW90ZWRTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHVud3JhcCh0b2tlbik7XG4gIH0gZWxzZSBpZiAoIWlzTmFOKHRva2VuKSkge1xuICAgIHJldHVybiArKHRva2VuKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHRva2VuKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheSh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cbn07XG5cbmNvbnN0IG5leHRUb2tlbiA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgbGV0IGxpbWl0ID0gc3RyaW5nLmxlbmd0aDtcblxuICBpZiAoc3RyaW5nWzBdID09PSAnOicgfHwgc3RyaW5nWzBdID09PSAnLCcpIHtcblxuICAgIGxpbWl0ID0gMTtcblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ3snIHx8IHN0cmluZ1swXSA9PT0gJ1snKSB7XG5cbiAgICBjb25zdCBjID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgbGV0IG5lc3RlZE9iamVjdCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYykge1xuICAgICAgICBuZXN0ZWRPYmplY3QrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMgKyAyKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdC0tO1xuICAgICAgICBpZiAobmVzdGVkT2JqZWN0ID09PSAwKSB7XG4gICAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ1xcJycgfHwgc3RyaW5nWzBdID09PSAnXCInKSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gc3RyaW5nWzBdKSB7XG4gICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChbJyAnLCAnLCcsICc6J10uaW5kZXhPZihzdHJpbmdbaV0pICE9PSAtMSkge1xuICAgICAgICBsaW1pdCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBsaW1pdCk7XG59O1xuXG5jb25zdCBwYXJzZU9iamVjdCA9IChzdHJpbmcpID0+IHtcbiAgY29uc3QgaXNWYWxpZEtleSA9IGtleSA9PiAvXltBLVpfJF1bQS1aMC05XyRdKiQvaS50ZXN0KGtleSk7XG5cbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuICBsZXQgcmVhZGluZ0tleSA9IHRydWUsIGtleSwgcHJldmlvdXNUb2tlbiwgdG9rZW47XG5cbiAgd2hpbGUoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltKCk7XG5cbiAgICBpZiAoKHRva2VuID09PSAnOicgJiYgKCFyZWFkaW5nS2V5IHx8ICFwcmV2aW91c1Rva2VuIHx8IHByZXZpb3VzVG9rZW4gPT09ICcsJykpXG4gICAgICAgfHwgKHRva2VuID09PSAnLCcgJiYgcmVhZGluZ0tleSlcbiAgICAgICB8fCAodG9rZW4gIT09ICc6JyAmJiB0b2tlbiAhPT0gJywnICYmIChwcmV2aW91c1Rva2VuICYmIHByZXZpb3VzVG9rZW4gIT09ICcsJyAmJiBwcmV2aW91c1Rva2VuICE9PSAnOicpKSkge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICc6JyAmJiByZWFkaW5nS2V5ICYmIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgIHByZXZpb3VzVG9rZW4gPSBpc1F1b3RlZFN0cmluZyhwcmV2aW91c1Rva2VuKSA/IHVud3JhcChwcmV2aW91c1Rva2VuKSA6IHByZXZpb3VzVG9rZW47XG4gICAgICBpZiAoaXNWYWxpZEtleShwcmV2aW91c1Rva2VuKSkge1xuICAgICAgICBrZXkgPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICByZWFkaW5nS2V5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHRva2VuIFxcJycgKyBwcmV2aW91c1Rva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAwIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJyAmJiAhcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgIHJlYWRpbmdLZXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5jb25zdCBwYXJzZUFycmF5ID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgbGV0IHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbSgpO1xuXG4gICAgaWYgKHRva2VuID09PSAnLCcgJiYgKCFwcmV2aW91c1Rva2VuIHx8IHByZXZpb3VzVG9rZW4gPT09ICcsJykpIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnLCcpIHtcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHByZXZpb3VzVG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gIT09ICcsJykge1xuICAgICAgYXJyYXkucHVzaChwcm9jZXNzVG9rZW4odG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbmNvbnN0IHBhcnNlID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuXG4gIGlmIChpc09iamVjdFN0cmluZyhzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHVud3JhcChzdHJpbmcpKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHN0cmluZykpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheSh1bndyYXAoc3RyaW5nKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBzdHJpbmcgbXVzdCBiZSBvYmplY3Qgb3IgYXJyYXkgbGlrZTogJyArIHN0cmluZyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHN0eWxlciBmcm9tICcuL3N0eWxlcic7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4vYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBhbmltYXRpb25PcHRpb25zUGFyc2UgZnJvbSAnLi9hbmltYXRpb24tb3B0aW9ucy1wYXJzZXInO1xuXG5jb25zdCB1dGlsID0ge307XG5cbnV0aWwuZ2xvYmFscyA9IHtcbiAgZmFiT2Zmc2V0OiAwXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG51dGlsLnByZXBhcmVRdWVyeSA9IChxdWVyeSkgPT4ge1xuICByZXR1cm4gcXVlcnkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHF1ZXJ5IDogKGVsZW1lbnQpID0+IHV0aWwubWF0Y2goZWxlbWVudCwgcXVlcnkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBzIENTUyBTZWxlY3Rvci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnV0aWwubWF0Y2ggPSAoZSwgcykgPT4gKGUubWF0Y2hlcyB8fCBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlLm1zTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGUsIHMpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7SFRNTEVsZW1lbnQvbnVsbH1cbiAqL1xudXRpbC5maW5kQ2hpbGQgPSAoZWxlbWVudCwgcXVlcnkpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgLy8gQ2F1dGlvbjogYGVsZW1lbnQuY2hpbGRyZW5gIGlzIGB1bmRlZmluZWRgIGluIHNvbWUgZW52aXJvbm1lbnRzIGlmIGBlbGVtZW50YCBpcyBgc3ZnYFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7IC8vIHByb2Nlc3Mgb25seSBlbGVtZW50IG5vZGVzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7SFRNTEVsZW1lbnQvbnVsbH1cbiAqL1xudXRpbC5maW5kUGFyZW50ID0gKGVsZW1lbnQsIHF1ZXJ5LCB1bnRpbCkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBkb2N1bWVudCB8fCBwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IHx8ICh1bnRpbCAmJiB1bnRpbChwYXJlbnQpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChtYXRjaChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNBdHRhY2hlZCA9IGVsZW1lbnQgPT4gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGVtZW50KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQgPSAoZWxlbWVudCkgPT4ge1xuICB3aGlsZSAoZWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKS5tYXRjaCgvKG9ucy1uYXZpZ2F0b3J8b25zLXRhYmJhcnxvbnMtbW9kYWwpLykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc1BhZ2VDb250cm9sID0gZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lLm1hdGNoKC9eb25zLShuYXZpZ2F0b3J8c3BsaXR0ZXJ8dGFiYmFyfHBhZ2UpJC9pKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdG8gcHJvcGFnYXRlXG4gKi9cbnV0aWwucHJvcGFnYXRlQWN0aW9uID0gKGVsZW1lbnQsIGFjdGlvbikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZFthY3Rpb25dIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNoaWxkW2FjdGlvbl0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24oY2hpbGQsIGFjdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBzdHJpbmcgdG8gYmUgY2FtZWxpemVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IENhbWVsaXplZCBzdHJpbmdcbiAqL1xudXRpbC5jYW1lbGl6ZSA9IHN0cmluZyA9PiBzdHJpbmcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFthLXpdKS9nLCAobSwgbCkgPT4gbC50b1VwcGVyQ2FzZSgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIGJlIGh5cGhlbmF0ZWRcbiAqIEByZXR1cm4ge1N0cmluZ30gSHlwaGVuYXRlZCBzdHJpbmdcbiAqL1xudXRpbC5oeXBoZW5hdGUgPSBzdHJpbmcgPT4gc3RyaW5nLnJlcGxhY2UoLyhbYS16QS1aXSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gdGFnIGFuZCBjbGFzcyBvbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGUgPSAoc2VsZWN0b3IgPSAnJywgc3R5bGUgPSB7fSkgPT4ge1xuICBjb25zdCBjbGFzc0xpc3QgPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjbGFzc0xpc3Quc2hpZnQoKSB8fCAnZGl2Jyk7XG5cbiAgaWYgKGNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XG4gIH1cblxuICBzdHlsZXIoZWxlbWVudCwgc3R5bGUpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGVFbGVtZW50ID0gKGh0bWwpID0+IHtcbiAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIGlmIChodG1sIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuaW1wb3J0Tm9kZShodG1sLCB0cnVlKSk7XG4gIH0gZWxzZSB7XG4gICAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sLnRyaW0oKTtcbiAgfVxuXG4gIGlmICh3cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaHRtbFwiIG11c3QgYmUgb25lIHdyYXBwZXIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnQgPSB3cmFwcGVyLmNoaWxkcmVuWzBdO1xuICB3cmFwcGVyLmNoaWxkcmVuWzBdLnJlbW92ZSgpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxGcmFnbWVudH1cbiAqL1xudXRpbC5jcmVhdGVGcmFnbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGUuY29udGVudCwgdHJ1ZSk7XG59O1xuXG4vKlxuICogQHBhcmFtIHtPYmplY3R9IGRzdCBEZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc3JjIFNvdXJjZSBvYmplY3QocykuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZWZlcmVuY2UgdG8gYGRzdGAuXG4gKi9cbnV0aWwuZXh0ZW5kID0gKGRzdCwgLi4uYXJncykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJnc1tpXSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZ3NbaV0pO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbal07XG4gICAgICAgIGRzdFtrZXldID0gYXJnc1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG51dGlsLmFycmF5RnJvbSA9IChhcnJheUxpa2UpID0+IHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheUxpa2UpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtmYWlsU2FmZV1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudXRpbC5wYXJzZUpTT05PYmplY3RTYWZlbHkgPSAoanNvblN0cmluZywgZmFpbFNhZmUgPSB7fSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoJycgKyBqc29uU3RyaW5nKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhaWxTYWZlO1xuICB9XG4gIHJldHVybiBmYWlsU2FmZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoIHN1Y2ggYXMgJ215QXBwLmNvbnRyb2xsZXJzLmRhdGEubG9hZERhdGEnXG4gKiBAcmV0dXJuIHtBbnl9IC0gd2hhdGV2ZXIgaXMgbG9jYXRlZCBhdCB0aGF0IHBhdGhcbiAqL1xudXRpbC5maW5kRnJvbVBhdGggPSAocGF0aCkgPT4ge1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgZWwgPSB3aW5kb3csIGtleTtcbiAgd2hpbGUgKGtleSA9IHBhdGguc2hpZnQoKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgZWwgPSBlbFtrZXldO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gUGFnZSBvciBwYWdlLWNvbnRhaW5lciB0aGF0IGltcGxlbWVudHMgJ3RvcFBhZ2UnXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSAtIFZpc2libGUgcGFnZSBlbGVtZW50IG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICovXG51dGlsLmdldFRvcFBhZ2UgPSBjb250YWluZXIgPT4gY29udGFpbmVyICYmIChjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXBhZ2UnID8gY29udGFpbmVyIDogY29udGFpbmVyLnRvcFBhZ2UpIHx8IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gRWxlbWVudCB3aGVyZSB0aGUgc2VhcmNoIGJlZ2luc1xuICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gLSBQYWdlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdmlzaWJsZSB0b29sYmFyIG9yIG51bGwuXG4gKi9cbnV0aWwuZmluZFRvb2xiYXJQYWdlID0gY29udGFpbmVyID0+IHtcbiAgY29uc3QgcGFnZSA9IHV0aWwuZ2V0VG9wUGFnZShjb250YWluZXIpO1xuXG4gIGlmIChwYWdlKSB7XG4gICAgaWYgKHBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCkpIHtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZS5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdXRpbC5nZXRUb3BQYWdlKHBhZ2UuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldKTtcbiAgICAgIGlmIChuZXh0UGFnZSAmJiAhL29ucy10YWJiYXIvaS50ZXN0KHBhZ2UuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZpbmRUb29sYmFyUGFnZShuZXh0UGFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxdXG4gKiBAcmV0dXJuIHtDdXN0b21FdmVudH1cbiAqL1xudXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50ID0gKHRhcmdldCwgZXZlbnROYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9KTtcblxuICBPYmplY3Qua2V5cyhkZXRhaWwpLmZvckVhY2goa2V5ID0+IHtcbiAgICBldmVudFtrZXldID0gZGV0YWlsW2tleV07XG4gIH0pO1xuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLmhhc01vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XG4gIGlmICghdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBSZWdFeHAoYChefFxcXFxzKykke21vZGlmaWVyTmFtZX0oJHxcXFxccyspYCwgJ2knKS50ZXN0KHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSBJZ25vcmVzIHBsYXRmb3JtIGxpbWl0YXRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBhZGRlZCBvciBub3QuXG4gKi9cbnV0aWwuYWRkTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAob3B0aW9ucy5hdXRvU3R5bGUpIHtcbiAgICBtb2RpZmllck5hbWUgPSBhdXRvU3R5bGUubWFwTW9kaWZpZXIobW9kaWZpZXJOYW1lLCB0YXJnZXQsIG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUpO1xuICB9XG5cbiAgaWYgKHV0aWwuaGFzTW9kaWZpZXIodGFyZ2V0LCBtb2RpZmllck5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAoKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJycpICsgJyAnICsgbW9kaWZpZXJOYW1lKS50cmltKCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF1dG9TdHlsZSBNYXBzIHRoZSBtb2RpZmllck5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGVkIG1vZGlmaWVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUgSWdub3JlcyBwbGF0Zm9ybSBsaW1pdGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgZm91bmQgb3Igbm90LlxuICovXG51dGlsLnJlbW92ZU1vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKG9wdGlvbnMuYXV0b1N0eWxlKSB7XG4gICAgbW9kaWZpZXJOYW1lID0gYXV0b1N0eWxlLm1hcE1vZGlmaWVyKG1vZGlmaWVyTmFtZSwgdGFyZ2V0LCBvcHRpb25zLmZvcmNlQXV0b1N0eWxlKTtcbiAgfVxuXG4gIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAhdXRpbC5oYXNNb2RpZmllcih0YXJnZXQsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBuZXdNb2RpZmllcnMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLykuZmlsdGVyKG0gPT4gbSAmJiBtICE9PSBtb2RpZmllck5hbWUpO1xuICBuZXdNb2RpZmllcnMubGVuZ3RoID8gdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKSA6IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZvcmNlIEZvcmNlcyBtb2RpZmllciB0byBiZSBhZGRlZCBvciByZW1vdmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUgSWdub3JlcyBwbGF0Zm9ybSBsaW1pdGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgZm91bmQgb3Igbm90LlxuICovXG51dGlsLnRvZ2dsZU1vZGlmaWVyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFyZ3MubGVuZ3RoID4gMiA/IGFyZ3NbMl0gOiB7fTtcbiAgY29uc3QgZm9yY2UgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMuZm9yY2U7XG5cbiAgY29uc3QgdG9nZ2xlID0gdHlwZW9mIGZvcmNlID09PSAnYm9vbGVhbicgPyBmb3JjZSA6ICF1dGlsLmhhc01vZGlmaWVyKC4uLmFyZ3MpO1xuICB0b2dnbGUgPyB1dGlsLmFkZE1vZGlmaWVyKC4uLmFyZ3MpIDogdXRpbC5yZW1vdmVNb2RpZmllciguLi5hcmdzKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdENsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gKi9cbnV0aWwucmVzdG9yZUNsYXNzID0gKGVsLCBkZWZhdWx0Q2xhc3MsIHNjaGVtZSkgPT4ge1xuICBkZWZhdWx0Q2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAhPT0gJycgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhjKSAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgZWwuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpICYmIE1vZGlmaWVyVXRpbC5yZWZyZXNoKGVsLCBzY2hlbWUpO1xufVxuXG4vLyBUT0RPOiBGSVhcbnV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSAoZWwpID0+IHtcbiAgaWYgKCFlbC5fcGFyZW50VXBkYXRlZCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLnBhcmVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgZWwuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICB9XG59O1xuXG51dGlsLnRvZ2dsZUF0dHJpYnV0ZSA9IChlbGVtZW50LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICBpZiAodmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/ICcnIDogdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59O1xuXG51dGlsLmJpbmRMaXN0ZW5lcnMgPSAoZWxlbWVudCwgbGlzdGVuZXJOYW1lcykgPT4ge1xuICBsaXN0ZW5lck5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29uc3QgYm91bmROYW1lID0gbmFtZS5yZXBsYWNlKC9eX1thLXpdLywgJ19ib3VuZCcgKyBuYW1lWzFdLnRvVXBwZXJDYXNlKCkpO1xuICAgIGVsZW1lbnRbYm91bmROYW1lXSA9IGVsZW1lbnRbYm91bmROYW1lXSB8fCBlbGVtZW50W25hbWVdLmJpbmQoZWxlbWVudCk7XG4gIH0pO1xufTtcblxudXRpbC5lYWNoID0gKG9iaiwgZikgPT4gT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiBmKGtleSwgb2JqW2tleV0pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1JpcHBsZVxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gKi9cbnV0aWwudXBkYXRlUmlwcGxlID0gKHRhcmdldCwgaGFzUmlwcGxlLCBhdHRycyA9IHt9KSA9PiB7XG4gIGlmIChoYXNSaXBwbGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGhhc1JpcHBsZSA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuICB9XG5cbiAgY29uc3QgcmlwcGxlRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRhcmdldCwgJ29ucy1yaXBwbGUnKTtcblxuICBpZiAoaGFzUmlwcGxlKSB7XG4gICAgaWYgKCFyaXBwbGVFbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXJpcHBsZScpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSkpO1xuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbGVtZW50LCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJpcHBsZUVsZW1lbnQpIHtcbiAgICByaXBwbGVFbGVtZW50LnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSA9IGFuaW1hdGlvbk9wdGlvbnNQYXJzZTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9IERlZmVycmVkIHByb21pc2UuXG4gKi9cbnV0aWwuZGVmZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGRlZmVycmVkID0ge307XG4gIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufTtcblxuLyoqXG4gKiBTaG93IHdhcm5pbmdzIHdoZW4gdGhleSBhcmUgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGFyZ3VtZW50cyB0byBjb25zb2xlLndhcm5cbiAqL1xudXRpbC53YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFpbnRlcm5hbC5jb25maWcud2FybmluZ3NEaXNhYmxlZCkge1xuICAgIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcmV2ZW50IHNjcm9sbGluZyB3aGlsZSBkcmFnaW5nIGhvcml6b250YWxseS5cbiAqXG4gKiBAcGFyYW0ge2dkfSBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqL1xudXRpbC5wcmV2ZW50U2Nyb2xsID0gZ2QgPT4ge1xuICBjb25zdCBwcmV2ZW50ID0gZSA9PiBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGNvbnN0IGNsZWFuID0gKGUpID0+IHtcbiAgICBnZC5vZmYoJ3RvdWNobW92ZScsIHByZXZlbnQpO1xuICAgIGdkLm9mZignZHJhZ2VuZCcsIGNsZWFuKTtcbiAgfTtcblxuICBnZC5vbigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gIGdkLm9uKCdkcmFnZW5kJywgY2xlYW4pO1xufTtcblxuLyoqXG4gKiBEaXN0YW5jZSBhbmQgZGVsdGFUaW1lIGZpbHRlciBzb21lIHdlaXJkIGRyYWdzdGFydCBldmVudHMgdGhhdCBhcmUgbm90IGZpcmVkIGltbWVkaWF0ZWx5LlxuICpcbiAqIEBwYXJhbSB7ZXZlbnR9XG4gKi9cbnV0aWwuaXNWYWxpZEdlc3R1cmUgPSBldmVudCA9PiBldmVudC5nZXN0dXJlICE9PSB1bmRlZmluZWQgJiYgKGV2ZW50Lmdlc3R1cmUuZGlzdGFuY2UgPD0gMTUgfHwgZXZlbnQuZ2VzdHVyZS5kZWx0YVRpbWUgPD0gMTAwKTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cblxuLyoqXG4gKiBNaW5pbWFsIGFuaW1hdGlvbiBsaWJyYXJ5IGZvciBtYW5hZ2luZyBjc3MgdHJhbnNpdGlvbiBvbiBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRJTUVPVVRfUkFUSU8gPSAxLjQ7XG5cbnZhciB1dGlsID0ge1xufTtcblxuLy8gY2FwaXRhbGl6ZSBzdHJpbmdcbnV0aWwuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnByb3BlcnR5XG4gKiBAcGFyYW0ge0Zsb2F0fSBwYXJhbXMuZHVyYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudGltaW5nXG4gKi9cbnV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcGFyYW1zLnByb3BlcnR5ID0gcGFyYW1zLnByb3BlcnR5IHx8ICdhbGwnO1xuICBwYXJhbXMuZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb24gfHwgMC40O1xuICBwYXJhbXMudGltaW5nID0gcGFyYW1zLnRpbWluZyB8fCAnbGluZWFyJztcblxuICB2YXIgcHJvcHMgPSBwYXJhbXMucHJvcGVydHkuc3BsaXQoLyArLyk7XG5cbiAgcmV0dXJuIHByb3BzLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgKyAnICcgKyBwYXJhbXMuZHVyYXRpb24gKyAncyAnICsgcGFyYW1zLnRpbWluZztcbiAgfSkuam9pbignLCAnKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGhhbmRsZXIgb24gXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQuXG4gKi9cbnV0aWwub25jZU9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgdmFyIGZuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBldmVudC50YXJnZXQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICB9KTtcblxuICByZXR1cm4gcmVtb3ZlTGlzdGVuZXJzO1xufTtcblxudXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cyA9IChmdW5jdGlvbigpIHtcblxuICBpZiAoJ29udHJhbnNpdGlvbmVuZCcgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuIFsndHJhbnNpdGlvbmVuZCddO1xuICB9XG5cbiAgaWYgKCdvbndlYmtpdHRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgIHJldHVybiBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnXTtcbiAgfVxuXG4gIGlmICh1dGlsLnZlbmRvclByZWZpeCA9PT0gJ3dlYmtpdCcgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdvJyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21veicgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtcycpIHtcbiAgICByZXR1cm4gW3V0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufSkoKTtcblxudXRpbC5fY3NzUHJvcGVydHlEaWN0ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gIHZhciBkaWN0ID0ge307XG4gIHZhciBhID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG4gIHZhciB6ID0gJ3onLmNoYXJDb2RlQXQoMCk7XG5cbiAgdmFyIHVwcGVyID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnN1YnN0cigxKS50b1VwcGVyQ2FzZSgpO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICB2YXIga2V5ID0gc3R5bGVzW2ldXG4gICAgLnJlcGxhY2UoL15bLV0rLywgJycpXG4gICAgLnJlcGxhY2UoL1stXVthLXpdL2csIHVwcGVyKVxuICAgIC5yZXBsYWNlKC9ebW96LywgJ01veicpO1xuXG4gICAgaWYgKGEgPD0ga2V5LmNoYXJDb2RlQXQoMCkgJiYgeiA+PSBrZXkuY2hhckNvZGVBdCgwKSkge1xuICAgICAgaWYgKGtleSAhPT0gJ2Nzc1RleHQnICYmIGtleSAhPT0gJ3BhcmVudFRleHQnKSB7XG4gICAgICAgIGRpY3Rba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpY3Q7XG59KSgpO1xuXG51dGlsLmhhc0Nzc1Byb3BlcnR5ID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gbmFtZSBpbiB1dGlsLl9jc3NQcm9wZXJ0eURpY3Q7XG59O1xuXG4vKipcbiAqIFZlbmRvciBwcmVmaXggZm9yIGNzcyBwcm9wZXJ0eS5cbiAqL1xudXRpbC52ZW5kb3JQcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKSxcbiAgICBwcmUgPSAoQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAuY2FsbChzdHlsZXMpXG4gICAgICAuam9pbignJylcbiAgICAgIC5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKSB8fCAoc3R5bGVzLk9MaW5rID09PSAnJyAmJiBbJycsICdvJ10pXG4gICAgKVsxXTtcbiAgICByZXR1cm4gcHJlO1xufSkoKTtcblxudXRpbC5mb3JjZUxheW91dEF0T25jZSA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuICB0aGlzLmJhdGNoSW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgLy8gZm9yY2UgbGF5b3V0XG4gICAgICBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB9KTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbn07XG5cbnV0aWwuYmF0Y2hJbW1lZGlhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcblxuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgY29uY3JlYXRlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcbn0pKCk7XG5cbnV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuXG4gIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmFmKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgY29uY3JlYXRlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcbn0pKCk7XG5cbnV0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkoJ3RyYW5zaXRpb25EdXJhdGlvbicpKSB7XG4gICAgcmV0dXJuICd0cmFuc2l0aW9uJztcbiAgfVxuXG4gIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KHV0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb25EdXJhdGlvbicpKSB7XG4gICAgcmV0dXJuIHV0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb24nO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG59KSgpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICovXG52YXIgQW5pbWl0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQW5pbWl0KSkge1xuICAgIHJldHVybiBuZXcgQW5pbWl0KGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBbZWxlbWVudF07XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnQ7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb3IgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQuJyk7XG4gIH1cblxuICB0aGlzLnRyYW5zaXRpb25RdWV1ZSA9IFtdO1xuICB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3QgPSBbXTtcbn07XG5cbkFuaW1pdC5wcm90b3R5cGUgPSB7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXl9XG4gICAqL1xuICB0cmFuc2l0aW9uUXVldWU6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICovXG4gIGVsZW1lbnRzOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGFuaW1hdGlvbiBzZXF1ZW5jZSB3aXRoIHBhc3NlZCBhbmltYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcGxheTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydEFuaW1hdGlvbigpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucyBvciBvdGhlciBmdW5jdGlvbi5cbiAgICpcbiAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y29sb3I6ICdyZWQnfSlcbiAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y29sb3I6ICdyZWQnfSwge2R1cmF0aW9uOiAwLjR9KVxuICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjc3M6IHtjb2xvcjogJ3JlZCd9LCBkdXJhdGlvbjogMC4yfSlcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8QW5pbWl0LlRyYW5zaXRpb258RnVuY3Rpb259IHRyYW5zaXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgcXVldWU6IGZ1bmN0aW9uKHRyYW5zaXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnRyYW5zaXRpb25RdWV1ZTtcblxuICAgIGlmICh0cmFuc2l0aW9uICYmIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMuY3NzID0gdHJhbnNpdGlvbjtcbiAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24ob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBbmltaXQuVHJhbnNpdGlvbikpIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uLmNzcykge1xuICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbih7XG4gICAgICAgICAgY3NzOiB0cmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHF1ZXVlLnB1c2godHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQW5pbWl0LlRyYW5zaXRpb24pIHtcbiAgICAgIHF1ZXVlLnB1c2godHJhbnNpdGlvbi5idWlsZCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBRdWV1ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RmxvYXR9IHNlY29uZHNcbiAgICovXG4gIHdhaXQ6IGZ1bmN0aW9uKHNlY29uZHMpIHtcbiAgICBpZiAoc2Vjb25kcyA+IDApIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgKiBzZWNvbmRzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNhdmVTdHlsZTogZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgY3NzID0gdGhpcy5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9IGVsZW1lbnQuc3R5bGVbZWxlbWVudC5zdHlsZVtpXV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICBkb25lKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIGVsZW1lbnQncyBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpbWluZ11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRyYW5zaXRpb25dXG4gICAqL1xuICByZXN0b3JlU3R5bGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uICYmICFvcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3B0aW9ucy5kdXJhdGlvblwiIGlzIHJlcXVpcmVkIHdoZW4gXCJvcHRpb25zLnRyYW5zaXRpb25cIiBpcyBlbmFibGVkLicpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHV0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZTtcblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gfHwgKG9wdGlvbnMuZHVyYXRpb24gJiYgb3B0aW9ucy5kdXJhdGlvbiA+IDApKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvblZhbHVlID0gb3B0aW9ucy50cmFuc2l0aW9uIHx8ICgnYWxsICcgKyBvcHRpb25zLmR1cmF0aW9uICsgJ3MgJyArIChvcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJykpO1xuXG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICB2YXIgY2xlYXJUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICcnO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBcInRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyXG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgIGNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZm9yIGZhaWwgc2FmZS5cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sIG9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTyk7XG5cbiAgICAgICAgLy8gdHJhbnNpdGlvbiBhbmQgc3R5bGUgc2V0dGluZ3NcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXG4gICAgICAgICAgdmFyIGNzcyA9IHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF07XG5cbiAgICAgICAgICBpZiAoIWNzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXN0b3JlU3R5bGUoKTogVGhlIHN0eWxlIGlzIG5vdCBzYXZlZC4gSW52b2tlIHNhdmVTdHlsZSgpIGJlZm9yZS4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAgICAgaWYgKGNzc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNzc1tuYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdHJhbnNpdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gY3NzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAvLyBDbGVhciB0cmFuc2l0aW9uIGFuaW1hdGlvbiBzZXR0aW5ncy5cbiAgICAgIHNlbGYuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICdub25lJztcblxuICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICBpZiAoIWNzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzdG9yZVN0eWxlKCk6IFRoZSBzdHlsZSBpcyBub3Qgc2F2ZWQuIEludm9rZSBzYXZlU3R5bGUoKSBiZWZvcmUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuYW1lID0gJyc7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gY3NzW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGFuaW1hdGlvbiBzZXF1ZW5jZS5cbiAgICovXG4gIHN0YXJ0QW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2RlcXVldWVUcmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnQgdHJhbnNpdGlvbiBleGlzdHMuJyk7XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHNlbGYuX2N1cnJlbnRUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxmLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlOiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB0d2ljZS4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb24uY2FsbCh0aGlzLCBkb25lKTtcbiAgICB9XG4gIH1cblxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FuaW1pdH0gYXJndW1lbnRzXG4gKi9cbkFuaW1pdC5ydW5BbGwgPSBmdW5jdGlvbigvKiBhcmd1bWVudHMuLi4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBhcmd1bWVudHNbaV0ucGxheSgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3BlcnR5XVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpbWluZ11cbiAqL1xuQW5pbWl0LlRyYW5zaXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5kdXJhdGlvbiB8fCAwO1xuICB0aGlzLm9wdGlvbnMudGltaW5nID0gdGhpcy5vcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJztcbiAgdGhpcy5vcHRpb25zLmNzcyA9IHRoaXMub3B0aW9ucy5jc3MgfHwge307XG4gIHRoaXMub3B0aW9ucy5wcm9wZXJ0eSA9IHRoaXMub3B0aW9ucy5wcm9wZXJ0eSB8fCAnYWxsJztcbn07XG5cbkFuaW1pdC5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIGJ1aWxkOiBmdW5jdGlvbigpIHtcblxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuY3NzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5jc3MgaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNzcyA9IGNyZWF0ZUFjdHVhbENzc1Byb3BzKHRoaXMub3B0aW9ucy5jc3MpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA+IDApIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSB1dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlKHRoaXMub3B0aW9ucyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdGltZW91dCA9IHNlbGYub3B0aW9ucy5kdXJhdGlvbiAqIDEwMDAgKiBUSU1FT1VUX1JBVElPO1xuICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gPD0gMCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWVdID0gJyc7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtuYW1lXSA9IGNzc1tuYW1lXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlKGVsZW1lbnRzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBY3R1YWxDc3NQcm9wcyhjc3MpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gY3NzW25hbWVdO1xuXG4gICAgICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWZpeGVkID0gdXRpbC52ZW5kb3JQcmVmaXggKyB1dGlsLmNhcGl0YWxpemUobmFtZSk7XG4gICAgICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KHByZWZpeGVkKSkge1xuICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbcHJlZml4ZWRdID0gdmFsdWU7XG4gICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAgQW5pbWl0O1xuXG4iLCIvKlxuICogR2VzdHVyZSBkZXRlY3RvciBsaWJyYXJ5IHRoYXQgZm9ya2VkIGZyb20gZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudCwgVXRpbHMsIERldGVjdGlvbiwgUG9pbnRlckV2ZW50O1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLkdlc3R1cmVEZXRlY3RvclxuICogQGNhdGVnb3J5IGdlc3R1cmVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVXRpbGl0eSBjbGFzcyBmb3IgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+OCr+ODqeOCueOBp+OBmeOAglsvamFdXG4gKi9cblxuLyoqXG4gKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gKiBAc2lnbmF0dXJlIGNvbnN0cnVjdG9yKGVsZW1lbnRbLCBvcHRpb25zXSlcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1DcmVhdGUgYSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlLlsvZW5dXG4gKiAgW2phXUdlc3R1cmVEZXRlY3RvcuOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgotET03opoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dT3B0aW9ucyBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcmV0dXJuIHtvbnMuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICovXG52YXIgR2VzdHVyZURldGVjdG9yID0gZnVuY3Rpb24gR2VzdHVyZURldGVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5ncy5cbiAqIG1vcmUgc2V0dGluZ3MgYXJlIGRlZmluZWQgcGVyIGdlc3R1cmUgYXQgYC9nZXN0dXJlc2AuIEVhY2ggZ2VzdHVyZSBjYW4gYmUgZGlzYWJsZWQvZW5hYmxlZFxuICogYnkgc2V0dGluZyBpdCdzIG5hbWUgKGxpa2UgYHN3aXBlYCkgdG8gZmFsc2UuXG4gKiBZb3UgY2FuIHNldCB0aGUgZGVmYXVsdHMgZm9yIGFsbCBpbnN0YW5jZXMgYnkgY2hhbmdpbmcgdGhpcyBvYmplY3QgYmVmb3JlIGNyZWF0aW5nIGFuIGluc3RhbmNlLlxuICogQGV4YW1wbGVcbiAqIGBgYGBcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuZHJhZyA9IGZhbHNlO1xuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci50b3VjaEFjdGlvbiA9ICdwYW4teSc7XG4gKiAgZGVsZXRlIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci51c2VyU2VsZWN0O1xuICogYGBgYFxuICogQHByb3BlcnR5IGRlZmF1bHRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMgPSB7XG4gIGJlaGF2aW9yOiB7XG4gICAgLy8gdXNlclNlbGVjdDogJ25vbmUnLCAvLyBBbHNvIGRpc2FibGVzIHNlbGVjdGlvbiBpbiBgaW5wdXRgIGNoaWxkcmVuXG4gICAgdG91Y2hBY3Rpb246ICdwYW4teScsXG4gICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG4gICAgY29udGVudFpvb21pbmc6ICdub25lJyxcbiAgICB1c2VyRHJhZzogJ25vbmUnLFxuICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgfVxufTtcblxuLyoqXG4gKiBHZXN0dXJlRGV0ZWN0b3IgZG9jdW1lbnQgd2hlcmUgdGhlIGJhc2UgZXZlbnRzIGFyZSBhZGRlZCBhdFxuICogQHByb3BlcnR5IERPQ1VNRU5UXG4gKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gKiBAZGVmYXVsdCB3aW5kb3cuZG9jdW1lbnRcbiAqL1xuR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5UID0gZG9jdW1lbnQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHBvaW50ZXIgZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1BPSU5URVJFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMgPSBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHRvdWNoIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19UT1VDSEVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcblxuLyoqXG4gKiBkZXRlY3QgbW9iaWxlIGJyb3dzZXJzXG4gKiBAcHJvcGVydHkgSVNfTU9CSUxFXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLklTX01PQklMRSA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogZGV0ZWN0IGlmIHdlIHdhbnQgdG8gc3VwcG9ydCBtb3VzZWV2ZW50cyBhdCBhbGxcbiAqIEBwcm9wZXJ0eSBOT19NT1VTRUVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUyA9IChHZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTICYmIEdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUpIHx8IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUztcblxuLyoqXG4gKiBpbnRlcnZhbCBpbiB3aGljaCBHZXN0dXJlRGV0ZWN0b3IgcmVjYWxjdWxhdGVzIGN1cnJlbnQgdmVsb2NpdHkvZGlyZWN0aW9uL2FuZ2xlIGluIG1zXG4gKiBAcHJvcGVydHkgQ0FMQ1VMQVRFX0lOVEVSVkFMXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgMjVcbiAqL1xuR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCA9IDI1O1xuXG4vKipcbiAqIGV2ZW50dHlwZXMgcGVyIHRvdWNoZXZlbnQgKHN0YXJ0LCBtb3ZlLCBlbmQpIGFyZSBmaWxsZWQgYnkgYEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXNgIG9uIGBzZXR1cGBcbiAqIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIERPTSBldmVudCBuYW1lcyBwZXIgdHlwZSAoYEVWRU5UX1NUQVJUYCwgYEVWRU5UX01PVkVgLCBgRVZFTlRfRU5EYClcbiAqIEBwcm9wZXJ0eSBFVkVOVF9UWVBFU1xuICogQHByaXZhdGVcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBFVkVOVF9UWVBFUyA9IHt9O1xuXG4vKipcbiAqIGRpcmVjdGlvbiBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IERJUkVDVElPTl9ET1dOfExFRlR8VVB8UklHSFRcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdkb3duJyAnbGVmdCcgJ3VwJyAncmlnaHQnXG4gKi9cbnZhciBESVJFQ1RJT05fRE9XTiA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fRE9XTiA9ICdkb3duJztcbnZhciBESVJFQ1RJT05fTEVGVCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbnZhciBESVJFQ1RJT05fVVAgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1VQID0gJ3VwJztcbnZhciBESVJFQ1RJT05fUklHSFQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcblxuLyoqXG4gKiBwb2ludGVydHlwZSBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnbW91c2UnICd0b3VjaCcgJ3BlbidcbiAqL1xudmFyIFBPSU5URVJfTU9VU0UgPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9NT1VTRSA9ICdtb3VzZSc7XG52YXIgUE9JTlRFUl9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1RPVUNIID0gJ3RvdWNoJztcbnZhciBQT0lOVEVSX1BFTiA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1BFTiA9ICdwZW4nO1xuXG4vKipcbiAqIGV2ZW50dHlwZXNcbiAqIEBwcm9wZXJ0eSBFVkVOVF9TVEFSVHxNT1ZFfEVORHxSRUxFQVNFfFRPVUNIXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnc3RhcnQnICdjaGFuZ2UnICdtb3ZlJyAnZW5kJyAncmVsZWFzZScgJ3RvdWNoJ1xuICovXG52YXIgRVZFTlRfU1RBUlQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfU1RBUlQgPSAnc3RhcnQnO1xudmFyIEVWRU5UX01PVkUgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfTU9WRSA9ICdtb3ZlJztcbnZhciBFVkVOVF9FTkQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfRU5EID0gJ2VuZCc7XG52YXIgRVZFTlRfUkVMRUFTRSA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9SRUxFQVNFID0gJ3JlbGVhc2UnO1xudmFyIEVWRU5UX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1RPVUNIID0gJ3RvdWNoJztcblxuLyoqXG4gKiBpZiB0aGUgd2luZG93IGV2ZW50cyBhcmUgc2V0Li4uXG4gKiBAcHJvcGVydHkgUkVBRFlcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGRlZmF1bHQgZmFsc2VcbiAqL1xuR2VzdHVyZURldGVjdG9yLlJFQURZID0gZmFsc2U7XG5cbi8qKlxuICogcGx1Z2lucyBuYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSBwbHVnaW5zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyA9IEdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zIHx8IHt9O1xuXG4vKipcbiAqIGdlc3R1cmVzIG5hbWVzcGFjZVxuICogc2VlIGAvZ2VzdHVyZXNgIGZvciB0aGUgZGVmaW5pdGlvbnNcbiAqIEBwcm9wZXJ0eSBnZXN0dXJlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzID0gR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIHx8IHt9O1xuXG4vKipcbiAqIHNldHVwIGV2ZW50cyB0byBkZXRlY3QgZ2VzdHVyZXMgb24gdGhlIGRvY3VtZW50XG4gKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGFuIG5ldyBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gIGlmKEdlc3R1cmVEZXRlY3Rvci5SRUFEWSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGZpbmQgd2hhdCBldmVudHR5cGVzIHdlIGFkZCBsaXN0ZW5lcnMgdG9cbiAgRXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlcygpO1xuXG4gIC8vIFJlZ2lzdGVyIGFsbCBnZXN0dXJlcyBpbnNpZGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXG4gIFV0aWxzLmVhY2goR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLCBmdW5jdGlvbihnZXN0dXJlKSB7XG4gICAgRGV0ZWN0aW9uLnJlZ2lzdGVyKGdlc3R1cmUpO1xuICB9KTtcblxuICAvLyBBZGQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudFxuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfTU9WRSwgRGV0ZWN0aW9uLmRldGVjdCk7XG4gIEV2ZW50Lm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9FTkQsIERldGVjdGlvbi5kZXRlY3QpO1xuXG4gIC8vIEdlc3R1cmVEZXRlY3RvciBpcyByZWFkeS4uLiFcbiAgR2VzdHVyZURldGVjdG9yLlJFQURZID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBVdGlsc1xuICogQHN0YXRpY1xuICovXG5VdGlscyA9IEdlc3R1cmVEZXRlY3Rvci51dGlscyA9IHtcbiAgLyoqXG4gICAqIGV4dGVuZCBtZXRob2QsIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgY2xvbmluZyB3aGVuIGBkZXN0YCBpcyBhbiBlbXB0eSBvYmplY3QuXG4gICAqIGNoYW5nZXMgdGhlIGRlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdICBkbyBhIG1lcmdlXG4gICAqIEByZXR1cm4ge09iamVjdH0gZGVzdFxuICAgKi9cbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZGVzdFtrZXldID09PSB1bmRlZmluZWQgfHwgIW1lcmdlKSkge1xuICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBhZGRFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSByZW1vdmVFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogZm9yRWFjaCBvdmVyIGFycmF5cyBhbmQgb2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7YW55fSBpdGVyYXRvci5pdGVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvci5pbmRleFxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gaXRlcmF0b3Iub2JqIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IHZhbHVlIHRvIHVzZSBhcyBgdGhpc2AgaW4gdGhlIGl0ZXJhdG9yXG4gICAqL1xuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgLy8gbmF0aXZlIGZvckVhY2ggb24gYXJyYXlzXG4gICAgaWYoJ2ZvckVhY2gnIGluIG9iaikge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgLy8gYXJyYXlzXG4gICAgfSBlbHNlIGlmKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yKGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBvYmplY3RzXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcihpIGluIG9iaikge1xuICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkgJiZcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBzdHJpbmcgY29udGFpbnMgdGhlIHN0cmluZyB1c2luZyBpbmRleE9mXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGluU3RyOiBmdW5jdGlvbiBpblN0cihzcmMsIGZpbmQpIHtcbiAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCkgPiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5ZmlsbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuICBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZGVlcCkge1xuICAgIGlmIChkZWVwKSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgLy8gQXJyYXkuZmluZEluZGV4XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhmaW5kKS5ldmVyeShmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHNyY1tpXVtrZXldID09PSBmaW5kW2tleV07IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZihzcmMuaW5kZXhPZikge1xuICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYoc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlKG5vZGUpIHtcbiAgICAgIGlmKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgcGFnZVhgLCBgcGFnZVlgLCBgY2xpZW50WGAgYW5kIGBjbGllbnRZYCBwcm9wZXJ0aWVzXG4gICAqL1xuICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgdmFyIHBhZ2VYID0gW10sXG4gICAgICAgIHBhZ2VZID0gW10sXG4gICAgICAgIGNsaWVudFggPSBbXSxcbiAgICAgICAgY2xpZW50WSA9IFtdLFxuICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlWDogdG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgIGNsaWVudFg6IHRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogdG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cblxuICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHBhZ2VYLnB1c2godG91Y2gucGFnZVgpO1xuICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XG4gICAgICBjbGllbnRYLnB1c2godG91Y2guY2xpZW50WCk7XG4gICAgICBjbGllbnRZLnB1c2godG91Y2guY2xpZW50WSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVg6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVgpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VYKSkgLyAyLFxuICAgICAgcGFnZVk6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVkpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VZKSkgLyAyLFxuICAgICAgY2xpZW50WDogKG1pbi5hcHBseShNYXRoLCBjbGllbnRYKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRYKSkgLyAyLFxuICAgICAgY2xpZW50WTogKG1pbi5hcHBseShNYXRoLCBjbGllbnRZKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRZKSkgLyAyXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBnZXRWZWxvY2l0eTogZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmFicyhkZWx0YVggLyBkZWx0YVRpbWUpIHx8IDAsXG4gICAgICB5OiBNYXRoLmFicyhkZWx0YVkgLyBkZWx0YVRpbWUpIHx8IDBcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfSxcblxuICAvKipcbiAgICogZG8gYSBzbWFsbCBjb21wYXJpc29uIHRvIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHRvdWNoZXMuXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX0xFRlR8UklHSFR8VVB8RE9XTmBcbiAgICovXG4gIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYKSxcbiAgICAgICAgeSA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkpO1xuXG4gICAgaWYoeCA+PSB5KSB7XG4gICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdG91Y2hlc1xuICAgKiBAcGFyYW0ge1RvdWNofXRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cbiAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uIGdldERpc3RhbmNlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAgICovXG4gIGdldFNjYWxlOiBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vycy4uLlxuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0pIC8gdGhpcy5nZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX1VQfERPV05gXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzX3ZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzZXRQcmVmaXhlZENzczogZnVuY3Rpb24gc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSkge1xuICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgIHByb3AgPSBVdGlscy50b0NhbWVsQ2FzZShwcm9wKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwcm9wO1xuICAgICAgLy8gcHJlZml4ZXNcbiAgICAgIGlmKHByZWZpeGVzW2ldKSB7XG4gICAgICAgIHAgPSBwcmVmaXhlc1tpXSArIHAuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHAuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3QgdGhlIHN0eWxlXG4gICAgICBpZihwIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT09IG51bGwgfHwgdG9nZ2xlKSAmJiB2YWx1ZSB8fCAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXG4gICAqIGB1c2VyU2VsZWN0PSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uc2VsZWN0c3RhcnRgIHRvIGZhbHNlXG4gICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqL1xuICB0b2dnbGVCZWhhdmlvcjogZnVuY3Rpb24gdG9nZ2xlQmVoYXZpb3IoZWxlbWVudCwgcHJvcHMsIHRvZ2dsZSkge1xuICAgIGlmKCFwcm9wcyB8fCAhZWxlbWVudCB8fCAhZWxlbWVudC5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgY3NzIHByb3BlcnRpZXNcbiAgICBVdGlscy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgVXRpbHMuc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZmFsc2VGbiA9IHRvZ2dsZSAmJiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgaWYocHJvcHMudXNlclNlbGVjdCA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgaWYocHJvcHMudXNlckRyYWcgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uZHJhZ3N0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYSBzdHJpbmcgd2l0aCB1bmRlcnNjb3JlcyB0byBjYW1lbENhc2VcbiAgICogc28gcHJldmVudF9kZWZhdWx0IGJlY29tZXMgcHJldmVudERlZmF1bHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsQ2FzZVN0clxuICAgKi9cbiAgdG9DYW1lbENhc2U6IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW18tXShbYS16XSkvZywgZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKi9cbi8qKlxuICogQGNsYXNzIEV2ZW50XG4gKiBAc3RhdGljXG4gKi9cbkV2ZW50ID0gR2VzdHVyZURldGVjdG9yLmV2ZW50ID0ge1xuICAvKipcbiAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3AgbW91c2UgZXZlbnRzXG4gICAqIEBwcm9wZXJ0eSBwcmV2ZW50X21vdXNlZXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAvKipcbiAgICogaWYgRVZFTlRfU1RBUlQgaGFzIGJlZW4gZmlyZWRcbiAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdGFydGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICogQHByb3BlcnR5IHNob3VsZF9kZXRlY3RcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGREZXRlY3Q6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRoZSBjb3JlIHRvdWNoIGV2ZW50IGhhbmRsZXIuXG4gICAqIHRoaXMgZmluZHMgb3V0IGlmIHdlIHNob3VsZCB0byBkZXRlY3QgZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4gb25Ub3VjaEhhbmRsZXIge0Z1bmN0aW9ufSB0aGUgY29yZSBldmVudCBoYW5kbGVyXG4gICAqL1xuICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKGVsZW1lbnQsIGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uIG9uVG91Y2hIYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgc3JjVHlwZSA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpc1BvaW50ZXIgPSBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMsXG4gICAgICAgICAgaXNNb3VzZSA9IFV0aWxzLmluU3RyKHNyY1R5cGUsICdtb3VzZScpLFxuICAgICAgICAgIHRyaWdnZXJUeXBlO1xuXG4gICAgICAvLyBpZiB3ZSBhcmUgaW4gYSBtb3VzZWV2ZW50LCBidXQgdGhlcmUgaGFzIGJlZW4gYSB0b3VjaGV2ZW50IHRyaWdnZXJlZCBpbiB0aGlzIHNlc3Npb25cbiAgICAgIC8vIHdlIHdhbnQgdG8gZG8gbm90aGluZy4gc2ltcGx5IGJyZWFrIG91dCBvZiB0aGUgZXZlbnQuXG4gICAgICBpZihpc01vdXNlICYmIHNlbGYucHJldmVudE1vdXNlRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBtb3VzZWJ1dHRvbiBtdXN0IGJlIGRvd25cbiAgICAgIH0gZWxzZSBpZihpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSAoZXYuYnV0dG9ucyA9PT0gMSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfVE9VQ0gsIGV2KSk7XG4gICAgICAgIC8vIGp1c3QgYSB2YWxpZCBzdGFydCBldmVudCwgYnV0IG5vIG1vdXNlXG4gICAgICB9IGVsc2UgaWYoIWlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgZXZlbnQgYmVmb3JlIGVudGVyaW5nIHRoZSBkZXRlY3Rpb25cbiAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gYSB0b3VjaC9kb3duIHN0YXRlLCBzbyBhbGxvd2VkIGRldGVjdGlvbiBvZiBnZXN0dXJlc1xuICAgICAgaWYoc2VsZi5zaG91bGREZXRlY3QpIHtcbiAgICAgICAgdHJpZ2dlclR5cGUgPSBzZWxmLmRvRGV0ZWN0LmNhbGwoc2VsZiwgZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgaWYodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIFBvaW50ZXJFdmVudC5yZXNldCgpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXJldmVudCBvYmplY3QgYWZ0ZXIgdGhlIGRldGVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbihlbGVtZW50LCBFVkVOVF9UWVBFU1tldmVudFR5cGVdLCBvblRvdWNoSGFuZGxlcik7XG4gICAgcmV0dXJuIG9uVG91Y2hIYW5kbGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSBkZXRlY3Rpb24gbWV0aG9kXG4gICAqIHRoaXMgZmluZHMgb3V0IHdoYXQgR2VzdHVyZURldGVjdG9yLXRvdWNoLWV2ZW50cyB0byB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7U3RyaW5nfSB0cmlnZ2VyVHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICovXG4gIGRvRGV0ZWN0OiBmdW5jdGlvbiBkb0RldGVjdChldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIHRvdWNoTGlzdCA9IHRoaXMuZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpO1xuICAgIHZhciB0b3VjaExpc3RMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoO1xuICAgIHZhciB0cmlnZ2VyVHlwZSA9IGV2ZW50VHlwZTtcbiAgICB2YXIgdHJpZ2dlckNoYW5nZSA9IHRvdWNoTGlzdC50cmlnZ2VyOyAvLyB1c2VkIGJ5IGZha2VNdWx0aXRvdWNoIHBsdWdpblxuICAgIHZhciBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0TGVuZ3RoO1xuXG4gICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXG4gICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfVE9VQ0g7XG4gICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9SRUxFQVNFO1xuXG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoIC0gKChldi5jaGFuZ2VkVG91Y2hlcykgPyBldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggOiAxKTtcbiAgICB9XG5cbiAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgIC8vIHdlIGp1c3Qgd2FudCB0byB0cmlnZ2VyIGEgTU9WRSBldmVudC4gc28gY2hhbmdlIHRoZSBTVEFSVCBvciBFTkQgdG8gYSBNT1ZFXG4gICAgLy8gYnV0IG9ubHkgYWZ0ZXIgZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHRoZSBmaXJzdCB0aW1lIHdlIGFjdHVhbGx5IHdhbnQgYSBTVEFSVFxuICAgIGlmKGNoYW5nZWRMZW5ndGggPiAwICYmIHRoaXMuc3RhcnRlZCkge1xuICAgICAgdHJpZ2dlclR5cGUgPSBFVkVOVF9NT1ZFO1xuICAgIH1cblxuICAgIC8vIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB3ZSBrZWVwIHRyYWNrIG9mIHRoaXMsIHNlZSBhYm92ZVxuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cbiAgICB2YXIgZXZEYXRhID0gdGhpcy5jb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIHRyaWdnZXJUeXBlLCB0b3VjaExpc3QsIGV2KTtcblxuICAgIC8vIHRyaWdnZXIgdGhlIHRyaWdnZXJUeXBlIGV2ZW50IGJlZm9yZSB0aGUgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnRzXG4gICAgLy8gYnV0IHRoZSBFTkQgZXZlbnQgc2hvdWxkIGJlIGF0IGxhc3RcbiAgICBpZihldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICBpZih0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICBldkRhdGEuY2hhbmdlZExlbmd0aCA9IGNoYW5nZWRMZW5ndGg7XG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlckNoYW5nZTtcblxuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJUeXBlO1xuICAgICAgZGVsZXRlIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJpZ2dlclR5cGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgKiBkZXRlcm1pbmUgd2hhdCB3ZSBuZWVkIGFuZCBzZXQgdGhlbSBpbiB0aGUgRVZFTlRfVFlQRVMgY29uc3RhbnRcbiAgICogdGhlIGBvblRvdWNoYCBtZXRob2QgaXMgYmluZCB0byB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xuICAgKi9cbiAgZGV0ZXJtaW5lRXZlbnRUeXBlczogZnVuY3Rpb24gZGV0ZXJtaW5lRXZlbnRUeXBlcygpIHtcbiAgICB2YXIgdHlwZXM7XG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICBpZih3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ01TUG9pbnRlckRvd24nLFxuICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihHZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCdcbiAgICAgIF07XG4gICAgfVxuXG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfTU9WRV0gPSB0eXBlc1sxXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9FTkRdID0gdHlwZXNbMl07XG4gICAgcmV0dXJuIEVWRU5UX1RZUEVTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNoZXNcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpIHtcbiAgICAvLyBnZXQgdGhlIGZha2UgcG9pbnRlckV2ZW50IHRvdWNobGlzdFxuICAgIGlmKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudC5nZXRUb3VjaExpc3QoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHRvdWNobGlzdFxuICAgIGlmKGV2LnRvdWNoZXMpIHtcbiAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9NT1ZFKSB7XG4gICAgICAgIHJldHVybiBldi50b3VjaGVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQoVXRpbHMudG9BcnJheShldi50b3VjaGVzKSwgVXRpbHMudG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcykpO1xuICAgICAgdmFyIHRvdWNoTGlzdCA9IFtdO1xuXG4gICAgICBVdGlscy5lYWNoKGNvbmNhdCwgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgaWYoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IC0xKSB7XG4gICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGZha2UgdG91Y2hMaXN0IGZyb20gbW91c2UgcG9zaXRpb25cbiAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICByZXR1cm4gW2V2XTtcbiAgfSxcblxuICAvKipcbiAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1RPVUNIO1xuICAgIGlmKFV0aWxzLmluU3RyKGV2LnR5cGUsICdtb3VzZScpIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XG4gICAgfSBlbHNlIGlmKFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9QRU4sIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1BFTjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiBVdGlscy5nZXRDZW50ZXIodG91Y2hlcyksXG4gICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICB0YXJnZXQ6IGV2LnRhcmdldCxcbiAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgIHNyY0V2ZW50OiBldixcblxuICAgICAgLyoqXG4gICAgICAgKiBwcmV2ZW50IHRoZSBicm93c2VyIGRlZmF1bHQgYWN0aW9uc1xuICAgICAgICogbW9zdGx5IHVzZWQgdG8gZGlzYWJsZSBzY3JvbGxpbmcgb2YgdGhlIGJyb3dzZXJcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSB0aGlzLnNyY0V2ZW50O1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQgJiYgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogc3RvcCBidWJibGluZyB0aGUgZXZlbnQgdXAgdG8gaXRzIHBhcmVudHNcbiAgICAgICAqL1xuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogaW1tZWRpYXRlbHkgc3RvcCBnZXN0dXJlIGRldGVjdGlvblxuICAgICAgICogbWlnaHQgYmUgdXNlZnVsIGFmdGVyIGEgc3dpcGUgd2FzIGRldGVjdGVkXG4gICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICovXG4gICAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICogQHN0YXRpY1xuICovXG5Qb2ludGVyRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuUG9pbnRlckV2ZW50ID0ge1xuICAvKipcbiAgICogaG9sZHMgYWxsIHBvaW50ZXJzLCBieSBgaWRlbnRpZmllcmBcbiAgICogQHByb3BlcnR5IHBvaW50ZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb2ludGVyczoge30sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgcG9pbnRlcnMgYXMgYW4gYXJyYXlcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoKSB7XG4gICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgIFV0aWxzLmVhY2godGhpcy5wb2ludGVycywgZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdG91Y2hsaXN0LnB1c2gocG9pbnRlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNobGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJFdmVudFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlcjogZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihldmVudFR5cGUsIHBvaW50ZXJFdmVudCkge1xuICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQgfHwgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbnMgIT09IDEpKSB7XG4gICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICovXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgIGlmKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgICB0eXBlcyA9IHt9O1xuXG4gICAgdHlwZXNbUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IFBPSU5URVJfUEVOKSk7XG4gICAgcmV0dXJuIHR5cGVzW3BvaW50ZXJUeXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0TGlzdCgpIHtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBEZXRlY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuRGV0ZWN0aW9uID0gR2VzdHVyZURldGVjdG9yLmRldGVjdGlvbiA9IHtcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gIGdlc3R1cmVzOiBbXSxcblxuICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXG4gIGN1cnJlbnQ6IG51bGwsXG5cbiAgLy8gdGhlIHByZXZpb3VzIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgcHJldmlvdXM6IG51bGwsXG5cbiAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gIHN0b3BwZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzdGFydCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9IGluc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKi9cbiAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xuICAgIC8vIGFscmVhZHkgYnVzeSB3aXRoIGEgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8vIGhvbGRzIGN1cnJlbnQgc2Vzc2lvblxuICAgIHRoaXMuY3VycmVudCA9IHtcbiAgICAgIGluc3Q6IGluc3QsIC8vIHJlZmVyZW5jZSB0byBHZXN0dXJlRGV0ZWN0b3JJbnN0YW5jZSB3ZSdyZSB3b3JraW5nIGZvclxuICAgICAgc3RhcnRFdmVudDogVXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgIGxhc3RDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgZnV0dXJlQ2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXG4gICAgICBuYW1lOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgIH07XG5cbiAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcbiAgICBpZighdGhpcy5jdXJyZW50IHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBldmVudCBkYXRhIHdpdGggY2FsY3VsYXRpb25zIGFib3V0IHNjYWxlLCBkaXN0YW5jZSBldGNcbiAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xuXG4gICAgLy8gR2VzdHVyZURldGVjdG9yIGluc3RhbmNlIGFuZCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcbiAgICAgICAgaW5zdE9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAvLyBjYWxsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgVXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbiB0cmlnZ2VyR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xuICAgICAgICBnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIGluc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgfVxuXG4gICAgaWYoZXZlbnREYXRhLmV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudERhdGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgfSxcblxuICAvKipcbiAgICogY2xlYXIgdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHZhcnNcbiAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICogdG8gc3RvcCBvdGhlciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgKi9cbiAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgdGhpcy5wcmV2aW91cyA9IFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICovXG4gIGdldENhbGN1bGF0ZWREYXRhOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkRGF0YShldiwgY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgcmVjYWxjID0gZmFsc2UsXG4gICAgICAgIGNhbGNFdiA9IGN1ci5sYXN0Q2FsY0V2ZW50LFxuICAgICAgICBjYWxjRGF0YSA9IGN1ci5sYXN0Q2FsY0RhdGE7XG5cbiAgICBpZihjYWxjRXYgJiYgZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcCA+IEdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNlbnRlciA9IGNhbGNFdi5jZW50ZXI7XG4gICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xuICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBjYWxjRXYuY2VudGVyLmNsaWVudFg7XG4gICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WTtcbiAgICAgIHJlY2FsYyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgaWYoIWN1ci5sYXN0Q2FsY0V2ZW50IHx8IHJlY2FsYykge1xuICAgICAgY2FsY0RhdGEudmVsb2NpdHkgPSBVdGlscy5nZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgY2FsY0RhdGEuZGlyZWN0aW9uID0gVXRpbHMuZ2V0RGlyZWN0aW9uKGNlbnRlciwgZXYuY2VudGVyKTtcblxuICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGV2LnZlbG9jaXR5WCA9IGNhbGNEYXRhLnZlbG9jaXR5Lng7XG4gICAgZXYudmVsb2NpdHlZID0gY2FsY0RhdGEudmVsb2NpdHkueTtcbiAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcbiAgICBldi5pbnRlcmltRGlyZWN0aW9uID0gY2FsY0RhdGEuZGlyZWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgc3RhcnRFdiA9IGN1ci5zdGFydEV2ZW50LFxuICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHN0YXJ0IHRvdWNobGlzdCB0byBjYWxjdWxhdGUgdGhlIHNjYWxlL3JvdGF0aW9uXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgIFV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICB9KTtcblxuICAgIHJldHVybiBldjtcbiAgfSxcblxuICAvKipcbiAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAqL1xuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgIGlmKG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zW2dlc3R1cmUubmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBHZXN0dXJlRGV0ZWN0b3IgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIG9wdGlvbnNcbiAgICBVdGlscy5leHRlbmQoR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgIC8vIHNldCBpdHMgaW5kZXhcbiAgICBnZXN0dXJlLmluZGV4ID0gZ2VzdHVyZS5pbmRleCB8fCAxMDAwO1xuXG4gICAgLy8gYWRkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHRvIHRoZSBsaXN0XG4gICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuXG4gICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxuICAgIHRoaXMuZ2VzdHVyZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZihhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZihhLmluZGV4ID4gYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG5cbi8qKlxuICogY3JlYXRlIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICpcbiAqIEBjbGFzcyBJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHNgXG4gKiBAcmV0dXJuIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIHNldHVwKCk7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICBvcHRpb25zW1V0aWxzLnRvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICB9KTtcblxuICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KTtcblxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZpb3JcbiAgaWYodGhpcy5vcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGV2ZW50IHN0YXJ0IGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGRldGVjdGlvblxuICAgKiBAcHJvcGVydHkgZXZlbnRTdGFydEhhbmRsZXJcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIgPSBFdmVudC5vblRvdWNoKGVsZW1lbnQsIEVWRU5UX1NUQVJULCBmdW5jdGlvbihldikge1xuICAgIGlmKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgfSBlbHNlIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgRGV0ZWN0aW9uLmRldGVjdChldik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICoga2VlcCBhIGxpc3Qgb2YgdXNlciBldmVudCBoYW5kbGVycyB3aGljaCBuZWVkcyB0byBiZSByZW1vdmVkIHdoZW4gY2FsbGluZyAnZGlzcG9zZSdcbiAgICogQHByb3BlcnR5IGV2ZW50SGFuZGxlcnNcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG59O1xuXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQG1ldGhvZCBvblxuICAgKiBAc2lnbmF0dXJlIG9uKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1BZGRzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2VzdHVyZS4gQXZhaWxhYmxlIGdlc3R1cmVzIGFyZTogZHJhZywgZHJhZ2xlZnQsIGRyYWdyaWdodCwgZHJhZ3VwLCBkcmFnZG93biwgaG9sZCwgcmVsZWFzZSwgc3dpcGUsIHN3aXBlbGVmdCwgc3dpcGVyaWdodCwgc3dpcGV1cCwgc3dpcGVkb3duLCB0YXAsIGRvdWJsZXRhcCwgdG91Y2gsIHRyYW5zZm9ybSwgcGluY2gsIHBpbmNoaW4sIHBpbmNob3V0IGFuZCByb3RhdGUuIFsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj44Gr5a++44GZ44KL44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS6L+95Yqg44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL44K444Kn44K544OB44Oj5ZCN44Gv44CBZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIGhvbGQgcmVsZWFzZSBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93biB0YXAgZG91YmxldGFwIHRvdWNoIHRyYW5zZm9ybSBwaW5jaCBwaW5jaGluIHBpbmNob3V0IHJvdGF0ZSDjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3mpJznn6XjgZnjgovjgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb25FdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBzZWxmLmV2ZW50SGFuZGxlcnMucHVzaCh7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb2ZmXG4gICAqIEBzaWduYXR1cmUgb2ZmKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgRXZlbnQub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBpbmRleCA9IFV0aWxzLmluQXJyYXkoc2VsZi5ldmVudEhhbmRsZXJzLCB7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSwgdHJ1ZSk7XG4gICAgICBpZihpbmRleCA+PSAwKSB7XG4gICAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGdlc3R1cmUgZXZlbnRcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqIEBzaWduYXR1cmUgdHJpZ2dlcihnZXN0dXJlLCBldmVudERhdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXVxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGdlc3R1cmUsIGV2ZW50RGF0YSkge1xuICAgIC8vIG9wdGlvbmFsXG4gICAgaWYoIWV2ZW50RGF0YSkge1xuICAgICAgZXZlbnREYXRhID0ge307XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgIHZhciBldmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmKFV0aWxzLmhhc1BhcmVudChldmVudERhdGEudGFyZ2V0LCBlbGVtZW50KSkge1xuICAgICAgZWxlbWVudCA9IGV2ZW50RGF0YS50YXJnZXQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBlbmFibGVcbiAgICogQHNpZ25hdHVyZSBlbmFibGUoc3RhdGUpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUVuYWJsZSBvciBkaXNhYmxlIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj5qSc55+l44KS5pyJ5Yq55YyWL+eEoeWKueWMluOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGVcbiAgICogICBbZW5dU3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgZW5hYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd5pyJ5Yq544Gr44GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgdGhpcy5lbmFibGVkID0gc3RhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGlzcG9zZVxuICAgKiBAc2lnbmF0dXJlIGRpc3Bvc2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW5kIGRlc3Ryb3kgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGlzIGluc3RhbmNlLlsvZW5dXG4gICAqICBbamFd44GT44Gu44Kk44Oz44K544K/44Oz44K544Gn44Gu44K444Kn44K544OB44Oj44Gu5qSc55+l44KE44CB44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS5YWo44Gm6Kej6Zmk44GX44Gm5buD5qOE44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdmFyIGksIGVoO1xuXG4gICAgLy8gdW5kbyBhbGwgY2hhbmdlcyBtYWRlIGJ5IHN0b3BfYnJvd3Nlcl9iZWhhdmlvclxuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCBmYWxzZSk7XG5cbiAgICAvLyB1bmJpbmQgYWxsIGN1c3RvbSBldmVudCBoYW5kbGVyc1xuICAgIGZvcihpID0gLTE7IChlaCA9IHRoaXMuZXZlbnRIYW5kbGVyc1srK2ldKTspIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgVXRpbHMub2ZmKHRoaXMuZWxlbWVudCwgZWguZ2VzdHVyZSwgZWguaGFuZGxlcik7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyB1bmJpbmQgdGhlIHN0YXJ0IGV2ZW50IGxpc3RlbmVyXG4gICAgRXZlbnQub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIE1vdmUgd2l0aCB4IGZpbmdlcnMgKGRlZmF1bHQgMSkgYXJvdW5kIG9uIHRoZSBwYWdlLlxuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLlxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnXCIsIGZ1bmN0aW9uKGV2KSB7XG4gKiAgICBjb25zb2xlLmxvZyhldik7XG4gKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gKiAgfSk7XG4gKiBgYGBgXG4gKlxuICogQGNsYXNzIERyYWdcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdzdGFydFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFwbGVmdFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdyaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWd1cFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdkb3duXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBkcmFnR2VzdHVyZShldiwgaW5zdCkge1xuICAgIHZhciBjdXIgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgIC8vIG1heCB0b3VjaGVzXG4gICAgaWYoaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzID4gMCAmJlxuICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICBpZihldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiZcbiAgICAgICAgY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENlbnRlciA9IGN1ci5zdGFydEV2ZW50LmNlbnRlcjtcblxuICAgICAgLy8gd2UgYXJlIGRyYWdnaW5nIVxuICAgICAgaWYoY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICBjdXIubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnRGlzdGFuY2VDb3JyZWN0aW9uICYmIGV2LmRpc3RhbmNlID4gMCkge1xuICAgICAgICAgIC8vIFdoZW4gYSBkcmFnIGlzIHRyaWdnZXJlZCwgc2V0IHRoZSBldmVudCBjZW50ZXIgdG8gZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBmcm9tIHRoZSBvcmlnaW5hbCBldmVudCBjZW50ZXIuXG4gICAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvcnJlY3Rpb24sIHRoZSBkcmFnZ2VkIGRpc3RhbmNlIHdvdWxkIGp1bXBzdGFydCBhdCBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGluc3RlYWQgb2YgYXQgMC5cbiAgICAgICAgICAvLyBJdCBtaWdodCBiZSB1c2VmdWwgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgc3RhcnQgcG9pbnQgc29tZXdoZXJlXG4gICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGguYWJzKGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgLyBldi5kaXN0YW5jZSk7XG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcblxuICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGV2ZW50IGRhdGEgdXNpbmcgbmV3IHN0YXJ0IHBvaW50XG4gICAgICAgICAgZXYgPSBEZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsb2NrIGRyYWcgdG8gYXhpcz9cbiAgICAgIGlmKGN1ci5sYXN0RXZlbnQuZHJhZ0xvY2tUb0F4aXMgfHxcbiAgICAgICAgKCBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tUb0F4aXMgJiZcbiAgICAgICAgICBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tNaW5EaXN0YW5jZSA8PSBldi5kaXN0YW5jZVxuICAgICAgICApKSB7XG4gICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgdmFyIGxhc3REaXJlY3Rpb24gPSBjdXIubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgaWYoZXYuZHJhZ0xvY2tUb0F4aXMgJiYgbGFzdERpcmVjdGlvbiAhPT0gZXYuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgaWYoVXRpbHMuaXNWZXJ0aWNhbChsYXN0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudHNcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcblxuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IFV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBibG9jayB0aGUgYnJvd3NlciBldmVudHNcbiAgICAgICAgaWYoKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tWZXJ0aWNhbCAmJiBpc1ZlcnRpY2FsKSB8fFxuICAgICAgICAgIChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrSG9yaXpvbnRhbCAmJiAhaXNWZXJ0aWNhbCkpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDw9IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuRHJhZyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNTAsXG4gICAgICBoYW5kbGVyOiBkcmFnR2VzdHVyZSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW5pbWFsIG1vdmVtZW50IHRoYXQgaGF2ZSB0byBiZSBtYWRlIGJlZm9yZSB0aGUgZHJhZyBldmVudCBnZXRzIHRyaWdnZXJlZFxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01pbkRpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiB0byB0cnVlIHRvIG1ha2UgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBkcmFnXG4gICAgICAgICAqIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cbiAgICAgICAgICogVXNlZnVsIHRvIGF2b2lkIGEgamVyay1zdGFydGluZyBkcmFnLCB3aGljaCBjYW4gbWFrZSBmaW5lLWFkanVzdG1lbnRzXG4gICAgICAgICAqIHRocm91Z2ggZHJhZ2dpbmcgZGlmZmljdWx0LCBhbmQgYmUgdmlzdWFsbHkgdW5hcHBlYWxpbmcuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNYXhUb3VjaGVzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIGRyYWdnaW5nIG9jY3Vyc1xuICAgICAgICAgKiBiZSBjYXJlZnVsIHdpdGggaXQsIGl0IG1ha2VzIHRoZSBlbGVtZW50IGEgYmxvY2tpbmcgZWxlbWVudFxuICAgICAgICAgKiB3aGVuIHlvdSBhcmUgdXNpbmcgdGhlIGRyYWcgZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja0hvcml6b250YWxcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnQmxvY2tIb3Jpem9udGFsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2FtZSBhcyBgZHJhZ0Jsb2NrSG9yaXpvbnRhbGAsIGJ1dCBmb3IgdmVydGljYWwgbW92ZW1lbnRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja1ZlcnRpY2FsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrVmVydGljYWw6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnTG9ja1RvQXhpcyBrZWVwcyB0aGUgZHJhZyBnZXN0dXJlIG9uIHRoZSBheGlzIHRoYXQgaXQgc3RhcnRlZCBvbixcbiAgICAgICAgICogSXQgZGlzYWxsb3dzIHZlcnRpY2FsIGRpcmVjdGlvbnMgaWYgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHdhcyBob3Jpem9udGFsLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrVG9BeGlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tUb0F4aXM6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnIGxvY2sgb25seSBraWNrcyBpbiB3aGVuIGRpc3RhbmNlID4gZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBUaGlzIHdheSwgbG9ja2luZyBvY2N1cnMgb25seSB3aGVuIHRoZSBkaXN0YW5jZSBoYXMgYmVjb21lIGxhcmdlIGVub3VnaCB0byByZWxpYWJseSBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyNVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tNaW5EaXN0YW5jZTogMjVcbiAgICAgIH1cbiAgICB9O1xuICB9KSgnZHJhZycpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlciBhIHNpbXBsZSBnZXN0dXJlIGV2ZW50LCBzbyB5b3UgY2FuIGRvIGFueXRoaW5nIGluIHlvdXIgaGFuZGxlci5cbiAgICogb25seSB1c2FibGUgaWYgeW91IGtub3cgd2hhdCB5b3VyIGRvaW5nLi4uXG4gICAqXG4gICAqIEBjbGFzcyBHZXN0dXJlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5HZXN0dXJlID0ge1xuICAgIG5hbWU6ICdnZXN0dXJlJyxcbiAgICBpbmRleDogMTMzNyxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFRvdWNoIHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlIGZvciB4IHRpbWVcbiAgICpcbiAgICogQGNsYXNzIEhvbGRcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBob2xkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRpbWVyO1xuXG4gICAgZnVuY3Rpb24gaG9sZEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGdlc3R1cmUgc28gd2UgY2FuIGNoZWNrIGluIHRoZSB0aW1lb3V0IGlmIGl0IHN0aWxsIGlzXG4gICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gc2V0IHRpbWVyIGFuZCBpZiBhZnRlciB0aGUgdGltZW91dCBpdCBzdGlsbCBpcyBob2xkLFxuICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBob2xkIGV2ZW50XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihjdXJyZW50ICYmIGN1cnJlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5ob2xkVGltZW91dCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGlmKGV2LmRpc3RhbmNlID4gb3B0aW9ucy5ob2xkVGhyZXNob2xkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuSG9sZCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogMTAsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaW1lb3V0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDUwMFxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZFRpbWVvdXQ6IDUwMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZW1lbnQgYWxsb3dlZCB3aGlsZSBob2xkaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGhyZXNob2xkXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDJcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaHJlc2hvbGQ6IDJcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyOiBob2xkR2VzdHVyZVxuICAgIH07XG4gIH0pKCdob2xkJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgcmVsZWFzZWQgZnJvbSB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgUmVsZWFzZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJlbGVhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuUmVsZWFzZSA9IHtcbiAgICBuYW1lOiAncmVsZWFzZScsXG4gICAgaW5kZXg6IEluZmluaXR5LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlcnMgc3dpcGUgZXZlbnRzIHdoZW4gdGhlIGVuZCB2ZWxvY2l0eSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gICAqIGZvciBiZXN0IHVzYWdlLCBzZXQgYHByZXZlbnREZWZhdWx0YCAob24gdGhlIGRyYWcgZ2VzdHVyZSkgdG8gYHRydWVgXG4gICAqIGBgYGBcbiAgICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnbGVmdCBzd2lwZWxlZnRcIiwgZnVuY3Rpb24oZXYpIHtcbiAgICogICAgY29uc29sZS5sb2coZXYpO1xuICAgKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqICB9KTtcbiAgICogYGBgYFxuICAgKlxuICAgKiBAY2xhc3MgU3dpcGVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVsZWZ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXJpZ2h0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gICAgbmFtZTogJ3N3aXBlJyxcbiAgICBpbmRleDogNDAsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWluVG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNaW5Ub3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1heFRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBob3Jpem9udGFsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVhcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVg6IDAuNixcblxuICAgICAgLyoqXG4gICAgICAgKiB2ZXJ0aWNhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlZXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlZOiAwLjZcbiAgICB9LFxuXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gc3dpcGVHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICBpZih0b3VjaGVzIDwgb3B0aW9ucy5zd2lwZU1pblRvdWNoZXMgfHxcbiAgICAgICAgICB0b3VjaGVzID4gb3B0aW9ucy5zd2lwZU1heFRvdWNoZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoZXYudmVsb2NpdHlYID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WCB8fFxuICAgICAgICAgIGV2LnZlbG9jaXR5WSA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVkpIHtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHN3aXBlIGV2ZW50c1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBTaW5nbGUgdGFwIGFuZCBhIGRvdWJsZSB0YXAgb24gYSBwbGFjZVxuICAgKlxuICAgKiBAY2xhc3MgVGFwXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBkb3VibGV0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGFzTW92ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudCxcbiAgICAgICAgICBwcmV2ID0gRGV0ZWN0aW9uLnByZXZpb3VzLFxuICAgICAgICAgIHNpbmNlUHJldixcbiAgICAgICAgICBkaWREb3VibGVUYXA7XG5cbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGhhc01vdmVkID0gaGFzTW92ZWQgfHwgKGV2LmRpc3RhbmNlID4gb3B0aW9ucy50YXBNYXhEaXN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgaWYoIVV0aWxzLmluU3RyKGV2LnNyY0V2ZW50LnR5cGUsICdjYW5jZWwnKSAmJiBldi5kZWx0YVRpbWUgPCBvcHRpb25zLnRhcE1heFRpbWUgJiYgIWhhc01vdmVkKSB7XG4gICAgICAgICAgLy8gcHJldmlvdXMgZ2VzdHVyZSwgZm9yIHRoZSBkb3VibGUgdGFwIHNpbmNlIHRoZXNlIGFyZSB0d28gZGlmZmVyZW50IGdlc3R1cmUgZGV0ZWN0aW9uc1xuICAgICAgICAgIHNpbmNlUHJldiA9IHByZXYgJiYgcHJldi5sYXN0RXZlbnQgJiYgZXYudGltZVN0YW1wIC0gcHJldi5sYXN0RXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgIGRpZERvdWJsZVRhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZG91YmxlIHRhcFxuICAgICAgICAgIGlmKHByZXYgJiYgcHJldi5uYW1lID09IG5hbWUgJiZcbiAgICAgICAgICAgIChzaW5jZVByZXYgJiYgc2luY2VQcmV2IDwgb3B0aW9ucy5kb3VibGVUYXBJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgIGV2LmRpc3RhbmNlIDwgb3B0aW9ucy5kb3VibGVUYXBEaXN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdkb3VibGV0YXAnLCBldik7XG4gICAgICAgICAgICBkaWREb3VibGVUYXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxuICAgICAgICAgIGlmKCFkaWREb3VibGVUYXAgfHwgb3B0aW9ucy50YXBBbHdheXMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UYXAgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwMCxcbiAgICAgIGhhbmRsZXI6IHRhcEdlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IHRpbWUgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heFRpbWVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjUwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhUaW1lOiAyNTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBvZiBtb3ZlbWVudCBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4RGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIHRhcE1heERpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWx3YXlzIHRyaWdnZXIgdGhlIGB0YXBgIGV2ZW50LCBldmVuIHdoaWxlIGRvdWJsZS10YXBwaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRhcEFsd2F5czogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICBkb3VibGVUYXBEaXN0YW5jZTogMjAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcEludGVydmFsXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDMwMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwSW50ZXJ2YWw6IDMwMFxuICAgICAgfVxuICAgIH07XG4gIH0pKCd0YXAnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyB0b3VjaGVkIGF0IHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBUb3VjaFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRvdWNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRvdWNoID0ge1xuICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgaW5kZXg6IC1JbmZpbml0eSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IGF0IHRvdWNoc3RhcnQsIGFuZCBtYWtlcyB0aGUgZWxlbWVudCBibG9ja2luZyBieSBkaXNhYmxpbmcgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZSxcbiAgICAgICAqIGJ1dCBpdCBpbXByb3ZlcyBnZXN0dXJlcyBsaWtlIHRyYW5zZm9ybWluZyBhbmQgZHJhZ2dpbmcuXG4gICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudERlZmF1bHRcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRpc2FibGUgbW91c2UgZXZlbnRzLCBzbyBvbmx5IHRvdWNoIChvciBwZW4hKSBpbnB1dCB0cmlnZ2VycyBldmVudHNcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50TW91c2VcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudE1vdXNlOiBmYWxzZVxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudE1vdXNlICYmIGV2LnBvaW50ZXJUeXBlID09IFBPSU5URVJfTU9VU0UpIHtcbiAgICAgICAgZXYuc3RvcERldGVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKCd0b3VjaCcsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBVc2VyIHdhbnQgdG8gc2NhbGUgb3Igcm90YXRlIHdpdGggMiBmaW5nZXJzXG4gICAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy4gVGhpcyBjYW4gYmUgZG9uZSB3aXRoIHRoZVxuICAgKiBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAgICpcbiAgICogQGNsYXNzIFRyYW5zZm9ybVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3Jtc3RhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybWVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hpblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJvdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAvLyBhdCBsZWFzdCBtdWx0aXRvdWNoXG4gICAgICAgIGlmKGV2LnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZVRocmVzaG9sZCA9IE1hdGguYWJzKDEgLSBldi5zY2FsZSk7XG4gICAgICAgIHZhciByb3RhdGlvblRocmVzaG9sZCA9IE1hdGguYWJzKGV2LnJvdGF0aW9uKTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiZcbiAgICAgICAgICByb3RhdGlvblRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGFyZSB0cmFuc2Zvcm1pbmchXG4gICAgICAgIERldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTsgLy8gYmFzaWMgdHJhbnNmb3JtIGV2ZW50XG5cbiAgICAgICAgLy8gdHJpZ2dlciByb3RhdGUgZXZlbnRcbiAgICAgICAgaWYocm90YXRpb25UaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJywgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKGV2LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JyksIGV2KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8IDIpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRyYW5zZm9ybSA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNDUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBzY2FsZSBmYWN0b3IsIG5vIHNjYWxlIGlzIDEsIHpvb21pbiBpcyB0byAwIGFuZCB6b29tb3V0IHVudGlsIGhpZ2hlciB0aGVuIDFcbiAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zZm9ybU1pblNjYWxlOiAwLjAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5Sb3RhdGlvblxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5Sb3RhdGlvbjogMVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlcjogdHJhbnNmb3JtR2VzdHVyZVxuICAgIH07XG4gIH0pKCd0cmFuc2Zvcm0nKTtcblxuZXhwb3J0IGRlZmF1bHQgR2VzdHVyZURldGVjdG9yO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmNvbnN0IHJlYWR5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHF1ZXVlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gaXNDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJlYWR5TWFwLmhhcyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpIHtcbiAgcmVhZHlNYXAuc2V0KGVsZW1lbnQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBhZGRDYWxsYmFjayhlbGVtZW50LCBmbikge1xuICBpZiAoIXF1ZXVlTWFwLmhhcyhlbGVtZW50KSkge1xuICAgIHF1ZXVlTWFwLnNldChlbGVtZW50LCBbXSk7XG4gIH1cbiAgcXVldWVNYXAuZ2V0KGVsZW1lbnQpLnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lUXVldWUoZWxlbWVudCkge1xuICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZU1hcC5nZXQoZWxlbWVudCwgW10pIHx8IFtdO1xuICBxdWV1ZU1hcC5kZWxldGUoZWxlbWVudCk7XG4gIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250ZW50UmVhZHkoZWxlbWVudCwgZm4gPSAoKSA9PiB7fSkge1xuICBhZGRDYWxsYmFjayhlbGVtZW50LCBmbik7XG5cbiAgaWYgKGlzQ29udGVudFJlYWR5KGVsZW1lbnQpKSB7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIC8vIGZhaWxiYWNrIGZvciBlbGVtZW50cyBoYXMgZW1wdHkgY29udGVudC5cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNsYXNzIFRvYXN0UXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gIH1cblxuICBhZGQoZm4sIHByb21pc2UpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goZm4pO1xuXG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBzZXRJbW1lZGlhdGUodGhpcy5xdWV1ZVswXSk7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucXVldWUuc2hpZnQoKTtcblxuICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucXVldWVbMF0sIDEwMDAvMzApOyAvLyBBcHBseSBzb21lIHZpc3VhbCBkZWxheVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBUb2FzdFF1ZXVlKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IFRvYXN0UXVldWUgZnJvbSAnLi9pbnRlcm5hbC90b2FzdC1xdWV1ZSc7XG5cbmNvbnN0IF9zZXRBdHRyaWJ1dGVzID0gKGVsZW1lbnQsIG9wdGlvbnMpID0+IHtcbiAgWydpZCcsICdjbGFzcycsICdhbmltYXRpb24nXVxuICAgIC5mb3JFYWNoKGEgPT4gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShhKSAmJiBlbGVtZW50LnNldEF0dHJpYnV0ZShhLCBvcHRpb25zW2FdKSk7XG5cbiAgaWYgKG9wdGlvbnMubW9kaWZpZXIpIHtcbiAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLm5vdGlmaWNhdGlvblxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBVdGlsaXR5IG1ldGhvZHMgdG8gY3JlYXRlIGRpZmZlcmVudCBraW5kcyBvZiBub3RpZmljYXRpb25zLiBUaGVyZSBhcmUgdGhyZWUgbWV0aG9kcyBhdmFpbGFibGU6XG4gKlxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uYWxlcnQoKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLnByb21wdCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24udG9hc3QoKWBcbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOBhOOBj+OBpOOBi+OBrueorumhnuOBruOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuS9nOaIkOOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBn+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnSGVsbG8sIHdvcmxkIScpO1xuICpcbiAqIG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgnQXJlIHlvdSByZWFkeT8nKVxuICogICAudGhlbihcbiAqICAgICBmdW5jdGlvbihhbnN3ZXIpIHtcbiAqICAgICAgIGlmIChhbnN3ZXIgPT09IDEpIHtcbiAqICAgICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnTGV0XFwncyBnbyEnKTtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgICk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQoJ0hvdyBvbGQgYXJlID8nKVxuICogICAudGhlbihcbiAqICAgICBmdW5jdGlvbihhZ2UpIHtcbiAqICAgICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ1lvdSBhcmUgJyArIGFnZSArICcgeWVhcnMgb2xkLicpO1xuICogICAgIH1cbiAqICAgKTtcbiAqL1xuY29uc3Qgbm90aWZpY2F0aW9uID0ge307XG5cbm5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cgPSBvcHRpb25zID0+IHtcbiAgLy8gUHJvbXB0IGlucHV0IHN0cmluZ1xuICBsZXQgaW5wdXRTdHJpbmcgPSAnJztcbiAgaWYgKG9wdGlvbnMuaXNQcm9tcHQpIHtcbiAgICBpbnB1dFN0cmluZyA9IGBcbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzcz1cInRleHQtaW5wdXQgdGV4dC1pbnB1dC0tdW5kZXJiYXJcIlxuICAgICAgICB0eXBlPVwiJHtvcHRpb25zLmlucHV0VHlwZSB8fCAndGV4dCd9XCJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCIke29wdGlvbnMucGxhY2Vob2xkZXIgfHwgJyd9XCJcbiAgICAgICAgdmFsdWU9XCIke29wdGlvbnMuZGVmYXVsdFZhbHVlIHx8ICcnfVwiXG4gICAgICAgIHN0eWxlPVwid2lkdGg6IDEwMCU7IG1hcmdpbi10b3A6IDEwcHg7XCJcbiAgICAgIC8+XG4gICAgYDtcbiAgfVxuXG4gIC8vIEJ1dHRvbnMgc3RyaW5nXG4gIGxldCBidXR0b25zID0gJyc7XG4gIG9wdGlvbnMuYnV0dG9uTGFiZWxzLmZvckVhY2goKGxhYmVsLCBpbmRleCkgPT4ge1xuICAgIGJ1dHRvbnMgKz0gYFxuICAgICAgPG9ucy1hbGVydC1kaWFsb2ctYnV0dG9uXG4gICAgICAgIGNsYXNzPVwiXG4gICAgICAgICAgJHtpbmRleCA9PT0gb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXggPyAnIGFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCcgOiAnJ31cbiAgICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXInIDogJyd9XG4gICAgICAgIFwiIFxuICAgICAgICBzdHlsZT1cInBvc2l0aW9uOiByZWxhdGl2ZTtcIj5cbiAgICAgICAgJHtsYWJlbH1cbiAgICAgIDwvb25zLWFsZXJ0LWRpYWxvZy1idXR0b24+XG4gICAgYDtcbiAgfSk7XG5cbiAgLy8gRGlhbG9nIEVsZW1lbnRcbiAgbGV0IGVsID0ge307XG4gIGNvbnN0IF9kZXN0cm95RGlhbG9nID0gKCkgPT4ge1xuICAgIGlmIChlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwpIHtcbiAgICAgIGVsLmRpYWxvZy5yZW1vdmVFdmVudExpc3RlbmVyKCdkaWFsb2ctY2FuY2VsJywgZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsKTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhlbCkuZm9yRWFjaChrZXkgPT4gZGVsZXRlIGVsW2tleV0pO1xuICAgIGVsID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLmRlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgb3B0aW9ucy5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuXG4gIGVsLmRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy1hbGVydC1kaWFsb2cnKTtcbiAgZWwuZGlhbG9nLmlubmVySFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+XG4gICAgICAgICAgJHtvcHRpb25zLnRpdGxlIHx8ICcnfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gICAgICAgICAgJHtvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTH1cbiAgICAgICAgICAke2lucHV0U3RyaW5nfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIlxuICAgICAgICAgIGFsZXJ0LWRpYWxvZy1mb290ZXJcbiAgICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXInIDogJyd9XG4gICAgICAgIFwiPlxuICAgICAgICAgICR7YnV0dG9uc31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcbiAgY29udGVudFJlYWR5KGVsLmRpYWxvZyk7XG5cbiAgLy8gU2V0IGF0dHJpYnV0ZXNcbiAgX3NldEF0dHJpYnV0ZXMoZWwuZGlhbG9nLCBvcHRpb25zKTtcblxuICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcblxuICAvLyBQcm9tcHQgZXZlbnRzXG4gIGlmIChvcHRpb25zLmlzUHJvbXB0ICYmIG9wdGlvbnMuc3VibWl0T25FbnRlcikge1xuICAgIGVsLmlucHV0ID0gZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJy50ZXh0LWlucHV0Jyk7XG4gICAgZWwuaW5wdXQub25rZXlwcmVzcyA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBlbC5kaWFsb2cuaGlkZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGVsLmlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQnV0dG9uIGV2ZW50c1xuICBlbC5mb290ZXIgPSBlbC5kaWFsb2cucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1mb290ZXInKTtcbiAgdXRpbC5hcnJheUZyb20oZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbGVydC1kaWFsb2ctYnV0dG9uJykpLmZvckVhY2goKGJ1dHRvbkVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9uRWxlbWVudC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBlbC5kaWFsb2cuaGlkZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIGxldCByZXNvbHZlVmFsdWUgPSBpbmRleDtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNQcm9tcHQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWUgPSBpbmRleCA9PT0gb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXggPyBlbC5pbnB1dC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZWwuZm9vdGVyLmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpO1xuICB9KTtcblxuICAvLyBDYW5jZWwgZXZlbnRzXG4gIGlmIChvcHRpb25zLmNhbmNlbGFibGUpIHtcbiAgICBlbC5kaWFsb2cuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsID0gKCkgPT4ge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBvcHRpb25zLmlzUHJvbXB0ID8gbnVsbCA6IC0xO1xuICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgIH07XG4gICAgZWwuZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIFNob3cgZGlhbG9nXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwuZGlhbG9nKTtcbiAgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZWwuZGlhbG9nLnNob3coKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuaW5wdXQgJiYgb3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLmF1dG9mb2N1cykge1xuICAgICAgICAgIGVsLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbmNvbnN0IF9ub3JtYWxpemVBcmd1bWVudHMgPSAobWVzc2FnZSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cyA9IHt9KSA9PiB7XG4gIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gKG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2UpIDogKG9wdGlvbnMgPSBtZXNzYWdlKTtcbiAgaWYgKCFvcHRpb25zLm1lc3NhZ2UgJiYgIW9wdGlvbnMubWVzc2FnZUhUTUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdGlmaWNhdGlvbnMgbXVzdCBjb250YWluIGEgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbHMnKSB8fCBvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbCcpKSB7XG4gICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBvcHRpb25zLmJ1dHRvbkxhYmVscyB8fCBvcHRpb25zLmJ1dHRvbkxhYmVsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmJ1dHRvbkxhYmVscykpIHtcbiAgICAgIG9wdGlvbnMuYnV0dG9uTGFiZWxzID0gW29wdGlvbnMuYnV0dG9uTGFiZWxzIHx8ICcnXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1dGlsLmV4dGVuZCh7XG4gICAgICBjb21waWxlOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGNhbGxiYWNrOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBwcmltYXJ5QnV0dG9uSW5kZXg6IChvcHRpb25zLmJ1dHRvbkxhYmVscyB8fCBkZWZhdWx0cy5idXR0b25MYWJlbHMgfHwgW10pLmxlbmd0aCAtIDFcbiAgICB9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWxlcnRcbiAqIEBzaWduYXR1cmUgYWxlcnQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+aWh+Wtl+WIl+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZUhUTUxdXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZSBpbiBIVE1MLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IFtvcHRpb25zLmJ1dHRvbkxhYmVsc11cbiAqICAgW2VuXUxhYmVscyBmb3IgdGhlIGJ1dHRvbnMuIERlZmF1bHQgaXMgYFwiT0tcImAuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgdGhlIGxhc3Qgb25lLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMCDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuIElmIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBpdCBjYW4gYmUgY2xvc2VkIGJ5IGNsaWNraW5nIHRoZSBiYWNrZ3JvdW5kIG9yIHByZXNzaW5nIHRoZSBBbmRyb2lkIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYG5vbmVgIGFuZCBgZmFkZWAuIERlZmF1bHQgaXMgYGZhZGVgLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBJRC5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc11cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgY2xhc3MuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5jbGFzc+OAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQWxlcnRcImAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS4iumDqOOBq+ihqOekuuOBmeOCi+OCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiQWxlcnRcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYW4gYWxlcnQgZGlhbG9nIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlLlxuICpcbiAqICAgICBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBjYW4gYmUgZWl0aGVyIHNpbXBsZSB0ZXh0IG9yIEhUTUwuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgbjjg6Hjg4Pjgrvjg7zjgrjjgpLopovjgZvjgovjgZ/jgoHjga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjga/jgIHjg4bjgq3jgrnjg4jjgYvjgoLjgZfjgY/jga9IVE1M44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uYWxlcnQgPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ09LJ10sXG4gICAgdGl0bGU6ICdBbGVydCdcbiAgfSk7XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29uZmlybVxuICogQHNpZ25hdHVyZSBjb25maXJtKG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5kZXggb2YgdGhlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkIG9yIGAtMWAgd2hlbiBjYW5jZWxlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmJ1dHRvbkxhYmVsc11cbiAqICAgW2VuXUxhYmVscyBmb3IgdGhlIGJ1dHRvbnMuIERlZmF1bHQgaXMgYFtcIkNhbmNlbFwiLCBcIk9LXCJdYC5bL2VuXVxuICogICBbamFd44Oc44K/44Oz44Gu44Op44OZ44Or44Gu6YWN5YiX44KS5oyH5a6a44GX44G+44GZ44CCW1wiQ2FuY2VsXCIsIFwiT0tcIl3jgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIHRoZSBsYXN0IG9uZS5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDEg44Gn44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB0byBhc2sgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbi4gRXh0ZW5kcyBgYWxlcnQoKWAgcGFyYW1ldGVycy5cbiAqICAgICBUaGUgZGVmYXVsdCBidXR0b24gbGFiZWxzIGFyZSBgXCJDYW5jZWxcImAgYW5kIGBcIk9LXCJgIGJ1dCB0aGV5IGNhbiBiZSBjdXN0b21pemVkLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuOBq+eiuuiqjeOCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOODh+OCquODq+OBqOOBruODnOOCv+ODs+ODqeODmeODq+OBr+OAgVwiQ2FuY2VsXCLjgahcIk9LXCLjgafjgZnjgYzjgIHjgZPjgozjga/jgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgafjgqvjgrnjgr/jg57jgqTjgrrjgafjgY3jgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5jb25maXJtID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIGJ1dHRvbkxhYmVsczogWydDYW5jZWwnLCAnT0snXSxcbiAgICB0aXRsZTogJ0NvbmZpcm0nXG4gIH0pO1xuXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHByb21wdFxuICogQHNpZ25hdHVyZSBwcm9tcHQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGlucHV0IHZhbHVlIHdoZW4gdGhlIGRpYWxvZyBpcyBjbG9zZWQgb3IgYG51bGxgIHdoZW4gY2FuY2VsZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IFtvcHRpb25zLmJ1dHRvbkxhYmVsc11cbiAqICAgW2VuXUxhYmVscyBmb3IgdGhlIGJ1dHRvbnMuIERlZmF1bHQgaXMgYFwiT0tcImAuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgdGhlIGxhc3Qgb25lLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMCDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBsYWNlaG9sZGVyXVxuICogICBbZW5dUGxhY2Vob2xkZXIgZm9yIHRoZSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgIFtqYV3jg4bjgq3jgrnjg4jmrITjga7jg5fjg6zjg7zjgrnjg5vjg6vjg4DjgavooajnpLrjgZnjgovjg4bjgq3jgrnjg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRWYWx1ZV1cbiAqICAgW2VuXURlZmF1bHQgdmFsdWUgZm9yIHRoZSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgIFtqYV3jg4bjgq3jgrnjg4jmrITjga7jg4fjg5Xjgqnjg6vjg4jjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlucHV0VHlwZV1cbiAqICAgW2VuXVR5cGUgb2YgdGhlIGlucHV0IGVsZW1lbnQgKGBwYXNzd29yZGAsIGBkYXRlYC4uLikuIERlZmF1bHQgaXMgYHRleHRgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvZm9jdXNdXG4gKiAgIFtlbl1BdXRvZm9jdXMgdGhlIGlucHV0IGVsZW1lbnQuIERlZmF1bHQgaXMgYHRydWVgLiBJbiBDb3Jkb3ZhLCBgS2V5Ym9hcmREaXNwbGF5UmVxdWlyZXNVc2VyQWN0aW9uYCBpbiBgY29uZmlnLnhtbGAgbXVzdCBiZSBgZmFsc2VgIHRvIGFjdGl2YXRlIHRoaXMgZmVhdHVyZS5bL2VuXVxuICogICBbamFdaW5wdXTopoHntKDjgavoh6rli5XnmoTjgavjg5Xjgqnjg7zjgqvjgrnjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCQ29yZG92YeeSsOWig+OBp+OBr+OAgeOBk+OBruapn+iDveOCkuacieWKueOBq+OBmeOCi+OBn+OCgeOBq+OBryBgY29uZmlnLnhtbGAg44GnIGBLZXlib2FyZERpc3BsYXlSZXF1aXJlc1VzZXJBY3Rpb25gIOOCkiBgZmFsc2VgIOOBq+ioreWumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1Ym1pdE9uRW50ZXJdXG4gKiAgIFtlbl1TdWJtaXQgYXV0b21hdGljYWxseSB3aGVuIGVudGVyIGlzIHByZXNzZWQuIERlZmF1bHQgaXMgYHRydWVgLlsvZW5dXG4gKiAgIFtqYV1FbnRlcuOBjOaKvOOBleOCjOOBn+mam+OBq+OBneOBrmZvcm3jgpJzdWJtaXTjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB3aXRoIGEgcHJvbXB0IHRvIGFzayB0aGUgdXNlciBhIHF1ZXN0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgavlhaXlipvjgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5wcm9tcHQgPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ09LJ10sXG4gICAgdGl0bGU6ICdBbGVydCcsXG4gICAgaXNQcm9tcHQ6IHRydWUsXG4gICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgIHN1Ym1pdE9uRW50ZXI6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdG9hc3RcbiAqIEBzaWduYXR1cmUgdG9hc3QobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHdoZW4gdGhlIHRvYXN0IGlzIGhpZGRlbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1Ub2FzdCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIHRoZW4gYG9wdGlvbnMubWVzc2FnZWAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuWy9lbl1cbiAqICAgW2phXeODiOODvOOCueODiOOBq+ihqOekuuOBmeOCi+aWh+Wtl+WIl+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYnV0dG9uTGFiZWxdXG4gKiAgIFtlbl1MYWJlbCBmb3IgdGhlIGJ1dHRvbi5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBub25lYCwgYGZhZGVgLCBgYXNjZW5kYCwgYGxpZnRgIGFuZCBgZmFsbGAuIERlZmF1bHQgaXMgYGFzY2VuZGAgZm9yIEFuZHJvaWQgYW5kIGBsaWZ0YCBmb3IgaU9TLlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwiYXNjZW5kXCIsIFwibGlmdFwiLCBcImZhbGxcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZW91dF1cbiAqICAgW2VuXU51bWJlciBvZiBtaWxpc2Vjb25kcyB3aGVyZSB0aGUgdG9hc3QgaXMgdmlzaWJsZSBiZWZvcmUgaGlkaW5nIGF1dG9tYXRpY2FsbHkuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcmNlXVxuICogICBbZW5dSWYgYHRydWVgLCB0aGUgdG9hc3Qgc2tpcHMgdGhlIG5vdGlmaWNhdGlvbiBxdWV1ZSBhbmQgaXMgc2hvd24gaW1tZWRpYXRlbHkuIERlZmF1bHRzIHRvIGBmYWxzZWAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9hc3Q+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy10b2FzdOimgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc11cbiAqICAgW2VuXVRoZSBgPG9ucy10b2FzdD5gIGVsZW1lbnQncyBjbGFzcy5bL2VuXVxuICogICBbamFdb25zLXRvYXN06KaB57Sg44GuY2xhc3PjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgdG9hc3QgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjgYzplonjgZjjgonjgozjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgc2ltcGxlIG5vdGlmaWNhdGlvbiB0b2FzdCB3aXRoIGFuIG9wdGlvbmFsIGJ1dHRvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBzaW1wbGUgYWN0aW9ucy5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24udG9hc3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi50b2FzdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi50b2FzdCA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzKG1lc3NhZ2UsIG9wdGlvbnMsIHtcbiAgICB0aW1lb3V0OiAwLFxuICAgIGZvcmNlOiBmYWxzZVxuICB9KTtcblxuICBsZXQgdG9hc3QgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgIDxvbnMtdG9hc3Q+XG4gICAgICAke29wdGlvbnMubWVzc2FnZX1cbiAgICAgICR7b3B0aW9ucy5idXR0b25MYWJlbHMgPyBgPGJ1dHRvbj4ke29wdGlvbnMuYnV0dG9uTGFiZWxzWzBdfTwvYnV0dG9uPmAgOiAnJ31cbiAgICA8L29ucy10b2FzdD5cbiAgYCk7XG5cbiAgX3NldEF0dHJpYnV0ZXModG9hc3QsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICBjb25zdCByZXNvbHZlID0gdmFsdWUgPT4ge1xuICAgIGlmICh0b2FzdCkge1xuICAgICAgdG9hc3RcbiAgICAgIC5oaWRlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRvYXN0KSB7XG4gICAgICAgICAgdG9hc3QucmVtb3ZlKCk7XG4gICAgICAgICAgdG9hc3QgPSBudWxsO1xuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuYnV0dG9uTGFiZWxzKSB7XG4gICAgdXRpbC5maW5kQ2hpbGQodG9hc3QuX3RvYXN0LCAnYnV0dG9uJykub25jbGljayA9ICgpID0+IHJlc29sdmUoMCk7XG4gIH1cblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvYXN0KTtcbiAgb3B0aW9ucy5jb21waWxlKHRvYXN0KTtcblxuICBjb25zdCBzaG93ID0gKCkgPT4ge1xuICAgIHRvYXN0LnBhcmVudEVsZW1lbnQgJiYgdG9hc3Quc2hvdyhvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKC0xKSwgb3B0aW9ucy50aW1lb3V0KVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIG9wdGlvbnMuZm9yY2UgPyBzaG93KCkgOiBUb2FzdFF1ZXVlLmFkZChzaG93LCBkZWZlcnJlZC5wcm9taXNlKTtcblxuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vdGlmaWNhdGlvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8vIFZhbGlkYXRlIHBhcmFtZXRlcnNcbmNvbnN0IGNoZWNrT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdidXR0b25zJykgfHwgIShvcHRpb25zLmJ1dHRvbnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3B0aW9ucy5idXR0b25zXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBBcnJheS4nKVxuICB9XG4gIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnY2FsbGJhY2snKSAmJiAhKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3B0aW9ucy5jYWxsYmFja1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24uJylcbiAgfVxuICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2NvbXBpbGUnKSAmJiAhKG9wdGlvbnMuY29tcGlsZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmNvbXBpbGVcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uLicpXG4gIH1cbiAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdkZXN0cm95JykgJiYgIShvcHRpb25zLmRlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3B0aW9ucy5kZXN0cm95XCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbi4nKVxuICB9XG59O1xuXG4vLyBBY3Rpb24gU2hlZXRcbmV4cG9ydCBkZWZhdWx0IChvcHRpb25zID0ge30pID0+IHtcbiAgY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIE1haW4gY29tcG9uZW50XG4gIGxldCBhY3Rpb25TaGVldCA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgPG9ucy1hY3Rpb24tc2hlZXRcbiAgICAgICR7b3B0aW9ucy50aXRsZSA/IGB0aXRsZT1cIiR7b3B0aW9ucy50aXRsZX1cImAgOiAnJ31cbiAgICAgICR7b3B0aW9ucy5jYW5jZWxhYmxlID8gJ2NhbmNlbGFibGUnIDogJyd9XG4gICAgICAke29wdGlvbnMubW9kaWZpZXIgPyBgbW9kaWZpZXI9XCIke29wdGlvbnMubW9kaWZpZXJ9XCJgIDogJyd9XG4gICAgICAke29wdGlvbnMubWFza0NvbG9yID8gYG1hc2stY29sb3I9XCIke29wdGlvbnMubWFza0NvbG9yfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLmlkID8gYGlkPVwiJHtvcHRpb25zLmlkfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLmNsYXNzID8gYGNsYXNzPVwiJHtvcHRpb25zLmNsYXNzfVwiYCA6ICcnfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXRcIj48L2Rpdj5cbiAgICA8L29ucy1hY3Rpb24tc2hlZXQ+XG4gIGApO1xuXG4gIC8vIFJlc29sdmUgYWN0aW9uIGFuZCBjbGVhbiB1cFxuICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgY29uc3QgcmVzb2x2ZXIgPSAoZXZlbnQsIGluZGV4ID0gLTEpID0+IHtcbiAgICBpZiAoYWN0aW9uU2hlZXQpIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSAmJiBvcHRpb25zLmRlc3Ryb3koYWN0aW9uU2hlZXQpO1xuXG4gICAgICBhY3Rpb25TaGVldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaWFsb2ctY2FuY2VsJywgcmVzb2x2ZXIsIGZhbHNlKTtcbiAgICAgIGFjdGlvblNoZWV0LnJlbW92ZSgpO1xuICAgICAgYWN0aW9uU2hlZXQgPSBudWxsO1xuXG4gICAgICBvcHRpb25zLmNhbGxiYWNrICYmIG9wdGlvbnMuY2FsbGJhY2soaW5kZXgpO1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbmRleCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIExpbmsgY2FuY2VsIGhhbmRsZXJcbiAgYWN0aW9uU2hlZXQuYWRkRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIHJlc29sdmVyLCBmYWxzZSk7XG5cbiAgLy8gQ3JlYXRlIGJ1dHRvbnMgYW5kIGxpbmsgYWN0aW9uIGhhbmRsZXJcbiAgY29uc3QgYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgb3B0aW9ucy5idXR0b25zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgYnV0dG9uT3B0aW9ucyA9ICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpID8geyBsYWJlbDogaXRlbSB9IDogeyAuLi5pdGVtIH07XG4gICAgaWYgKG9wdGlvbnMuZGVzdHJ1Y3RpdmUgPT09IGluZGV4KSB7XG4gICAgICBidXR0b25PcHRpb25zLm1vZGlmaWVyID0gKGJ1dHRvbk9wdGlvbnMubW9kaWZpZXIgfHwgJycpICsgJyBkZXN0cnVjdGl2ZSc7XG4gICAgfVxuXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvblxuICAgICAgICAke2J1dHRvbk9wdGlvbnMuaWNvbiA/IGBpY29uPVwiJHtidXR0b25PcHRpb25zLmljb259XCJgIDogJyd9XG4gICAgICAgICR7YnV0dG9uT3B0aW9ucy5tb2RpZmllciA/IGBtb2RpZmllcj1cIiR7YnV0dG9uT3B0aW9ucy5tb2RpZmllcn1cImAgOiAnJ31cbiAgICAgID5cbiAgICAgICAgJHtidXR0b25PcHRpb25zLmxhYmVsfVxuICAgICAgPC9vbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5cbiAgICBgKTtcblxuICAgIGJ1dHRvbi5vbmNsaWNrID0gZXZlbnQgPT4gYWN0aW9uU2hlZXQuaGlkZSgpLnRoZW4oKCkgPT4gcmVzb2x2ZXIoZXZlbnQsIGluZGV4KSk7XG4gICAgYnV0dG9ucy5hcHBlbmRDaGlsZChidXR0b24pO1xuICB9KTtcblxuICAvLyBGaW5pc2ggY29tcG9uZW50IGFuZCBhdHRhY2hcbiAgdXRpbC5maW5kQ2hpbGQoYWN0aW9uU2hlZXQsICcuYWN0aW9uLXNoZWV0JykuYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWN0aW9uU2hlZXQpO1xuICBvcHRpb25zLmNvbXBpbGUgJiYgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG5cbiAgLy8gU2hvd1xuICBzZXRJbW1lZGlhdGUoKCkgPT4gYWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgYW5pbWF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbixcbiAgICBhbmltYXRpb25PcHRpb25zOiBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgfSkpO1xuXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcbiIsIi8qKlxuICogTWljcm9FdmVudCAtIHRvIG1ha2UgYW55IGpzIG9iamVjdCBhbiBldmVudCBlbWl0dGVyIChzZXJ2ZXIgb3IgYnJvd3NlcilcbiAqXG4gKiAtIHB1cmUgamF2YXNjcmlwdCAtIHNlcnZlciBjb21wYXRpYmxlLCBicm93c2VyIGNvbXBhdGlibGVcbiAqIC0gZG9udCByZWx5IG9uIHRoZSBicm93c2VyIGRvbXNcbiAqIC0gc3VwZXIgc2ltcGxlIC0geW91IGdldCBpdCBpbW1lZGlhdGVseSwgbm8gbXlzdGVyeSwgbm8gbWFnaWMgaW52b2x2ZWRcbiAqXG4gKiAtIGNyZWF0ZSBhIE1pY3JvRXZlbnREZWJ1ZyB3aXRoIGdvb2RpZXMgdG8gZGVidWdcbiAqICAgLSBtYWtlIGl0IHNhZmVyIHRvIHVzZVxuKi9cblxuLyoqIE5PVEU6IFRoaXMgbGlicmFyeSBpcyBjdXN0b21pemVkIGZvciBPbnNlbiBVSS4gKi9cblxuY29uc3QgTWljcm9FdmVudCAgPSBmdW5jdGlvbigpe307XG5NaWNyb0V2ZW50LnByb3RvdHlwZSAgPSB7XG4gIG9uOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX2V2ZW50c1tldmVudF0gfHwgW107XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGZjdCk7XG4gIH0sXG4gIG9uY2U6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5vZmYoZXZlbnQsIHdyYXBwZXIpO1xuICAgICAgcmV0dXJuIGZjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdGhpcy5vbihldmVudCwgd3JhcHBlcik7XG4gIH0sXG4gIG9mZjogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIGlmIChldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX2V2ZW50c1tldmVudF1cbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oX2ZjdCkge1xuICAgICAgICBpZiAoZmN0KSB7XG4gICAgICAgICAgIHJldHVybiBmY3QgIT09IF9mY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSxcbiAgZW1pdDogZnVuY3Rpb24oZXZlbnQgLyogLCBhcmdzLi4uICovKXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYgKGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2ZW50c1tldmVudF0ubGVuZ3RoOyBpKyspe1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XVtpXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogbWl4aW4gd2lsbCBkZWxlZ2F0ZSBhbGwgTWljcm9FdmVudC5qcyBmdW5jdGlvbiBpbiB0aGUgZGVzdGluYXRpb24gb2JqZWN0XG4gKlxuICogLSByZXF1aXJlKCdNaWNyb0V2ZW50JykubWl4aW4oRm9vYmFyKSB3aWxsIG1ha2UgRm9vYmFyIGFibGUgdG8gdXNlIE1pY3JvRXZlbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGhlIG9iamVjdCB3aGljaCB3aWxsIHN1cHBvcnQgTWljcm9FdmVudFxuKi9cbk1pY3JvRXZlbnQubWl4aW4gID0gZnVuY3Rpb24oZGVzdE9iamVjdCl7XG4gIHZhciBwcm9wcyA9IFsnb24nLCAnb25jZScsICdvZmYnLCAnZW1pdCddO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICsrKXtcbiAgICBpZiAodHlwZW9mIGRlc3RPYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlc3RPYmplY3QucHJvdG90eXBlW3Byb3BzW2ldXSAgPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RPYmplY3RbcHJvcHNbaV1dID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuTWljcm9FdmVudCA9IE1pY3JvRXZlbnQ7XG5leHBvcnQgZGVmYXVsdCBNaWNyb0V2ZW50O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE1pY3JvRXZlbnQgZnJvbSAnLi9taWNyb2V2ZW50JztcblxuY29uc3QgY3JlYXRlID0gKCkgPT4ge1xuXG4gIC8qKlxuICAgKiBAb2JqZWN0IG9ucy5vcmllbnRhdGlvblxuICAgKiBAY2F0ZWdvcnkgdXRpbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXRpbGl0eSBtZXRob2RzIGZvciBvcmllbnRhdGlvbiBkZXRlY3Rpb24uWy9lbl1cbiAgICogICBbamFd55S76Z2i44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz5qSc55+l44Gu44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gm44GE44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGNvbnN0IG9iaiA9IHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgZGV2aWNlIG9yaWVudGF0aW9uIGNoYW5nZXMuWy9lbl1cbiAgICAgKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1BvcnRyYWl0XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3nj77lnKjjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOOBruWgtOWQiOOBq3RydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBzaWduYXR1cmUgb24oZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeOBk+OBruOCpOODmeODs+ODiOOBjOeZuueBq+OBleOCjOOBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9uY2VcbiAgICAgKiBAc2lnbmF0dXJlIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgW2VuXUFkZCBhbiBldmVudCBsaXN0ZW5lciB0aGF0J3Mgb25seSB0cmlnZ2VyZWQgb25jZS5bL2VuXVxuICAgICAqICBbamFd5LiA5bqm44Gg44GR5ZG844Gz5Ye644GV44KM44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAc2lnbmF0dXJlIG9mZihldmVudE5hbWUsIFtsaXN0ZW5lcl0pXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuIElmIHRoZSBsaXN0ZW5lciBpcyBub3Qgc3BlY2lmaWVkIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5bL2VuXVxuICAgICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CC44KC44GX44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44Gq44GL44Gj44Gf5aC05ZCI44Gr44Gv44CB44Gd44Gu44Kk44OZ44Oz44OI44Gr57SQ44Gl44GP5YWo44Gm44Gu44Kk44OZ44Oz44OI44Oq44K544OK44O844GM5YmK6Zmk44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3liYrpmaTjgZnjgovjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLy8gYWN0dWFsIGltcGxlbWVudGF0aW9uIHRvIGRldGVjdCBpZiB3aGV0aGVyIGN1cnJlbnQgc2NyZWVuIGlzIHBvcnRyYWl0IG9yIG5vdFxuICAgIF9pc1BvcnRyYWl0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgaXNQb3J0cmFpdFxuICAgICAqIEBzaWduYXR1cmUgaXNQb3J0cmFpdCgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG4gICAgaXNQb3J0cmFpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzTGFuZHNjYXBlXG4gICAgICogQHNpZ25hdHVyZSBpc0xhbmRzY2FwZSgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgbGFuZHNjYXBlIG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njga7loLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzTGFuZHNjYXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pc1BvcnRyYWl0KCk7XG4gICAgfSxcblxuICAgIF9pbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRPTUNvbnRlbnRMb2FkZWQuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfb25ET01Db250ZW50TG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24oKTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfSxcblxuICAgIF9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgaWYgKCEoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpKSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDAgPyBpc1BvcnRyYWl0IDogIWlzUG9ydHJhaXQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDkwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gdGhpcy5faXNQb3J0cmFpdCgpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgZGltZW5zaW9ucyB0byBjaGFuZ2UgYmVjYXVzZVxuICAgICAgLy8gb2YgQW5kcm9pZCBpbmNvbnNpc3RlbmN5LlxuICAgICAgbGV0IG5JdGVyID0gMDtcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBuSXRlcisrO1xuXG4gICAgICAgIGNvbnN0IHcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICBpZiAoKGlzUG9ydHJhaXQgJiYgdyA8PSBoKSB8fFxuICAgICAgICAgICAoIWlzUG9ydHJhaXQgJiYgdyA+PSBoKSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IGlzUG9ydHJhaXR9KTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChuSXRlciA9PT0gNTApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDIwKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIG9uIG5vdCBtb2JpbGUgYnJvd3Nlci5cbiAgICBfb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCl9KTtcbiAgICB9XG4gIH07XG5cbiAgTWljcm9FdmVudC5taXhpbihvYmopO1xuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGUoKS5faW5pdCgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5tb2RpZmllclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBVdGlsaXR5IG1ldGhvZHMgdG8gY2hhbmdlIG1vZGlmaWVyIGF0dHJpYnV0ZXMgb2YgT25zZW4gVUkgZWxlbWVudHMuLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiBvbnMubW9kaWZpZXIuYWRkKG15T25zSW5wdXRFbGVtZW50LCAndW5kZXJiYXInKTtcbiAqIG9ucy5tb2RpZmllci50b2dnbGUobXlPbnNUb2FzdEVsZW1lbnQsICdjdXN0b20tbW9kaWZpZXInKTtcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkXG4gICAqIEBzaWduYXR1cmUgYWRkKGVsZW1lbnQsIG1vZGlmaWVyIFssIG1vZGlmaWVyXSlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFkZCB0aGUgc3BlY2lmaWVkIG1vZGlmaWVycyB0byB0aGUgZWxlbWVudCBpZiB0aGV5IGFyZSBub3QgYWxyZWFkeSBpbmNsdWRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllclxuICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgYWRkOiAoZWxlbWVudCwgLi4ubW9kaWZpZXJzKSA9PiBtb2RpZmllcnMuZm9yRWFjaChtb2RpZmllciA9PiB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsIG1vZGlmaWVyKSksXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgKiBAc2lnbmF0dXJlIHJlbW92ZShlbGVtZW50LCBtb2RpZmllciBbLCBtb2RpZmllcl0pXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZW1vdmUgdGhlIHNwZWNpZmllZCBtb2RpZmllcnMgZnJvbSB0aGUgZWxlbWVudCBpZiB0aGV5IGFyZSBpbmNsdWRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllclxuICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgcmVtb3ZlOiAoZWxlbWVudCwgLi4ubW9kaWZpZXJzKSA9PiBtb2RpZmllcnMuZm9yRWFjaChtb2RpZmllciA9PiB1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsIG1vZGlmaWVyKSksXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAqIEBzaWduYXR1cmUgY29udGFpbnMoZWxlbWVudCwgbW9kaWZpZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGVjayB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXIgaXMgaW5jbHVkZWQgaW4gdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogICBbZW5dYHRydWVgIHdoZW4gdGhlIHNwZWNpZmllZCBtb2RpZmllciBpcyBmb3VuZCBpbiB0aGUgZWxlbWVudCdzIGBtb2RpZmllcmAgYXR0cmlidXRlLiBgZmFsc2VgIG90aGVyd2lzZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY29udGFpbnM6IHV0aWwuaGFzTW9kaWZpZXIsXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShlbGVtZW50LCBtb2RpZmllciBbLCBmb3JjZV0pXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdGhlIHNwZWNpZmllZCBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllclxuICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9yY2VcbiAgICogICBbZW5dSWYgaXQgZXZhbHVhdGVzIHRvIHRydWUsIGFkZCBzcGVjaWZpZWQgbW9kaWZpZXIgdmFsdWUsIGFuZCBpZiBpdCBldmFsdWF0ZXMgdG8gZmFsc2UsIHJlbW92ZSBpdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgdG9nZ2xlOiB1dGlsLnRvZ2dsZU1vZGlmaWVyXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBNaWNyb0V2ZW50IGZyb20gJy4vbWljcm9ldmVudCc7XG5cbmNvbnN0IHNvZnR3YXJlS2V5Ym9hcmQgPSBuZXcgTWljcm9FdmVudCgpO1xuc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuXG5jb25zdCBvblNob3cgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSB0cnVlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ3Nob3cnKTtcbn07XG5cbmNvbnN0IG9uSGlkZSA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2hpZGUnKTtcbn07XG5cbmNvbnN0IGJpbmRFdmVudHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcnRpbm1vc2UvY29yZG92YS1rZXlib2FyZC9ibG9iLzk1ZjNkYTNhMzhkOGY4ZTFmYTQxZmJmNDAxNDUzNTJjMTM1MzVhMDAvUkVBRE1FLm1kXG4gICAgS2V5Ym9hcmQub25zaG93ID0gb25TaG93O1xuICAgIEtleWJvYXJkLm9uaGlkZSA9IG9uSGlkZTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29yZG92YS5wbHVnaW5zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29yZG92YS5wbHVnaW5zLktleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmlmdHljby9pb25pYy1wbHVnaW5zLWtleWJvYXJkL2Jsb2IvY2EyN2VjZi9SRUFETUUubWRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIG9uU2hvdyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZGhpZGUnLCBvbkhpZGUpO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IG5vUGx1Z2luRXJyb3IgPSAoKSA9PiB7XG4gIHV0aWwud2Fybignb25zLWtleWJvYXJkOiBDb3Jkb3ZhIEtleWJvYXJkIHBsdWdpbiBpcyBub3QgcHJlc2VudC4nKTtcbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xuICBpZiAoIWJpbmRFdmVudHMoKSkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWFjdGl2ZV0nKSB8fFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1pbmFjdGl2ZV0nKSkge1xuICAgICAgbm9QbHVnaW5FcnJvcigpO1xuICAgIH1cblxuICAgIHNvZnR3YXJlS2V5Ym9hcmQub24gPSBub1BsdWdpbkVycm9yO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29mdHdhcmVLZXlib2FyZDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IGdlbmVyYXRlSWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpKys7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIERvb3IgbG9ja2luZyBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb29yTG9jayB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fbG9ja0xpc3QgPSBbXTtcbiAgICB0aGlzLl93YWl0TGlzdCA9IFtdO1xuICAgIHRoaXMuX2xvZyA9IG9wdGlvbnMubG9nIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBsb2NrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQ2FsbGJhY2sgZm9yIHVubG9ja2luZy5cbiAgICovXG4gIGxvY2soKSB7XG4gICAgY29uc3QgdW5sb2NrID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdW5sb2NrKHVubG9jayk7XG4gICAgfTtcbiAgICB1bmxvY2suaWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5fbG9ja0xpc3QucHVzaCh1bmxvY2spO1xuICAgIHRoaXMuX2xvZygnbG9jazogJyArICh1bmxvY2suaWQpKTtcblxuICAgIHJldHVybiB1bmxvY2s7XG4gIH1cblxuICBfdW5sb2NrKGZuKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9sb2NrTGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgaW4gdGhlIGxvY2sgbGlzdC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2NrTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuX2xvZygndW5sb2NrOiAnICsgZm4uaWQpO1xuXG4gICAgdGhpcy5fdHJ5VG9GcmVlV2FpdExpc3QoKTtcbiAgfVxuXG4gIF90cnlUb0ZyZWVXYWl0TGlzdCgpIHtcbiAgICB3aGlsZSAoIXRoaXMuaXNMb2NrZWQoKSAmJiB0aGlzLl93YWl0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl93YWl0TGlzdC5zaGlmdCgpKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZm9yIHdhaXRpbmcgdW5sb2NrZWQgZG9vci5cbiAgICpcbiAgICogQHBhcmFtcyB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIG9uIHVubG9ja2luZyB0aGUgZG9vciBjb21wbGV0ZWx5LlxuICAgKi9cbiAgd2FpdFVubG9jayhjYWxsYmFjaykge1xuICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYWxsYmFjayBwYXJhbSBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgdGhpcy5fd2FpdExpc3QucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja0xpc3QubGVuZ3RoID4gMDtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5cbi8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIGdsb2JhbCBQYWdlTG9hZGVyLlxuZnVuY3Rpb24gbG9hZFBhZ2Uoe3BhZ2UsIHBhcmVudCwgcGFyYW1zID0ge319LCBkb25lKSB7XG4gIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBjb25zdCBwYWdlRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgZG9uZShwYWdlRWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1bmxvYWRQYWdlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuX2Rlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIGVsZW1lbnQuX2Rlc3Ryb3koKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQYWdlTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2FkZXIsIHVubG9hZGVyKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBsb2FkZXIgOiBsb2FkUGFnZTtcbiAgICB0aGlzLl91bmxvYWRlciA9IHVubG9hZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24gPyB1bmxvYWRlciA6IHVubG9hZFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGludGVybmFsIGxvYWRlciBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG4gIHNldCBpbnRlcm5hbExvYWRlcihmbikge1xuICAgIGlmICghKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVyID0gZm47XG4gIH1cblxuICBnZXQgaW50ZXJuYWxMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3B0aW9ucy5wYWdlXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9ucy5wYXJlbnQgQSBsb2NhdGlvbiB0byBsb2FkIHBhZ2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXJhbXNdIEV4dHJhIHBhcmFtZXRlcnMgZm9yIG9ucy1wYWdlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIFRha2UgYW4gb2JqZWN0IHRoYXQgaGFzIFwiZWxlbWVudFwiIHByb3BlcnR5IGFuZCBcInVubG9hZFwiIGZ1bmN0aW9uLlxuICAgKi9cbiAgbG9hZCh7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgICB0aGlzLl9sb2FkZXIoe3BhZ2UsIHBhcmVudCwgcGFyYW1zfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgaWYgKCEocGFnZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBFcnJvcigncGFnZUVsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgICAgfVxuXG4gICAgICBkb25lKHBhZ2VFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHVubG9hZChwYWdlRWxlbWVudCkge1xuICAgIGlmICghKHBhZ2VFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdwYWdlRWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdW5sb2FkZXIocGFnZUVsZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKCk7XG5cbmV4cG9ydCBjb25zdCBpbnN0YW50UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKFxuICBmdW5jdGlvbih7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KHBhZ2UudHJpbSgpKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICBkb25lKGVsZW1lbnQpO1xuICB9LFxuICB1bmxvYWRQYWdlXG4pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi9hbmltaXQnXG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgbm90aWZpY2F0aW9uIGZyb20gJy4vbm90aWZpY2F0aW9uJztcbmltcG9ydCBhY3Rpb25TaGVldCBmcm9tICcuL2FjdGlvbi1zaGVldCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi9vcmllbnRhdGlvbic7XG5pbXBvcnQgbW9kaWZpZXIgZnJvbSAnLi9tb2RpZmllcic7XG5pbXBvcnQgc29mdHdhcmVLZXlib2FyZCBmcm9tICcuL3NvZnR3YXJlLWtleWJvYXJkJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24nO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuL2F1dG9zdHlsZSc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi9kb29ybG9jayc7XG5pbXBvcnQgeyBkZWZhdWx0UGFnZUxvYWRlciwgUGFnZUxvYWRlciB9IGZyb20gJy4vcGFnZS1sb2FkZXInO1xuXG4vKipcbiAqIEBvYmplY3Qgb25zXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtqYV1PbnNlbiBVSeOBp+WIqeeUqOOBp+OBjeOCi+OCsOODreODvOODkOODq+OBquOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiAgIFtlbl1BIGdsb2JhbCBvYmplY3QgdGhhdCdzIHVzZWQgaW4gT25zZW4gVUkuIFsvZW5dXG4gKi9cbmNvbnN0IG9ucyA9IHtcbiAgYW5pbWl0LFxuICBkZWZhdWx0UGFnZUxvYWRlcixcbiAgZWxlbWVudHM6IHt9LFxuICBHZXN0dXJlRGV0ZWN0b3IsXG4gIG1vZGlmaWVyLFxuICBub3RpZmljYXRpb24sXG4gIG9yaWVudGF0aW9uLFxuICBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbixcbiAgUGFnZUxvYWRlcixcbiAgcGxhdGZvcm0sXG4gIHNvZnR3YXJlS2V5Ym9hcmQsXG4gIF9hdXRvU3R5bGU6IGF1dG9TdHlsZSxcbiAgX2ludGVybmFsOiBpbnRlcm5hbCxcbiAgX3JlYWR5TG9jazogbmV3IERvb3JMb2NrKCksXG4gIF91dGlsOiB1dGlsLFxufTtcblxub25zLnBsYXRmb3JtLnNlbGVjdCgod2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvcGxhdGZvcm09KFtcXHctXSspLykgfHwgW10pWzFdKTtcblxud2FpdERldmljZVJlYWR5KCk7XG5cbi8qKlxuICogQG1ldGhvZCBpc1JlYWR5XG4gKiBAc2lnbmF0dXJlIGlzUmVhZHkoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFd5Yid5pyf5YyW44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmV0dXJucyB0cnVlIGlmIE9uc2VuIFVJIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOOBmeOBp+OBq+WIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1JlYWR5ID0gKCkgPT4ge1xuICByZXR1cm4gIW9ucy5fcmVhZHlMb2NrLmlzTG9ja2VkKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaXNXZWJWaWV3XG4gKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBDb3Jkb3ZhLlsvZW5dXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmlzV2ViVmlldyA9IG9ucy5wbGF0Zm9ybS5pc1dlYlZpZXc7XG5cbi8qKlxuICogQG1ldGhvZCByZWFkeVxuICogQHNpZ25hdHVyZSByZWFkeShjYWxsYmFjaylcbiAqIEBkZXNjcmlwdGlvblxuICogICBbamFd44Ki44OX44Oq44Gu5Yid5pyf5YyW44Gr5Yip55So44GZ44KL44Oh44K944OD44OJ44Gn44GZ44CC5rih44GV44KM44Gf6Zai5pWw44Gv44CBT25zZW4gVUnjga7liJ3mnJ/ljJbjgYzntYLkuobjgZfjgabjgYTjgovmmYLngrnjgaflv4XjgZrlkbzjgbDjgozjgb7jgZnjgIJbL2phXVxuICogICBbZW5dTWV0aG9kIHVzZWQgdG8gd2FpdCBmb3IgYXBwIGluaXRpYWxpemF0aW9uLiBXYWl0cyBmb3IgYERPTUNvbnRlbnRMb2FkZWRgIGFuZCBgZGV2aWNlcmVhZHlgLCB3aGVuIG5lY2Vzc2FyeSwgYmVmb3JlIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2suWy9lbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIE9uc2VuIFVJIGhhcyBiZWVuIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOWIneacn+WMluOBjOWujOS6huOBl+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5yZWFkeSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIG9ucy5fcmVhZHlMb2NrLndhaXRVbmxvY2soY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lclxuICogQHNpZ25hdHVyZSBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyKGxpc3RlbmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiBkZXZpY2UgYmFjayBidXR0b24gaXMgcHJlc3NlZC4gTXVzdCBiZSBjYWxsZWQgb24gYG9ucy5yZWFkeWAuWy9lbl1cbiAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBjOaKvOOBleOCjOOBn+aZguOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNldCBkZWZhdWx0IGhhbmRsZXIgZm9yIGRldmljZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Gf44KB44Gu44OH44OV44Kp44Or44OI44Gu44OP44Oz44OJ44Op44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLnNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICBpZiAoIW9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGFmdGVyIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcbiAgfVxuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5zZXRMaXN0ZW5lcihsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1EaXNhYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLiBNdXN0IGJlIGNhbGxlZCBvbiBgb25zLnJlYWR5YC5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOBquOBhOOCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBhZnRlciBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gIH1cbiAgaW50ZXJuYWwuZGJiRGlzcGF0Y2hlci5kaXNhYmxlKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKVxuICogQGRlc2NyaXB0aW9uXG4gKiBbZW5dRW5hYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLiBNdXN0IGJlIGNhbGxlZCBvbiBgb25zLnJlYWR5YC5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIW9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGFmdGVyIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcbiAgfVxuICBpbnRlcm5hbC5kYmJEaXNwYXRjaGVyLmVuYWJsZSgpO1xufTtcblxub25zLmZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgaW50ZXJuYWwuZGJiRGlzcGF0Y2hlci5maXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgc3RhdHVzIGJhciBmaWxsIGZlYXR1cmUgb24gaU9TNyBhbmQgYWJvdmUgKGV4Y2VwdCBmb3IgaVBob25lIFgpLiBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgYG9ucy5yZWFkeWAuWy9lbl1cbiAqICAgW2phXWlPUzfku6XkuIrvvIhpUGhvbmUgWOOBr+mZpOOBj++8ieOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gIH1cbiAgaW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZSAoZXhjZXB0IGZvciBpUGhvbmUgWCkuIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBgb25zLnJlYWR5YC5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iu+8iGlQaG9uZSBY44Gv6Zmk44GP77yJ44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS54Sh5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gIH1cbiAgaW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgbW9ja1N0YXR1c0JhclxuICogQHNpZ25hdHVyZSBtb2NrU3RhdHVzQmFyKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlcyBhIHN0YXRpYyBlbGVtZW50IHNpbWlsYXIgdG8gaU9TIHN0YXR1cyBiYXIuIE9ubHkgdXNlZnVsIGZvciBicm93c2VyIHRlc3RpbmcuIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBgb25zLnJlYWR5YC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLm1vY2tTdGF0dXNCYXIgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG5cbiAgY29uc3QgbW9jayA9ICgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkuY2hpbGRyZW5bMF0gfHwgIWRvY3VtZW50LmJvZHkuY2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdvbnMtc3RhdHVzLWJhci1tb2NrJykpIHtcbiAgICAgIGNvbnN0IGFuZHJvaWQgPSBwbGF0Zm9ybS5pc0FuZHJvaWQoKSwgaSA9IGkgPT4gYDxpIGNsYXNzPVwiJHtpLnNwbGl0KCctJylbMF19ICR7aX1cIj48L2k+YDtcbiAgICAgIGNvbnN0IGxlZnQgPSBhbmRyb2lkID8gYCR7aSgnem1kaS10d2l0dGVyJyl9ICR7aSgnem1kaS1nb29nbGUtcGxheScpfWAgOiBgTm8gU0lNICR7aSgnZmEtd2lmaScpfWAsXG4gICAgICAgIGNlbnRlciA9IGFuZHJvaWQgPyAnJyA6ICcxMjoyOCBQTScsXG4gICAgICAgIHJpZ2h0ID0gYW5kcm9pZCA/IGAke2koJ3ptZGktbmV0d29yaycpfSAke2koJ3ptZGktd2lmaScpfSAke2koJ3ptZGktYmF0dGVyeScpfSAxMjoyOCBQTWAgOiBgODAlICR7aSgnZmEtYmF0dGVyeS10aHJlZS1xdWFydGVycycpfWA7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICAgYDxkaXYgY2xhc3M9XCJvbnMtc3RhdHVzLWJhci1tb2NrICR7YW5kcm9pZCA/ICdhbmRyb2lkJyA6ICdpb3MnfVwiPmAgK1xuICAgICAgICAgIGA8ZGl2PiR7bGVmdH08L2Rpdj48ZGl2PiR7Y2VudGVyfTwvZGl2PjxkaXY+JHtyaWdodH08L2Rpdj5gICtcbiAgICAgICAgYDwvZGl2PmBcbiAgICAgICksIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIGRvY3VtZW50LmJvZHlcbiAgICA/IG1vY2soKVxuICAgIDogaW50ZXJuYWwud2FpdERPTUNvbnRlbnRMb2FkZWQobW9jayk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFsbCBhbmltYXRpb25zLiBDb3VsZCBiZSBoYW5keSBmb3IgdGVzdGluZyBhbmQgb2xkZXIgZGV2aWNlcy5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5YWo44Gm54Sh5Yq544Gr44GX44G+44GZ44CC44OG44K544OI44Gu6Zqb44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVBbmltYXRpb25zXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgYW5pbWF0aW9ucyAoZGVmYXVsdCkuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID0gZmFsc2U7XG59O1xuXG5vbnMuX2Rpc2FibGVXYXJuaW5ncyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLndhcm5pbmdzRGlzYWJsZWQgPSB0cnVlO1xufTtcblxub25zLl9lbmFibGVXYXJuaW5ncyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLndhcm5pbmdzRGlzYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0eWxpbmdcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBhdXRvbWF0aWMgc3R5bGluZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmRpc2FibGVBdXRvU3R5bGluZyA9IGF1dG9TdHlsZS5kaXNhYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0eWxpbmdcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgYXV0b21hdGljIHN0eWxpbmcgYmFzZWQgb24gT1MgKGRlZmF1bHQpLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0eWxpbmcgPSBhdXRvU3R5bGUuZW5hYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUljb25BdXRvUHJlZml4XG4gKiBAc2lnbmF0dXJlIGRpc2FibGVJY29uQXV0b1ByZWZpeCgpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgYWRkaW5nIGBmYS1gIHByZWZpeCBhdXRvbWF0aWNhbGx5IHRvIGBvbnMtaWNvbmAgY2xhc3Nlcy4gVXNlZnVsIHdoZW4gaW5jbHVkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZGlzYWJsZUljb25BdXRvUHJlZml4ID0gKCkgPT4ge1xuICBpZiAoIW9ucy5lbGVtZW50cy5JY29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yIChgRXhwZWN0ZWQgJ29ucy1pY29uJyBDdXN0b20gRWxlbWVudCB0byBiZSByZWdpc3RlcmVkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLmApO1xuICB9XG4gIG9ucy5lbGVtZW50cy5JY29uLnNldEF1dG9QcmVmaXgoZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGZvcmNlUGxhdGZvcm1TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGZvcmNlUGxhdGZvcm1TdHlsaW5nKHBsYXRmb3JtKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZWZyZXNoIHN0eWxpbmcgZm9yIHRoZSBnaXZlbiBwbGF0Zm9ybS4gT25seSB1c2VmdWwgZm9yIGRlbW9zLiBVc2UgYG9ucy5wbGF0Zm9ybS5zZWxlY3QoLi4uKWAgaW5zdGVhZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm0gTmV3IHBsYXRmb3JtIHRvIHN0eWxlIHRoZSBlbGVtZW50cy5cbiAqL1xub25zLmZvcmNlUGxhdGZvcm1TdHlsaW5nID0gbmV3UGxhdGZvcm0gPT4ge1xuICBvbnMuZW5hYmxlQXV0b1N0eWxpbmcoKTtcbiAgb25zLnBsYXRmb3JtLnNlbGVjdChuZXdQbGF0Zm9ybSB8fCAnaW9zJyk7XG5cbiAgb25zLl91dGlsLmFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWlmJykge1xuICAgICAgICBlbGVtZW50Ll9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUubWF0Y2goL15vbnMtL2kpKSB7XG4gICAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBwcmVsb2FkXG4gKiBAc2lnbmF0dXJlIHByZWxvYWQodGVtcGxhdGVQYXRocylcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0ZW1wbGF0ZVBhdGhzXG4gKiAgIFtlbl1TZXQgb2YgSFRNTCBmaWxlIHBhdGhzIGNvbnRhaW5pbmcgJ29ucy1wYWdlJyBlbGVtZW50cy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgdGhlIHRlbXBsYXRlcyBhcmUgY2FjaGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TZXBhcmF0ZWQgZmlsZXMgbmVlZCB0byBiZSByZXF1ZXN0ZWQgb24gZGVtYW5kIGFuZCB0aGlzIGNhbiBzbGlnaHRseSBkZWxheSBwdXNoaW5nIG5ldyBwYWdlcy4gVGhpcyBtZXRob2QgcmVxdWVzdHMgYW5kIGNhY2hlcyB0ZW1wbGF0ZXMgZm9yIGxhdGVyIHVzZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLnByZWxvYWQgPSBmdW5jdGlvbih0ZW1wbGF0ZXMgPSBbXSkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoKHRlbXBsYXRlcyBpbnN0YW5jZW9mIEFycmF5ID8gdGVtcGxhdGVzIDogW3RlbXBsYXRlc10pLm1hcCh0ZW1wbGF0ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciAoJ0V4cGVjdGVkIHN0cmluZyBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZW9mIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHRlbXBsYXRlKTtcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZUVsZW1lbnRcbiAqIEBzaWduYXR1cmUgY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICogICBbZW5dRWl0aGVyIGFuIEhUTUwgZmlsZSBwYXRoLCBhbiBgPG9ucy10ZW1wbGF0ZT5gIGlkIG9yIGFuIEhUTUwgc3RyaW5nIHN1Y2ggYXMgYCc8ZGl2IGlkPVwiZm9vXCI+aG9nZTwvZGl2PidgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbnxIVE1MRWxlbWVudH0gW29wdGlvbnMuYXBwZW5kXVxuICogICBbZW5dV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQgdG8gdGhlIERPTS4gIERlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGB0cnVlYCB2YWx1ZSBpcyBnaXZlbiwgYGRvY3VtZW50LmJvZHlgIHdpbGwgYmUgdXNlZCBhcyB0aGUgdGFyZ2V0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMuaW5zZXJ0QmVmb3JlXVxuICogICBbZW5dUmVmZXJlbmNlIG5vZGUgdGhhdCBiZWNvbWVzIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIG5ldyBub2RlIChgb3B0aW9ucy5hcHBlbmRgIGVsZW1lbnQpLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR8UHJvbWlzZX1cbiAqICAgW2VuXUlmIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSB3YXMgYW4gaW5saW5lIEhUTUwgc3RyaW5nLCBpdCByZXR1cm5zIHRoZSBuZXcgZWxlbWVudC4gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgZWxlbWVudC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgbmV3IGVsZW1lbnQgZnJvbSBhIHRlbXBsYXRlLiBCb3RoIGlubGluZSBIVE1MIGFuZCBleHRlcm5hbCBmaWxlcyBhcmUgc3VwcG9ydGVkIGFsdGhvdWdoIHRoZSByZXR1cm4gdmFsdWUgZGlmZmVycy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmNyZWF0ZUVsZW1lbnQgPSAodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnRyaW0oKTtcblxuICBjb25zdCBjcmVhdGUgPSBodG1sID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcblxuICAgIGlmIChvcHRpb25zLmFwcGVuZCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5hcHBlbmQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IG9wdGlvbnMuYXBwZW5kIDogZG9jdW1lbnQuYm9keTtcbiAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgb3B0aW9ucy5pbnNlcnRCZWZvcmUgfHwgbnVsbCk7XG4gICAgICBvcHRpb25zLmxpbmsgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmxpbmsoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJzwnID8gY3JlYXRlKHRlbXBsYXRlKSA6IGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmModGVtcGxhdGUpLnRoZW4oY3JlYXRlKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVQb3BvdmVyXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZVBvcG92ZXIocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhcmVudFNjb3BlXVxuICogICBbZW5dUGFyZW50IHNjb3BlIG9mIHRoZSBkaWFsb2cuIFVzZWQgdG8gYmluZCBtb2RlbHMgYW5kIGFjY2VzcyBzY29wZSBtZXRob2RzIGZyb20gdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw5YaF44Gn5Yip55So44GZ44KL6Kaq44K544Kz44O844OX44KS5oyH5a6a44GX44G+44GZ44CC44OA44Kk44Ki44Ot44Kw44GL44KJ44Oi44OH44Or44KE44K544Kz44O844OX44Gu44Oh44K944OD44OJ44Gr44Ki44Kv44K744K544GZ44KL44Gu44Gr5L2/44GE44G+44GZ44CC44GT44Gu44OR44Op44Oh44O844K/44GvQW5ndWxhckpT44OQ44Kk44Oz44OH44Kj44Oz44Kw44Gn44Gu44G/5Yip55So44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBwb3BvdmVyIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBwb3BvdmVyIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Od44OD44OX44Kq44O844OQ44O844Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZURpYWxvZ1xuICogQHNpZ25hdHVyZSBjcmVhdGVEaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZUFsZXJ0RGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZUFsZXJ0RGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGNvbnRhaW5pbmcgYSA8b25zLWFsZXJ0LWRpYWxvZz4gY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBhbGVydCBkaWFsb2cgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIGFsZXJ0IGRpYWxvZyBpbnN0YW5jZSBmcm9tIGEgdGVtcGxhdGUuWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5jcmVhdGVQb3BvdmVyID0gb25zLmNyZWF0ZURpYWxvZyA9IG9ucy5jcmVhdGVBbGVydERpYWxvZyA9ICh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSA9PiBvbnMuY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgeyBhcHBlbmQ6IHRydWUsIC4uLm9wdGlvbnMgfSk7XG5cbi8qKlxuICogQG1ldGhvZCBvcGVuQWN0aW9uU2hlZXRcbiAqIEBzaWduYXR1cmUgb3BlbkFjdGlvblNoZWV0KG9wdGlvbnMpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3dzIGFuIGluc3RhbnQgQWN0aW9uIFNoZWV0IGFuZCBsZXRzIHRoZSB1c2VyIGNob29zZSBhbiBhY3Rpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uc11cbiAqICAgW2VuXVJlcHJlc2VudCBlYWNoIGJ1dHRvbiBvZiB0aGUgYWN0aW9uIHNoZWV0IGZvbGxvd2luZyB0aGUgc3BlY2lmaWVkIG9yZGVyLiBFdmVyeSBpdGVtIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgbGFiZWwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYGxhYmVsYCwgYGljb25gIGFuZCBgbW9kaWZpZXJgIHByb3BlcnRpZXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1PcHRpb25hbCB0aXRsZSBmb3IgdGhlIGFjdGlvbiBzaGVldC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZXN0cnVjdGl2ZV1cbiAqICAgW2VuXU9wdGlvbmFsIGluZGV4IG9mIHRoZSBcImRlc3RydWN0aXZlXCIgYnV0dG9uIChvbmx5IGZvciBpT1MpLiBJdCBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBidXR0b24gYXJyYXkgYXMgd2VsbC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsYWJsZV1cbiAqICAgW2VuXVdoZXRoZXIgdGhlIGFjdGlvbiBzaGVldCBjYW4gYmUgY2FuY2VsZWQgYnkgdGFwcGluZyBvbiB0aGUgYmFja2dyb3VuZCBtYXNrIG9yIG5vdC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGF0dHJpYnV0ZSBvZiB0aGUgYWN0aW9uIHNoZWV0LiBFLmcuIGAnZGVzdHJ1Y3RpdmUnYC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tYXNrQ29sb3JdXG4gKiAgIFtlbl1PcHRpb25hbGx5IGNoYW5nZSB0aGUgYmFja2dyb3VuZCBtYXNrIGNvbG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGVsZW1lbnQncyBpZCBhdHRyaWJ1dGUuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2xhc3NdXG4gKiAgIFtlbl1UaGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgd2hlbiB0aGUgYWN0aW9uIHNoZWV0IGlzIGNsb3NlZC4gVGhlIHJlc29sdmUgdmFsdWUgaXMgZWl0aGVyIHRoZSBpbmRleCBvZiB0aGUgdGFwcGVkIGJ1dHRvbiBvciAtMSB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMub3BlbkFjdGlvblNoZWV0ID0gYWN0aW9uU2hlZXQ7XG5cbi8qKlxuICogQG1ldGhvZCByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyXG4gKiBAc2lnbmF0dXJlIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIocGFnZSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGEgYDx0ZW1wbGF0ZT5gIGlkLlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1JZiBubyBwYWdlIGlzIGRlZmluZWQgZm9yIHRoZSBgb25zLWxvYWRpbmctcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSBpdCB3aWxsIHdhaXQgZm9yIHRoaXMgbWV0aG9kIGJlaW5nIGNhbGxlZCBiZWZvcmUgbG9hZGluZyB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWxvYWRpbmctcGxhY2Vob2xkZXLjga7lsZ7mgKflgKTjgajjgZfjgabjg5rjg7zjgrjjgYzmjIflrprjgZXjgozjgabjgYTjgarjgYTloLTlkIjjga/jgIHjg5rjg7zjgrjjg63jg7zjg4nliY3jgavlkbzjgbDjgozjgotvbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcuWHpueQhuOBjOihjOOCj+OCjOOCi+OBvuOBp+ihqOekuuOBleOCjOOBvuOBm+OCk+OAglsvamFdXG4gKi9cbm9ucy5yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyID0gKHBhZ2UsIGxpbmspID0+IHtcbiAgY29uc3QgZWxlbWVudHMgPSBvbnMuX3V0aWwuYXJyYXlGcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLWxvYWRpbmctcGxhY2Vob2xkZXJdJykpO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBvbnMtbG9hZGluZy1wbGFjZWhvbGRlciBleGlzdHMuJyk7XG4gIH1cblxuICBlbGVtZW50c1xuICAgIC5maWx0ZXIoZWxlbWVudCA9PiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSlcbiAgICAuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicsIHBhZ2UpO1xuICAgICAgb25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKGVsZW1lbnQsIHBhZ2UsIGxpbmspO1xuICAgIH0pO1xufTtcblxuXG5vbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycyA9IGZ1bmN0aW9uKCkge1xuICBvbnMucmVhZHkoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XG4gICAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5vbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihwYXJlbnQsIHBhZ2UsIGxpbmsgPSAoKGVsLCBkb25lKSA9PiBkb25lKCkpKSB7XG4gIHBhZ2UgJiYgb25zLmNyZWF0ZUVsZW1lbnQocGFnZSlcbiAgICAudGhlbihlbGVtZW50ID0+IHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIGxpbmsoZWxlbWVudCwgKCkgPT4ge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgfSk7XG4gICAgfSlcbiAgICAuY2F0Y2goZXJyb3IgPT4gUHJvbWlzZS5yZWplY3QoJ1VuYWJsZWQgdG8gcmVzb2x2ZSBwbGFjZWhvbGRlcjogJyArIGVycm9yKSk7XG59O1xuXG5mdW5jdGlvbiB3YWl0RGV2aWNlUmVhZHkoKSB7XG4gIGNvbnN0IHVubG9ja0RldmljZVJlYWR5ID0gb25zLl9yZWFkeUxvY2subG9jaygpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICBpZiAob25zLmlzV2ViVmlldygpKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCB1bmxvY2tEZXZpY2VSZWFkeSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmxvY2tEZXZpY2VSZWFkeSgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEBtZXRob2QgZ2V0U2NyaXB0UGFnZVxuICogQHNpZ25hdHVyZSBnZXRTY3JpcHRQYWdlKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQWNjZXNzIHRoZSBsYXN0IGNyZWF0ZWQgcGFnZSBmcm9tIHRoZSBjdXJyZW50IGBzY3JpcHRgIHNjb3BlLiBPbmx5IHdvcmtzIGluc2lkZSBgPHNjcmlwdD48L3NjcmlwdD5gIHRhZ3MgdGhhdCBhcmUgZGlyZWN0IGNoaWxkcmVuIG9mIGBvbnMtcGFnZWAgZWxlbWVudC4gVXNlIHRoaXMgdG8gYWRkIGxpZmVjeWNsZSBob29rcyB0byBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqICAgW2VuXVJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFnZSBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5jb25zdCBnZXRDUyA9ICdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCA/ICgpID0+IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiAoKSA9PiBkb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoIC0gMV07XG5vbnMuZ2V0U2NyaXB0UGFnZSA9ICgpID0+IGdldENTKCkgJiYgL29ucy1wYWdlL2kudGVzdChnZXRDUygpLnBhcmVudEVsZW1lbnQudGFnTmFtZSkgJiYgZ2V0Q1MoKS5wYXJlbnRFbGVtZW50IHx8IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IG9ucztcbiIsIi8vIEZvciBAb25zZW51aS9jdXN0b20tZWxlbWVudHNcbmlmICh3aW5kb3cuY3VzdG9tRWxlbWVudHMpIHsgLy8gZXZlbiBpZiBuYXRpdmUgQ0UxIGltcGwgZXhpc3RzLCB1c2UgcG9seWZpbGxcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZm9yY2VQb2x5ZmlsbCA9IHRydWU7XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYikgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSAkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikgeyBuZXcgQyhpdGVyKTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKCksIHRhcmdldCwgQyk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIHByb3RvLmNsZWFyKSBkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcbiIsImNvbnN0IHJlc2VydmVkVGFnTGlzdCA9IG5ldyBTZXQoW1xuICAnYW5ub3RhdGlvbi14bWwnLFxuICAnY29sb3ItcHJvZmlsZScsXG4gICdmb250LWZhY2UnLFxuICAnZm9udC1mYWNlLXNyYycsXG4gICdmb250LWZhY2UtdXJpJyxcbiAgJ2ZvbnQtZmFjZS1mb3JtYXQnLFxuICAnZm9udC1mYWNlLW5hbWUnLFxuICAnbWlzc2luZy1nbHlwaCcsXG5dKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpIHtcbiAgY29uc3QgcmVzZXJ2ZWQgPSByZXNlcnZlZFRhZ0xpc3QuaGFzKGxvY2FsTmFtZSk7XG4gIGNvbnN0IHZhbGlkRm9ybSA9IC9eW2Etel1bLjAtOV9hLXpdKi1bXFwtLjAtOV9hLXpdKiQvLnRlc3QobG9jYWxOYW1lKTtcbiAgcmV0dXJuICFyZXNlcnZlZCAmJiB2YWxpZEZvcm07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nvbm5lY3RlZChub2RlKSB7XG4gIC8vIFVzZSBgTm9kZSNpc0Nvbm5lY3RlZGAsIGlmIGRlZmluZWQuXG4gIGNvbnN0IG5hdGl2ZVZhbHVlID0gbm9kZS5pc0Nvbm5lY3RlZDtcbiAgaWYgKG5hdGl2ZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmF0aXZlVmFsdWU7XG4gIH1cblxuICAvKiogQHR5cGUgez9Ob2RlfHVuZGVmaW5lZH0gKi9cbiAgbGV0IGN1cnJlbnQgPSBub2RlO1xuICB3aGlsZSAoY3VycmVudCAmJiAhKGN1cnJlbnQuX19DRV9pc0ltcG9ydERvY3VtZW50IHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIHx8ICh3aW5kb3cuU2hhZG93Um9vdCAmJiBjdXJyZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IGN1cnJlbnQuaG9zdCA6IHVuZGVmaW5lZCk7XG4gIH1cbiAgcmV0dXJuICEhKGN1cnJlbnQgJiYgKGN1cnJlbnQuX19DRV9pc0ltcG9ydERvY3VtZW50IHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0XG4gKiBAcmV0dXJuIHs/Tm9kZX1cbiAqL1xuZnVuY3Rpb24gbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBzdGFydCkge1xuICBsZXQgbm9kZSA9IHN0YXJ0O1xuICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSByb290ICYmICFub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gKCFub2RlIHx8IG5vZGUgPT09IHJvb3QpID8gbnVsbCA6IG5vZGUubmV4dFNpYmxpbmc7XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICogQHBhcmFtIHshTm9kZX0gc3RhcnRcbiAqIEByZXR1cm4gez9Ob2RlfVxuICovXG5mdW5jdGlvbiBuZXh0Tm9kZShyb290LCBzdGFydCkge1xuICByZXR1cm4gc3RhcnQuZmlyc3RDaGlsZCA/IHN0YXJ0LmZpcnN0Q2hpbGQgOiBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIHN0YXJ0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSByb290XG4gKiBAcGFyYW0geyFmdW5jdGlvbighRWxlbWVudCl9IGNhbGxiYWNrXG4gKiBAcGFyYW0geyFTZXQ8Tm9kZT49fSB2aXNpdGVkSW1wb3J0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgY2FsbGJhY2ssIHZpc2l0ZWRJbXBvcnRzID0gbmV3IFNldCgpKSB7XG4gIGxldCBub2RlID0gcm9vdDtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyhub2RlKTtcblxuICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGVsZW1lbnQubG9jYWxOYW1lO1xuICAgICAgaWYgKGxvY2FsTmFtZSA9PT0gJ2xpbmsnICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpbXBvcnQgKHBvbHlmaWxsZWQgb3Igbm90KSBoYXMgaXQncyByb290IG5vZGUgYXZhaWxhYmxlLFxuICAgICAgICAvLyB3YWxrIGl0LlxuICAgICAgICBjb25zdCBpbXBvcnROb2RlID0gLyoqIEB0eXBlIHshTm9kZX0gKi8gKGVsZW1lbnQuaW1wb3J0KTtcbiAgICAgICAgaWYgKGltcG9ydE5vZGUgaW5zdGFuY2VvZiBOb2RlICYmICF2aXNpdGVkSW1wb3J0cy5oYXMoaW1wb3J0Tm9kZSkpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIHdhbGtzIG9mIHRoZSBzYW1lIGltcG9ydCByb290LlxuICAgICAgICAgIHZpc2l0ZWRJbXBvcnRzLmFkZChpbXBvcnROb2RlKTtcblxuICAgICAgICAgIGZvciAobGV0IGNoaWxkID0gaW1wb3J0Tm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMoY2hpbGQsIGNhbGxiYWNrLCB2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWdub3JlIGRlc2NlbmRhbnRzIG9mIGltcG9ydCBsaW5rcyB0byBwcmV2ZW50IGF0dGVtcHRpbmcgdG8gd2FsayB0aGVcbiAgICAgICAgLy8gZWxlbWVudHMgY3JlYXRlZCBieSB0aGUgSFRNTCBJbXBvcnRzIHBvbHlmaWxsIHRoYXQgd2UganVzdCB3YWxrZWRcbiAgICAgICAgLy8gYWJvdmUuXG4gICAgICAgIG5vZGUgPSBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIGVsZW1lbnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxOYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIC8vIElnbm9yZSBkZXNjZW5kYW50cyBvZiB0ZW1wbGF0ZXMuIFRoZXJlIHNob3VsZG4ndCBiZSBhbnkgZGVzY2VuZGFudHNcbiAgICAgICAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgbW92ZWQgaW50byBgLmNvbnRlbnRgIGR1cmluZyBjb25zdHJ1Y3Rpb24gaW5cbiAgICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHRlbXBsYXRlIGJ1dCwgaW4gY2FzZSB0aGV5IGV4aXN0IGFuZCBhcmUgc3RpbGxcbiAgICAgICAgLy8gd2FpdGluZyB0byBiZSBtb3ZlZCBieSBhIHBvbHlmaWxsLCB0aGV5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgZWxlbWVudCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBXYWxrIHNoYWRvdyByb290cy5cbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50Ll9fQ0Vfc2hhZG93Um9vdDtcbiAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gc2hhZG93Um9vdC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgIHdhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKGNoaWxkLCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5leHROb2RlKHJvb3QsIG5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogVXNlZCB0byBzdXBwcmVzcyBDbG9zdXJlJ3MgXCJNb2RpZnlpbmcgdGhlIHByb3RvdHlwZSBpcyBvbmx5IGFsbG93ZWQgaWYgdGhlXG4gKiBjb25zdHJ1Y3RvciBpcyBpbiB0aGUgc2FtZSBzY29wZVwiIHdhcm5pbmcgd2l0aG91dCB1c2luZ1xuICogYEBzdXBwcmVzcyB7bmV3Q2hlY2tUeXBlcywgZHVwbGljYXRlfWAgYmVjYXVzZSBgbmV3Q2hlY2tUeXBlc2AgaXMgdG9vIGJyb2FkLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eVVuY2hlY2tlZChkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgZGVzdGluYXRpb25bbmFtZV0gPSB2YWx1ZTtcbn1cbiIsIi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ3VzdG9tRWxlbWVudFN0YXRlID0ge1xuICBjdXN0b206IDEsXG4gIGZhaWxlZDogMixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUVsZW1lbnRTdGF0ZTtcbiIsImltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuL1V0aWxpdGllcy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuL0N1c3RvbUVsZW1lbnRTdGF0ZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgeyFNYXA8c3RyaW5nLCAhQ3VzdG9tRWxlbWVudERlZmluaXRpb24+fSAqL1xuICAgIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbiA9IG5ldyBNYXAoKTtcblxuICAgIC8qKiBAdHlwZSB7IU1hcDwhRnVuY3Rpb24sICFDdXN0b21FbGVtZW50RGVmaW5pdGlvbj59ICovXG4gICAgdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24gPSBuZXcgTWFwKCk7XG5cbiAgICAvKiogQHR5cGUgeyFBcnJheTwhZnVuY3Rpb24oIU5vZGUpPn0gKi9cbiAgICB0aGlzLl9wYXRjaGVzID0gW107XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5faGFzUGF0Y2hlcyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudERlZmluaXRpb259IGRlZmluaXRpb25cbiAgICovXG4gIHNldERlZmluaXRpb24obG9jYWxOYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uLnNldChsb2NhbE5hbWUsIGRlZmluaXRpb24pO1xuICAgIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uLnNldChkZWZpbml0aW9uLmNvbnN0cnVjdG9yLCBkZWZpbml0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEByZXR1cm4geyFDdXN0b21FbGVtZW50RGVmaW5pdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuICBsb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbi5nZXQobG9jYWxOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAgICogQHJldHVybiB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufHVuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yVG9EZWZpbml0aW9uKGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uLmdldChjb25zdHJ1Y3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIU5vZGUpfSBsaXN0ZW5lclxuICAgKi9cbiAgYWRkUGF0Y2gobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9oYXNQYXRjaGVzID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXRjaGVzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICovXG4gIHBhdGNoVHJlZShub2RlKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNQYXRjaGVzKSByZXR1cm47XG5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMobm9kZSwgZWxlbWVudCA9PiB0aGlzLnBhdGNoKGVsZW1lbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqL1xuICBwYXRjaChub2RlKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNQYXRjaGVzKSByZXR1cm47XG5cbiAgICBpZiAobm9kZS5fX0NFX3BhdGNoZWQpIHJldHVybjtcbiAgICBub2RlLl9fQ0VfcGF0Y2hlZCA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3BhdGNoZXNbaV0obm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAgICovXG4gIGNvbm5lY3RUcmVlKHJvb3QpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGVsZW1lbnQgPT4gZWxlbWVudHMucHVzaChlbGVtZW50KSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5fX0NFX3N0YXRlID09PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGdyYWRlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICAgKi9cbiAgZGlzY29ubmVjdFRyZWUocm9vdCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgZWxlbWVudCA9PiBlbGVtZW50cy5wdXNoKGVsZW1lbnQpKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGVzIGFsbCB1bmN1c3RvbWl6ZWQgY3VzdG9tIGVsZW1lbnRzIGF0IGFuZCBiZWxvdyBhIHJvb3Qgbm9kZSBmb3JcbiAgICogd2hpY2ggdGhlcmUgaXMgYSBkZWZpbml0aW9uLiBXaGVuIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9uIGNhbGxiYWNrcyBhcmVcbiAgICogYXNzdW1lZCB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSAod2hpY2gsIGJ5IHRoZSBjdXJyZW50IERPTSAvIEhUTUwgc3BlY1xuICAgKiBkZWZpbml0aW9ucywgdGhleSBhcmUgKm5vdCopLCBjYWxsYmFja3MgZm9yIGJvdGggZWxlbWVudHMgY3VzdG9taXplZFxuICAgKiBzeW5jaHJvbm91c2x5IGJ5IHRoZSBwYXJzZXIgYW5kIGVsZW1lbnRzIGJlaW5nIHVwZ3JhZGVkIG9jY3VyIGluIHRoZSBzYW1lXG4gICAqIHJlbGF0aXZlIG9yZGVyLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIGZ1bmN0aW9uLCB3aGVuIHVzZWQgdG8gc2ltdWxhdGUgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHRyZWUgdGhhdFxuICAgKiBpcyBhbHJlYWR5IGNyZWF0ZWQgYnV0IG5vdCBjdXN0b21pemVkIChpLmUuIGJ5IHRoZSBwYXJzZXIpLCBkb2VzICpub3QqXG4gICAqIHByZXZlbnQgdGhlIGVsZW1lbnQgZnJvbSByZWFkaW5nIHRoZSAnZmluYWwnICh0cnVlKSBzdGF0ZSBvZiB0aGUgdHJlZS4gRm9yXG4gICAqIGV4YW1wbGUsIHRoZSBlbGVtZW50LCBkdXJpbmcgdHJ1bHkgc3luY2hyb25vdXMgcGFyc2luZyAvIGNvbnN0cnVjdGlvbiB3b3VsZFxuICAgKiBzZWUgdGhhdCBpdCBjb250YWlucyBubyBjaGlsZHJlbiBhcyB0aGV5IGhhdmUgbm90IHlldCBiZWVuIGluc2VydGVkLlxuICAgKiBIb3dldmVyLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1vZGlmeSB0aGUgdHJlZSwgdGhlIGVsZW1lbnQgd2lsbFxuICAgKiAoaW5jb3JyZWN0bHkpIGhhdmUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSwgc2VsZi1tb2RpZmljYXRpb24gcmVzdHJpY3Rpb25zXG4gICAqIGZvciBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcnMgaW1wb3NlZCBieSB0aGUgRE9NIHNwZWMgYXJlICpub3QqIGVuZm9yY2VkLlxuICAgKlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIG5lc3RlZCBsaXN0IHNob3dzIHRoZSBzdGVwcyBleHRlbmRpbmcgZG93biBmcm9tIHRoZSBIVE1MXG4gICAqIHNwZWMncyBwYXJzaW5nIHNlY3Rpb24gdGhhdCBjYXVzZSBlbGVtZW50cyB0byBiZSBzeW5jaHJvbm91c2x5IGNyZWF0ZWQgYW5kXG4gICAqIHVwZ3JhZGVkOlxuICAgKlxuICAgKiBUaGUgXCJpbiBib2R5XCIgaW5zZXJ0aW9uIG1vZGU6XG4gICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICogLSBTd2l0Y2ggb24gdG9rZW46XG4gICAqICAgLi4gb3RoZXIgY2FzZXMgLi5cbiAgICogICAtPiBBbnkgb3RoZXIgc3RhcnQgdGFnXG4gICAqICAgICAgLSBbSW5zZXJ0IGFuIEhUTUwgZWxlbWVudF0oYmVsb3cpIGZvciB0aGUgdG9rZW4uXG4gICAqXG4gICAqIEluc2VydCBhbiBIVE1MIGVsZW1lbnQ6XG4gICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2luc2VydC1hbi1odG1sLWVsZW1lbnRcbiAgICogLSBJbnNlcnQgYSBmb3JlaWduIGVsZW1lbnQgZm9yIHRoZSB0b2tlbiBpbiB0aGUgSFRNTCBuYW1lc3BhY2U6XG4gICAqICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaW5zZXJ0LWEtZm9yZWlnbi1lbGVtZW50XG4gICAqICAgLSBDcmVhdGUgYW4gZWxlbWVudCBmb3IgYSB0b2tlbjpcbiAgICogICAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2NyZWF0ZS1hbi1lbGVtZW50LWZvci10aGUtdG9rZW5cbiAgICogICAgIC0gV2lsbCBleGVjdXRlIHNjcmlwdCBmbGFnIGlzIHRydWU/XG4gICAqICAgICAgIC0gKEVsZW1lbnQgcXVldWUgcHVzaGVkIHRvIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suKVxuICAgKiAgICAgLSBDcmVhdGUgYW4gZWxlbWVudDpcbiAgICogICAgICAgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWNyZWF0ZS1lbGVtZW50XG4gICAqICAgICAgIC0gU3luYyBDRSBmbGFnIGlzIHRydWU/XG4gICAqICAgICAgICAgLSBDb25zdHJ1Y3RvciBjYWxsZWQuXG4gICAqICAgICAgICAgLSBTZWxmLW1vZGlmaWNhdGlvbiByZXN0cmljdGlvbnMgZW5mb3JjZWQuXG4gICAqICAgICAgIC0gU3luYyBDRSBmbGFnIGlzIGZhbHNlP1xuICAgKiAgICAgICAgIC0gKFVwZ3JhZGUgcmVhY3Rpb24gZW5xdWV1ZWQuKVxuICAgKiAgICAgLSBBdHRyaWJ1dGVzIGFwcGVuZGVkIHRvIGVsZW1lbnQuXG4gICAqICAgICAgIChgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCByZWFjdGlvbnMgZW5xdWV1ZWQuKVxuICAgKiAgICAgLSBXaWxsIGV4ZWN1dGUgc2NyaXB0IGZsYWcgaXMgdHJ1ZT9cbiAgICogICAgICAgLSAoRWxlbWVudCBxdWV1ZSBwb3BwZWQgZnJvbSB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLlxuICAgKiAgICAgICAgIFJlYWN0aW9ucyBpbiB0aGUgcG9wcGVkIHN0YWNrIGFyZSBpbnZva2VkLilcbiAgICogICAtIChFbGVtZW50IHF1ZXVlIHB1c2hlZCB0byB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLilcbiAgICogICAtIEluc2VydCB0aGUgZWxlbWVudDpcbiAgICogICAgIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ub2RlLWluc2VydFxuICAgKiAgICAgLSBTaGFkb3ctaW5jbHVkaW5nIGRlc2NlbmRhbnRzIGFyZSBjb25uZWN0ZWQuIER1cmluZyBwYXJzaW5nXG4gICAqICAgICAgIGNvbnN0cnVjdGlvbiwgdGhlcmUgYXJlIG5vIHNoYWRvdy0qZXhjbHVkaW5nKiBkZXNjZW5kYW50cy5cbiAgICogICAgICAgSG93ZXZlciwgdGhlIGNvbnN0cnVjdG9yIG1heSBoYXZlIHZhbGlkbHkgYXR0YWNoZWQgYSBzaGFkb3dcbiAgICogICAgICAgdHJlZSB0byBpdHNlbGYgYW5kIGFkZGVkIGRlc2NlbmRhbnRzIHRvIHRoYXQgc2hhZG93IHRyZWUuXG4gICAqICAgICAgIChgY29ubmVjdGVkQ2FsbGJhY2tgIHJlYWN0aW9ucyBlbnF1ZXVlZC4pXG4gICAqICAgLSAoRWxlbWVudCBxdWV1ZSBwb3BwZWQgZnJvbSB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLlxuICAgKiAgICAgUmVhY3Rpb25zIGluIHRoZSBwb3BwZWQgc3RhY2sgYXJlIGludm9rZWQuKVxuICAgKlxuICAgKiBAcGFyYW0geyFOb2RlfSByb290XG4gICAqIEBwYXJhbSB7IVNldDxOb2RlPj19IHZpc2l0ZWRJbXBvcnRzXG4gICAqL1xuICBwYXRjaEFuZFVwZ3JhZGVUcmVlKHJvb3QsIHZpc2l0ZWRJbXBvcnRzID0gbmV3IFNldCgpKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgIGNvbnN0IGdhdGhlckVsZW1lbnRzID0gZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdsaW5rJyAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdpbXBvcnQnKSB7XG4gICAgICAgIC8vIFRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgc2V0cyBhIGRlc2NlbmRhbnQgZWxlbWVudCBvZiB0aGUgbGluayB0b1xuICAgICAgICAvLyB0aGUgYGltcG9ydGAgcHJvcGVydHksIHNwZWNpZmljYWxseSB0aGlzIGlzICpub3QqIGEgRG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IGltcG9ydE5vZGUgPSAvKiogQHR5cGUgez9Ob2RlfSAqLyAoZWxlbWVudC5pbXBvcnQpO1xuXG4gICAgICAgIGlmIChpbXBvcnROb2RlIGluc3RhbmNlb2YgTm9kZSAmJiBpbXBvcnROb2RlLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaXNJbXBvcnREb2N1bWVudCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBDb25uZWN0ZWQgbGlua3MgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGxpbmsncyBpbXBvcnQgcm9vdCBpcyBub3QgYXZhaWxhYmxlLCBpdHMgY29udGVudHMgY2FuJ3QgYmVcbiAgICAgICAgICAvLyB3YWxrZWQuIFdhaXQgZm9yICdsb2FkJyBhbmQgd2FsayBpdCB3aGVuIGl0J3MgcmVhZHkuXG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0Tm9kZSA9IC8qKiBAdHlwZSB7IU5vZGV9ICovIChlbGVtZW50LmltcG9ydCk7XG5cbiAgICAgICAgICAgIGlmIChpbXBvcnROb2RlLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaXNJbXBvcnREb2N1bWVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENvbm5lY3RlZCBsaW5rcyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9oYXNSZWdpc3RyeSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBgdmlzaXRlZEltcG9ydHNgIHNldCB0aGF0IHdhcyBwb3B1bGF0ZWQgc3luYyBkdXJpbmdcbiAgICAgICAgICAgIC8vIHRoZSBgcGF0Y2hBbmRVcGdyYWRlVHJlZWAgY2FsbCB0aGF0IGNhdXNlZCB0aGlzICdsb2FkJyBoYW5kbGVyIHRvXG4gICAgICAgICAgICAvLyBiZSBhZGRlZC4gVGhlbiwgcmVtb3ZlICp0aGlzKiBsaW5rJ3MgaW1wb3J0IG5vZGUgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHdhbGsgdGhhdCBpbXBvcnQgYWdhaW4sIGV2ZW4gaWYgaXQgd2FzIHBhcnRpYWxseSB3YWxrZWQgbGF0ZXJcbiAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgc2FtZSBgcGF0Y2hBbmRVcGdyYWRlVHJlZWAgY2FsbC5cbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZpc2l0ZWRJbXBvcnRzID0gbmV3IFNldCh2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgICAgICB2aXNpdGVkSW1wb3J0cy5kZWxldGUoaW1wb3J0Tm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMucGF0Y2hBbmRVcGdyYWRlVHJlZShpbXBvcnROb2RlLCB2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50c2AgcG9wdWxhdGVzIChhbmQgaW50ZXJuYWxseSBjaGVja3MgYWdhaW5zdClcbiAgICAvLyBgdmlzaXRlZEltcG9ydHNgIHdoZW4gdHJhdmVyc2luZyBhIGxvYWRlZCBpbXBvcnQuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGdhdGhlckVsZW1lbnRzLCB2aXNpdGVkSW1wb3J0cyk7XG5cbiAgICBpZiAodGhpcy5faGFzUGF0Y2hlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhdGNoKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVwZ3JhZGVFbGVtZW50KGVsZW1lbnRzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgdXBncmFkZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGVsZW1lbnQuX19DRV9zdGF0ZTtcbiAgICBpZiAoY3VycmVudFN0YXRlICE9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgaWYgKCFkZWZpbml0aW9uKSByZXR1cm47XG5cbiAgICBkZWZpbml0aW9uLmNvbnN0cnVjdGlvblN0YWNrLnB1c2goZWxlbWVudCk7XG5cbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGRlZmluaXRpb24uY29uc3RydWN0b3I7XG4gICAgdHJ5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgKGNvbnN0cnVjdG9yKSgpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3IgZGlkIG5vdCBwcm9kdWNlIHRoZSBlbGVtZW50IGJlaW5nIHVwZ3JhZGVkLicpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkZWZpbml0aW9uLmNvbnN0cnVjdGlvblN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVsZW1lbnQuX19DRV9zdGF0ZSA9IENFU3RhdGUuZmFpbGVkO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9fQ0Vfc3RhdGUgPSBDRVN0YXRlLmN1c3RvbTtcbiAgICBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG5cbiAgICBpZiAoZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkQXR0cmlidXRlcyA9IGRlZmluaXRpb24ub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYnNlcnZlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9ic2VydmVkQXR0cmlidXRlc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZWxlbWVudCwgbmFtZSwgbnVsbCwgdmFsdWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZChlbGVtZW50KSkge1xuICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmaW5pdGlvbi5jb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgZGVmaW5pdGlvbi5jb25uZWN0ZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBkaXNjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50Ll9fQ0VfaXNDb25uZWN0ZWRDYWxsYmFja0NhbGxlZCkge1xuICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG4gICAgaWYgKGRlZmluaXRpb24uZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgIGRlZmluaXRpb24uZGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9fQ0VfaXNDb25uZWN0ZWRDYWxsYmFja0NhbGxlZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkVmFsdWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBuZXdWYWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgKi9cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGVsZW1lbnQuX19DRV9kZWZpbml0aW9uO1xuICAgIGlmIChcbiAgICAgIGRlZmluaXRpb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrICYmXG4gICAgICBkZWZpbml0aW9uLm9ic2VydmVkQXR0cmlidXRlcy5pbmRleE9mKG5hbWUpID4gLTFcbiAgICApIHtcbiAgICAgIGRlZmluaXRpb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwoZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGludGVybmFscywgZG9jKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfVxuICAgICAqL1xuICAgIHRoaXMuX2ludGVybmFscyA9IGludGVybmFscztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshRG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5fZG9jdW1lbnQgPSBkb2M7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG5cblxuICAgIC8vIFNpbXVsYXRlIHRyZWUgY29uc3RydWN0aW9uIGZvciBhbGwgY3VycmVudGx5IGFjY2Vzc2libGUgbm9kZXMgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUodGhpcy5fZG9jdW1lbnQpO1xuXG4gICAgaWYgKHRoaXMuX2RvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9oYW5kbGVNdXRhdGlvbnMuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIE5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciBhcmUgZ2l2ZW4gdG8gdGhlIG9ic2VydmVyICpiZWZvcmUqIHRoZSBuZXh0XG4gICAgICAvLyB0YXNrIHJ1bnMuIElubGluZSBzY3JpcHRzIGFyZSBydW4gaW4gYSBuZXcgdGFzay4gVGhpcyBtZWFucyB0aGF0IHRoZVxuICAgICAgLy8gb2JzZXJ2ZXIgd2lsbCBiZSBhYmxlIHRvIGhhbmRsZSB0aGUgbmV3bHkgcGFyc2VkIG5vZGVzIGJlZm9yZSB0aGUgaW5saW5lXG4gICAgICAvLyBzY3JpcHQgaXMgcnVuLlxuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSBtdXRhdGlvbnNcbiAgICovXG4gIF9oYW5kbGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgLy8gT25jZSB0aGUgZG9jdW1lbnQncyBgcmVhZHlTdGF0ZWAgaXMgJ2ludGVyYWN0aXZlJyBvciAnY29tcGxldGUnLCBhbGwgbmV3XG4gICAgLy8gbm9kZXMgY3JlYXRlZCB3aXRoaW4gdGhhdCBkb2N1bWVudCB3aWxsIGJlIHRoZSByZXN1bHQgb2Ygc2NyaXB0IGFuZFxuICAgIC8vIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHBhdGNoaW5nLlxuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLl9kb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IHJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhZGRlZE5vZGVzID0gbXV0YXRpb25zW2ldLmFkZGVkTm9kZXM7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFkZGVkTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGFkZGVkTm9kZXNbal07XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZlcnJlZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshUHJvbWlzZTxUPn1cbiAgICAgKi9cbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5fdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICovXG4gIHJlc29sdmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWxyZWFkeSByZXNvbHZlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMuX3Jlc29sdmUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxUPn1cbiAgICovXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgfVxufVxuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIGZyb20gJy4vRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlci5qcyc7XG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi9EZWZlcnJlZC5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi9VdGlsaXRpZXMuanMnO1xuXG4vKipcbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IHtcblxuICAvKipcbiAgICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbHMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQ3VzdG9tRWxlbWVudEludGVybmFsc31cbiAgICAgKi9cbiAgICB0aGlzLl9pbnRlcm5hbHMgPSBpbnRlcm5hbHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshTWFwPHN0cmluZywgIURlZmVycmVkPHVuZGVmaW5lZD4+fVxuICAgICAqL1xuICAgIHRoaXMuX3doZW5EZWZpbmVkRGVmZXJyZWQgPSBuZXcgTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmbHVzaCBjYWxsYmFjayB0cmlnZ2VycyB0aGUgZG9jdW1lbnQgd2FsayBzeW5jaHJvbm91c2x5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gZm4gPT4gZm4oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fZmx1c2hQZW5kaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9kb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyID0gbmV3IERvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIoaW50ZXJuYWxzLCBkb2N1bWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAgICovXG4gIGRlZmluZShsb2NhbE5hbWUsIGNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0N1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9ycyBtdXN0IGJlIGZ1bmN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAoIVV0aWxpdGllcy5pc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUobG9jYWxOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgZWxlbWVudCBuYW1lICcke2xvY2FsTmFtZX0nIGlzIG5vdCB2YWxpZC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgY3VzdG9tIGVsZW1lbnQgd2l0aCBuYW1lICcke2xvY2FsTmFtZX0nIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBjdXN0b20gZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIGRlZmluZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGxldCBjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBsZXQgZGlzY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgbGV0IGFkb3B0ZWRDYWxsYmFjaztcbiAgICBsZXQgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrO1xuICAgIGxldCBvYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgdHJ5IHtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIGNvbnN0IHByb3RvdHlwZSA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgIGlmICghKHByb3RvdHlwZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9yXFwncyBwcm90b3R5cGUgaXMgbm90IGFuIG9iamVjdC4nKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2sobmFtZSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja1ZhbHVlID0gcHJvdG90eXBlW25hbWVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICEoY2FsbGJhY2tWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke25hbWV9JyBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2Nvbm5lY3RlZENhbGxiYWNrJyk7XG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgYWRvcHRlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2Fkb3B0ZWRDYWxsYmFjaycpO1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycpO1xuICAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gY29uc3RydWN0b3JbJ29ic2VydmVkQXR0cmlidXRlcyddIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgbG9jYWxOYW1lLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjayxcbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrLFxuICAgICAgYWRvcHRlZENhbGxiYWNrLFxuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLFxuICAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAgY29uc3RydWN0aW9uU3RhY2s6IFtdLFxuICAgIH07XG5cbiAgICB0aGlzLl9pbnRlcm5hbHMuc2V0RGVmaW5pdGlvbihsb2NhbE5hbWUsIGRlZmluaXRpb24pO1xuXG4gICAgdGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5wdXNoKGxvY2FsTmFtZSk7XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGNhbGxlZCB0aGUgZmx1c2ggY2FsbGJhY2sgYW5kIGl0IGhhc24ndCBjYWxsZWQgYmFjayB5ZXQsXG4gICAgLy8gZG9uJ3QgY2FsbCBpdCBhZ2Fpbi5cbiAgICBpZiAoIXRoaXMuX2ZsdXNoUGVuZGluZykge1xuICAgICAgdGhpcy5fZmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2soKCkgPT4gdGhpcy5fZmx1c2goKSk7XG4gICAgfVxuICB9XG5cbiAgX2ZsdXNoKCkge1xuICAgIC8vIElmIG5vIG5ldyBkZWZpbml0aW9ucyB3ZXJlIGRlZmluZWQsIGRvbid0IGF0dGVtcHQgdG8gZmx1c2guIFRoaXMgY291bGRcbiAgICAvLyBoYXBwZW4gaWYgYSBmbHVzaCBjYWxsYmFjayBrZWVwcyB0aGUgZnVuY3Rpb24gaXQgaXMgZ2l2ZW4gYW5kIGNhbGxzIGl0XG4gICAgLy8gbXVsdGlwbGUgdGltZXMuXG4gICAgaWYgKHRoaXMuX2ZsdXNoUGVuZGluZyA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgIHRoaXMuX2ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKGRvY3VtZW50KTtcblxuICAgIHdoaWxlICh0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5nZXQobG9jYWxOYW1lKTtcbiAgICAgIGlmIChkZWZlcnJlZCkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0KGxvY2FsTmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9pbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiBkZWZpbml0aW9uLmNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx1bmRlZmluZWQ+fVxuICAgKi9cbiAgd2hlbkRlZmluZWQobG9jYWxOYW1lKSB7XG4gICAgaWYgKCFVdGlsaXRpZXMuaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lKGxvY2FsTmFtZSkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgU3ludGF4RXJyb3IoYCcke2xvY2FsTmFtZX0nIGlzIG5vdCBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUuYCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW9yID0gdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5nZXQobG9jYWxOYW1lKTtcbiAgICBpZiAocHJpb3IpIHtcbiAgICAgIHJldHVybiBwcmlvci50b1Byb21pc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHRoaXMuX3doZW5EZWZpbmVkRGVmZXJyZWQuc2V0KGxvY2FsTmFtZSwgZGVmZXJyZWQpO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcbiAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IG9ubHkgaWYgdGhlIGdpdmVuIGxvY2FsIG5hbWUgaGFzIGEgZGVmaW5pdGlvbiAqYW5kKlxuICAgIC8vIHRoZSBmdWxsIGRvY3VtZW50IHdhbGsgdG8gdXBncmFkZSBlbGVtZW50cyB3aXRoIHRoYXQgbG9jYWwgbmFtZSBoYXNcbiAgICAvLyBhbHJlYWR5IGhhcHBlbmVkLlxuICAgIGlmIChkZWZpbml0aW9uICYmIHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMuaW5kZXhPZihsb2NhbE5hbWUpID09PSAtMSkge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZlcnJlZC50b1Byb21pc2UoKTtcbiAgfVxuXG4gIHBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2sob3V0ZXIpIHtcbiAgICB0aGlzLl9kb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBjb25zdCBpbm5lciA9IHRoaXMuX2ZsdXNoQ2FsbGJhY2s7XG4gICAgdGhpcy5fZmx1c2hDYWxsYmFjayA9IGZsdXNoID0+IG91dGVyKCgpID0+IGlubmVyKGZsdXNoKSk7XG4gIH1cbn1cblxuLy8gQ2xvc3VyZSBjb21waWxlciBleHBvcnRzLlxud2luZG93WydDdXN0b21FbGVtZW50UmVnaXN0cnknXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeTtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ2RlZmluZSddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5kZWZpbmU7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydnZXQnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0O1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsnd2hlbkRlZmluZWQnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUud2hlbkRlZmluZWQ7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrJ10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2s7XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIERvY3VtZW50X2NyZWF0ZUVsZW1lbnQ6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCxcbiAgRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnROUyxcbiAgRG9jdW1lbnRfaW1wb3J0Tm9kZTogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLFxuICBEb2N1bWVudF9wcmVwZW5kOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlWydwcmVwZW5kJ10sXG4gIERvY3VtZW50X2FwcGVuZDogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZVsnYXBwZW5kJ10sXG4gIE5vZGVfY2xvbmVOb2RlOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlLFxuICBOb2RlX2FwcGVuZENoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQsXG4gIE5vZGVfaW5zZXJ0QmVmb3JlOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLFxuICBOb2RlX3JlbW92ZUNoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsXG4gIE5vZGVfcmVwbGFjZUNoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkLFxuICBOb2RlX3RleHRDb250ZW50OiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5Ob2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50JyksXG4gIEVsZW1lbnRfYXR0YWNoU2hhZG93OiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2F0dGFjaFNoYWRvdyddLFxuICBFbGVtZW50X2lubmVySFRNTDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsICdpbm5lckhUTUwnKSxcbiAgRWxlbWVudF9nZXRBdHRyaWJ1dGU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUsXG4gIEVsZW1lbnRfc2V0QXR0cmlidXRlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLFxuICBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxcbiAgRWxlbWVudF9nZXRBdHRyaWJ1dGVOUzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5TLFxuICBFbGVtZW50X3NldEF0dHJpYnV0ZU5TOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsXG4gIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlM6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyxcbiAgRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnaW5zZXJ0QWRqYWNlbnRFbGVtZW50J10sXG4gIEVsZW1lbnRfcHJlcGVuZDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydwcmVwZW5kJ10sXG4gIEVsZW1lbnRfYXBwZW5kOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2FwcGVuZCddLFxuICBFbGVtZW50X2JlZm9yZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydiZWZvcmUnXSxcbiAgRWxlbWVudF9hZnRlcjogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydhZnRlciddLFxuICBFbGVtZW50X3JlcGxhY2VXaXRoOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ3JlcGxhY2VXaXRoJ10sXG4gIEVsZW1lbnRfcmVtb3ZlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ3JlbW92ZSddLFxuICBIVE1MRWxlbWVudDogd2luZG93LkhUTUxFbGVtZW50LFxuICBIVE1MRWxlbWVudF9pbm5lckhUTUw6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2lubmVySFRNTCcpLFxuICBIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQ6IHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGVbJ2luc2VydEFkamFjZW50RWxlbWVudCddLFxufTtcbiIsIi8qKlxuICogVGhpcyBjbGFzcyBleGlzdHMgb25seSB0byB3b3JrIGFyb3VuZCBDbG9zdXJlJ3MgbGFjayBvZiBhIHdheSB0byBkZXNjcmliZVxuICogc2luZ2xldG9ucy4gSXQgcmVwcmVzZW50cyB0aGUgJ2FscmVhZHkgY29uc3RydWN0ZWQgbWFya2VyJyB1c2VkIGluIGN1c3RvbVxuICogZWxlbWVudCBjb25zdHJ1Y3Rpb24gc3RhY2tzLlxuICpcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYWxyZWFkeS1jb25zdHJ1Y3RlZC1tYXJrZXJcbiAqL1xuY2xhc3MgQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyIHt9XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIoKTtcbiIsImltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuaW1wb3J0IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlciBmcm9tICcuLi9BbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgd2luZG93WydIVE1MRWxlbWVudCddID0gKGZ1bmN0aW9uKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihuZXc6IEhUTUxFbGVtZW50KTogIUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhUTUxFbGVtZW50KCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgcmVhbGx5IGJlIGBuZXcudGFyZ2V0YCBidXQgYG5ldy50YXJnZXRgIGNhbid0IGJlIGVtdWxhdGVkXG4gICAgICAvLyBpbiBFUzUuIEFzc3VtaW5nIHRoZSB1c2VyIGtlZXBzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBjb25zdHJ1Y3RvcidzXG4gICAgICAvLyBwcm90b3R5cGUncyBgY29uc3RydWN0b3JgIHByb3BlcnR5LCB0aGlzIGlzIGVxdWl2YWxlbnQuXG4gICAgICAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi9cbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGludGVybmFscy5jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbihjb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VzdG9tIGVsZW1lbnQgYmVpbmcgY29uc3RydWN0ZWQgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggYGN1c3RvbUVsZW1lbnRzYC4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29uc3RydWN0aW9uU3RhY2sgPSBkZWZpbml0aW9uLmNvbnN0cnVjdGlvblN0YWNrO1xuXG4gICAgICBpZiAoY29uc3RydWN0aW9uU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCBkZWZpbml0aW9uLmxvY2FsTmFtZSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihlbGVtZW50LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBlbGVtZW50Ll9fQ0Vfc3RhdGUgPSBDRVN0YXRlLmN1c3RvbTtcbiAgICAgICAgZWxlbWVudC5fX0NFX2RlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2goZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBjb25zdHJ1Y3Rpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGNvbnN0cnVjdGlvblN0YWNrW2xhc3RJbmRleF07XG4gICAgICBpZiAoZWxlbWVudCA9PT0gQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIEhUTUxFbGVtZW50IGNvbnN0cnVjdG9yIHdhcyBlaXRoZXIgY2FsbGVkIHJlZW50cmFudGx5IGZvciB0aGlzIGNvbnN0cnVjdG9yIG9yIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdGlvblN0YWNrW2xhc3RJbmRleF0gPSBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXI7XG5cbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihlbGVtZW50LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgaW50ZXJuYWxzLnBhdGNoKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyAoZWxlbWVudCkpO1xuXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUgPSBOYXRpdmUuSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9KSgpO1xufTtcbiIsImltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uLy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uLy4uL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgcHJlcGVuZDogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAgKiAgYXBwZW5kOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogfX1cbiAqL1xubGV0IFBhcmVudE5vZGVOYXRpdmVNZXRob2RzO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICogQHBhcmFtIHshT2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHshUGFyZW50Tm9kZU5hdGl2ZU1ldGhvZHN9IGJ1aWx0SW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzLCBkZXN0aW5hdGlvbiwgYnVpbHRJbikge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydwcmVwZW5kJ10gPSBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcbiAgICBjb25zdCBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovIChub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgIH0pKTtcblxuICAgIGJ1aWx0SW4ucHJlcGVuZC5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydhcHBlbmQnXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5hcHBlbmQuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi9VdGlsaXRpZXMuanMnO1xuXG5pbXBvcnQgUGF0Y2hQYXJlbnROb2RlIGZyb20gJy4vSW50ZXJmYWNlL1BhcmVudE5vZGUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2NyZWF0ZUVsZW1lbnQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAgICogQHJldHVybiB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24obG9jYWxOYW1lKSB7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKHRoaXMuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgKGRlZmluaXRpb24uY29uc3RydWN0b3IpKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cbiAgICAgICAgKE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbG9jYWxOYW1lKSk7XG4gICAgICBpbnRlcm5hbHMucGF0Y2gocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2ltcG9ydE5vZGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZGVlcFxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUsIGRlZXApIHtcbiAgICAgIGNvbnN0IGNsb25lID0gTmF0aXZlLkRvY3VtZW50X2ltcG9ydE5vZGUuY2FsbCh0aGlzLCBub2RlLCBkZWVwKTtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGRvY3VtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAoIXRoaXMuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2hUcmVlKGNsb25lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKGNsb25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9KTtcblxuICBjb25zdCBOU19IVE1MID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2NyZWF0ZUVsZW1lbnROUycsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0RvY3VtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgICAqIEByZXR1cm4geyFFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5hbWVzcGFjZSwgbG9jYWxOYW1lKSB7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKHRoaXMuX19DRV9oYXNSZWdpc3RyeSAmJiAobmFtZXNwYWNlID09PSBudWxsIHx8IG5hbWVzcGFjZSA9PT0gTlNfSFRNTCkpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IChkZWZpbml0aW9uLmNvbnN0cnVjdG9yKSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG4gICAgICAgIChOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBsb2NhbE5hbWUpKTtcbiAgICAgIGludGVybmFscy5wYXRjaChyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICBQYXRjaFBhcmVudE5vZGUoaW50ZXJuYWxzLCBEb2N1bWVudC5wcm90b3R5cGUsIHtcbiAgICBwcmVwZW5kOiBOYXRpdmUuRG9jdW1lbnRfcHJlcGVuZCxcbiAgICBhcHBlbmQ6IE5hdGl2ZS5Eb2N1bWVudF9hcHBlbmQsXG4gIH0pO1xufTtcbiIsImltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vVXRpbGl0aWVzLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzKSB7XG4gIC8vIGBOb2RlI25vZGVWYWx1ZWAgaXMgaW1wbGVtZW50ZWQgb24gYEF0dHJgLlxuICAvLyBgTm9kZSN0ZXh0Q29udGVudGAgaXMgaW1wbGVtZW50ZWQgb24gYEF0dHJgLCBgRWxlbWVudGAuXG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAnaW5zZXJ0QmVmb3JlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gcmVmTm9kZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUsIHJlZk5vZGUpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBjb25zdCBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2luc2VydEJlZm9yZS5jYWxsKHRoaXMsIG5vZGUsIHJlZk5vZGUpO1xuXG4gICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2luc2VydEJlZm9yZS5jYWxsKHRoaXMsIG5vZGUsIHJlZk5vZGUpO1xuXG4gICAgICBpZiAobm9kZVdhc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2FwcGVuZENoaWxkJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBjYW4ndCBiZSBjb25uZWN0ZWQsIHNvIGBkaXNjb25uZWN0VHJlZWAgd2lsbCBuZXZlclxuICAgICAgICAvLyBuZWVkIHRvIGJlIGNhbGxlZCBvbiBhIERvY3VtZW50RnJhZ21lbnQncyBjaGlsZHJlbiBhZnRlciBpbnNlcnRpbmcgaXQuXG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zZXJ0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGluc2VydGVkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgICBpZiAobm9kZVdhc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2Nsb25lTm9kZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZGVlcFxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgIGNvbnN0IGNsb25lID0gTmF0aXZlLk5vZGVfY2xvbmVOb2RlLmNhbGwodGhpcywgZGVlcCk7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQgaXNcbiAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAoIXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaFRyZWUoY2xvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoY2xvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ3JlbW92ZUNoaWxkJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgY29uc3Qgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdyZXBsYWNlQ2hpbGQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVUb0luc2VydFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVUb1JlbW92ZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKSB7XG4gICAgICBpZiAobm9kZVRvSW5zZXJ0IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBjb25zdCBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGVUb0luc2VydC5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfcmVwbGFjZUNoaWxkLmNhbGwodGhpcywgbm9kZVRvSW5zZXJ0LCBub2RlVG9SZW1vdmUpO1xuXG4gICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb1JlbW92ZSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGVUb0luc2VydCk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9yZXBsYWNlQ2hpbGQuY2FsbCh0aGlzLCBub2RlVG9JbnNlcnQsIG5vZGVUb1JlbW92ZSk7XG4gICAgICBjb25zdCB0aGlzSXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzSXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb1JlbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlVG9JbnNlcnRXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb0luc2VydCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzSXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGVUb0luc2VydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cblxuICBmdW5jdGlvbiBwYXRjaF90ZXh0Q29udGVudChkZXN0aW5hdGlvbiwgYmFzZURlc2NyaXB0b3IpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdGluYXRpb24sICd0ZXh0Q29udGVudCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGJhc2VEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGJhc2VEZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldDogLyoqIEB0aGlzIHtOb2RlfSAqLyBmdW5jdGlvbihhc3NpZ25lZFZhbHVlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSB0ZXh0IG5vZGUgdGhlbiB0aGVyZSBhcmUgbm8gbm9kZXMgdG8gZGlzY29ubmVjdC5cbiAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgYXNzaWduZWRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlbW92ZWROb2RlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2hlY2tpbmcgZm9yIGBmaXJzdENoaWxkYCBpcyBmYXN0ZXIgdGhhbiByZWFkaW5nIGBjaGlsZE5vZGVzLmxlbmd0aGBcbiAgICAgICAgLy8gdG8gY29tcGFyZSB3aXRoIDAuXG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAvLyBVc2luZyBgY2hpbGROb2Rlc2AgaXMgZmFzdGVyIHRoYW4gYGNoaWxkcmVuYCwgZXZlbiB0aG91Z2ggd2Ugb25seVxuICAgICAgICAgIC8vIGNhcmUgYWJvdXQgZWxlbWVudHMuXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNMZW5ndGggPiAwICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgICAgLy8gQ29weWluZyBhbiBhcnJheSBieSBpdGVyYXRpbmcgaXMgZmFzdGVyIHRoYW4gdXNpbmcgc2xpY2UuXG4gICAgICAgICAgICByZW1vdmVkTm9kZXMgPSBuZXcgQXJyYXkoY2hpbGROb2Rlc0xlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICByZW1vdmVkTm9kZXNbaV0gPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VEZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIGFzc2lnbmVkVmFsdWUpO1xuXG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKHJlbW92ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50ICYmIE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50LmdldCkge1xuICAgIHBhdGNoX3RleHRDb250ZW50KE5vZGUucHJvdG90eXBlLCBOYXRpdmUuTm9kZV90ZXh0Q29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxzLmFkZFBhdGNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHBhdGNoX3RleHRDb250ZW50KGVsZW1lbnQsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAvLyBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgdGV4dENvbnRlbnRgIGdldHRlciBhc3N1bWVzIHRoYXRcbiAgICAgICAgLy8gdGV4dCBub2RlcycgYHRleHRDb250ZW50YCBnZXR0ZXIgd2lsbCBub3QgYmUgcGF0Y2hlZC5cbiAgICAgICAgZ2V0OiAvKiogQHRoaXMge05vZGV9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59ICovXG4gICAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuY2hpbGROb2Rlc1tpXS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IC8qKiBAdGhpcyB7Tm9kZX0gKi8gZnVuY3Rpb24oYXNzaWduZWRWYWx1ZSkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwodGhpcywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbCh0aGlzLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhc3NpZ25lZFZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsImltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uLy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uLy4uL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYmVmb3JlOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogICBhZnRlcjogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqICAgcmVwbGFjZVdpdGg6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiAgIHJlbW92ZTogIWZ1bmN0aW9uKCksXG4gKiB9fVxuICovXG5sZXQgQ2hpbGROb2RlTmF0aXZlTWV0aG9kcztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7IUNoaWxkTm9kZU5hdGl2ZU1ldGhvZHN9IGJ1aWx0SW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzLCBkZXN0aW5hdGlvbiwgYnVpbHRJbikge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydiZWZvcmUnXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5iZWZvcmUuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG4gICAqL1xuICBkZXN0aW5hdGlvblsnYWZ0ZXInXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5hZnRlci5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydyZXBsYWNlV2l0aCddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBjb25zdCB3YXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICBidWlsdEluLnJlcGxhY2VXaXRoLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUodGhpcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGRlc3RpbmF0aW9uWydyZW1vdmUnXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgIGJ1aWx0SW4ucmVtb3ZlLmNhbGwodGhpcyk7XG5cbiAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUodGhpcyk7XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uL1V0aWxpdGllcy5qcyc7XG5cbmltcG9ydCBQYXRjaFBhcmVudE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvUGFyZW50Tm9kZS5qcyc7XG5pbXBvcnQgUGF0Y2hDaGlsZE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvQ2hpbGROb2RlLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzKSB7XG4gIGlmIChOYXRpdmUuRWxlbWVudF9hdHRhY2hTaGFkb3cpIHtcbiAgICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdhdHRhY2hTaGFkb3cnLFxuICAgICAgLyoqXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEBwYXJhbSB7IXttb2RlOiBzdHJpbmd9fSBpbml0XG4gICAgICAgKiBAcmV0dXJuIHtTaGFkb3dSb290fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihpbml0KSB7XG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBOYXRpdmUuRWxlbWVudF9hdHRhY2hTaGFkb3cuY2FsbCh0aGlzLCBpbml0KTtcbiAgICAgICAgdGhpcy5fX0NFX3NoYWRvd1Jvb3QgPSBzaGFkb3dSb290O1xuICAgICAgICByZXR1cm4gc2hhZG93Um9vdDtcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIEVsZW1lbnRzOiBgRWxlbWVudCNhdHRhY2hTaGFkb3dgIHdhcyBub3QgcGF0Y2hlZC4nKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcGF0Y2hfaW5uZXJIVE1MKGRlc3RpbmF0aW9uLCBiYXNlRGVzY3JpcHRvcikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0aW5hdGlvbiwgJ2lubmVySFRNTCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGJhc2VEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGJhc2VEZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldDogLyoqIEB0aGlzIHtFbGVtZW50fSAqLyBmdW5jdGlvbihodG1sU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpO1xuXG4gICAgICAgIC8vIE5PVEU6IEluIElFMTEsIHdoZW4gdXNpbmcgdGhlIG5hdGl2ZSBgaW5uZXJIVE1MYCBzZXR0ZXIsIGFsbCBub2Rlc1xuICAgICAgICAvLyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZXNjZW5kYW50cyBvZiB0aGUgY29udGV4dCBlbGVtZW50IGhhdmUgYWxsIG9mXG4gICAgICAgIC8vIHRoZWlyIGNoaWxkcmVuIHJlbW92ZWQgYXMgcGFydCBvZiB0aGUgc2V0IC0gdGhlIGVudGlyZSBzdWJ0cmVlIGlzXG4gICAgICAgIC8vICdkaXNhc3NlbWJsZWQnLiBUaGlzIHdvcmsgYXJvdW5kIHdhbGtzIHRoZSBzdWJ0cmVlICpiZWZvcmUqIHVzaW5nIHRoZVxuICAgICAgICAvLyBuYXRpdmUgc2V0dGVyLlxuICAgICAgICAvKiogQHR5cGUgeyFBcnJheTwhRWxlbWVudD58dW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgcmVtb3ZlZEVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICByZW1vdmVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHModGhpcywgZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICByZW1vdmVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VEZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIGh0bWxTdHJpbmcpO1xuXG4gICAgICAgIGlmIChyZW1vdmVkRWxlbWVudHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlbW92ZWRFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgICAgICAgIGludGVybmFscy5kaXNjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgICAgaWYgKCF0aGlzLm93bmVyRG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICAgIGludGVybmFscy5wYXRjaFRyZWUodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWxTdHJpbmc7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTCAmJiBOYXRpdmUuRWxlbWVudF9pbm5lckhUTUwuZ2V0KSB7XG4gICAgcGF0Y2hfaW5uZXJIVE1MKEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuRWxlbWVudF9pbm5lckhUTUwpO1xuICB9IGVsc2UgaWYgKE5hdGl2ZS5IVE1MRWxlbWVudF9pbm5lckhUTUwgJiYgTmF0aXZlLkhUTUxFbGVtZW50X2lubmVySFRNTC5nZXQpIHtcbiAgICBwYXRjaF9pbm5lckhUTUwoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuSFRNTEVsZW1lbnRfaW5uZXJIVE1MKTtcbiAgfSBlbHNlIHtcblxuICAgIC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovXG4gICAgY29uc3QgcmF3RGl2ID0gTmF0aXZlLkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgJ2RpdicpO1xuXG4gICAgaW50ZXJuYWxzLmFkZFBhdGNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHBhdGNoX2lubmVySFRNTChlbGVtZW50LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gSW1wbGVtZW50cyBnZXR0aW5nIGBpbm5lckhUTUxgIGJ5IHBlcmZvcm1pbmcgYW4gdW5wYXRjaGVkIGBjbG9uZU5vZGVgXG4gICAgICAgIC8vIG9mIHRoZSBlbGVtZW50IGFuZCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBlbGVtZW50J3MgYGlubmVySFRNTGAuXG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgdG9vIGV4cGVuc2l2ZT9cbiAgICAgICAgZ2V0OiAvKiogQHRoaXMge0VsZW1lbnR9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBOYXRpdmUuTm9kZV9jbG9uZU5vZGUuY2FsbCh0aGlzLCB0cnVlKS5pbm5lckhUTUw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEltcGxlbWVudHMgc2V0dGluZyBgaW5uZXJIVE1MYCBieSBjcmVhdGluZyBhbiB1bnBhdGNoZWQgZWxlbWVudCxcbiAgICAgICAgLy8gc2V0dGluZyBgaW5uZXJIVE1MYCBvZiB0aGF0IGVsZW1lbnQgYW5kIHJlcGxhY2luZyB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIGVsZW1lbnQncyBjaGlsZHJlbiB3aXRoIHRob3NlIG9mIHRoZSB1bnBhdGNoZWQgZWxlbWVudC5cbiAgICAgICAgc2V0OiAvKiogQHRoaXMge0VsZW1lbnR9ICovIGZ1bmN0aW9uKGFzc2lnbmVkVmFsdWUpIHtcbiAgICAgICAgICAvLyBOT1RFOiByZS1yb3V0ZSB0byBgY29udGVudGAgZm9yIGB0ZW1wbGF0ZWAgZWxlbWVudHMuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGJlY2F1c2UgYHRlbXBsYXRlLmFwcGVuZENoaWxkYCBkb2VzIG5vdFxuICAgICAgICAgIC8vIHJvdXRlIGludG8gYHRlbXBsYXRlLmNvbnRlbnRgLlxuICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMubG9jYWxOYW1lID09PSAndGVtcGxhdGUnID8gKC8qKiBAdHlwZSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9ICovICh0aGlzKSkuY29udGVudCA6IHRoaXM7XG4gICAgICAgICAgcmF3RGl2LmlubmVySFRNTCA9IGFzc2lnbmVkVmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwoY29udGVudCwgY29udGVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJhd0Rpdi5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwoY29udGVudCwgcmF3RGl2LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdzZXRBdHRyaWJ1dGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICBuZXdWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG51bGwpO1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3NldEF0dHJpYnV0ZU5TJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZXNwYWNlLCBuYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGludGVybmFscy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcywgbmFtZSwgb2xkVmFsdWUsIG51bGwsIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3JlbW92ZUF0dHJpYnV0ZU5TJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZXNwYWNlLCBuYW1lKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICByZXR1cm4gTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIC8vIEluIG9sZGVyIGJyb3dzZXJzLCBgRWxlbWVudCNnZXRBdHRyaWJ1dGVOU2AgbWF5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICAvLyBpbnN0ZWFkIG9mIG51bGwgaWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdC4gRm9yIGRldGFpbHMsIHNlZTtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEF0dHJpYnV0ZU5TI05vdGVzXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfSk7XG5cblxuICBmdW5jdGlvbiBwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQoZGVzdGluYXRpb24sIGJhc2VNZXRob2QpIHtcbiAgICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoZGVzdGluYXRpb24sICdpbnNlcnRBZGphY2VudEVsZW1lbnQnLFxuICAgICAgLyoqXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aGVyZVxuICAgICAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7P0VsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHdoZXJlLCBlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWRFbGVtZW50ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cbiAgICAgICAgICAoYmFzZU1ldGhvZC5jYWxsKHRoaXMsIHdoZXJlLCBlbGVtZW50KSk7XG5cbiAgICAgICAgaWYgKHdhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQoaW5zZXJ0ZWRFbGVtZW50KSkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zZXJ0ZWRFbGVtZW50O1xuICAgICAgfSk7XG4gIH1cblxuICBpZiAoTmF0aXZlLkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCkge1xuICAgIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChIVE1MRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5IVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpO1xuICB9IGVsc2UgaWYgKE5hdGl2ZS5FbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCkge1xuICAgIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChFbGVtZW50LnByb3RvdHlwZSwgTmF0aXZlLkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBFbGVtZW50czogYEVsZW1lbnQjaW5zZXJ0QWRqYWNlbnRFbGVtZW50YCB3YXMgbm90IHBhdGNoZWQuJyk7XG4gIH1cblxuXG4gIFBhdGNoUGFyZW50Tm9kZShpbnRlcm5hbHMsIEVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgcHJlcGVuZDogTmF0aXZlLkVsZW1lbnRfcHJlcGVuZCxcbiAgICBhcHBlbmQ6IE5hdGl2ZS5FbGVtZW50X2FwcGVuZCxcbiAgfSk7XG5cbiAgUGF0Y2hDaGlsZE5vZGUoaW50ZXJuYWxzLCBFbGVtZW50LnByb3RvdHlwZSwge1xuICAgIGJlZm9yZTogTmF0aXZlLkVsZW1lbnRfYmVmb3JlLFxuICAgIGFmdGVyOiBOYXRpdmUuRWxlbWVudF9hZnRlcixcbiAgICByZXBsYWNlV2l0aDogTmF0aXZlLkVsZW1lbnRfcmVwbGFjZVdpdGgsXG4gICAgcmVtb3ZlOiBOYXRpdmUuRWxlbWVudF9yZW1vdmUsXG4gIH0pO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRSZWdpc3RyeSBmcm9tICcuL0N1c3RvbUVsZW1lbnRSZWdpc3RyeS5qcyc7XG5cbmltcG9ydCBQYXRjaEhUTUxFbGVtZW50IGZyb20gJy4vUGF0Y2gvSFRNTEVsZW1lbnQuanMnO1xuaW1wb3J0IFBhdGNoRG9jdW1lbnQgZnJvbSAnLi9QYXRjaC9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgUGF0Y2hOb2RlIGZyb20gJy4vUGF0Y2gvTm9kZS5qcyc7XG5pbXBvcnQgUGF0Y2hFbGVtZW50IGZyb20gJy4vUGF0Y2gvRWxlbWVudC5qcyc7XG5cbmNvbnN0IHByaW9yQ3VzdG9tRWxlbWVudHMgPSB3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ107XG5cbmlmICghcHJpb3JDdXN0b21FbGVtZW50cyB8fFxuICAgICBwcmlvckN1c3RvbUVsZW1lbnRzWydmb3JjZVBvbHlmaWxsJ10gfHxcbiAgICAgKHR5cGVvZiBwcmlvckN1c3RvbUVsZW1lbnRzWydkZWZpbmUnXSAhPSAnZnVuY3Rpb24nKSB8fFxuICAgICAodHlwZW9mIHByaW9yQ3VzdG9tRWxlbWVudHNbJ2dldCddICE9ICdmdW5jdGlvbicpKSB7XG4gIC8qKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9ICovXG4gIGNvbnN0IGludGVybmFscyA9IG5ldyBDdXN0b21FbGVtZW50SW50ZXJuYWxzKCk7XG5cbiAgUGF0Y2hIVE1MRWxlbWVudChpbnRlcm5hbHMpO1xuICBQYXRjaERvY3VtZW50KGludGVybmFscyk7XG4gIFBhdGNoTm9kZShpbnRlcm5hbHMpO1xuICBQYXRjaEVsZW1lbnQoaW50ZXJuYWxzKTtcblxuICAvLyBUaGUgbWFpbiBkb2N1bWVudCBpcyBhbHdheXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgZG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeSA9IHRydWU7XG5cbiAgLyoqIEB0eXBlIHshQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5fSAqL1xuICBjb25zdCBjdXN0b21FbGVtZW50cyA9IG5ldyBDdXN0b21FbGVtZW50UmVnaXN0cnkoaW50ZXJuYWxzKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnY3VzdG9tRWxlbWVudHMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGN1c3RvbUVsZW1lbnRzLFxuICB9KTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLy8gQHZlcnNpb24gMC43LjIyXG5pZiAodHlwZW9mIFdlYWtNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgY291bnRlciA9IERhdGUubm93KCkgJSAxZTk7XG4gICAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiX19zdFwiICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApICsgKGNvdW50ZXIrKyArIFwiX19cIik7XG4gICAgfTtcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIGVudHJ5WzFdID0gdmFsdWU7IGVsc2UgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgcmV0dXJuIChlbnRyeSA9IGtleVt0aGlzLm5hbWVdKSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZW50cnlbMF0gPSBlbnRyeVsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5WzBdID09PSBrZXk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuV2Vha01hcCA9IFdlYWtNYXA7XG4gIH0pKCk7XG59XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgaWYgKGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzZXRJbW1lZGlhdGU7XG4gIGlmICgvVHJpZGVudHxFZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcbiAgfSBlbHNlIGlmICh3aW5kb3cuc2V0SW1tZWRpYXRlKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gd2luZG93LnNldEltbWVkaWF0ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICB2YXIgc2VudGluZWwgPSBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmRhdGEgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNldEltbWVkaWF0ZVF1ZXVlO1xuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZVF1ZXVlLnB1c2goZnVuYyk7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2Uoc2VudGluZWwsIFwiKlwiKTtcbiAgICB9O1xuICB9XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2sob2JzZXJ2ZXIpIHtcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0SW1tZWRpYXRlKGRpc3BhdGNoQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrcygpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBvYnNlcnZlcnMgPSBzY2hlZHVsZWRPYnNlcnZlcnM7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICByZXR1cm4gbzEudWlkXyAtIG8yLnVpZF87XG4gICAgfSk7XG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFja18ocXVldWUsIG9ic2VydmVyKTtcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJldHVybjtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHJlZ2lzdHJhdGlvbi5yZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSByZWdpc3RyYXRpb24ub3B0aW9ucztcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBjYWxsYmFjayhvcHRpb25zKTtcbiAgICAgICAgICBpZiAocmVjb3JkKSByZWdpc3RyYXRpb24uZW5xdWV1ZShyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciB1aWRDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gSnNNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLm5vZGVzXyA9IFtdO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XG4gIH1cbiAgSnNNdXRhdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldCA9IHdyYXBJZk5lZWRlZCh0YXJnZXQpO1xuICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEgfHwgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xuICAgICAgICB0aGlzLm5vZGVzXy5wdXNoKHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB9LFxuICAgIHRha2VSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5T2ZSZWNvcmRzID0gdGhpcy5yZWNvcmRzXztcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICAgIHJldHVybiBjb3B5T2ZSZWNvcmRzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcbiAgICB0aGlzLm9sZFZhbHVlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcbiAgICB2YXIgcmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKG9yaWdpbmFsLnR5cGUsIG9yaWdpbmFsLnRhcmdldCk7XG4gICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBvcmlnaW5hbC5hZGRlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBvcmlnaW5hbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmVjb3JkLm5leHRTaWJsaW5nID0gb3JpZ2luYWwubmV4dFNpYmxpbmc7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgcmVjb3JkLm9sZFZhbHVlID0gb3JpZ2luYWwub2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuICB2YXIgY3VycmVudFJlY29yZCwgcmVjb3JkV2l0aE9sZFZhbHVlO1xuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZSA9IGNvcHlNdXRhdGlvblJlY29yZChjdXJyZW50UmVjb3JkKTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcbiAgICBjdXJyZW50UmVjb3JkID0gcmVjb3JkV2l0aE9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZCA9PT0gcmVjb3JkV2l0aE9sZFZhbHVlIHx8IHJlY29yZCA9PT0gY3VycmVudFJlY29yZDtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IG5ld1JlY29yZCkgcmV0dXJuIGxhc3RSZWNvcmQ7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSAmJiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKGxhc3RSZWNvcmQpKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIFJlZ2lzdHJhdGlvbihvYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gIH1cbiAgUmVnaXN0cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHZhciByZWNvcmRzID0gdGhpcy5vYnNlcnZlci5yZWNvcmRzXztcbiAgICAgIHZhciBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDtcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RSZWNvcmQgPSByZWNvcmRzW2xlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xuICAgICAgICAgIHJlY29yZHNbbGVuZ3RoIC0gMV0gPSByZWNvcmRUb1JlcGxhY2VMYXN0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIHJlY29yZHNbbGVuZ3RoXSA9IHJlY29yZDtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGRUcmFuc2llbnRPYnNlcnZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18obm9kZSk7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldChub2RlLCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gICAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18obm9kZSk7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XG4gICAgICAgIHZhciBuYW1lID0gZS5hdHRyTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGUucmVsYXRlZE5vZGUubmFtZXNwYWNlVVJJO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXcgZ2V0UmVjb3JkKFwiYXR0cmlidXRlc1wiLCB0YXJnZXQpO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUuYXR0ckNoYW5nZSA9PT0gTXV0YXRpb25FdmVudC5BRERJVElPTiA/IG51bGwgOiBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWVzcGFjZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoYXJhY3RlckRhdGFcIiwgdGFyZ2V0KTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVSZW1vdmVkXCI6XG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVJbnNlcnRlZFwiOlxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcztcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJET01Ob2RlSW5zZXJ0ZWRcIikge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjaGFuZ2VkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoaWxkTGlzdFwiLCBlLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xuICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKGUucmVsYXRlZE5vZGUsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0KSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjbGVhclJlY29yZHMoKTtcbiAgICB9XG4gIH07XG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmICghZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgICBKc011dGF0aW9uT2JzZXJ2ZXIuX2lzUG9seWZpbGxlZCA9IHRydWU7XG4gIH1cbn0pKHNlbGYpOyIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTIgQmFybmVzYW5kbm9ibGUuY29tLCBsbGMsIERvbmF2b24gV2VzdCwgYW5kIERvbWVuaWMgRGVuaWNvbGFcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNldEltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJncykge1xuICAgICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gcGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgc2V0SW1tZWRpYXRlLCBidXRcbiAgICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBubyBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcIlwiICsgaGFuZGxlcikpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufShzZWxmKSk7XG4iLCIvLyBDYXV0aW9uOlxuLy8gRG8gbm90IHJlcGxhY2UgdGhpcyBpbXBvcnQgc3RhdGVtZW50IHdpdGggY29kZXMuXG4vL1xuLy8gSWYgeW91IHJlcGxhY2UgdGhpcyBpbXBvcnQgc3RhdGVtZW50IHdpdGggY29kZXMsXG4vLyB0aGUgY29kZXMgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgZm9sbG93aW5nIHBvbHlmaWxscyBhcmUgaW1wb3J0ZWRcbi8vIGJlY2F1c2UgaW1wb3J0IHN0YXRlbWVudHMgYXJlIGhvaXN0ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLlxuaW1wb3J0ICcuL3BvbHlmaWxsLXN3aXRjaGVzJztcblxuLy8gUG9seWZpbGwgRUNNQVNjcmlwdCBzdGFuZGFyZCBmZWF0dXJlcyB3aXRoIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uXG5pbXBvcnQgJ2NvcmUtanMvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL3NldCc7XG5pbXBvcnQgJ2NvcmUtanMvZm4vbWFwJztcblxuLy8gUG9seWZpbGwgQ3VzdG9tIEVsZW1lbnRzIHYxIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9jdXN0b20tZWxlbWVudHMnO1xuXG4vLyBQb2x5ZmlsbCBNdXRhdGlvbk9ic2VydmVyIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnLi9NdXRhdGlvbk9ic2VydmVyQDAuNy4yMi9NdXRhdGlvbk9ic2VydmVyLmpzJztcblxuLy8gUG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnLi9zZXRJbW1lZGlhdGVAMS4wLjIrbW9kL3NldEltbWVkaWF0ZS5qcyc7XG4iLCI7KGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8qKlxuXHQgKiBAcHJlc2VydmUgRmFzdENsaWNrOiBwb2x5ZmlsbCB0byByZW1vdmUgY2xpY2sgZGVsYXlzIG9uIGJyb3dzZXJzIHdpdGggdG91Y2ggVUlzLlxuXHQgKlxuXHQgKiBAY29kaW5nc3RhbmRhcmQgZnRsYWJzLWpzdjJcblx0ICogQGNvcHlyaWdodCBUaGUgRmluYW5jaWFsIFRpbWVzIExpbWl0ZWQgW0FsbCBSaWdodHMgUmVzZXJ2ZWRdXG5cdCAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChzZWUgTElDRU5TRS50eHQpXG5cdCAqL1xuXG5cdC8qanNsaW50IGJyb3dzZXI6dHJ1ZSwgbm9kZTp0cnVlKi9cblx0LypnbG9iYWwgZGVmaW5lLCBFdmVudCwgTm9kZSovXG5cblxuXHQvKipcblx0ICogSW5zdGFudGlhdGUgZmFzdC1jbGlja2luZyBsaXN0ZW5lcnMgb24gdGhlIHNwZWNpZmllZCBsYXllci5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0ZnVuY3Rpb24gRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0dmFyIG9sZE9uQ2xpY2s7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgYSBjbGljayBpcyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGltZXN0YW1wIGZvciB3aGVuIGNsaWNrIHRyYWNraW5nIHN0YXJ0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbGVtZW50IGJlaW5nIHRyYWNrZWQgZm9yIGEgY2xpY2suXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFdmVudFRhcmdldFxuXHRcdCAqL1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFgtY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFggPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBZLWNvb3JkaW5hdGUgb2YgdG91Y2ggc3RhcnQgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogSUQgb2YgdGhlIGxhc3QgdG91Y2gsIHJldHJpZXZlZCBmcm9tIFRvdWNoLmlkZW50aWZpZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUb3VjaG1vdmUgYm91bmRhcnksIGJleW9uZCB3aGljaCBhIGNsaWNrIHdpbGwgYmUgY2FuY2VsbGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaEJvdW5kYXJ5ID0gb3B0aW9ucy50b3VjaEJvdW5kYXJ5IHx8IDEwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaGUgRmFzdENsaWNrIGxheWVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgRWxlbWVudFxuXHRcdCAqL1xuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIHRpbWUgYmV0d2VlbiB0YXAodG91Y2hzdGFydCBhbmQgdG91Y2hlbmQpIGV2ZW50c1xuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBEZWxheSA9IG9wdGlvbnMudGFwRGVsYXkgfHwgMjAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gdGltZSBmb3IgYSB0YXBcblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudGFwVGltZW91dCA9IG9wdGlvbnMudGFwVGltZW91dCB8fCA3MDA7XG5cblx0XHRpZiAoRmFzdENsaWNrLm5vdE5lZWRlZChsYXllcikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBBbmRyb2lkIGRvbid0IGhhdmUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblx0XHRmdW5jdGlvbiBiaW5kKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7IH07XG5cdFx0fVxuXG5cblx0XHR2YXIgbWV0aG9kcyA9IFsnb25Nb3VzZScsICdvbkNsaWNrJywgJ29uVG91Y2hTdGFydCcsICdvblRvdWNoTW92ZScsICdvblRvdWNoRW5kJywgJ29uVG91Y2hDYW5jZWwnXTtcblx0XHR2YXIgY29udGV4dCA9IHRoaXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtZXRob2RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29udGV4dFttZXRob2RzW2ldXSA9IGJpbmQoY29udGV4dFttZXRob2RzW2ldXSwgY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIGV2ZW50IGhhbmRsZXJzIGFzIHJlcXVpcmVkXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblxuXHRcdC8vIEhhY2sgaXMgcmVxdWlyZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdC8vIHdoaWNoIGlzIGhvdyBGYXN0Q2xpY2sgbm9ybWFsbHkgc3RvcHMgY2xpY2sgZXZlbnRzIGJ1YmJsaW5nIHRvIGNhbGxiYWNrcyByZWdpc3RlcmVkIG9uIHRoZSBGYXN0Q2xpY2tcblx0XHQvLyBsYXllciB3aGVuIHRoZXkgYXJlIGNhbmNlbGxlZC5cblx0XHRpZiAoIUV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgcm12ID0gTm9kZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRybXYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgYWR2ID0gTm9kZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgKGNhbGxiYWNrLmhpamFja2VkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGlmICghZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSwgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWR2LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBJZiBhIGhhbmRsZXIgaXMgYWxyZWFkeSBkZWNsYXJlZCBpbiB0aGUgZWxlbWVudCdzIG9uY2xpY2sgYXR0cmlidXRlLCBpdCB3aWxsIGJlIGZpcmVkIGJlZm9yZVxuXHRcdC8vIEZhc3RDbGljaydzIG9uQ2xpY2sgaGFuZGxlci4gRml4IHRoaXMgYnkgcHVsbGluZyBvdXQgdGhlIHVzZXItZGVmaW5lZCBoYW5kbGVyIGZ1bmN0aW9uIGFuZFxuXHRcdC8vIGFkZGluZyBpdCBhcyBsaXN0ZW5lci5cblx0XHRpZiAodHlwZW9mIGxheWVyLm9uY2xpY2sgPT09ICdmdW5jdGlvbicpIHtcblxuXHRcdFx0Ly8gQW5kcm9pZCBicm93c2VyIG9uIGF0IGxlYXN0IDMuMiByZXF1aXJlcyBhIG5ldyByZWZlcmVuY2UgdG8gdGhlIGZ1bmN0aW9uIGluIGxheWVyLm9uY2xpY2tcblx0XHRcdC8vIC0gdGhlIG9sZCBvbmUgd29uJ3Qgd29yayBpZiBwYXNzZWQgdG8gYWRkRXZlbnRMaXN0ZW5lciBkaXJlY3RseS5cblx0XHRcdG9sZE9uQ2xpY2sgPSBsYXllci5vbmNsaWNrO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRvbGRPbkNsaWNrKGV2ZW50KTtcblx0XHRcdH0sIGZhbHNlKTtcblx0XHRcdGxheWVyLm9uY2xpY2sgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIFdpbmRvd3MgUGhvbmUgOC4xIGZha2VzIHVzZXIgYWdlbnQgc3RyaW5nIHRvIGxvb2sgbGlrZSBBbmRyb2lkIGFuZCBpUGhvbmUuXG5cdCpcblx0KiBAdHlwZSBib29sZWFuXG5cdCovXG5cdHZhciBkZXZpY2VJc1dpbmRvd3NQaG9uZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIldpbmRvd3MgUGhvbmVcIikgPj0gMDtcblxuXHQvKipcblx0ICogQW5kcm9pZCByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPiAwICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TID0gL2lQKGFkfGhvbmV8b2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNCByZXF1aXJlcyBhbiBleGNlcHRpb24gZm9yIHNlbGVjdCBlbGVtZW50cy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TNCA9IGRldmljZUlzSU9TICYmICgvT1MgNF9cXGQoX1xcZCk/LykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNi4wLTcuKiByZXF1aXJlcyB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gYmUgbWFudWFsbHkgZGVyaXZlZFxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyBbNi03XV9cXGQvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdC8qKlxuXHQgKiBCbGFja0JlcnJ5IHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0JsYWNrQmVycnkxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQkIxMCcpID4gMDtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgbmF0aXZlIGNsaWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBuZWVkcyBhIG5hdGl2ZSBjbGlja1xuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0NsaWNrID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2VuZCBhIHN5bnRoZXRpYyBjbGljayB0byBkaXNhYmxlZCBpbnB1dHMgKGlzc3VlICM2Milcblx0XHRjYXNlICdidXR0b24nOlxuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0aWYgKHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaW5wdXQnOlxuXG5cdFx0XHQvLyBGaWxlIGlucHV0cyBuZWVkIHJlYWwgY2xpY2tzIG9uIGlPUyA2IGR1ZSB0byBhIGJyb3dzZXIgYnVnIChpc3N1ZSAjNjgpXG5cdFx0XHRpZiAoKGRldmljZUlzSU9TICYmIHRhcmdldC50eXBlID09PSAnZmlsZScpIHx8IHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGFiZWwnOlxuXHRcdGNhc2UgJ2lmcmFtZSc6IC8vIGlPUzggaG9tZXNjcmVlbiBhcHBzIGNhbiBwcmV2ZW50IGV2ZW50cyBidWJibGluZyBpbnRvIGZyYW1lc1xuXHRcdGNhc2UgJ3ZpZGVvJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiAoL1xcYm5lZWRzY2xpY2tcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgY2xpY2sgaW50byBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgbmF0aXZlIGNsaWNrLlxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0ZvY3VzID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdGNhc2UgJ3RleHRhcmVhJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0XHRyZXR1cm4gIWRldmljZUlzQW5kcm9pZDtcblx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRzd2l0Y2ggKHRhcmdldC50eXBlKSB7XG5cdFx0XHRjYXNlICdidXR0b24nOlxuXHRcdFx0Y2FzZSAnY2hlY2tib3gnOlxuXHRcdFx0Y2FzZSAnZmlsZSc6XG5cdFx0XHRjYXNlICdpbWFnZSc6XG5cdFx0XHRjYXNlICdyYWRpbyc6XG5cdFx0XHRjYXNlICdzdWJtaXQnOlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vIHBvaW50IGluIGF0dGVtcHRpbmcgdG8gZm9jdXMgZGlzYWJsZWQgaW5wdXRzXG5cdFx0XHRyZXR1cm4gIXRhcmdldC5kaXNhYmxlZCAmJiAhdGFyZ2V0LnJlYWRPbmx5O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gKC9cXGJuZWVkc2ZvY3VzXFxiLykudGVzdCh0YXJnZXQuY2xhc3NOYW1lKTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogU2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnNlbmRDbGljayA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQsIGV2ZW50KSB7XG5cdFx0dmFyIGNsaWNrRXZlbnQsIHRvdWNoO1xuXG5cdFx0Ly8gT24gc29tZSBBbmRyb2lkIGRldmljZXMgYWN0aXZlRWxlbWVudCBuZWVkcyB0byBiZSBibHVycmVkIG90aGVyd2lzZSB0aGUgc3ludGhldGljIGNsaWNrIHdpbGwgaGF2ZSBubyBlZmZlY3QgKCMyNClcblx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0YXJnZXRFbGVtZW50KSB7XG5cdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcblx0XHR9XG5cblx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0Ly8gU3ludGhlc2l6ZSBhIGNsaWNrIGV2ZW50LCB3aXRoIGFuIGV4dHJhIGF0dHJpYnV0ZSBzbyBpdCBjYW4gYmUgdHJhY2tlZFxuXHRcdGNsaWNrRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0XHRjbGlja0V2ZW50LmluaXRNb3VzZUV2ZW50KHRoaXMuZGV0ZXJtaW5lRXZlbnRUeXBlKHRhcmdldEVsZW1lbnQpLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIHRvdWNoLnNjcmVlblgsIHRvdWNoLnNjcmVlblksIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblx0XHRjbGlja0V2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQgPSB0cnVlO1xuXHRcdHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcblx0fTtcblxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRldGVybWluZUV2ZW50VHlwZSA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblxuXHRcdC8vSXNzdWUgIzE1OTogQW5kcm9pZCBDaHJvbWUgU2VsZWN0IEJveCBkb2VzIG5vdCBvcGVuIHdpdGggYSBzeW50aGV0aWMgY2xpY2sgZXZlbnRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkICYmIHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xuXHRcdFx0cmV0dXJuICdtb3VzZWRvd24nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnY2xpY2snO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgbGVuZ3RoO1xuXG5cdFx0Ly8gSXNzdWUgIzE2MDogb24gaU9TIDcsIHNvbWUgaW5wdXQgZWxlbWVudHMgKGUuZy4gZGF0ZSBkYXRldGltZSBtb250aCkgdGhyb3cgYSB2YWd1ZSBUeXBlRXJyb3Igb24gc2V0U2VsZWN0aW9uUmFuZ2UuIFRoZXNlIGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gaW50ZWdlciB2YWx1ZSBmb3IgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgcHJvcGVydGllcywgYnV0IHVuZm9ydHVuYXRlbHkgdGhhdCBjYW4ndCBiZSB1c2VkIGZvciBkZXRlY3Rpb24gYmVjYXVzZSBhY2Nlc3NpbmcgdGhlIHByb3BlcnRpZXMgYWxzbyB0aHJvd3MgYSBUeXBlRXJyb3IuIEp1c3QgY2hlY2sgdGhlIHR5cGUgaW5zdGVhZC4gRmlsZWQgYXMgQXBwbGUgYnVnICMxNTEyMjcyNC5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSAmJiB0YXJnZXRFbGVtZW50LnR5cGUuaW5kZXhPZignZGF0ZScpICE9PSAwICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ3RpbWUnICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ21vbnRoJykge1xuXHRcdFx0bGVuZ3RoID0gdGFyZ2V0RWxlbWVudC52YWx1ZS5sZW5ndGg7XG5cdFx0XHR0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciBhbmQgaWYgc28sIHNldCBhIGZsYWcgb24gaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS51cGRhdGVTY3JvbGxQYXJlbnQgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50KSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudCwgcGFyZW50RWxlbWVudDtcblxuXHRcdHNjcm9sbFBhcmVudCA9IHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBkaXNjb3ZlciB3aGV0aGVyIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgc2Nyb2xsYWJsZSBsYXllci4gUmUtY2hlY2sgaWYgdGhlXG5cdFx0Ly8gdGFyZ2V0IGVsZW1lbnQgd2FzIG1vdmVkIHRvIGFub3RoZXIgcGFyZW50LlxuXHRcdGlmICghc2Nyb2xsUGFyZW50IHx8ICFzY3JvbGxQYXJlbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdHBhcmVudEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAocGFyZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodCkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSBwYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdH0gd2hpbGUgKHBhcmVudEVsZW1lbnQpO1xuXHRcdH1cblxuXHRcdC8vIEFsd2F5cyB1cGRhdGUgdGhlIHNjcm9sbCB0b3AgdHJhY2tlciBpZiBwb3NzaWJsZS5cblx0XHRpZiAoc2Nyb2xsUGFyZW50KSB7XG5cdFx0XHRzY3JvbGxQYXJlbnQuZmFzdENsaWNrTGFzdFNjcm9sbFRvcCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3A7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQgPSBmdW5jdGlvbihldmVudFRhcmdldCkge1xuXG5cdFx0Ly8gT24gc29tZSBvbGRlciBicm93c2VycyAobm90YWJseSBTYWZhcmkgb24gaU9TIDQuMSAtIHNlZSBpc3N1ZSAjNTYpIHRoZSBldmVudCB0YXJnZXQgbWF5IGJlIGEgdGV4dCBub2RlLlxuXHRcdGlmIChldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdHJldHVybiBldmVudFRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudFRhcmdldDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBzdGFydCwgcmVjb3JkIHRoZSBwb3NpdGlvbiBhbmQgc2Nyb2xsIG9mZnNldC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRhcmdldEVsZW1lbnQsIHRvdWNoLCBzZWxlY3Rpb247XG5cblx0XHQvLyBJZ25vcmUgbXVsdGlwbGUgdG91Y2hlcywgb3RoZXJ3aXNlIHBpbmNoLXRvLXpvb20gaXMgcHJldmVudGVkIGlmIGJvdGggZmluZ2VycyBhcmUgb24gdGhlIEZhc3RDbGljayBlbGVtZW50IChpc3N1ZSAjMTExKS5cblx0XHRpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cdFx0dG91Y2ggPSBldmVudC50YXJnZXRUb3VjaGVzWzBdO1xuXG5cdFx0Ly8gSWdub3JlIHRvdWNoZXMgb24gY29udGVudGVkaXRhYmxlIGVsZW1lbnRzIHRvIHByZXZlbnQgY29uZmxpY3Qgd2l0aCB0ZXh0IHNlbGVjdGlvbi5cblx0XHQvLyAoRm9yIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mdGxhYnMvZmFzdGNsaWNrL3B1bGwvMjExIClcblx0XHRpZiAodGFyZ2V0RWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGRldmljZUlzSU9TKSB7XG5cblx0XHRcdC8vIE9ubHkgdHJ1c3RlZCBldmVudHMgd2lsbCBkZXNlbGVjdCB0ZXh0IG9uIGlPUyAoaXNzdWUgIzQ5KVxuXHRcdFx0c2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHRcdFx0aWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdFx0Ly8gV2VpcmQgdGhpbmdzIGhhcHBlbiBvbiBpT1Mgd2hlbiBhbiBhbGVydCBvciBjb25maXJtIGRpYWxvZyBpcyBvcGVuZWQgZnJvbSBhIGNsaWNrIGV2ZW50IGNhbGxiYWNrIChpc3N1ZSAjMjMpOlxuXHRcdFx0XHQvLyB3aGVuIHRoZSB1c2VyIG5leHQgdGFwcyBhbnl3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCBuZXcgdG91Y2hzdGFydCBhbmQgdG91Y2hlbmQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkXG5cdFx0XHRcdC8vIHdpdGggdGhlIHNhbWUgaWRlbnRpZmllciBhcyB0aGUgdG91Y2ggZXZlbnQgdGhhdCBwcmV2aW91c2x5IHRyaWdnZXJlZCB0aGUgY2xpY2sgdGhhdCB0cmlnZ2VyZWQgdGhlIGFsZXJ0LlxuXHRcdFx0XHQvLyBTYWRseSwgdGhlcmUgaXMgYW4gaXNzdWUgb24gaU9TIDQgdGhhdCBjYXVzZXMgc29tZSBub3JtYWwgdG91Y2ggZXZlbnRzIHRvIGhhdmUgdGhlIHNhbWUgaWRlbnRpZmllciBhcyBhblxuXHRcdFx0XHQvLyBpbW1lZGlhdGVseSBwcmVjZWRpbmcgdG91Y2ggZXZlbnQgKGlzc3VlICM1MiksIHNvIHRoaXMgZml4IGlzIHVuYXZhaWxhYmxlIG9uIHRoYXQgcGxhdGZvcm0uXG5cdFx0XHRcdC8vIElzc3VlIDEyMDogdG91Y2guaWRlbnRpZmllciBpcyAwIHdoZW4gQ2hyb21lIGRldiB0b29scyAnRW11bGF0ZSB0b3VjaCBldmVudHMnIGlzIHNldCB3aXRoIGFuIGlPUyBkZXZpY2UgVUEgc3RyaW5nLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYWxsIHRvdWNoIGV2ZW50cyB0byBiZSBpZ25vcmVkLiBBcyB0aGlzIGJsb2NrIG9ubHkgYXBwbGllcyB0byBpT1MsIGFuZCBpT1MgaWRlbnRpZmllcnMgYXJlIGFsd2F5cyBsb25nLFxuXHRcdFx0XHQvLyByYW5kb20gaW50ZWdlcnMsIGl0J3Mgc2FmZSB0byB0byBjb250aW51ZSBpZiB0aGUgaWRlbnRpZmllciBpcyAwIGhlcmUuXG5cdFx0XHRcdGlmICh0b3VjaC5pZGVudGlmaWVyICYmIHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMubGFzdFRvdWNoSWRlbnRpZmllcikge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBhIHNjcm9sbGFibGUgbGF5ZXIgKHVzaW5nIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgYW5kOlxuXHRcdFx0XHQvLyAxKSB0aGUgdXNlciBkb2VzIGEgZmxpbmcgc2Nyb2xsIG9uIHRoZSBzY3JvbGxhYmxlIGxheWVyXG5cdFx0XHRcdC8vIDIpIHRoZSB1c2VyIHN0b3BzIHRoZSBmbGluZyBzY3JvbGwgd2l0aCBhbm90aGVyIHRhcFxuXHRcdFx0XHQvLyB0aGVuIHRoZSBldmVudC50YXJnZXQgb2YgdGhlIGxhc3QgJ3RvdWNoZW5kJyBldmVudCB3aWxsIGJlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHVuZGVyIHRoZSB1c2VyJ3MgZmluZ2VyXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGZsaW5nIHNjcm9sbCB3YXMgc3RhcnRlZCwgY2F1c2luZyBGYXN0Q2xpY2sgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoYXQgbGF5ZXIgLSB1bmxlc3MgYSBjaGVja1xuXHRcdFx0XHQvLyBpcyBtYWRlIHRvIGVuc3VyZSB0aGF0IGEgcGFyZW50IGxheWVyIHdhcyBub3Qgc2Nyb2xsZWQgYmVmb3JlIHNlbmRpbmcgYSBzeW50aGV0aWMgY2xpY2sgKGlzc3VlICM0MikuXG5cdFx0XHRcdHRoaXMudXBkYXRlU2Nyb2xsUGFyZW50KHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IHRydWU7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSBldmVudC50aW1lU3RhbXA7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcblxuXHRcdHRoaXMudG91Y2hTdGFydFggPSB0b3VjaC5wYWdlWDtcblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gdG91Y2gucGFnZVk7XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkgJiYgKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPiAtMSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBCYXNlZCBvbiBhIHRvdWNobW92ZSBldmVudCBvYmplY3QsIGNoZWNrIHdoZXRoZXIgdGhlIHRvdWNoIGhhcyBtb3ZlZCBwYXN0IGEgYm91bmRhcnkgc2luY2UgaXQgc3RhcnRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnRvdWNoSGFzTW92ZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLCBib3VuZGFyeSA9IHRoaXMudG91Y2hCb3VuZGFyeTtcblxuXHRcdGlmIChNYXRoLmFicyh0b3VjaC5wYWdlWCAtIHRoaXMudG91Y2hTdGFydFgpID4gYm91bmRhcnkgfHwgTWF0aC5hYnModG91Y2gucGFnZVkgLSB0aGlzLnRvdWNoU3RhcnRZKSA+IGJvdW5kYXJ5KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBsYXN0IHBvc2l0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgdG91Y2ggaGFzIG1vdmVkLCBjYW5jZWwgdGhlIGNsaWNrIHRyYWNraW5nXG5cdFx0aWYgKHRoaXMudGFyZ2V0RWxlbWVudCAhPT0gdGhpcy5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCkgfHwgdGhpcy50b3VjaEhhc01vdmVkKGV2ZW50KSkge1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gZmluZCB0aGUgbGFiZWxsZWQgY29udHJvbCBmb3IgdGhlIGdpdmVuIGxhYmVsIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8SFRNTExhYmVsRWxlbWVudH0gbGFiZWxFbGVtZW50XG5cdCAqIEByZXR1cm5zIHtFbGVtZW50fG51bGx9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZpbmRDb250cm9sID0gZnVuY3Rpb24obGFiZWxFbGVtZW50KSB7XG5cblx0XHQvLyBGYXN0IHBhdGggZm9yIG5ld2VyIGJyb3dzZXJzIHN1cHBvcnRpbmcgdGhlIEhUTUw1IGNvbnRyb2wgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5jb250cm9sICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBsYWJlbEVsZW1lbnQuY29udHJvbDtcblx0XHR9XG5cblx0XHQvLyBBbGwgYnJvd3NlcnMgdW5kZXIgdGVzdCB0aGF0IHN1cHBvcnQgdG91Y2ggZXZlbnRzIGFsc28gc3VwcG9ydCB0aGUgSFRNTDUgaHRtbEZvciBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50Lmh0bWxGb3IpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsYWJlbEVsZW1lbnQuaHRtbEZvcik7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gZm9yIGF0dHJpYnV0ZSBleGlzdHMsIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGZpcnN0IGxhYmVsbGFibGUgZGVzY2VuZGFudCBlbGVtZW50XG5cdFx0Ly8gdGhlIGxpc3Qgb2Ygd2hpY2ggaXMgZGVmaW5lZCBoZXJlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxhYmVsXG5cdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24sIGlucHV0Om5vdChbdHlwZT1oaWRkZW5dKSwga2V5Z2VuLCBtZXRlciwgb3V0cHV0LCBwcm9ncmVzcywgc2VsZWN0LCB0ZXh0YXJlYScpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIGVuZCwgZGV0ZXJtaW5lIHdoZXRoZXIgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IGF0IG9uY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZm9yRWxlbWVudCwgdHJhY2tpbmdDbGlja1N0YXJ0LCB0YXJnZXRUYWdOYW1lLCBzY3JvbGxQYXJlbnQsIHRvdWNoLCB0YXJnZXRFbGVtZW50ID0gdGhpcy50YXJnZXRFbGVtZW50O1xuXG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHR0aGlzLmNhbmNlbE5leHRDbGljayA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0KSA+IHRoaXMudGFwVGltZW91dCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgdG8gcHJldmVudCB3cm9uZyBjbGljayBjYW5jZWwgb24gaW5wdXQgKGlzc3VlICMxNTYpLlxuXHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gZmFsc2U7XG5cblx0XHR0aGlzLmxhc3RDbGlja1RpbWUgPSBldmVudC50aW1lU3RhbXA7XG5cblx0XHR0cmFja2luZ0NsaWNrU3RhcnQgPSB0aGlzLnRyYWNraW5nQ2xpY2tTdGFydDtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XG5cblx0XHQvLyBPbiBzb21lIGlPUyBkZXZpY2VzLCB0aGUgdGFyZ2V0RWxlbWVudCBzdXBwbGllZCB3aXRoIHRoZSBldmVudCBpcyBpbnZhbGlkIGlmIHRoZSBsYXllclxuXHRcdC8vIGlzIHBlcmZvcm1pbmcgYSB0cmFuc2l0aW9uIG9yIHNjcm9sbCwgYW5kIGhhcyB0byBiZSByZS1kZXRlY3RlZCBtYW51YWxseS4gTm90ZSB0aGF0XG5cdFx0Ly8gZm9yIHRoaXMgdG8gZnVuY3Rpb24gY29ycmVjdGx5LCBpdCBtdXN0IGJlIGNhbGxlZCAqYWZ0ZXIqIHRoZSBldmVudCB0YXJnZXQgaXMgY2hlY2tlZCFcblx0XHQvLyBTZWUgaXNzdWUgIzU3OyBhbHNvIGZpbGVkIGFzIHJkYXI6Ly8xMzA0ODU4OSAuXG5cdFx0aWYgKGRldmljZUlzSU9TV2l0aEJhZFRhcmdldCkge1xuXHRcdFx0dG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuXHRcdFx0Ly8gSW4gY2VydGFpbiBjYXNlcyBhcmd1bWVudHMgb2YgZWxlbWVudEZyb21Qb2ludCBjYW4gYmUgbmVnYXRpdmUsIHNvIHByZXZlbnQgc2V0dGluZyB0YXJnZXRFbGVtZW50IHRvIG51bGxcblx0XHRcdHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCB0b3VjaC5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCkgfHwgdGFyZ2V0RWxlbWVudDtcblx0XHRcdHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50ID0gdGhpcy50YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHR9XG5cblx0XHR0YXJnZXRUYWdOYW1lID0gdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKHRhcmdldFRhZ05hbWUgPT09ICdsYWJlbCcpIHtcblx0XHRcdGZvckVsZW1lbnQgPSB0aGlzLmZpbmRDb250cm9sKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0aWYgKGZvckVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5mb2N1cyh0YXJnZXRFbGVtZW50KTtcblx0XHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldEVsZW1lbnQgPSBmb3JFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5uZWVkc0ZvY3VzKHRhcmdldEVsZW1lbnQpKSB7XG5cblx0XHRcdC8vIENhc2UgMTogSWYgdGhlIHRvdWNoIHN0YXJ0ZWQgYSB3aGlsZSBhZ28gKGJlc3QgZ3Vlc3MgaXMgMTAwbXMgYmFzZWQgb24gdGVzdHMgZm9yIGlzc3VlICMzNikgdGhlbiBmb2N1cyB3aWxsIGJlIHRyaWdnZXJlZCBhbnl3YXkuIFJldHVybiBlYXJseSBhbmQgdW5zZXQgdGhlIHRhcmdldCBlbGVtZW50IHJlZmVyZW5jZSBzbyB0aGF0IHRoZSBzdWJzZXF1ZW50IGNsaWNrIHdpbGwgYmUgYWxsb3dlZCB0aHJvdWdoLlxuXHRcdFx0Ly8gQ2FzZSAyOiBXaXRob3V0IHRoaXMgZXhjZXB0aW9uIGZvciBpbnB1dCBlbGVtZW50cyB0YXBwZWQgd2hlbiB0aGUgZG9jdW1lbnQgaXMgY29udGFpbmVkIGluIGFuIGlmcmFtZSwgdGhlbiBhbnkgaW5wdXR0ZWQgdGV4dCB3b24ndCBiZSB2aXNpYmxlIGV2ZW4gdGhvdWdoIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgdXBkYXRlZCBhcyB0aGUgdXNlciB0eXBlcyAoaXNzdWUgIzM3KS5cblx0XHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdHJhY2tpbmdDbGlja1N0YXJ0KSA+IDEwMCB8fCAoZGV2aWNlSXNJT1MgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICYmIHRhcmdldFRhZ05hbWUgPT09ICdpbnB1dCcpKSB7XG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mb2N1cyh0YXJnZXRFbGVtZW50KTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblxuXHRcdFx0Ly8gU2VsZWN0IGVsZW1lbnRzIG5lZWQgdGhlIGV2ZW50IHRvIGdvIHRocm91Z2ggb24gaU9TIDQsIG90aGVyd2lzZSB0aGUgc2VsZWN0b3IgbWVudSB3b24ndCBvcGVuLlxuXHRcdFx0Ly8gQWxzbyB0aGlzIGJyZWFrcyBvcGVuaW5nIHNlbGVjdHMgd2hlbiBWb2ljZU92ZXIgaXMgYWN0aXZlIG9uIGlPUzYsIGlPUzcgKGFuZCBwb3NzaWJseSBvdGhlcnMpXG5cdFx0XHRpZiAoIWRldmljZUlzSU9TIHx8IHRhcmdldFRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgIWRldmljZUlzSU9TNCkge1xuXG5cdFx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIGV2ZW50IGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgcGFyZW50IGxheWVyIHRoYXQgd2FzIHNjcm9sbGVkXG5cdFx0XHQvLyBhbmQgdGhpcyB0YXAgaXMgYmVpbmcgdXNlZCB0byBzdG9wIHRoZSBzY3JvbGxpbmcgKHVzdWFsbHkgaW5pdGlhdGVkIGJ5IGEgZmxpbmcgLSBpc3N1ZSAjNDIpLlxuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cdFx0XHRpZiAoc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wICE9PSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgdGhlIGFjdHVhbCBjbGljayBmcm9tIGdvaW5nIHRob3VnaCAtIHVubGVzcyB0aGUgdGFyZ2V0IG5vZGUgaXMgbWFya2VkIGFzIHJlcXVpcmluZ1xuXHRcdC8vIHJlYWwgY2xpY2tzIG9yIGlmIGl0IGlzIGluIHRoZSB3aGl0ZWxpc3QgaW4gd2hpY2ggY2FzZSBvbmx5IG5vbi1wcm9ncmFtbWF0aWMgY2xpY2tzIGFyZSBwZXJtaXR0ZWQuXG5cdFx0aWYgKCF0aGlzLm5lZWRzQ2xpY2sodGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIGNhbmNlbCwgc3RvcCB0cmFja2luZyB0aGUgY2xpY2suXG5cdCAqXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgbW91c2UgZXZlbnRzIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbk1vdXNlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vIElmIGEgdGFyZ2V0IGVsZW1lbnQgd2FzIG5ldmVyIHNldCAoYmVjYXVzZSBhIHRvdWNoIGV2ZW50IHdhcyBuZXZlciBmaXJlZCkgYWxsb3cgdGhlIGV2ZW50XG5cdFx0aWYgKCF0aGlzLnRhcmdldEVsZW1lbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5mb3J3YXJkZWRUb3VjaEV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcm9ncmFtbWF0aWNhbGx5IGdlbmVyYXRlZCBldmVudHMgdGFyZ2V0aW5nIGEgc3BlY2lmaWMgZWxlbWVudCBzaG91bGQgYmUgcGVybWl0dGVkXG5cdFx0aWYgKCFldmVudC5jYW5jZWxhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBEZXJpdmUgYW5kIGNoZWNrIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzZWUgd2hldGhlciB0aGUgbW91c2UgZXZlbnQgbmVlZHMgdG8gYmUgcGVybWl0dGVkO1xuXHRcdC8vIHVubGVzcyBleHBsaWNpdGx5IGVuYWJsZWQsIHByZXZlbnQgbm9uLXRvdWNoIGNsaWNrIGV2ZW50cyBmcm9tIHRyaWdnZXJpbmcgYWN0aW9ucyxcblx0XHQvLyB0byBwcmV2ZW50IGdob3N0L2RvdWJsZWNsaWNrcy5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0aGlzLnRhcmdldEVsZW1lbnQpIHx8IHRoaXMuY2FuY2VsTmV4dENsaWNrKSB7XG5cblx0XHRcdC8vIFByZXZlbnQgYW55IHVzZXItYWRkZWQgbGlzdGVuZXJzIGRlY2xhcmVkIG9uIEZhc3RDbGljayBlbGVtZW50IGZyb20gYmVpbmcgZmlyZWQuXG5cdFx0XHRpZiAoZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBQYXJ0IG9mIHRoZSBoYWNrIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIChlLmcuIEFuZHJvaWQgMilcblx0XHRcdFx0ZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FuY2VsIHRoZSBldmVudFxuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG1vdXNlIGV2ZW50IGlzIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiBhY3R1YWwgY2xpY2tzLCBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgdG91Y2gtZ2VuZXJhdGVkIGNsaWNrLCBhIGNsaWNrIGFjdGlvbiBvY2N1cnJpbmdcblx0ICogbmF0dXJhbGx5IGFmdGVyIGEgZGVsYXkgYWZ0ZXIgYSB0b3VjaCAod2hpY2ggbmVlZHMgdG8gYmUgY2FuY2VsbGVkIHRvIGF2b2lkIGR1cGxpY2F0aW9uKSwgb3Jcblx0ICogYW4gYWN0dWFsIGNsaWNrIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcGVybWl0dGVkO1xuXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSBmb3IgYW5vdGhlciBGYXN0Q2xpY2stbGlrZSBsaWJyYXJ5IGRlbGl2ZXJlZCB3aXRoIHRoaXJkLXBhcnR5IGNvZGUgdG8gZmlyZSBhIGNsaWNrIGV2ZW50IGJlZm9yZSBGYXN0Q2xpY2sgZG9lcyAoaXNzdWUgIzQ0KS4gSW4gdGhhdCBjYXNlLCBzZXQgdGhlIGNsaWNrLXRyYWNraW5nIGZsYWcgYmFjayB0byBmYWxzZSBhbmQgcmV0dXJuIGVhcmx5LiBUaGlzIHdpbGwgY2F1c2Ugb25Ub3VjaEVuZCB0byByZXR1cm4gZWFybHkuXG5cdFx0aWYgKHRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVmVyeSBvZGQgYmVoYXZpb3Igb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIG5vbi1wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvYXBwcy9IaDc2NzMxMy5hc3B4XG5cdFx0aWYgKGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgRmFzdENsaWNrIG9iamVjdFxuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHNcblx0ICovXG5cdEZhc3RDbGljay5hdHRhY2ggPSBmdW5jdGlvbihsYXllciwgb3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKTtcblx0fTtcblxuICB3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xufSgpKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIERFRkFVTFRfVklFV1BPUlQgPSAnd2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSxtYXhpbXVtLXNjYWxlPTEsbWluaW11bS1zY2FsZT0xLHVzZXItc2NhbGFibGU9bm8nO1xuXG4gIHZhciBWaWV3cG9ydCA9IHsgXG4gICAgZW5zdXJlVmlld3BvcnRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cbiAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICAgICAgdmlld3BvcnRFbGVtZW50Lm5hbWUgPSAndmlld3BvcnQnO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHZpZXdwb3J0RWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3cG9ydEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIHNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydC5lbnN1cmVWaWV3cG9ydEVsZW1lbnQoKTtcblxuICAgICAgaWYgKCF2aWV3cG9ydEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgREVGQVVMVF9WSUVXUE9SVCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdpbmRvdy5WaWV3cG9ydCA9IFZpZXdwb3J0O1xufSkoKTtcbiIsIi8vIExvYWQgbm9uLXBvbHlmaWxsIGxpYnJhcmllc1xuaW1wb3J0ICcuL0Zhc3RDbGlja0AxLjAuNittb2QvZmFzdGNsaWNrLmpzJztcbi8vIGltcG9ydCAnLi9taWNyb2V2ZW50LmpzQDQ3Y2JjMTQrbW9kL21pY3JvZXZlbnQuanMnO1xuaW1wb3J0ICcuL3ZpZXdwb3J0LmpzJztcbiIsImltcG9ydCAnLi9vbnMvcGxhdGZvcm0nOyAvLyBUaGlzIGZpbGUgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIEN1c3RvbSBFbGVtZW50cyBwb2x5ZmlsbHMuXG5pbXBvcnQgJy4vcG9seWZpbGxzL2luZGV4LmpzJztcbmltcG9ydCAnLi92ZW5kb3IvaW5kZXguanMnO1xuaW1wb3J0ICcuL29ucy9taWNyb2V2ZW50LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXAob25zKSB7XG4gIGlmICh3aW5kb3cub25zKSB7XG4gICAgb25zLl91dGlsLndhcm4oJ09uc2VuIFVJIGlzIGxvYWRlZCBtb3JlIHRoYW4gb25jZS4nKTtcbiAgfVxuXG4gIC8vIGZhc3RjbGlja1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICBvbnMuZmFzdENsaWNrID0gRmFzdENsaWNrLmF0dGFjaChkb2N1bWVudC5ib2R5KTtcblxuICAgIGNvbnN0IHN1cHBvcnRUb3VjaEFjdGlvbiA9ICd0b3VjaC1hY3Rpb24nIGluIGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICBvbnMucGxhdGZvcm0uX3J1bk9uQWN0dWFsUGxhdGZvcm0oKCkgPT4ge1xuICAgICAgaWYgKG9ucy5wbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAvLyBJbiBBbmRyb2lkNC40KywgY29ycmVjdCB2aWV3cG9ydCBzZXR0aW5ncyBjYW4gcmVtb3ZlIGNsaWNrIGRlbGF5LlxuICAgICAgICAvLyBTbyBkaXNhYmxlIEZhc3RDbGljayBvbiBBbmRyb2lkLlxuICAgICAgICBvbnMuZmFzdENsaWNrLmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSBpZiAob25zLnBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRUb3VjaEFjdGlvbiAmJiAob25zLnBsYXRmb3JtLmlzSU9TU2FmYXJpKCkgfHwgb25zLnBsYXRmb3JtLmlzV0tXZWJWaWV3KCkpKSB7XG4gICAgICAgICAgLy8gSWYgJ3RvdWNoLWFjdGlvbicgc3VwcG9ydGVkIGluIGlPUyBTYWZhcmkgb3IgV0tXZWJWaWV3LCBkaXNhYmxlIEZhc3RDbGljay5cbiAgICAgICAgICBvbnMuZmFzdENsaWNrLmRlc3Ryb3koKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEbyBub3RoaW5nLiAndG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb24nIGhhcyBubyBlZmZlY3Qgb24gVUlXZWJWaWV3LlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGZhbHNlKTtcblxuICBvbnMucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgb25zLmVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKCk7XG4gICAgb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBvbnMuX2ludGVybmFsLmRiYkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih3aW5kb3cuZG9jdW1lbnQuYm9keSwgKCkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5hdmlnYXRvciwgJ2FwcCcpKSB7XG4gICAgICAgIG5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgY2xvc2UgdGhlIGFwcC4gSXMgXFwnY29yZG92YS5qc1xcJyBpbmNsdWRlZD9cXG5FcnJvcjogXFwnd2luZG93Lm5hdmlnYXRvci5hcHBcXCcgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBvbnMuR2VzdHVyZURldGVjdG9yKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgLy8gU2ltdWxhdGUgRGV2aWNlIEJhY2sgQnV0dG9uIG9uIEVTQyBwcmVzc1xuICAgIGlmICghb25zLnBsYXRmb3JtLmlzV2ViVmlldygpKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICBvbnMuZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHNldHVwIGxvYWRpbmcgcGxhY2Vob2xkZXJcbiAgICBvbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycygpO1xuICB9KTtcblxuICAvLyB2aWV3cG9ydC5qc1xuICBWaWV3cG9ydC5zZXR1cCgpO1xufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZnVuY3Rpb24gZ2V0RWxlbWVudENsYXNzKCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAnZnVuY3Rpb24nKSB7IC8vIGNhc2Ugb2YgU2FmYXJpXG4gICAgY29uc3QgQmFzZUVsZW1lbnQgPSAoKSA9PiB7fTtcbiAgICBCYXNlRWxlbWVudC5wcm90b3R5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXR1cm4gQmFzZUVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VFbGVtZW50IGV4dGVuZHMgZ2V0RWxlbWVudENsYXNzKCkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRlbXBsYXRlXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEZWZpbmUgYSBzZXBhcmF0ZSBIVE1MIGZyYWdtZW50IGFuZCB1c2UgYXMgYSB0ZW1wbGF0ZS4gVGhlc2UgdGVtcGxhdGVzIGNhbiBiZSBsb2FkZWQgYXMgcGFnZXMgaW4gYDxvbnMtbmF2aWdhdG9yPmAsIGA8b25zLXRhYmJhcj5gIGFuZCBgPG9ucy1zcGxpdHRlcj5gLiBUaGV5IGNhbiBhbHNvIGJlIHVzZWQgdG8gZ2VuZXJhdGUgZGlhbG9ncy4gU2luY2UgT25zZW4gVUkgMi40LjAsIHRoZSBuYXRpdmUgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBgPG9ucy10ZW1wbGF0ZT5gIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIGZlYXR1cmVzLiBgPG9ucy10ZW1wbGF0ZT5gIGlzIHN0aWxsIHN1cHBvcnRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBqOOBl+OBpuS9v+eUqOOBmeOCi+OBn+OCgeOBrkhUTUzjg5Xjg6njgrDjg6Hjg7Pjg4jjgpLlrprnvqnjgZfjgb7jgZnjgILjgZPjga7opoHntKDjgadIVE1M44KS5a6j6KiA44GZ44KL44Go44CBaWTlsZ7mgKfjgavmjIflrprjgZfjgZ/lkI3liY3jgpJwYWdl44GuVVJM44Go44GX44Gmb25zLW5hdmlnYXRvcuOBquOBqeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBi+OCieWPgueFp+OBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbmF2aWdhdG9yXG4gKiAgIFtlbl1UaGUgYDxvbnMtbmF2aWdhdG9yPmAgY29tcG9uZW50IGVuYWJsZXMgc3RhY2sgYmFzZWQgbmF2aWdhdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWJiYXI+YCBjb21wb25lbnQgaXMgdXNlZCB0byBhZGQgdGFiIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBkcmFnZ2FibGUgbWVudSBvciBjb2x1bW4gYmFzZWQgbGF5b3V0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJmb29iYXIuaHRtbFwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgUGFnZSBjb250ZW50XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLW5hdmlnYXRvciBwYWdlPVwiZm9vYmFyLmh0bWxcIj48L29ucy1uYXZpZ2F0b3I+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHRlbXBsYXRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRlbXBsYXRlIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgY2FuIG5vdCBiZSB1c2VkIHdpdGggQW5ndWxhckpTIGJpbmRpbmdzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLmlubmVySFRNTDtcblxuICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7IC8vIE5vdGU6IHRoaXMucGFyZW50Tm9kZSBpcyBub3Qgc2V0IGluIHNvbWUgQ0UwL0NFMSBwb2x5ZmlsbHMuXG4gICAgICAvLyBTaG93IHdhcm5pbmcgd2hlbiB0aGUgb25zLXRlbXBsYXRlIGlzIG5vdCBsb2NhdGVkIGp1c3QgdW5kZXIgZG9jdW1lbnQuYm9keVxuICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkgeyAvLyBpZiB0aGUgcGFyZW50IGlzIG5vdCBkb2N1bWVudC5ib2R5XG4gICAgICAgIHV0aWwud2Fybihgb25zLXRlbXBsYXRlIChpZCA9ICR7dGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyl9KSBtdXN0IGJlIGxvY2F0ZWQganVzdCB1bmRlciBkb2N1bWVudC5ib2R5JHsgdGhpcy5wYXJlbnROb2RlLm91dGVySFRNTCA/IGA6XFxuXFxuJHt0aGlzLnBhcmVudE5vZGUub3V0ZXJIVE1MfWAgOiAnLicgfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnX3RlbXBsYXRlbG9hZGVkJywge2J1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWV9KTtcbiAgICBldmVudC50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgZXZlbnQudGVtcGxhdGVJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuVGVtcGxhdGUgPSBUZW1wbGF0ZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10ZW1wbGF0ZScsIFRlbXBsYXRlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi4vb25zL29yaWVudGF0aW9uJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlmXG4gKiBAY2F0ZWdvcnkgY29uZGl0aW9uYWxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pZlxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb25kaXRpb25hbGx5IGRpc3BsYXkgY29udGVudCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLCBkZXZpY2Ugb3JpZW50YXRpb24gb3IgYm90aC5cbiAqXG4gKiAgICAgU29tZXRpbWVzIGl0IGlzIHVzZWZ1bCB0byBjb25kaXRpb25hbGx5IGhpZGUgb3Igc2hvdyBjZXJ0YWluIGNvbXBvbmVudHMgYmFzZWQgb24gcGxhdGZvcm0uIFdoZW4gcnVubmluZyBvbiBpT1MgdGhlIGA8b25zLWlmPmAgZWxlbWVudCBjYW4gYmUgdXNlZCB0byBoaWRlIHRoZSBgPG9ucy1mYWI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1pZiBvcmllbnRhdGlvbj1cImxhbmRzY2FwZVwiPlxuICogICAgIExhbmRzY2FwZSB2aWV3IVxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImFuZHJvaWRcIj5cbiAqICAgICBUaGlzIGlzIEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiaW9zIG90aGVyXCI+XG4gKiAgICAgVGhpcyBpcyBub3QgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhdGZvcm1cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwYWNlLXNlcGFyYXRlZCBwbGF0Zm9ybSBuYW1lcy4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJpb3NcImAsIGBcImFuZHJvaWRcImAsIGBcIndpbmRvd3NcImAgYW5kIGBcIm90aGVyXCJgLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3JpZW50YXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWl0aGVyIGBcInBvcnRyYWl0XCJgIG9yIGBcImxhbmRzY2FwZVwiYC5bL2VuXVxuICAgKiAgW2phXXBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GX44G+44GZWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAocGxhdGZvcm0uX2dldFNlbGVjdGVkUGxhdGZvcm0oKSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ29yaWVudGF0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnb3JpZW50YXRpb24nKSB7XG4gICAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcbiAgfVxuXG4gIF9wbGF0Zm9ybVVwZGF0ZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICBfaXNBbGxvd2VkUGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKS5zcGxpdCgvXFxzKy8pLmluZGV4T2YocGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPj0gMDtcbiAgfVxuXG4gIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb3JpZW50YXRpb24nKSAmJiB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25hbE9yaWVudGF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudGF0aW9uJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKSA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJztcblxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gKGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPT09IGN1cnJlbnRPcmllbnRhdGlvbikgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLklmID0gSWZFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaWYnLCBJZkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDA7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgfVxuXG4gIHN0YXRpYyBleHRlbmQocHJvcGVydGllcyA9IHt9KSB7XG4gICAgY29uc3QgZXh0ZW5kZWRBbmltYXRvciA9IHRoaXM7XG4gICAgY29uc3QgbmV3QW5pbWF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGV4dGVuZGVkQW5pbWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICBuZXdBbmltYXRvci5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3QW5pbWF0b3I7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBjbGFzcyBBY3Rpb25TaGVldEFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIEFjdGlvbiBTaGVldC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1EQWN0aW9uU2hlZXRBbmltYXRvciBleHRlbmRzIEFjdGlvblNoZWV0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40IH0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuXG4gICAgdGhpcy5tYXNrVGltaW5nID0gJ2xpbmVhcic7XG4gICAgdGhpcy5tYXNrRHVyYXRpb24gPSAwLjI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5tYXNrRHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0KVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDgwJSwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5tYXNrRHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0KVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDgwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0FjdGlvblNoZWV0QW5pbWF0b3IgZXh0ZW5kcyBBY3Rpb25TaGVldEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMyB9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMubWFza1RpbWluZyA9ICdsaW5lYXInO1xuICAgIHRoaXMubWFza0R1cmF0aW9uID0gMC4yO1xuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9zaGVldClcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmJvZHlIZWlnaHQgLyAyLjAgLSAxfXB4LCAwKWBcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9zaGVldClcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIGNzczoge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDEwMCUsIDApYFxuICAgICAgICB9LFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi8uLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZURpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfc2NoZW1lIGdldHRlciBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGVBbmltYXRvckZhY3RvcnkgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBfdG9nZ2xlU3R5bGUoc2hvdWxkU2hvdykge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHNob3VsZFNob3cgPyAnYmxvY2snIDogJ25vbmUnO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2NhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NlbGZDYW1lbE5hbWUgPSB1dGlsLmNhbWVsaXplKHRoaXMudGFnTmFtZS5zbGljZSg0KSk7XG4gICAgdGhpcy5fZGVmYXVsdERCQiA9IGUgPT4gdGhpcy5jYW5jZWxhYmxlID8gdGhpcy5fY2FuY2VsKCkgOiBlLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgX3ByZXZlbnRTY3JvbGwoZXZlbnQpIHtcbiAgICBldmVudC5jYW5jZWxhYmxlICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBzaG93KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0VmlzaWJsZSh0cnVlLCAuLi5hcmdzKTtcbiAgfVxuXG4gIGhpZGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9zZXRWaXNpYmxlKGZhbHNlLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHRvZ2dsZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldFZpc2libGUoIXRoaXMudmlzaWJsZSwgLi4uYXJncyk7XG4gIH1cblxuICBfc2V0VmlzaWJsZShzaG91bGRTaG93LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzaG91bGRTaG93ID8gJ3Nob3cnIDogJ2hpZGUnO1xuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGBwcmUke2FjdGlvbn1gLCB7IC8vIHByZXNob3cgcHJlaGlkZVxuICAgICAgW3RoaXMuX3NlbGZDYW1lbE5hbWVdOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBjYW5jZWxlZCA9IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke2FjdGlvbn0gZXZlbnQuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgc2hvdWxkU2hvdyAmJiB0aGlzLl90b2dnbGVTdHlsZSh0cnVlLCBvcHRpb25zKTtcblxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgIGFuaW1hdG9yW2FjdGlvbl0odGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgIXNob3VsZFNob3cgJiYgdGhpcy5fdG9nZ2xlU3R5bGUoZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHNob3VsZFNob3c7XG5cbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnXycgKyBhY3Rpb24pO1xuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0JyArIGFjdGlvbiwge1t0aGlzLl9zZWxmQ2FtZWxOYW1lXTogdGhpc30pOyAvLyBwb3N0c2hvdyBwb3N0aGlkZVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgX3VwZGF0ZU1hc2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tYXNrICYmIHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9kZWZhdWx0REJCLmJpbmQodGhpcyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NhbmNlbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3ByZXZlbnRTY3JvbGwsIGZhbHNlKTsgLy8gaU9TIGZpeFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2FuY2VsLCBmYWxzZSk7XG4gICAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3ByZXZlbnRTY3JvbGwsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdhbmltYXRpb24nLCAnbWFzay1jb2xvciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWFzay1jb2xvcic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hc2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJywgJ2RpYWxvZy1jYW5jZWwnXTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi8uLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBBY3Rpb25TaGVldEFuaW1hdG9yLCBJT1NBY3Rpb25TaGVldEFuaW1hdG9yLCBNREFjdGlvblNoZWV0QW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hY3Rpb24tc2hlZXQnOiAnYWN0aW9uLXNoZWV0LS0qJyxcbiAgJy5hY3Rpb24tc2hlZXQtbWFzayc6ICdhY3Rpb24tc2hlZXQtbWFzay0tKicsXG4gICcuYWN0aW9uLXNoZWV0LXRpdGxlJzogJ2FjdGlvbi1zaGVldC10aXRsZS0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREFjdGlvblNoZWV0QW5pbWF0b3IgOiBJT1NBY3Rpb25TaGVldEFuaW1hdG9yLFxuICAnbm9uZSc6IEFjdGlvblNoZWV0QW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFjdGlvbi1zaGVldFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBY3Rpb24vYm90dG9tIHNoZWV0IHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiBjdXJyZW50IHNjcmVlbi5cbiAqXG4gKiAgICAgVGhpcyBlbGVtZW50IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIG9yIGR5bmFtaWNhbGx5IGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlIHVzaW5nIHRoZSBgb25zLmNyZWF0ZUVsZW1lbnQodGVtcGxhdGUsIHsgYXBwZW5kOiB0cnVlIH0pYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBhY3Rpb24gc2hlZXQgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIGEgbGlzdCBvZiBvcHRpb25zIGFuZCBhc2tpbmcgdGhlIHVzZXIgdG8gbWFrZSBhIGRlY2lzaW9uLiBBIGBvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbmAgaXMgcHJvdmlkZWQgZm9yIHRoaXMgcHVycG9zZSwgYWx0aG91Z2ggaXQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgY29udGVudC5cbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRpc3BsYXllZCBhcyBNYXRlcmlhbCBEZXNpZ24gKGJvdHRvbSBzaGVldCkgd2hlbiBydW5uaW5nIG9uIGFuIEFuZHJvaWQgZGV2aWNlLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Ki44Kv44K344On44Oz44K344O844OI44CB44KC44GX44GP44Gv44Oc44OI44Og44K344O844OI44KS54++5Zyo44Gu44K544Kv44Oq44O844Oz5LiK44Gr6KGo56S644GX44G+44GZ44CCXG4gKlxuICogICAgIOOBk+OBruimgee0oOOBr+OAgWA8Ym9keT5g6KaB57Sg44Gr55u05o6l44Ki44K/44OD44OB44GV44KM44KL44GL44CB44KC44GX44GP44GvYG9ucy5jcmVhdGVFbGVtZW50KHRlbXBsYXRlLCB7IGFwcGVuZDogdHJ1ZSB9KWDjgahgPG9ucy10ZW1wbGF0ZT5g44K/44Kw44KS5L2/44Gj44Gm44OG44Oz44OX44Os44O844OI44GL44KJ5YuV55qE44Gr55Sf5oiQ44GV44KM44G+44GZ44CCXG4gKlxuICogICAgIOOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBr+OAgemBuOaKnuiCouOBruODquOCueODiOOCkuihqOekuuOBl+OBpuODpuODvOOCtuODvOOBq+Wwi+OBreOCi+OBruOBq+S+v+WIqeOBp+OBmeOAgmBvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbmDjga/jgIHjgZPjga7opoHntKDjga7kuK3jgavnva7jgY/jgZ/jgoHjgavmj5DkvpvjgZXjgozjgabjgYTjgb7jgZnjgYzjgIHjgZ3jgozku6XlpJbjgavjgoLku5bjga7jganjga7jgojjgYbjgaropoHntKDjgpLlkKvjgoDjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJcbiAqXG4gKiAgICAgQW5kcm9pZOODh+ODkOOCpOOCueOBp+Wun+ihjOOBleOCjOOCi+OBqOOBjeOBq+OBr+OAgeiHquWLleeahOOBq+ODnuODhuODquOCouODq+ODh+OCtuOCpOODsyjjg5zjg4jjg6Djgrfjg7zjg4gp44Go44GX44Gm6KGo56S644GV44KM44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gYm90dG9tIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjg4jjg6Djgrfjg7zjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvcmVmZXJlbmNlL2FjdGlvbi1zaGVldFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5dYDxvbnMtcG9wb3Zlcj5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbW9kYWxcbiAqICAgW2VuXWA8b25zLW1vZGFsPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1tb2RhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hY3Rpb24tc2hlZXQgaWQ9XCJzaGVldFwiPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogPC9vbnMtYWN0aW9uLXNoZWV0PlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaGVldCcpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25TaGVldEVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgYWN0aW9uIHNoZWV0IGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhY3Rpb24gc2hlZXQgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWN0aW9uU2hlZXRcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGFjdGlvbiBzaGVldCBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFjdGlvblNoZWV0XG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGl0bGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dT3B0aW9uYWwgdGl0bGUgb2YgdGhlIGFjdGlvbiBzaGVldC4gQSBuZXcgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgY29udGFpbmluZyB0aGlzIHN0cmluZy5bL2VuXVxuICAgKiAgW2phXeOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBruOCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBk+OBp+aMh+WumuOBl+OBn+aWh+Wtl+WIl+OCkuWQq+OCgOaWsOOBl+OBhOimgee0oOOBjOS9nOaIkOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44KL44Go44CB44Ki44Kv44K344On44Oz44K344O844OI44Gu6IOM5pmv44KEQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+OCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBjOmWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGFjdGlvbiBzaGVldC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZGVmYXVsdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQtbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9zaGVldCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQnKTtcbiAgfVxuXG4gIGdldCBfdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmFjdGlvbi1zaGVldC10aXRsZScpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFjdGlvblNoZWV0QW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWN0aW9uU2hlZXRBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWFjdGlvbi1zaGVldD5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImFjdGlvbi1zaGVldC1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXRcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLXNoZWV0LXRpdGxlPjwvZGl2PlxuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWFjdGlvbi1zaGVldD5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fc2hlZXQpIHtcbiAgICAgIGNvbnN0IHNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzaGVldC5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBzaGVldC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpdGxlICYmIHRoaXMuaGFzQXR0cmlidXRlKCd0aXRsZScpKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGl0bGUuaW5uZXJIVE1MID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICB0aXRsZS5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQtdGl0bGUnKTtcbiAgICAgIHRoaXMuX3NoZWV0Lmluc2VydEJlZm9yZSh0aXRsZSwgdGhpcy5fc2hlZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2FjdGlvbi1zaGVldC1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NoZWV0LnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlVGl0bGUoKSB7XG4gICAgaWYgKHRoaXMuX3RpdGxlKSB7XG4gICAgICB0aGlzLl90aXRsZS5pbm5lckhUTUwgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFd6Zqg44KM44Gf6KaB57Sg44KS6Kej5rG644GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGFjdGlvbiBzaGVldCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBhY3Rpb24gc2hlZXQgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBhY3Rpb24gc2hlZXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS6Kit5a6a44GX44G+44GZ44CC44Kt44Oj44Oz44K744Or5Y+v6IO944Gq44Ki44Kv44K344On44Oz44K344O844OI44Gv44CB6IOM5pmv44KS44K/44OD44OX44GX44Gf44KKQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+mWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAndGl0bGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtBY3Rpb25TaGVldEFuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBY3Rpb25TaGVldEFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc0FjdGlvblNoZWV0RWxlbWVudC5BY3Rpb25TaGVldEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBBY3Rpb25TaGVldEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBBY3Rpb25TaGVldEFuaW1hdG9yO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5BY3Rpb25TaGVldCA9IEFjdGlvblNoZWV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFjdGlvbi1zaGVldCcsIEFjdGlvblNoZWV0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdhY3Rpb24tc2hlZXQtYnV0dG9uJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdhY3Rpb24tc2hlZXQtYnV0dG9uLS0qJyxcbiAgJy5hY3Rpb24tc2hlZXQtaWNvbic6ICdhY3Rpb24tc2hlZXQtaWNvbi0tKidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFjdGlvbi1zaGVldC1idXR0b25cbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBtb2RpZmllciBkZXN0cnVjdGl2ZVxuICogICBbZW5dU2hvd3MgYSBcImRlc3RydWN0aXZlXCIgYnV0dG9uIChvbmx5IGZvciBpT1MpLlsvZW5dXG4gKiAgIFtqYV1cImRlc3RydWN0aXZlXCLjgarjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZkoaU9T44Gn44Gu44G/5pyJ5Yq5KeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNvbXBvbmVudCB0aGF0IHJlcHJlc2VudCBlYWNoIGJ1dHRvbiBvZiB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV3jgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjgavooajnpLrjgZXjgozjgovlkITjg5zjgr/jg7PjgpLooajnj77jgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWFjdGlvbi1zaGVldFxuICogICBbZW5dVGhlIGA8b25zLWFjdGlvbi1zaGVldD5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWN0aW9uLXNoZWV044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0LWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxuICogICBbZW5dVGhlIGA8b25zLWljb24+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWljb27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2FjdGlvbi1zaGVldFxuICogQGd1aWRlIGFwcHNpemUuaHRtbCNyZW1vdmluZy1pY29uLXBhY2tzIFtlbl1SZW1vdmluZyBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgZmFxLmh0bWwjaG93LWNhbi1pLXVzZS1jdXN0b20taWNvbi1wYWNrcyBbZW5dQWRkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gYWN0aW9uIHNoZWV0IGJ1dHRvbi5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Ki44Kv44K344On44Oz44K344O844OI55So44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFjdGlvbi1zaGVldCBpZD1cInNoZWV0XCI+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiA8L29ucy1hY3Rpb24tc2hlZXQ+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NoZWV0Jykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdGlvblNoZWV0QnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNyZWF0ZXMgYW4gYG9ucy1pY29uYCBjb21wb25lbnQgd2l0aCB0aGlzIHN0cmluZy4gT25seSB2aXNpYmxlIG9uIEFuZHJvaWQuIENoZWNrIFtTZWUgYWxzb10oI3NlZWFsc28pIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uWy9lbl1cbiAgICogIFtqYV1gb25zLWljb25g44Kz44Oz44Od44O844ON44Oz44OI44KS5oKq5oCn44GX44G+44GZ44CCQW5kcm9pZOOBp+OBruOBv+ihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYWN0aW9uIHNoZWV0IGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjg5zjgr/jg7Pjga7opovjgZ/nm67jgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX2ljb24oKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWN0aW9uLXNoZWV0LWljb24nKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghdGhpcy5faWNvbiAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpKSB7XG4gICAgICBjb25zdCBpY29uID0gdXRpbC5jcmVhdGVFbGVtZW50KGA8b25zLWljb24gaWNvbj1cIiR7dGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKX1cIj48L29ucy1pY29uPmApO1xuICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQtaWNvbicpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlSWNvbigpIHtcbiAgICBpZiAodGhpcy5faWNvbikge1xuICAgICAgdGhpcy5faWNvbi5zZXRBdHRyaWJ1dGUoJ2ljb24nLCB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsICdpY29uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5BY3Rpb25TaGVldEJ1dHRvbiA9IEFjdGlvblNoZWV0QnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFjdGlvbi1zaGVldC1idXR0b24nLCBBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgY2xhc3MgQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgwLjksIDAuOSwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMC45LCAwLjksIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgQWxlcnREaWFsb2dBbmltYXRvciwgSU9TQWxlcnREaWFsb2dBbmltYXRvciwgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hbGVydC1kaWFsb2cnOiAnYWxlcnQtZGlhbG9nLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJzogJ2FsZXJ0LWRpYWxvZy1jb250YWluZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy10aXRsZSc6ICdhbGVydC1kaWFsb2ctdGl0bGUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250ZW50JzogJ2FsZXJ0LWRpYWxvZy1jb250ZW50LS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXItLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCc6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24nOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKicsXG4gICdvbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctbWFzayc6ICdhbGVydC1kaWFsb2ctbWFzay0tKicsXG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ25vbmUnOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWxlcnQgZGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzY3JlZW4uIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBxdWVzdGlvbnMsIHdhcm5pbmdzIG9yIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiBUaGUgdGl0bGUsIGNvbnRlbnQgYW5kIGJ1dHRvbnMgY2FuIGJlIGVhc2lseSBjdXN0b21pemVkIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHN0eWxlIGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlQWxlcnREaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDnj77lnKjjga7jgrnjgq/jg6rjg7zjg7Pjga7kuIrjgavooajnpLrjgZnjgovjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgafjgZnjgILjg6bjg7zjgrbjgavlr77jgZnjgovllY/jgYTjgYvjgZHjgIHorablkYrjgIHjgqjjg6njg7zjg6Hjg4Pjgrvjg7zjgrjjgpLooajnpLrjgZnjgovjga7jgavliKnnlKjjgafjgY3jgb7jgZnjgILjgr/jgqTjg4jjg6vjgoTjgrPjg7Pjg4bjg7Pjg4TjgoTjg5zjgr/jg7Pjga/nsKHljZjjgavjgqvjgrnjgr/jg57jgqTjgrrjgafjgY3jgIHlrp/ooYzjgZfjgabjgYTjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DjgavkvbXjgZvjgabjgrnjgr/jgqTjg6vjgYzoh6rli5XnmoTjgavliIfjgormm7/jgo/jgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIFF3d3h5cFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44K544K/44Kk44OrWy9qYV1cbiAqIEBtb2RpZmllciByb3dmb290ZXJcbiAqICAgW2VuXUhvcml6b250YWxseSBhbGlnbnMgdGhlIGZvb3RlciBidXR0b25zLlsvZW5dXG4gKiAgIFtqYV3jg5Xjg4Pjgr/jg7zjga7opIfmlbDjga7jg5zjgr/jg7PjgpLmsLTlubPjgavphY3nva5bL2phXVxuICogQHNlZWFsc28gb25zLWRpYWxvZ1xuICogICBbZW5db25zLWRpYWxvZyBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5db25zLXBvcG92ZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLm5vdGlmaWNhdGlvblxuICogICBbZW5dVXNpbmcgb25zLm5vdGlmaWNhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL44Gr44Gv44CBb25zLm5vdGlmaWNhdGlvbuOCquODluOCuOOCp+OCr+ODiOOBruODoeOCveODg+ODieOCkuS9v+OBhuOBk+OBqOOCguOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hbGVydC1kaWFsb2cgaWQ9XCJhbGVydC1kaWFsb2dcIj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy10aXRsZVwiPldhcm5pbmchPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICogICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+XG4gKiAgICAgPGJ1dHRvbiBpZD1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj5PSzwvYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbGVydC1kaWFsb2cnKS5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnREaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZURpYWxvZ0VsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gc2hvd2luZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgpLmraLjgoHjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gaGlkaW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCiOOBhuOBqOOBmeOCi+OBruOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OCkuioreWumuOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruiDjOaZr+OCkuOCv+ODg+ODl+OBl+OBn+OCikFuZHJvaWTjg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7PjgpLmirzjgZnjgajjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBr2Rpc2FibGVk54q25oWL44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44Gn44GvXCJub25lXCLjgYtcImRlZmF1bHRcIuOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBcInJnYmEoMCwgMCwgMCwgMC4yKVwiLlsvZW5dXG4gICAqICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2ctbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2cnKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX3RpdGxlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy10aXRsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ0FsZXJ0RGlhbG9nQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuXG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgcmVzdWx0IGFmdGVyIGNvbXBpbGU6XG4gICAgICpcbiAgICAgKiA8b25zLWFsZXJ0LWRpYWxvZyBzdHlsZT1cIm5vbmVcIj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctbWFza1wiPjwvZGl2PlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGlmICghdGhpcy5fbWFzayAmJiAhdGhpcy5fZGlhbG9nKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2cnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGRpYWxvZywgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2csICcuYWxlcnQtZGlhbG9nLWNvbnRhaW5lcicpKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctY29udGFpbmVyJyk7XG4gICAgICB0aGlzLl9kaWFsb2cuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0uYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICB0aGlzLl9kaWFsb2cuc3R5bGUuekluZGV4ID0gMjAwMDE7XG4gICAgdGhpcy5fbWFzay5zdHlsZS56SW5kZXggPSAyMDAwMDtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFd44Gd44Gu44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS6KGo44GX44G+44GZ44CC44Kt44Oj44Oz44K744Or5Y+v6IO944Gq44OA44Kk44Ki44Ot44Kw44Gv44CB6IOM5pmv44KS44K/44OD44OX44GZ44KL44GLQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaKvOOBmeOBk+OBqOOBp+mWieOBmOOCi+OBk+OBqOOBjOWHuuadpeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjga7jga/jgIFcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgYFByb21pc2VgIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3ooajnpLrjgZXjgozjgovopoHntKDjgpLop6PmsbrjgZnjgotgUHJvbWlzZWDjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXemaoOOCjOOBn+imgee0oOOCkuino+axuuOBmeOCi2BQcm9taXNlYOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RGlhbG9nQW5pbWF0b3J9IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIEFsZXJ0RGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zQWxlcnREaWFsb2dFbGVtZW50LkFsZXJ0RGlhbG9nQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEFsZXJ0RGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIEFsZXJ0RGlhbG9nQW5pbWF0b3I7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkFsZXJ0RGlhbG9nID0gQWxlcnREaWFsb2dFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYWxlcnQtZGlhbG9nJywgQWxlcnREaWFsb2dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdhbGVydC1kaWFsb2ctYnV0dG9uJztcblxuY29uc3Qgc2NoZW1lID0geycnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2ctYnV0dG9uXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBhbGVydC1kaWFsb2cgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnQgZGlzcGxheXMgYSBhbGVydCBkaWFsb2cuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqICA8b25zLWFsZXJ0LWRpYWxvZz5cbiAqICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj5XYXJuaW5nITwvZGl2PlxuICogICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcbiAqICAgIDwvZGl2PlxuICogICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICAgPGFsZXJ0LWRpYWxvZy1idXR0b24gb25jbGljaz1cImFwcC5jbG9zZSgpXCI+Q2FuY2VsPC9hbGVydC1kaWFsb2ctYnV0dG9uPlxuICogICAgICA8YWxlcnQtZGlhbG9nLWJ1dHRvbiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBvbmNsaWNrPVwiYXBwLmNsb3NlKClcIj5PSzwvYWxlcnQtZGlhbG9nLWJ1dHRvbj5cbiAqICAgIDwvZGl2PlxuICogIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnREaWFsb2dCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMsIHVuZGVmaW5lZCwgeydtb2RpZmllcic6ICdsaWdodC1ncmF5J30pO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5BbGVydERpYWxvZ0J1dHRvbiA9IEFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nLCBBbGVydERpYWxvZ0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgaW9zQmFja0J1dHRvbkljb24gZnJvbSAnLi4vLi4vaW1hZ2VzL2lvcy1iYWNrLWJ1dHRvbi1pY29uLnN2Zyc7XG5pbXBvcnQgbWRCYWNrQnV0dG9uSWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvbWQtYmFjay1idXR0b24taWNvbi5zdmcnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2JhY2stYnV0dG9uJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ2JhY2stYnV0dG9uLS0qJyxcbiAgJy5iYWNrLWJ1dHRvbl9faWNvbic6ICdiYWNrLWJ1dHRvbi0tKl9faWNvbicsXG4gICcuYmFjay1idXR0b25fX2xhYmVsJzogJ2JhY2stYnV0dG9uLS0qX19sYWJlbCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJhY2stYnV0dG9uXG4gKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBCYWNrIGJ1dHRvbiBjb21wb25lbnQgZm9yIGA8b25zLXRvb2xiYXI+YC4gUHV0IGl0IGluIHRoZSBsZWZ0IHBhcnQgb2YgdGhlIGA8b25zLXRvb2xiYXI+YC5cbiAqXG4gKiAgICAgSXQgd2lsbCBmaW5kIHRoZSBwYXJlbnQgYDxvbnMtbmF2aWdhdG9yPmAgZWxlbWVudCBhbmQgcG9wIGEgcGFnZSB3aGVuIGNsaWNrZWQuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzcGVjaWZ5aW5nIHRoZSBgb25DbGlja2AgcHJvcGVydHkuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gYUhtR0xcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXW9ucy1uYXZpZ2F0b3IgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1uYXZpZ2F0b3LjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8ZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYWNrQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44OQ44OD44Kv44Oc44K/44Oz44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0ge307XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZUljb24oaWNvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgIGljb24uaW5uZXJIVE1MID0gYXV0b1N0eWxlLmdldFBsYXRmb3JtKHRoaXMpID09PSAnYW5kcm9pZCcgfHwgdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKSA/IG1kQmFja0J1dHRvbkljb24gOiBpb3NCYWNrQnV0dG9uSWNvbjtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19sYWJlbCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgY29uc3QgaWNvbiA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19pY29uJyk7XG4gICAgICB0aGlzLl91cGRhdGVJY29uKGljb24pO1xuXG4gICAgICB0aGlzLmluc2VydEJlZm9yZShpY29uLCB0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzLCB1bmRlZmluZWQsIHtjZW50ZXI6ICcnLCAnc2l6ZSc6ICdjb250YWluJywgJ2JhY2tncm91bmQnOiAndHJhbnNwYXJlbnQnfSk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgXCItaW9zXCIgb3IgXCItbWRcIlxuICAgKiAgICAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBcImxpZnQtaW9zXCIsIFwibGlmdC1tZFwiLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIFwic2xpZGUtaW9zXCIgYW5kIFwiZmFkZS1tZFwiLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuY2FsbGJhY2tcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25DbGlja1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhY2sgYnV0dG9uIGJlaGF2aW9yLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBfb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLm9uQ2xpY2suYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbmF2aWdhdG9yID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtbmF2aWdhdG9yJyk7XG4gICAgICBpZiAobmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5wb3BQYWdlKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtb2RpZmllcic6IHtcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkgJiYgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkJhY2tCdXR0b24gPSBCYWNrQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJhY2stYnV0dG9uJywgQmFja0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2JvdHRvbS1iYXInO1xuY29uc3Qgc2NoZW1lID0geycnOiAnYm90dG9tLWJhci0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1ib3R0b20tdG9vbGJhclxuICogQGNhdGVnb3J5IHBhZ2VcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVG9vbGJhciBjb21wb25lbnQgdGhhdCBpcyBwb3NpdGlvbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFNpbmNlIGJvdHRvbSB0b29sYmFycyBhcmUgdmVyeSB2ZXJzYXRpbGUgZWxlbWVudHMsIGBvbnMtYm90dG9tLXRvb2xiYXJgIGRvZXMgbm90IHByb3ZpZGUgYW55IHNwZWNpZmljIGxheW91dCBzeW50YXggZm9yIGl0cyBjaGlsZHJlbi4gTW9kaWZpZXJzIG9yIGN1c3RvbSBDU1MgbXVzdCBiZSB1c2VkLlsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjkuIvpg6jjgavphY3nva7jgZXjgozjgovjg4Tjg7zjg6vjg5Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgIFtlbl1NYWtlIHRoZSB0b29sYmFyIHRyYW5zcGFyZW50LlsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7og4zmma/jgpLpgI/mmI7jgavjgZfjgabooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGFsaWduZWRcbiAqICAgW2VuXVZlcnRpY2FsbHkgYWxpZ25zIGl0cyBjaGlsZHJlbiBhbmQgYXBwbGllcyBmbGV4Ym94IGZvciBibG9jayBlbGVtZW50cy4gYGp1c3RpZnktY29udGVudGAgQ1NTIHJ1bGUgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIGhvcml6b250YWwgYWxpZ24uWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBruiDjOaZr+OCkumAj+aYjuOBq+OBl+OBpuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhciBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1bamFdb25zLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYm90dG9tLXRvb2xiYXI+XG4gKiAgIENvbnRlbnRcbiAqIDwvb25zLWJvdHRvbS10b29sYmFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3R0b21Ub29sYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0b29sYmFyLlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruimi+OBn+ebruOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXBhZ2UnKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ3BhZ2Utd2l0aC1ib3R0b20tdG9vbGJhcicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG59XG5cbm9ucy5lbGVtZW50cy5Cb3R0b21Ub29sYmFyID0gQm90dG9tVG9vbGJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1ib3R0b20tdG9vbGJhcicsIEJvdHRvbVRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAnYnV0dG9uLS0qJ307XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYnV0dG9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYnV0dG9uXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG91dGxpbmVcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG91dGxpbmUgYW5kIHRyYW5zcGFyZW50IGJhY2tncm91bmRbL2VuXVxuICogICBbamFd44Ki44Km44OI44Op44Kk44Oz44KS5oyB44Gj44Gf44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsaWdodFxuICogICBbZW5dQnV0dG9uIHRoYXQgZG9lc24ndCBzdGFuZCBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBn+OBquOBhOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgcXVpZXRcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG5vIG91dGxpbmUgYW5kIG9yIGJhY2tncm91bmQuLlsvZW5dXG4gKiAgIFtqYV3mnqDnt5rjgoTog4zmma/jgYznhKHjgYTmloflrZfjgaDjgZHjga7jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGN0YVxuICogICBbZW5dQnV0dG9uIHRoYXQgcmVhbGx5IHN0YW5kcyBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBpOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2VcbiAqICAgW2VuXUxhcmdlIGJ1dHRvbiB0aGF0IGNvdmVycyB0aGUgd2lkdGggb2YgdGhlIHNjcmVlbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KL5aSn44GN44Gq44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tcXVpZXRcbiAqICAgW2VuXUxhcmdlIHF1aWV0IGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLcXVpZXTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlLS1jdGFcbiAqICAgW2VuXUxhcmdlIGNhbGwgdG8gYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLY3Rh44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjgr/jg7NbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsLS1mbGF0XG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gZmxhdCBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44OV44Op44OD44OI44Oc44K/44OzWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQnV0dG9uIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gcGxhY2UgYSBidXR0b24gaW4gYSB0b29sYmFyLCB1c2UgYDxvbnMtdG9vbGJhci1idXR0b24+YCBvciBgPG9ucy1iYWNrLWJ1dHRvbj5gIGluc3RlYWQuXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIGJ1dHRvbiB3aXRoIGEgcmlwcGxlIGVmZmVjdCBvbiBBbmRyb2lkLlxuICogICBbL2VuXVxuICogICBbamFd44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44CC44OE44O844Or44OQ44O844Gr44Oc44K/44Oz44KS6Kit572u44GZ44KL5aC05ZCI44Gv44CBb25zLXRvb2xiYXItYnV0dG9u44KC44GX44GP44Gvb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OI44KS5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGhMYXl4XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYnV0dG9uXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIG1vZGlmaWVyPVwibGFyZ2UtLWN0YVwiPlxuICogICBUYXAgTWVcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByaXBwbGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgdGhlIGJ1dHRvbiB3aWxsIGhhdmUgYSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkJ1dHRvbiA9IEJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1idXR0b24nLCBCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2NhcmQnO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ2NhcmQtLSonLFxuICAnLmNhcmRfX3RpdGxlJzogJ2NhcmQtLSpfX3RpdGxlJyxcbiAgJy5jYXJkX19jb250ZW50JzogJ2NhcmQtLSpfX2NvbnRlbnQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jYXJkXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXUEgY2FyZCB3aXRoIG1hdGVyaWFsIGRlc2lnbi5bL2VuXVxuICogICBbamFd44Oq44K544OI44Gu5LiK5LiL44Gu44Oc44O844OA44O844GM54Sh44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICBDb21wb25lbnQgdG8gY3JlYXRlIGEgY2FyZCB0aGF0IGRpc3BsYXlzIHNvbWUgaW5mb3JtYXRpb24uXG4gKlxuICogICAgVGhlIGNhcmQgbWF5IGJlIGNvbXBvc2VkIGJ5IGRpdnMgd2l0aCBzcGVjaWFsbHkgcHJlcGFyZWQgY2xhc3NlcyBgdGl0bGVgIGFuZC9vciBgY29udGVudGAuIFlvdSBjYW4gYWxzbyBhZGQgeW91ciBvd24gY29udGVudCBhcyB5b3UgcGxlYXNlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2NhcmRcbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcmQ+XG4gKiAgIDxwPlNvbWUgY29udGVudDwvcD5cbiAqIDwvb25zLWNhcmQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcmRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY2FyZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGxldCB0aXRsZSwgY29udGVudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd0aXRsZScpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NhcmRfX3RpdGxlJyk7XG4gICAgICAgIHRpdGxlID0gZWw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbnRlbnQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdjYXJkX19jb250ZW50Jyk7XG4gICAgICAgIGNvbnRlbnQgPSBlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5DYXJkID0gQ2FyZEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJkJywgQ2FyZEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdjYXJvdXNlbC1pdGVtLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBpdGVtIGNvbXBvbmVudC4gVXNlZCBhcyBhIGNoaWxkIG9mIHRoZSBgPG9ucy1jYXJvdXNlbD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcbiAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbFxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWw+YCBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXTxvbnMtY2Fyb3VzZWw+44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogPC9vbnMtY2Fyb3VzZWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcm91c2VsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuQ2Fyb3VzZWxJdGVtID0gQ2Fyb3VzZWxJdGVtRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNhcm91c2VsLWl0ZW0nLCBDYXJvdXNlbEl0ZW1FbGVtZW50KTtcbiIsImltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vYW5pbWl0JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IGRpcmVjdGlvbk1hcCA9IHtcbiAgdmVydGljYWw6IHtcbiAgICBheGlzOiAnWScsXG4gICAgc2l6ZTogJ0hlaWdodCcsXG4gICAgZGlyOiBbJ3VwJywgJ2Rvd24nXSxcbiAgICB0M2Q6IFsnMHB4LCAnLCAncHgsIDBweCddXG4gIH0sXG4gIGhvcml6b250YWw6IHtcbiAgICBheGlzOiAnWCcsXG4gICAgc2l6ZTogJ1dpZHRoJyxcbiAgICBkaXI6IFsnbGVmdCcsICdyaWdodCddLFxuICAgIHQzZDogWycnLCAncHgsIDBweCwgMHB4J11cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpcGVyIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIGNvbnN0IEZBTFNFID0gKCgpID0+IGZhbHNlKTtcbiAgICBgZ2V0SW5pdGlhbEluZGV4IGdldEJ1YmJsZVdpZHRoIGlzVmVydGljYWwgaXNPdmVyU2Nyb2xsYWJsZSBpc0NlbnRlcmVkXG4gICAgaXNBdXRvU2Nyb2xsYWJsZSByZWZyZXNoSG9vayBwcmVDaGFuZ2VIb29rIHBvc3RDaGFuZ2VIb29rIG92ZXJTY3JvbGxIb29rYFxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC5mb3JFYWNoKGtleSA9PiB0aGlzW2tleV0gPSBwYXJhbXNba2V5XSB8fCBGQUxTRSk7XG5cbiAgICB0aGlzLmdldEVsZW1lbnQgPSBwYXJhbXMuZ2V0RWxlbWVudDsgLy8gUmVxdWlyZWRcbiAgICB0aGlzLnNjcm9sbEhvb2sgPSBwYXJhbXMuc2Nyb2xsSG9vazsgLy8gT3B0aW9uYWxcbiAgICB0aGlzLml0ZW1TaXplID0gcGFyYW1zLml0ZW1TaXplIHx8ICcxMDAlJztcblxuICAgIHRoaXMuZ2V0QXV0b1Njcm9sbFJhdGlvID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCByYXRpbyA9IHBhcmFtcy5nZXRBdXRvU2Nyb2xsUmF0aW8gJiYgcGFyYW1zLmdldEF1dG9TY3JvbGxSYXRpbyguLi5hcmdzKTtcbiAgICAgIHJhdGlvID0gdHlwZW9mIHJhdGlvID09PSAnbnVtYmVyJyAmJiByYXRpbyA9PT0gcmF0aW8gPyByYXRpbyA6IC41O1xuICAgICAgaWYgKHJhdGlvIDwgMC4wIHx8IHJhdGlvID4gMS4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhdXRvLXNjcm9sbC1yYXRpbyAnICsgcmF0aW8gKyAnLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhdGlvO1xuICAgIH07XG5cbiAgICAvLyBCaW5kIGhhbmRsZXJzXG4gICAgdGhpcy5vbkRyYWdTdGFydCA9IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRHJhZyA9IHRoaXMub25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkRyYWdFbmQgPSB0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG4gIH1cblxuICBpbml0KHsgc3dpcGVhYmxlLCBhdXRvUmVmcmVzaCB9ID0ge30pIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnRhcmdldCA9IHRoaXMuZ2V0RWxlbWVudCgpLmNoaWxkcmVuWzBdO1xuICAgIHRoaXMuYmxvY2tlciA9IHRoaXMuZ2V0RWxlbWVudCgpLmNoaWxkcmVuWzFdO1xuICAgIGlmICghdGhpcy50YXJnZXQgfHwgIXRoaXMuYmxvY2tlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcInRhcmdldFwiIGFuZCBcImJsb2NrZXJcIiBlbGVtZW50cyB0byBleGlzdCBiZWZvcmUgaW5pdGlhbGl6aW5nIFN3aXBlci4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY2xhc3Nlc1xuICAgIHRoaXMuZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoJ29ucy1zd2lwZXInKTtcbiAgICB0aGlzLnRhcmdldC5jbGFzc0xpc3QuYWRkKCdvbnMtc3dpcGVyLXRhcmdldCcpO1xuICAgIHRoaXMuYmxvY2tlci5jbGFzc0xpc3QuYWRkKCdvbnMtc3dpcGVyLWJsb2NrZXInKTtcblxuICAgIC8vIFNldHVwIGxpc3RlbmVyc1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5nZXRFbGVtZW50KCksIHsgZHJhZ01pbkRpc3RhbmNlOiAxLCBkcmFnTG9ja1RvQXhpczogdHJ1ZSB9KTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuICAgIHRoaXMudXBkYXRlU3dpcGVhYmxlKHN3aXBlYWJsZSk7XG4gICAgdGhpcy51cGRhdGVBdXRvUmVmcmVzaChhdXRvUmVmcmVzaCk7XG5cbiAgICAvLyBTZXR1cCBpbml0aWFsIGxheW91dFxuICAgIHRoaXMuX3Njcm9sbCA9IHRoaXMuX29mZnNldCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KCk7XG4gICAgdGhpcy5fc2V0dXBJbml0aWFsSW5kZXgoKTtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5pbml0aWFsaXplZCAmJiB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpKTtcblxuICAgIC8vIEZpeCByZW5kZXJpbmcgZ2xpdGNoIG9uIEFuZHJvaWQgNC4xXG4gICAgaWYgKHRoaXMub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlU3dpcGVhYmxlKGZhbHNlKTtcbiAgICB0aGlzLnVwZGF0ZUF1dG9SZWZyZXNoKGZhbHNlKTtcblxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciAmJiB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5ibG9ja2VyID0gdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGw7XG5cbiAgICB0aGlzLnNldHVwUmVzaXplKGZhbHNlKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9zY3JvbGwgLyB0aGlzLnRhcmdldFNpemU7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLnNldEFjdGl2ZUluZGV4KGkpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgZ2V0IGl0ZW1Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQuY2hpbGRyZW4ubGVuZ3RoO1xuICB9XG5cbiAgZ2V0IGl0ZW1OdW1TaXplKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5faXRlbU51bVNpemUgIT09ICdudW1iZXInIHx8IHRoaXMuX2l0ZW1OdW1TaXplICE9PSB0aGlzLl9pdGVtTnVtU2l6ZSkge1xuICAgICAgdGhpcy5faXRlbU51bVNpemUgPSB0aGlzLl9jYWxjdWxhdGVJdGVtU2l6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faXRlbU51bVNpemU7XG4gIH1cblxuICBnZXQgbWF4U2Nyb2xsKCkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuaXRlbUNvdW50ICogdGhpcy5pdGVtTnVtU2l6ZSAtIHRoaXMudGFyZ2V0U2l6ZTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKG1heCA8IDAgPyAwIDogbWF4KTsgLy8gTmVlZCB0byByZXR1cm4gYW4gaW50ZWdlciB2YWx1ZS5cbiAgfVxuXG4gIF9jYWxjdWxhdGVJdGVtU2l6ZSgpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5pdGVtU2l6ZS5tYXRjaCgvXihcXGQrKShweHwlKS8pO1xuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGU6IHN3aXBlcidzIHNpemUgdW5pdCBtdXN0IGJlICclJyBvciAncHgnYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgcmV0dXJuIG1hdGNoZXNbMl0gPT09ICclJyA/IE1hdGgucm91bmQodmFsdWUgLyAxMDAgKiB0aGlzLnRhcmdldFNpemUpIDogdmFsdWU7XG4gIH1cblxuICBfc2V0dXBJbml0aWFsSW5kZXgoKSB7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBNYXRoLm1heChNYXRoLm1pbihOdW1iZXIodGhpcy5nZXRJbml0aWFsSW5kZXgoKSksIHRoaXMuaXRlbUNvdW50KSwgMCk7XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5pdGVtTnVtU2l6ZSAqIHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwpO1xuICB9XG5cbiAgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMuaXRlbUNvdW50IC0gMSkpO1xuICAgIGNvbnN0IHNjcm9sbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMubWF4U2Nyb2xsLCB0aGlzLl9vZmZzZXQgKyB0aGlzLml0ZW1OdW1TaXplICogaW5kZXgpKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc1VJV2ViVmlldygpKSB7XG4gICAgICAvKiBEaXJ0eSBmaXggZm9yICMyMjMxKGh0dHBzOi8vZ2l0aHViLmNvbS9PbnNlblVJL09uc2VuVUkvaXNzdWVzLzIyMzEpLiBiZWdpbiAqL1xuICAgICAgY29uc3QgY29uY2F0ID0gYXJyYXlPZkFycmF5ID0+IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5T2ZBcnJheSk7XG4gICAgICBjb25zdCBjb250ZW50cyA9IGNvbmNhdChcbiAgICAgICAgdXRpbC5hcnJheUZyb20odGhpcy50YXJnZXQuY2hpbGRyZW4pLm1hcChwYWdlID0+IHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5hcnJheUZyb20ocGFnZS5jaGlsZHJlbilcbiAgICAgICAgICAgIC5maWx0ZXIoY2hpbGQgPT4gY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlX19jb250ZW50JykpO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudHMuZm9yRWFjaChjb250ZW50ID0+IHtcbiAgICAgICAgICAgIG1hcC5zZXQoY29udGVudCwgY29udGVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuICAgICAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdwYWdlX19jb250ZW50LS1zdXBwcmVzcy1sYXllci1jcmVhdGlvbicpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLl9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMpKVxuICAgICAgICAudGhlbigoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50cy5mb3JFYWNoKGNvbnRlbnQgPT4ge1xuICAgICAgICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgbWFwLmdldChjb250ZW50KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpO1xuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgICAvKiBlbmQgKi9cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZVRvKHNjcm9sbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QWN0aXZlSW5kZXgoc2Nyb2xsID0gdGhpcy5fc2Nyb2xsKSB7XG4gICAgc2Nyb2xsIC09IHRoaXMuX29mZnNldDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuaXRlbUNvdW50LFxuICAgICAgc2l6ZSA9IHRoaXMuaXRlbU51bVNpemU7XG5cbiAgICBpZiAoc2Nyb2xsIDw9IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgaWYgKHNpemUgKiBpIDw9IHNjcm9sbCAmJiBzaXplICogKGkgKyAxKSA+IHNjcm9sbCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY291bnQgLSAxO1xuICB9XG5cbiAgc2V0dXBSZXNpemUoYWRkKSB7XG4gICAgd2luZG93WyhhZGQgPyAnYWRkJyA6ICdyZW1vdmUnKSArICdFdmVudExpc3RlbmVyJ10oJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUsIHRydWUpO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnNldHVwUmVzaXplKHRydWUpO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZShmYWxzZSk7XG4gIH1cblxuICB1cGRhdGVTd2lwZWFibGUoc2hvdWxkVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgY29uc3QgYWN0aW9uID0gc2hvdWxkVXBkYXRlID8gJ29uJyA6ICdvZmYnO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWcnLCB0aGlzLm9uRHJhZyk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ3N0YXJ0JywgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ2VuZCcsIHRoaXMub25EcmFnRW5kKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVBdXRvUmVmcmVzaChzaG91bGRXYXRjaCkge1xuICAgIGlmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBzaG91bGRXYXRjaFxuICAgICAgICA/IHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnRhcmdldCwgeyBjaGlsZExpc3Q6IHRydWUgfSlcbiAgICAgICAgOiB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVJdGVtU2l6ZShuZXdTaXplKSB7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IG5ld1NpemUgfHwgJzEwMCUnO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgdG9nZ2xlQmxvY2tlcihibG9jaykge1xuICAgIHRoaXMuYmxvY2tlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gYmxvY2sgPyAnYXV0bycgOiAnbm9uZSc7XG4gIH1cblxuICBfY2FuQ29uc3VtZUdlc3R1cmUoZ2VzdHVyZSkge1xuICAgIGNvbnN0IGQgPSBnZXN0dXJlLmRpcmVjdGlvbjtcbiAgICBjb25zdCBpc0ZpcnN0ID0gdGhpcy5fc2Nyb2xsID09PSAwICYmICF0aGlzLmlzT3ZlclNjcm9sbGFibGUoKTtcbiAgICBjb25zdCBpc0xhc3QgPSB0aGlzLl9zY3JvbGwgPT09IHRoaXMubWF4U2Nyb2xsICYmICF0aGlzLmlzT3ZlclNjcm9sbGFibGUoKTtcblxuICAgIHJldHVybiB0aGlzLmlzVmVydGljYWwoKVxuICAgICAgPyAoKGQgPT09ICdkb3duJyAmJiAhaXNGaXJzdCkgfHwgKGQgPT09ICd1cCcgJiYgIWlzTGFzdCkpXG4gICAgICA6ICgoZCA9PT0gJ3JpZ2h0JyAmJiAhaXNGaXJzdCkgfHwgKGQgPT09ICdsZWZ0JyAmJiAhaXNMYXN0KSk7XG4gIH1cblxuICBvbkRyYWdTdGFydChldmVudCkge1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSBldmVudC5jb25zdW1lZCB8fCAhdXRpbC5pc1ZhbGlkR2VzdHVyZShldmVudCk7XG5cbiAgICBpZiAoIXRoaXMuX2lnbm9yZURyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnN1bWUgPSBldmVudC5jb25zdW1lO1xuICAgICAgZXZlbnQuY29uc3VtZSA9ICgpID0+IHsgY29uc3VtZSAmJiBjb25zdW1lKCk7IHRoaXMuX2lnbm9yZURyYWcgPSB0cnVlOyB9O1xuXG4gICAgICBpZiAodGhpcy5fY2FuQ29uc3VtZUdlc3R1cmUoZXZlbnQuZ2VzdHVyZSkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRYID0gZXZlbnQuZ2VzdHVyZS5jZW50ZXIgJiYgZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WCB8fCAwLFxuICAgICAgICAgIGRpc3RGcm9tRWRnZSA9IHRoaXMuZ2V0QnViYmxlV2lkdGgoKSB8fCAwLFxuICAgICAgICAgIHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3VtZSAmJiBjb25zdW1lKCk7XG4gICAgICAgICAgICBldmVudC5jb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTsgLy8gQXZvaWQgc3RhcnRpbmcgZHJhZyBmcm9tIG91dHNpZGVcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQmxvY2tlcih0cnVlKTtcbiAgICAgICAgICAgIHV0aWwucHJldmVudFNjcm9sbCh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gTGV0IHBhcmVudCBlbGVtZW50cyBjb25zdW1lIHRoZSBnZXN0dXJlIG9yIGNvbnN1bWUgaXQgcmlnaHQgYXdheVxuICAgICAgICBzdGFydFggPCBkaXN0RnJvbUVkZ2UgfHwgc3RhcnRYID4gKHRoaXMudGFyZ2V0U2l6ZSAtIGRpc3RGcm9tRWRnZSlcbiAgICAgICAgICA/IHNldEltbWVkaWF0ZSgoKSA9PiAhdGhpcy5faWdub3JlRHJhZyAmJiBzdGFydCgpKVxuICAgICAgICAgIDogc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRyYWcoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50Lmdlc3R1cmUgfHwgdGhpcy5faWdub3JlRHJhZyB8fCAhdGhpcy5fc3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbnRpbnVlZCA9IHRydWU7IC8vIEZpeCBmb3IgcmFuZG9tICdkcmFnZW5kJyB3aXRob3V0ICdkcmFnJ1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0RGVsdGEoZXZlbnQpLCB7IHRocm90dGxlOiB0cnVlIH0pO1xuICB9XG5cbiAgb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLl9pZ25vcmVEcmFnIHx8ICF0aGlzLl9jb250aW51ZWQpIHtcbiAgICAgIHRoaXMuX2lnbm9yZURyYWcgPSB0cnVlOyAvLyBvbkRyYWdFbmQgbWlnaHQgZmlyZSBiZWZvcmUgb25EcmFnU3RhcnQncyBzZXRJbW1lZGlhdGVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250aW51ZWQgPSBmYWxzZTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldERlbHRhKGV2ZW50KTtcbiAgICBjb25zdCBub3JtYWxpemVkU2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsKHNjcm9sbCk7XG4gICAgc2Nyb2xsID09PSBub3JtYWxpemVkU2Nyb2xsID8gdGhpcy5fc3RhcnRNb21lbnR1bVNjcm9sbChzY3JvbGwsIGV2ZW50KSA6IHRoaXMuX2tpbGxPdmVyU2Nyb2xsKG5vcm1hbGl6ZWRTY3JvbGwpO1xuICAgIHRoaXMudG9nZ2xlQmxvY2tlcihmYWxzZSk7XG4gIH1cblxuICBfc3RhcnRNb21lbnR1bVNjcm9sbChzY3JvbGwsIGV2ZW50KSB7XG4gICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRWZWxvY2l0eShldmVudCksXG4gICAgICBtYXRjaGVzRGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uID09PSB0aGlzLmRNLmRpclt0aGlzLl9nZXREZWx0YShldmVudCkgPCAwID8gMCA6IDFdO1xuXG4gICAgY29uc3QgbmV4dFNjcm9sbCA9IHRoaXMuX2dldEF1dG9TY3JvbGwoc2Nyb2xsLCB2ZWxvY2l0eSwgbWF0Y2hlc0RpcmVjdGlvbik7XG4gICAgbGV0IGR1cmF0aW9uID0gTWF0aC5hYnMobmV4dFNjcm9sbCAtIHNjcm9sbCkgLyAodmVsb2NpdHkgKyAwLjAxKSAvIDEwMDA7XG4gICAgZHVyYXRpb24gPSBNYXRoLm1pbiguMjUsIE1hdGgubWF4KC4xLCBkdXJhdGlvbikpO1xuXG4gICAgdGhpcy5fY2hhbmdlVG8obmV4dFNjcm9sbCwgeyBzd2lwZTogdHJ1ZSwgYW5pbWF0aW9uT3B0aW9uczogeyBkdXJhdGlvbiwgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC40LCAuNywgLjUsIDEpJyB9IH0pO1xuICB9XG5cbiAgX2tpbGxPdmVyU2Nyb2xsKHNjcm9sbCkge1xuICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRNLmRpcltOdW1iZXIoc2Nyb2xsID4gMCldO1xuICAgIGNvbnN0IGtpbGxPdmVyU2Nyb2xsID0gKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCB7IGFuaW1hdGlvbk9wdGlvbnM6IHsgZHVyYXRpb246IC40LCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknIH0gfSk7XG4gICAgdGhpcy5vdmVyU2Nyb2xsSG9vayh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkgfHwga2lsbE92ZXJTY3JvbGwoKTtcbiAgfVxuXG4gIF9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGUgPSB7IGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KHNjcm9sbCksIGxhc3RBY3RpdmVJbmRleDogdGhpcy5fbGFzdEFjdGl2ZUluZGV4LCBzd2lwZTogb3B0aW9ucy5zd2lwZSB8fCBmYWxzZSB9O1xuICAgIGNvbnN0IGNoYW5nZSA9IGUuYWN0aXZlSW5kZXggIT09IGUubGFzdEFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IGNhbmNlbGVkID0gY2hhbmdlID8gdGhpcy5wcmVDaGFuZ2VIb29rKGUpIDogZmFsc2U7XG5cbiAgICB0aGlzLl9zY3JvbGwgPSBjYW5jZWxlZCA/IHRoaXMuX29mZnNldCArIGUubGFzdEFjdGl2ZUluZGV4ICogdGhpcy5pdGVtTnVtU2l6ZSA6IHNjcm9sbDtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjYW5jZWxlZCA/IGUubGFzdEFjdGl2ZUluZGV4IDogZS5hY3RpdmVJbmRleDtcblxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbCA9PT0gdGhpcy5fc2Nyb2xsICYmICFjYW5jZWxlZCkge1xuICAgICAgICBjaGFuZ2UgJiYgdGhpcy5wb3N0Q2hhbmdlSG9vayhlKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3Njcm9sbFRvKHNjcm9sbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMudGhyb3R0bGUpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gMC4zNTtcbiAgICAgIGlmIChzY3JvbGwgPCAwKSB7XG4gICAgICAgIHNjcm9sbCA9IHRoaXMuaXNPdmVyU2Nyb2xsYWJsZSgpID8gTWF0aC5yb3VuZChzY3JvbGwgKiByYXRpbykgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5tYXhTY3JvbGw7XG4gICAgICAgIGlmIChtYXhTY3JvbGwgPCBzY3JvbGwpIHtcbiAgICAgICAgICBzY3JvbGwgPSB0aGlzLmlzT3ZlclNjcm9sbGFibGUoKSA/IG1heFNjcm9sbCArIE1hdGgucm91bmQoKHNjcm9sbCAtIG1heFNjcm9sbCkgKiByYXRpbykgOiBtYXhTY3JvbGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHQgPSBvcHRpb25zLmFuaW1hdGlvbiAgPT09ICdub25lJyA/IHt9IDogb3B0aW9ucy5hbmltYXRpb25PcHRpb25zO1xuICAgIHRoaXMuc2Nyb2xsSG9vayAmJiB0aGlzLml0ZW1OdW1TaXplID4gMCAmJiB0aGlzLnNjcm9sbEhvb2soKHNjcm9sbCAvIHRoaXMuaXRlbU51bVNpemUpLnRvRml4ZWQoMiksIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuICAgICAgYW5pbWl0KHRoaXMudGFyZ2V0KVxuICAgICAgICAucXVldWUoeyB0cmFuc2Zvcm06IHRoaXMuX2dldFRyYW5zZm9ybShzY3JvbGwpIH0sIG9wdClcbiAgICAgICAgLnBsYXkocmVzb2x2ZSlcbiAgICApO1xuICB9XG5cbiAgX2dldEF1dG9TY3JvbGwoc2Nyb2xsLCB2ZWxvY2l0eSwgbWF0Y2hlc0RpcmVjdGlvbikge1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4U2Nyb2xsLFxuICAgICAgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0LFxuICAgICAgc2l6ZSA9IHRoaXMuaXRlbU51bVNpemU7XG5cbiAgICBpZiAoIXRoaXMuaXNBdXRvU2Nyb2xsYWJsZSgpKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcbiAgICB9XG5cbiAgICBsZXQgYXJyID0gW107XG4gICAgZm9yIChsZXQgcyA9IG9mZnNldDsgcyA8IG1heDsgcyArPSBzaXplKSB7XG4gICAgICBhcnIucHVzaChzKTtcbiAgICB9XG4gICAgYXJyLnB1c2gobWF4KTtcblxuICAgIGFyciA9IGFyclxuICAgICAgLnNvcnQoKGxlZnQsIHJpZ2h0KSA9PiBNYXRoLmFicyhsZWZ0IC0gc2Nyb2xsKSAtIE1hdGguYWJzKHJpZ2h0IC0gc2Nyb2xsKSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0sIHBvcykgPT4gIXBvcyB8fCBpdGVtICE9PSBhcnJbcG9zIC0gMV0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IGFyclswXTtcbiAgICBjb25zdCBsYXN0U2Nyb2xsID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ICogc2l6ZSArIG9mZnNldDtcbiAgICBjb25zdCBzY3JvbGxSYXRpbyA9IE1hdGguYWJzKHNjcm9sbCAtIGxhc3RTY3JvbGwpIC8gc2l6ZTtcblxuICAgIGlmIChzY3JvbGxSYXRpbyA8PSB0aGlzLmdldEF1dG9TY3JvbGxSYXRpbyhtYXRjaGVzRGlyZWN0aW9uLCB2ZWxvY2l0eSwgc2l6ZSkpIHtcbiAgICAgIHJlc3VsdCA9IGxhc3RTY3JvbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzY3JvbGxSYXRpbyA8IDEuMCAmJiBhcnJbMF0gPT09IGxhc3RTY3JvbGwgJiYgYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gYXJyWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCByZXN1bHQpKTtcbiAgfVxuXG4gIF9yZXNldCgpIHtcbiAgICB0aGlzLl90YXJnZXRTaXplID0gdGhpcy5faXRlbU51bVNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBfbm9ybWFsaXplU2Nyb2xsKHNjcm9sbCkge1xuICAgIHJldHVybiBNYXRoLm1heCggTWF0aC5taW4oc2Nyb2xsLCB0aGlzLm1heFNjcm9sbCksIDApXG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KCk7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGwodGhpcy5fc2Nyb2xsKTtcbiAgICBzY3JvbGwgIT09IHRoaXMuX3Njcm9sbCA/IHRoaXMuX2tpbGxPdmVyU2Nyb2xsKHNjcm9sbCkgOiB0aGlzLl9jaGFuZ2VUbyhzY3JvbGwpO1xuXG4gICAgdGhpcy5yZWZyZXNoSG9vaygpO1xuICB9XG5cbiAgZ2V0IHRhcmdldFNpemUoKSB7XG4gICAgaWYgKCF0aGlzLl90YXJnZXRTaXplKSB7XG4gICAgICB0aGlzLl90YXJnZXRTaXplID0gdGhpcy50YXJnZXRbYG9mZnNldCR7dGhpcy5kTS5zaXplfWBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U2l6ZTtcbiAgfVxuXG4gIF9nZXREZWx0YShldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlW2BkZWx0YSR7dGhpcy5kTS5heGlzfWBdO1xuICB9XG5cbiAgX2dldFZlbG9jaXR5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmVbYHZlbG9jaXR5JHt0aGlzLmRNLmF4aXN9YF07XG4gIH1cblxuICBfZ2V0VHJhbnNmb3JtKHNjcm9sbCkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRNLnQzZFswXX0key1zY3JvbGx9JHt0aGlzLmRNLnQzZFsxXX0pYDtcbiAgfVxuXG4gIF91cGRhdGVMYXlvdXQoKSB7XG4gICAgdGhpcy5kTSA9IGRpcmVjdGlvbk1hcFt0aGlzLmlzVmVydGljYWwoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCddO1xuICAgIHRoaXMudGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1zd2lwZXItdGFyZ2V0LS12ZXJ0aWNhbCcsIHRoaXMuaXNWZXJ0aWNhbCgpKTtcblxuICAgIGZvciAobGV0IGMgPSB0aGlzLnRhcmdldC5jaGlsZHJlblswXTsgYzsgYyA9IGMubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBjLnN0eWxlW3RoaXMuZE0uc2l6ZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDZW50ZXJlZCgpKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAodGhpcy50YXJnZXRTaXplIC0gdGhpcy5pdGVtTnVtU2l6ZSkgLyAtMiB8fCAwO1xuICAgIH1cbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBTd2lwZXIgZnJvbSAnLi4vb25zL2ludGVybmFsL3N3aXBlcic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsXG4gKiBAY2F0ZWdvcnkgY2Fyb3VzZWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ2Fyb3VzZWwgY29tcG9uZW50LiBBIGNhcm91c2VsIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgc2V2ZXJhbCBpdGVtcyBpbiB0aGUgc2FtZSBzcGFjZS5cbiAqXG4gKiAgICAgVGhlIGNvbXBvbmVudCBzdXBwb3J0cyBkaXNwbGF5aW5nIGNvbnRlbnQgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuIFRoZSB1c2VyIGNhbiBzY3JvbGwgdGhyb3VnaCB0aGUgaXRlbXMgYnkgZHJhZ2dpbmcgYW5kIGl0IGNhbiBhbHNvIGJlIGNvbnRyb2xsZXIgcHJvZ3JhbW1hdGljYWxseS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4YmJ6T1FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9jYXJvdXNlbFxuICogQHNlZWFsc28gb25zLWNhcm91c2VsLWl0ZW1cbiAqICAgW2VuXWA8b25zLWNhcm91c2VsLWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiA8L29ucy1jYXJvdXNlbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2Fyb3VzZWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY3VycmVudCBjYXJvdXNlbCBpdGVtIGhhcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBl+OBpuOBhOOCi+OCq+ODq+ODvOOCu+ODq+OBruimgee0oOOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5hY3RpdmVJbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGFjdGl2ZSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQubGFzdEFjdGl2ZUluZGV4XG4gICAqICAgW2VuXVByZXZpb3VzIGFjdGl2ZSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jgqLjgq/jg4bjgqPjg5bjgaDjgaPjgZ/opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHJlZnJlc2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgKiAgIFtlbl1DYXJvdXNlbCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfQ2Fyb3VzZWzjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IG92ZXJzY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIG92ZXJzY3JvbGxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzjgqrjg7zjg5Djg7zjgrnjgq/jg63jg7zjg6vjgZfjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBjYXJvdXNlbCBoYXMgYmVlbiByZWZyZXNoZWQuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or44GM5pu05paw44GV44KM44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5kaXJlY3Rpb25cbiAgICogICBbZW5dQ2FuIGJlIG9uZSBvZiBlaXRoZXIgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgb3IgXCJyaWdodFwiLlsvZW5dXG4gICAqICAgW2phXeOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBleOCjOOBn+aWueWQkeOBjOW+l+OCieOCjOOBvuOBmeOAglwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCLjga7jgYTjgZrjgozjgYvjga7mlrnlkJHjgYzmuKHjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC53YWl0VG9SZXR1cm5cbiAgICogICBbZW5dVGFrZXMgYSA8Y29kZT5Qcm9taXNlPC9jb2RlPiBvYmplY3QgYXMgYW4gYXJndW1lbnQuIFRoZSBjYXJvdXNlbCB3aWxsIG5vdCBzY3JvbGwgYmFjayB1bnRpbCB0aGUgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZCBvciByZWplY3RlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjga9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS5byV5pWw44Go44GX44Gm5Y+X44GR5Y+W44KK44G+44GZ44CC5rih44GX44GfUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOBjHJlc29sdmXjgZXjgozjgovjgYtyZWplY3TjgZXjgozjgovjgb7jgafjgIHjgqvjg6vjg7zjgrvjg6vjga/jgrnjgq/jg63jg7zjg6vjg5Djg4Pjgq/jgZfjgb7jgZvjgpPjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBkaXJlY3Rpb24gb2YgdGhlIGNhcm91c2VsLiBDYW4gYmUgZWl0aGVyIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4gRGVmYXVsdCBpcyBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjga7mlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJcImhvcml6b250YWxcIuOBi1widmVydGljYWxcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZnVsbHNjcmVlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGNvdmVyIHRoZSB3aG9sZSBzY3JlZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CBYWJzb2x1dGXjg53jgrjjgrfjg6fjg7PjgpLkvb/jgaPjgabjgqvjg6vjg7zjgrvjg6vjgYzoh6rli5XnmoTjgavnlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvdmVyc2Nyb2xsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIHNjcm9sbGFibGUgb3ZlciB0aGUgZWRnZS4gSXQgd2lsbCBib3VuY2UgYmFjayB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCv+ODg+ODgeOChOODieODqeODg+OCsOOBp+err+OBvuOBp+OCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+OAgeODkOOCpuODs+ODieOBmeOCi+OCiOOBhuOBquWKueaenOOBjOW9k+OBn+OCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNlbnRlcmVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHRoZW4gdGhlIHNlbGVjdGVkIGl0ZW0gd2lsbCBiZSBpbiB0aGUgY2VudGVyIG9mIHRoZSBjYXJvdXNlbCBpbnN0ZWFkIG9mIHRoZSBiZWdpbm5pbmcuIFVzZWZ1bCBvbmx5IHdoZW4gdGhlIGl0ZW1zIGFyZSBzbWFsbGVyIHRoYW4gdGhlIGNhcm91c2VsLiBbL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHpgbjjgpPjgafjgYTjgotvbnMtY2Fyb3VzZWwtaXRlbeOBr+OCq+ODq+ODvOOCu+ODq+OBruecn+OCk+S4reOBuOihjOOBjeOBvuOBmeOAgumgheebruOBjOOCq+ODq+ODvOOCu+ODq+OCiOOCiuOCguWwj+OBleOBhOWgtOWQiOOBq+OBruOBv+OAgeOBk+OCjOOBr+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0td2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIHdpZHRoLiBPbmx5IHdvcmtzIHdoZW4gdGhlIGRpcmVjdGlvbiBpcyBzZXQgdG8gXCJob3Jpem9udGFsXCIuWy9lbl1cbiAgICogICAgW2phXW9ucy1jYXJvdXNlbC1pdGVt44Gu5bmF44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5bGe5oCn44Gv44CBZGlyZWN0aW9u5bGe5oCn44GrXCJob3Jpem9udGFsXCLjgpLmjIflrprjgZfjgZ/mmYLjga7jgb/mnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpdGVtLWhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5db25zLWNhcm91c2VsLWl0ZW0ncyBoZWlnaHQuIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcInZlcnRpY2FsXCIuWy9lbl1cbiAgICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcInZlcnRpY2FsXCLjgpLmjIflrprjgZfjgZ/mmYLjga7jgb/mnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2Nyb2xsZWQgdG8gdGhlIGNsb3Nlc3QgaXRlbSBib3JkZXIgd2hlbiByZWxlYXNlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHkuIDnlarov5HjgYRjYXJvdXNlbC1pdGVt44Gu5aKD55WM44G+44Gn6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1zY3JvbGwtcmF0aW9cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgIFtlbl1BIG51bWJlciBiZXR3ZWVuIDAuMCBhbmQgMS4wIHRoYXQgc3BlY2lmaWVzIGhvdyBtdWNoIHRoZSB1c2VyIG11c3QgZHJhZyB0aGUgY2Fyb3VzZWwgaW4gb3JkZXIgZm9yIGl0IHRvIGF1dG8gc2Nyb2xsIHRvIHRoZSBuZXh0IGl0ZW0uWy9lbl1cbiAgICogICAgW2phXTAuMOOBi+OCiTEuMOOBvuOBp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCq+ODq+ODvOOCu+ODq+OBruimgee0oOOCkuOBqeOCjOOBkOOCieOBhOOBruWJsuWQiOOBvuOBp+ODieODqeODg+OCsOOBmeOCi+OBqOasoeOBruimgee0oOOBq+iHquWLleeahOOBq+OCueOCr+ODreODvOODq+OBmeOCi+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCBjYW4gYmUgc2Nyb2xsZWQgYnkgZHJhZyBvciBzd2lwZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqvjg6vjg7zjgrvjg6vjgpLjgrnjg6/jgqTjg5fjgoTjg4njg6njg4PjgrDjgafnp7vli5XjgafjgY3jgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIFkcmFn44KEdG91Y2jjgoRzd2lwZeOCkuWPl+OBkeS7mOOBkeOBquOBj+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluaXRpYWwtaW5kZXhcbiAgICogQGluaXRvbmx5XG4gICAqIEBkZWZhdWx0IDBcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXG4gICAqICAgW2phXeacgOWIneOBq+ihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSMOWni+OBvuOCiuOBruOCpOODs+ODh+ODg+OCr+OCueOBp+aMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOWApOOBryAwIOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hlbiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYXV0b21hdGljYWxseSByZWZyZXNoIHdoZW4gdGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBjaGFuZ2UuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5a2Q6KaB57Sg44Gu5pWw44GM5aSJ44KP44KL44Go44Kr44Or44O844K744Or44Gv6Ieq5YuV55qE44Gr5pu05paw44GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuY2hpbGRyZW5bMF0gJiYgdGhpcy5jaGlsZHJlblswXS50YWdOYW1lICE9PSAnT05TLUNBUk9VU0VMLUlURU0nICYmIHRoaXMuY2hpbGRyZW5bMF0gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKCF0YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICAhdGhpcy5jaGlsZHJlblsxXSAmJiB0aGlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQgPSB0aGlzLmFwcGVuZENoaWxkLmJpbmQodGFyZ2V0KTtcbiAgICB0aGlzLmluc2VydEJlZm9yZSA9IHRoaXMuaW5zZXJ0QmVmb3JlLmJpbmQodGFyZ2V0KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5fc3dpcGVyKSB7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBuZXcgU3dpcGVyKHtcbiAgICAgICAgZ2V0RWxlbWVudDogKCkgPT4gdGhpcyxcbiAgICAgICAgZ2V0SW5pdGlhbEluZGV4OiAoKSA9PiB0aGlzLmdldEF0dHJpYnV0ZSgnaW5pdGlhbC1pbmRleCcpLFxuICAgICAgICBnZXRBdXRvU2Nyb2xsUmF0aW86ICgpID0+IHRoaXMuYXV0b1Njcm9sbFJhdGlvLFxuICAgICAgICBpc1ZlcnRpY2FsOiAoKSA9PiB0aGlzLnZlcnRpY2FsLFxuICAgICAgICBpc092ZXJTY3JvbGxhYmxlOiAoKSA9PiB0aGlzLm92ZXJzY3JvbGxhYmxlLFxuICAgICAgICBpc0NlbnRlcmVkOiAoKSA9PiB0aGlzLmNlbnRlcmVkLFxuICAgICAgICBpc0F1dG9TY3JvbGxhYmxlOiAoKSA9PiB0aGlzLmF1dG9TY3JvbGwsXG4gICAgICAgIGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuICAgICAgICBvdmVyU2Nyb2xsSG9vazogdGhpcy5fb25PdmVyU2Nyb2xsLmJpbmQodGhpcyksXG4gICAgICAgIHByZUNoYW5nZUhvb2s6IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcywgJ3ByZWNoYW5nZScpLFxuICAgICAgICBwb3N0Q2hhbmdlSG9vazogdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzLCAncG9zdGNoYW5nZScpLFxuICAgICAgICByZWZyZXNoSG9vazogdGhpcy5fb25SZWZyZXNoLmJpbmQodGhpcyksXG4gICAgICAgIHNjcm9sbEhvb2s6IHRoaXMuX29uU3dpcGVcbiAgICAgIH0pO1xuXG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fc3dpcGVyLmluaXQoe1xuICAgICAgICBzd2lwZWFibGU6IHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSxcbiAgICAgICAgYXV0b1JlZnJlc2g6IHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXJlZnJlc2gnKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9zd2lwZXIgJiYgdGhpcy5fc3dpcGVyLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zd2lwZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fc3dpcGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydzd2lwZWFibGUnLCAnYXV0by1yZWZyZXNoJywgJ2RpcmVjdGlvbicsICdpdGVtLWhlaWdodCcsICdpdGVtLXdpZHRoJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmICghdGhpcy5fc3dpcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl9zd2lwZXIudXBkYXRlU3dpcGVhYmxlKHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXV0by1yZWZyZXNoJzpcbiAgICAgICAgdGhpcy5fc3dpcGVyLnVwZGF0ZUF1dG9SZWZyZXNoKHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXJlZnJlc2gnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaXRlbS1oZWlnaHQnOlxuICAgICAgICB0aGlzLnZlcnRpY2FsICYmIHRoaXMuX3N3aXBlci51cGRhdGVJdGVtU2l6ZSh0aGlzLml0ZW1TaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpdGVtLXdpZHRoJzpcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCB8fCB0aGlzLl9zd2lwZXIudXBkYXRlSXRlbVNpemUodGhpcy5pdGVtU2l6ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgdGhpcy5fc3dpcGVyLnJlZnJlc2goKTtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLl9zd2lwZXIuc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5fc3dpcGVyLmhpZGUoKTtcbiAgfVxuXG4gIF9vbk92ZXJTY3JvbGwoeyBkaXJlY3Rpb24sIGtpbGxPdmVyU2Nyb2xsIH0pIHtcbiAgICBsZXQgd2FpdEZvckFjdGlvbiA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3ZlcnNjcm9sbCcsIHtcbiAgICAgIGNhcm91c2VsOiB0aGlzLFxuICAgICAgYWN0aXZlSW5kZXg6IHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHdhaXRUb1JldHVybjogcHJvbWlzZSA9PiB7XG4gICAgICAgIHdhaXRGb3JBY3Rpb24gPSB0cnVlO1xuICAgICAgICBwcm9taXNlLnRoZW4oa2lsbE92ZXJTY3JvbGwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHdhaXRGb3JBY3Rpb247XG4gIH1cblxuICBfb25DaGFuZ2UoZXZlbnROYW1lLCB7IGFjdGl2ZUluZGV4LCBsYXN0QWN0aXZlSW5kZXggfSkge1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBldmVudE5hbWUsIHsgY2Fyb3VzZWw6IHRoaXMsIGFjdGl2ZUluZGV4LCBsYXN0QWN0aXZlSW5kZXggfSk7XG4gIH1cblxuICBfb25SZWZyZXNoKCkge1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVmcmVzaCcsIHsgY2Fyb3VzZWw6IHRoaXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVJbmRleFxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZUluZGV4KGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UaGUgaW5kZXggdGhhdCB0aGUgY2Fyb3VzZWwgc2hvdWxkIGJlIHNldCB0by5bL2VuXVxuICAgKiAgIFtqYV1jYXJvdXNlbOimgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAgdG8gc2hvdy5bL2VuXVxuICAgKiAgIFtqYV3ooajnpLrjgZnjgotvbnMtY2Fyb3VzZWwtaXRlbeOCkmluZGV444Gn5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZUluZGV4KGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpO1xuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgeyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguNCwgLjcsIC41LCAxKScgfSxcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIDoge31cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544GM6L+U44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GV44KM44Gm44GE44KLb25zLWNhcm91c2VsLWl0ZW3opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5nZXRBY3RpdmVJbmRleCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpcnN0XG4gICAqIEBzaWduYXR1cmUgZmlyc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgaXMgc2V0IHRvIGBcIm5vbmVcImAsIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBmaXJzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgoMCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsYXN0XG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBsYXN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxhc3Qob3B0aW9ucykge1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgYDxvbnMtY2Fyb3VzZWwtaXRlbXM+YCBkeW5hbWljYWxseSBvciB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZS5bL2VuXVxuICAgKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4jjgoTlhoXpg6jjga7nirbmhYvjgpLmnIDmlrDjga7jgoLjga7jgavmm7TmlrDjgZfjgb7jgZnjgIJvbnMtY2Fyb3VzZWwtaXRlbeOCkuWLleeahOOBq+Wil+OChOOBl+OBn+OCiuOAgW9ucy1jYXJvdXNlbOOBruWkp+OBjeOBleOCkuWLleeahOOBq+WkieOBiOOCi+mam+OBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3N3aXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGl0ZW1Db3VudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBpdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5pdGVtQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIGNhcm91c2VsLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29uU3dpcGUnIG11c3QgYmUgYSBmdW5jdGlvbi5gKVxuICAgIH1cbiAgICB0aGlzLl9vblN3aXBlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIGF1dG8gc2Nyb2xsIGlzIGVuYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Kq44O844OI44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgYXV0b1Njcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsJyk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnYXV0by1zY3JvbGwnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgdmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSA9PT0gJ3ZlcnRpY2FsJztcbiAgfVxuXG4gIGdldCBpdGVtU2l6ZSgpIHtcbiAgICBjb25zdCBpdGVtU2l6ZUF0dHIgPSAodGhpcy5nZXRBdHRyaWJ1dGUoYGl0ZW0tJHt0aGlzLnZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnfWApIHx8ICcnKS50cmltKCk7XG4gICAgcmV0dXJuIGl0ZW1TaXplQXR0ci5tYXRjaCgvXlxcZCsocHh8JSkkLykgPyBpdGVtU2l6ZUF0dHIgOiAnMTAwJSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxSYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgYXV0byBzY3JvbGwgcmF0aW8uIFsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruOCquODvOODiOOCueOCr+ODreODvOODq+OBrnJhdGlv5YCk44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJykpO1xuICB9XG5cbiAgc2V0IGF1dG9TY3JvbGxSYXRpbyhyYXRpbykge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycsIHJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvdmVyc2Nyb2xsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIG92ZXJzY3JvbGxhYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1vdmVyc2Nyb2xs44Gn44GN44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb3ZlcnNjcm9sbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdvdmVyc2Nyb2xsYWJsZScpO1xuICB9XG5cbiAgc2V0IG92ZXJzY3JvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdvdmVyc2Nyb2xsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2VudGVyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjZW50ZXJlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdY2VudGVyZWTnirbmhYvjgavjgarjgaPjgabjgYTjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBjZW50ZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NlbnRlcmVkJyk7XG4gIH1cblxuICBzZXQgY2VudGVyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NlbnRlcmVkJywgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncG9zdGNoYW5nZScsICdyZWZyZXNoJywgJ292ZXJzY3JvbGwnXTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuQ2Fyb3VzZWwgPSBDYXJvdXNlbEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJvdXNlbCcsIENhcm91c2VsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jb2xcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1yb3c+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ25tZW50LlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwgW2VuXUxheW91dGluZyBndWlkZVsvZW5dW2phXeODrOOCpOOCouOCpuODiOapn+iDvVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcm93XG4gKiAgIFtlbl1UaGUgYDxvbnMtcm93PmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgb2YgYDxvbnMtY29sPmAuWy9lbl1cbiAqICAgW2phXW9ucy1yb3fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiY2VudGVyXCIsIGFuZCBcImJvdHRvbVwiLlsvZW5dXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIGNzcyB3aWR0aCB2YWx1ZXMgKFwiMTAlXCIsIFwiNTBweFwiKS5bL2VuXVxuICogICBbamFd44Kr44Op44Og44Gu5qiq5bmF44KS5oyH5a6a44GZ44KL44CC44OR44O844K744Oz44OI44KC44GX44GP44Gv44OU44Kv44K744Or44Gn5oyH5a6a44GX44G+44GZ77yIMTAl44KENTBweO+8ieOAglsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyd3aWR0aCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgc3R5bGVyLmNsZWFyKHRoaXMsICdmbGV4IG1heFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gd2lkdGgudHJpbSgpLm1hdGNoKC9eXFxkKyQvKSA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG5cbiAgICAgIHN0eWxlcih0aGlzLCB7XG4gICAgICAgIGZsZXg6ICcwIDAgJyArIHdpZHRoLFxuICAgICAgICBtYXhXaWR0aDogd2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuQ29sID0gQ29sRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNvbCcsIENvbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBjbGFzcyBEaWFsb2dBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC02MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0RpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZS1pbi1vdXQnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLmJvZHlIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAke3RoaXMuYm9keUhlaWdodCAvIDIuMCAtIDF9cHgsIDApYFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAke3RoaXMuYm9keUhlaWdodCAvIDIuMCAtIDF9cHgsIDApYFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgU2xpZGVEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi8uLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBEaWFsb2dBbmltYXRvciwgSU9TRGlhbG9nQW5pbWF0b3IsIEFuZHJvaWREaWFsb2dBbmltYXRvciwgU2xpZGVEaWFsb2dBbmltYXRvciB9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmRpYWxvZyc6ICdkaWFsb2ctLSonLFxuICAnLmRpYWxvZy1jb250YWluZXInOiAnZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICcuZGlhbG9nLW1hc2snOiAnZGlhbG9nLW1hc2stLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZERpYWxvZ0FuaW1hdG9yIDogSU9TRGlhbG9nQW5pbWF0b3IsXG4gICdzbGlkZSc6IFNsaWRlRGlhbG9nQW5pbWF0b3IsXG4gICdub25lJzogRGlhbG9nQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWRpYWxvZ1xuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLiBBcyBvcHBvc2VkIHRvIHRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50LCB0aGlzIGNvbXBvbmVudCBjYW4gY29udGFpbiBhbnkga2luZCBvZiBjb250ZW50LlxuICpcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVEaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBkaWFsb2cgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIG1lbnVzLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIHRvIGFzayB0aGUgdXNlciB0byBtYWtlIGEgZGVjaXNpb24uXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4genh4YUdhXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXWA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1tb2RhbFxuICogICBbZW5dYDxvbnMtbW9kYWw+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW1vZGFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWRpYWxvZyBpZD1cImRpYWxvZ1wiPlxuICogICA8cD5UaGlzIGlzIGEgZGlhbG9nITwvcD5cbiAqIDwvb25zLWRpYWxvZz5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWRpYWxvZz5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJkaWFsb2dcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2cnKTtcblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zRGlhbG9nRWxlbWVudC5EaWFsb2dBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIERpYWxvZ0FuaW1hdG9yO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5EaWFsb2cgPSBEaWFsb2dFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZGlhbG9nJywgRGlhbG9nRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2ZhYic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdmYWItLSonLFxuICAnLmZhYl9faWNvbic6ICdmYWItLSpfX2ljb24nXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1mYWJcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIGlzIGEgY2lyY3VsYXIgYnV0dG9uIGRlZmluZWQgaW4gdGhlIFtNYXRlcmlhbCBEZXNpZ24gc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5odG1sKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCB0byBwcm9tb3RlIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiB0aGUgYXBwLlxuICpcbiAqICAgICBJdCBjYW4gYmUgZGlzcGxheWVkIGVpdGhlciBhcyBhbiBpbmxpbmUgZWxlbWVudCBvciBpbiBvbmUgb2YgdGhlIGNvcm5lcnMuIE5vcm1hbGx5IGl0IHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgbG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ZhYlxuICogQG1vZGlmaWVyIG1pbmlcbiAqICAgW2VuXU1ha2VzIHRoZSBgb25zLWZhYmAgc21hbGxlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50IGlzIGEgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiB0aGF0IGRpc3BsYXlzIGEgbWVudSB3aGVuIHRhcHBlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBwb3NpdGlvbiBvZiB0aGUgYnV0dG9uLiBTaG91bGQgYmUgYSBzdHJpbmcgbGlrZSBgXCJib3R0b20gcmlnaHRcImAgb3IgYFwidG9wIGxlZnRcImAuIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBkZWZpbmVkIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBzdGF0ZW1lbnRzIGNhbiBiZSBleGVjdXRlZCBiZWZvcmUgY29udGVudFJlYWR5XG4gICAgLy8gc2luY2UgdGhlc2UgZG8gbm90IGFjY2VzcyB0aGUgY2hpbGRyZW5cbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuZmFiX19pY29uJykpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ2ZhYl9faWNvbicpO1xuXG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGlmICghZWxlbWVudC50YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25zLXJpcHBsZScpIHtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuc2hvdygpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdwb3NpdGlvbicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5zaG93KCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5oaWRlKCkpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICBjYXNlICd0b3AgY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICBjYXNlICdib3R0b20gY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUhpZGUgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShhY3Rpb24gPSAhdGhpcy52aXNpYmxlKSB7XG4gICAgY29uc3QgaXNCb3R0b20gPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykgfHwgJycpLmluZGV4T2YoJ2JvdHRvbScpID49IDA7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gaXNCb3R0b20gPyBgdHJhbnNsYXRlM2QoMHB4LCAtJHt1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0IHx8IDB9cHgsIDBweClgIDogJyc7XG5cbiAgICBzdHlsZXIodGhpcywgeyB0cmFuc2Zvcm06IGAke3RyYW5zbGF0ZX0gc2NhbGUoJHtOdW1iZXIoYWN0aW9uKX0pYCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUudHJhbnNmb3JtLmluZGV4T2YoJ3NjYWxlKDApJykgPT09IC0xICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5GYWIgPSBGYWJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZmFiJywgRmFiRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZ2VzdHVyZS1kZXRlY3RvclxuICogQGNhdGVnb3J5IGdlc3R1cmVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRvIGRldGVjdCBmaW5nZXIgZ2VzdHVyZXMgd2l0aGluIHRoZSB3cmFwcGVkIGVsZW1lbnQuIEZvbGxvd2luZyBnZXN0dXJlcyBhcmUgc3VwcG9ydGVkOlxuICogICAgIC0gRHJhZyBnZXN0dXJlczogYGRyYWdgLCBgZHJhZ2xlZnRgLCBgZHJhZ3JpZ2h0YCwgYGRyYWd1cGAsIGBkcmFnZG93bmBcbiAqICAgICAtIEhvbGQgZ2VzdHVyZXM6IGBob2xkYCwgYHJlbGVhc2VgXG4gKiAgICAgLSBTd2lwZSBnZXN0dXJlczogYHN3aXBlYCwgYHN3aXBlbGVmdGAsIGBzd2lwZXJpZ2h0YCwgYHN3aXBldXBgLCBgc3dpcGVkb3duYFxuICogICAgIC0gVGFwIGdlc3R1cmVzOiBgdGFwYCwgYGRvdWJsZXRhcGBcbiAqICAgICAtIFBpbmNoIGdlc3R1cmVzOiBgcGluY2hgLCBgcGluY2hpbmAsIGBwaW5jaG91dGBcbiAqICAgICAtIE90aGVyIGdlc3R1cmVzOiBgdG91Y2hgLCBgdHJhbnNmb3JtYCwgYHJvdGF0ZWBcbiAqICAgWy9lbl1cbiAqICAgW2phXeimgee0oOWGheOBruOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOCkuaknOefpeOBl+OBvuOBmeOAguips+OBl+OBj+OBr+OCrOOCpOODieOCkuWPgueFp+OBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gKiBAZ3VpZGUgZmVhdHVyZXMuaHRtbCNnZXN0dXJlLWRldGVjdGlvblxuICogICBbZW5dRGV0ZWN0aW5nIGZpbmdlciBnZXN0dXJlc1svZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6Pjg7zmk43kvZzjga7mpJznn6VbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtZ2VzdHVyZS1kZXRlY3Rvcj5cbiAqICAgPGRpdiBpZD1cImRldGVjdC1hcmVhXCIgc3R5bGU9XCJ3aWR0aDogMTAwcHg7IGhlaWdodDogMTAwcHg7XCI+XG4gKiAgICAgU3dpcGUgSGVyZVxuICogICA8L2Rpdj5cbiAqIDwvb25zLWdlc3R1cmUtZGV0ZWN0b3I+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3dpcGVsZWZ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICBpZiAoZXZlbnQudGFyZ2V0Lm1hdGNoZXMoJyNkZXRlY3QtYXJlYScpKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygnU3dpcGUgbGVmdCBpcyBkZXRlY3RlZC4nKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMpO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5HZXN0dXJlRGV0ZWN0b3IgPSBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZ2VzdHVyZS1kZXRlY3RvcicsIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxubGV0IGF1dG9QcmVmaXggPSAnZmEnOyAvLyBGSVhNRTogVG8gYmUgcmVtb3ZlZCBpbiB2M1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pY29uXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXlzIGFuIGljb24uIFRoZSBmb2xsb3dpbmcgaWNvbiBzdWl0ZXMgYXJlIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBbRm9udCBBd2Vzb21lXShodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvKVxuICogICAgICogW0lvbmljb25zXShodHRwOi8vaW9uaWNvbnMuY29tLylcbiAqICAgICAqIFtNYXRlcmlhbCBEZXNpZ24gSWNvbmljIEZvbnRdKGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKVxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhBaHZnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWNvblxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdWy9qYV1cbiAqIEBndWlkZSBhcHBzaXplLmh0bWwjcmVtb3ZpbmctaWNvbi1wYWNrcyBbZW5dUmVtb3ZpbmcgaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQGd1aWRlIGZhcS5odG1sI2hvdy1jYW4taS11c2UtY3VzdG9tLWljb24tcGFja3MgW2VuXUFkZGluZyBjdXN0b20gaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtaWNvblxuICogICBpY29uPVwibWQtY2FyXCJcbiAqICAgc2l6ZT1cIjIwcHhcIlxuICogICBzdHlsZT1cImNvbG9yOiByZWRcIj5cbiAqIDwvb25zLWljb24+XG4gKlxuICogPG9ucy1idXR0b24+XG4gKiAgIDxvbnMtaWNvbiBpY29uPVwibWQtY2FyXCI+PC9vbnMtaWNvbj5cbiAqICAgQ2FyXG4gKiA8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZS4gYFwibWQtXCJgIHByZWZpeCBmb3IgTWF0ZXJpYWwgSWNvbnMsIGBcImZhLVwiYCBmb3IgRm9udCBBd2Vzb21lIGFuZCBgXCJpb24tXCJgIHByZWZpeCBmb3IgSW9uaWNvbnMuXG4gICAqXG4gICAqICAgICBTZWUgYWxsIGF2YWlsYWJsZSBpY29ucyBvbiB0aGUgZWxlbWVudCBkZXNjcmlwdGlvbiAoYXQgdGhlIHRvcCkuXG4gICAqXG4gICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cbiAgICpcbiAgICogICAgIFRoZSBjb2RlIGA8b25zLWljb24gaWNvbj1cImlvbi1lZGl0LCBtYXRlcmlhbDptZC1lZGl0XCI+PC9vbnMtaWNvbj5gIHdpbGwgZGlzcGxheSBgXCJtZC1lZGl0XCJgIGZvciBNYXRlcmlhbCBEZXNpZ24gYW5kIGBcImlvbi1lZGl0XCJgIGFzIHRoZSBkZWZhdWx0IGljb24uXG4gICAqXG4gICAqICAgICBgZmEtYCBwcmVmaXggaXMgYWRkZWQgYXV0b21hdGljYWxseSBpZiBub25lIGlzIHByb3ZpZGVkLiBDaGVjayBbU2VlIGFsc29dKCNzZWVhbHNvKSBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpemVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHNpemVzIG9mIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIGxnLCAyeCwgM3gsIDR4LCA1eCwgb3IgaW4gdGhlIHNpemUgaW4gcGl4ZWxzLlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZTpcbiAgICpcbiAgICogICAgIGBgYFxuICAgKiAgICAgPG9ucy1pY29uXG4gICAqICAgICAgIGljb249XCJpb24tZWRpdFwiXG4gICAqICAgICAgIHNpemU9XCIzMnB4LCBtYXRlcmlhbDoyNHB4XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIHJlbmRlciBhcyBhIGAyNHB4YCBpY29uIGlmIHRoZSBgXCJtYXRlcmlhbFwiYCBtb2RpZmllciBpcyBwcmVzZW50IGFuZCBgMzJweGAgb3RoZXJ3aXNlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJvdGF0ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIDkwLCAxODAgYW5kIDI3MC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZfjgabooajnpLrjgZfjgb7jgZnjgII5MCwgMTgwLCAyNzDjgYvjgonmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC13aWR0aFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dV2hlbiB1c2VkIGluIGEgbGlzdCwgeW91IHdhbnQgdGhlIGljb25zIHRvIGhhdmUgdGhlIHNhbWUgd2lkdGggc28gdGhhdCB0aGV5IGFsaWduIHZlcnRpY2FsbHkgYnkgZGVmaW5pbmcgdGhpcyBhdHRyaWJ1dGUuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzcGluXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoZXRoZXIgdGhlIGljb24gc2hvdWxkIGJlIHNwaW5uaW5nLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydpY29uJywgJ3NpemUnLCAnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgdGhpcy5fY2xlYW5DbGFzc0F0dHJpYnV0ZShuYW1lID09PSAnaWNvbicgPyBsYXN0IDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSwgbmFtZSA9PT0gJ21vZGlmaWVyJyA/IGxhc3QgOiB1bmRlZmluZWQpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIGNvbnN0IHtjbGFzc0xpc3QsIHN0eWxlfSA9IHRoaXMuX2J1aWxkQ2xhc3NBbmRTdHlsZSh0aGlzLl9wYXJzZUF0dHIoJ2ljb24nKSwgdGhpcy5fcGFyc2VBdHRyKCdzaXplJykpO1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMuc3R5bGUsIHN0eWxlKTtcblxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSk7XG4gIH1cblxuICBfcGFyc2VBdHRyKGF0dHJOYW1lLCBtb2RpZmllciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSB8fCBhdHRyTmFtZSB8fCAnJ1xuICAgIGNvbnN0IHBhcnRzID0gYXR0ci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgY29uc3QgZGVmID0gcGFydHNbMF07XG4gICAgbGV0IG1kID0gcGFydHNbMV07XG4gICAgbWQgPSAobWQgfHwgJycpLnNwbGl0KC9cXHMqOlxccyovKTtcblxuICAgIHJldHVybiAobW9kaWZpZXIgJiYgKFJlZ0V4cChgKF58XFxcXHMrKSR7bWRbMF19KCR8XFxcXHMrKWAsICdpJykudGVzdChtb2RpZmllcikpID8gbWRbMV0gOiBkZWYpIHx8ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1bm5lZWRlZCBjbGFzcyB2YWx1ZS5cbiAgICovXG4gIF9jbGVhbkNsYXNzQXR0cmlidXRlKGxhc3RJY29uLCBsYXN0TW9kaWZpZXIpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgcHJlZml4IH0gPSB0aGlzLl9wcmVmaXhJY29uKHRoaXMuX3BhcnNlQXR0cihsYXN0SWNvbiwgbGFzdE1vZGlmaWVyKSk7XG4gICAgY29uc3QgY3VzdG9tUHJlZml4UkUgPSBjbGFzc05hbWUgIT09IHByZWZpeCA/IGB8JHtwcmVmaXh9JHwke3ByZWZpeH0tYCA6IGB8JHtjbGFzc05hbWV9JGAgfHwgJyc7XG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKGBeKGZhJHxmYS18aW9uLXx6bWRpJHx6bWRpLXxvbnMtaWNvbi0tJHtjdXN0b21QcmVmaXhSRX0pYCk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNsYXNzTGlzdClcbiAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IHJlLnRlc3QoY2xhc3NOYW1lKSlcbiAgICAgIC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7XG4gIH1cblxuICBfcHJlZml4SWNvbihpY29uTmFtZSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGF1dG9QcmVmaXggKyAoYXV0b1ByZWZpeCA/ICctJyA6ICcnKSArIGljb25OYW1lO1xuICAgIHJldHVybiB7IGNsYXNzTmFtZSwgcHJlZml4OiBjbGFzc05hbWUuc3BsaXQoJy0nKVswXSB9O1xuICB9XG5cbiAgX2J1aWxkQ2xhc3NBbmRTdHlsZShpY29uTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGNsYXNzTGlzdCA9IFsnb25zLWljb24nXTtcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuXG4gICAgLy8gSWNvblxuICAgIGlmIChpY29uTmFtZS5pbmRleE9mKCdpb24tJykgPT09IDApIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKGljb25OYW1lKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdvbnMtaWNvbi0taW9uJyk7XG4gICAgfSBlbHNlIGlmIChpY29uTmFtZS5pbmRleE9mKCdmYS0nKSA9PT0gMCkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgfSBlbHNlIGlmKGljb25OYW1lLmluZGV4T2YoJ21kLScpID09PSAwKSAge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGknKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCd6bWRpLScgKyBpY29uTmFtZS5zcGxpdCgvLSguKyk/LylbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGNsYXNzTmFtZSwgcHJlZml4IH0gPSB0aGlzLl9wcmVmaXhJY29uKGljb25OYW1lKTtcbiAgICAgIHByZWZpeCAmJiBjbGFzc0xpc3QucHVzaChwcmVmaXgpO1xuICAgICAgY2xhc3NOYW1lICYmIGNsYXNzTGlzdC5wdXNoKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gU2l6ZVxuICAgIGlmIChzaXplLm1hdGNoKC9eWzEtNV14fGxnJC8pKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnb25zLWljb24tLScgKyBzaXplKTtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtc2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5mb250U2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzTGlzdDogY2xhc3NMaXN0LFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBzZXRBdXRvUHJlZml4KHByZWZpeCkge1xuICAgIGF1dG9QcmVmaXggPSBwcmVmaXggPyAodHlwZW9mIHByZWZpeCA9PT0gJ3N0cmluZycgJiYgcHJlZml4IHx8ICdmYScpIDogJyc7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkljb24gPSBJY29uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWljb24nLCBJY29uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5cbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0RGVsZWdhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHVzZXJEZWxlZ2F0ZSwgdGVtcGxhdGVFbGVtZW50ID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdXNlckRlbGVnYXRlICE9PSAnb2JqZWN0JyB8fCB1c2VyRGVsZWdhdGUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB1c2VyRGVsZWdhdGU7XG5cbiAgICBpZiAoISh0ZW1wbGF0ZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSAmJiB0ZW1wbGF0ZUVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcInRlbXBsYXRlRWxlbWVudFwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQgb3IgbnVsbC4nKTtcbiAgICB9XG4gICAgdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gdGVtcGxhdGVFbGVtZW50O1xuICB9XG5cbiAgZ2V0IGl0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5pdGVtSGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNSZW5kZXJGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX3JlbmRlcigpIHtcbiAgICB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlci5hcHBseSh0aGlzLl91c2VyRGVsZWdhdGUsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQSBmdW5jdGlvbiB0aGF0IHRha2UgaXRlbSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgKi9cbiAgbG9hZEl0ZW1FbGVtZW50KGluZGV4LCBkb25lKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnQoaW5kZXgsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCk7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZUl0ZW1Db250ZW50KCkgbXVzdCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgZG9uZSh7ZWxlbWVudH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb3VudEl0ZW1zKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgICBpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdW50SXRlbXMoKSBtdXN0IHJldHVybiBhIG51bWJlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW0uZWxlbWVudFxuICAgKi9cbiAgdXBkYXRlSXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignY2FsY3VsYXRlSXRlbUhlaWdodCgpIG11c3QgcmV0dXJuIGEgbnVtYmVyLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKi9cbiAgZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGUgY29yZSBmdW5jdGlvbnMgZm9yIG9ucy1sYXp5LXJlcGVhdC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhenlSZXBlYXRQcm92aWRlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gd3JhcHBlckVsZW1lbnRcbiAgICogQHBhcmFtIHtMYXp5UmVwZWF0RGVsZWdhdGV9IGRlbGVnYXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3cmFwcGVyRWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICBpZiAoIShkZWxlZ2F0ZSBpbnN0YW5jZW9mIExhenlSZXBlYXREZWxlZ2F0ZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgTGF6eVJlcGVhdERlbGVnYXRlLicpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnQ7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB0aGlzLl9pbnNlcnRJbmRleCA9ICh0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXSAmJiB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXS50YWdOYW1lID09PSAnT05TLUxBWlktUkVQRUFUJykgPyAxIDogMDtcblxuICAgIGlmICh3cmFwcGVyRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdCcpIHtcbiAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhenktbGlzdCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50ID0gdGhpcy5fZmluZFBhZ2VDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudCk7XG5cbiAgICBpZiAoIXRoaXMuX3BhZ2VDb250ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ucy1sYXp5LXJlcGVhdCBtdXN0IGJlIGEgZGVzY2VuZGFudCBvZiBhbiA8b25zLXBhZ2U+IG9yIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gdGhpcy5fcGFnZUNvbnRlbnQuc2Nyb2xsVG9wO1xuICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgdGhpcy5fdG9wUG9zaXRpb25zID0gWzBdO1xuICAgIHRoaXMuX3JlbmRlcmVkSXRlbXMgPSB7fTtcblxuICAgIGlmICghdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCAmJiAhdGhpcy5fZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCgwKSkge1xuICAgICAgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgfVxuXG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wLCAxMCk7XG4gIH1cblxuICBzZXQgcGFkZGluZyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnBhZGRpbmdUb3AgPSBuZXdWYWx1ZSArICdweCc7XG4gIH1cblxuICBfZmluZFBhZ2VDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudCkge1xuICAgIGNvbnN0IHBhZ2VDb250ZW50ID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnLnBhZ2VfX2NvbnRlbnQnKTtcblxuICAgIGlmIChwYWdlQ29udGVudCkge1xuICAgICAgcmV0dXJuIHBhZ2VDb250ZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICdvbnMtcGFnZScpO1xuICAgIGlmIChwYWdlKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5maW5kQ2hpbGQocGFnZSwgJy5jb250ZW50Jyk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9jaGVja0l0ZW1IZWlnaHQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoMCwgaXRlbSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0uZWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKDAsIGl0ZW0pO1xuICAgICAgICBpdGVtLmVsZW1lbnQgJiYgaXRlbS5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQ7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPiAwKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZXRyeSB0byBtZWFzdXJlIG9mZnNldCBoZWlnaHRcbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgYW5ndWxhcjIgZGlyZWN0aXZlXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPT0gMCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlOiB0aGlzLl9pdGVtSGVpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBzdGF0aWNJdGVtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0IHx8IHRoaXMuX2l0ZW1IZWlnaHQ7XG4gIH1cbiAgX2NvdW50SXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgfVxuXG4gIF9nZXRJdGVtSGVpZ2h0KGkpIHtcbiAgICAvLyBJdGVtIGlzIHJlbmRlcmVkXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkSXRlbXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmICghdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oZWlnaHQgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2ldLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkSXRlbXNbaV0uaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIEl0ZW0gaXMgbm90IHJlbmRlcmVkLCBzY3JvbGwgdXBcbiAgICBpZiAodGhpcy5fdG9wUG9zaXRpb25zW2kgKyAxXSAmJiB0aGlzLl90b3BQb3NpdGlvbnNbaV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3BQb3NpdGlvbnNbaSArIDFdIC0gdGhpcy5fdG9wUG9zaXRpb25zW2ldO1xuICAgIH1cbiAgICAvLyBJdGVtIGlzIG5vdCByZW5kZXJlZCwgc2Nyb2xsIGRvd25cbiAgICByZXR1cm4gdGhpcy5zdGF0aWNJdGVtSGVpZ2h0IHx8IHRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoaSk7XG4gIH1cblxuICBfY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLnJlZHVjZSgoYSwgYikgPT4gYSArIHRoaXMuX2dldEl0ZW1IZWlnaHQoKyhiKSksIDApXG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cblxuICBfbGFzdEl0ZW1SZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykpO1xuICB9XG5cbiAgX2ZpcnN0SXRlbVJlbmRlcmVkKCkge1xuICAgIHJldHVybiBNYXRoLm1pbiguLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0geyBmb3JjZVNjcm9sbERvd246IHRydWUgfTtcbiAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gTWF0aC5taW4odGhpcy5fbGFzdEl0ZW1SZW5kZXJlZCgpLCB0aGlzLl9jb3VudEl0ZW1zKCkgLSAxKTtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMuX2ZpcnN0SXRlbVJlbmRlcmVkKCk7XG5cbiAgICBpZiAodXRpbC5pc0ludGVnZXIobGFzdEl0ZW1JbmRleCkpIHtcbiAgICAgIGZvcmNlUmVuZGVyLmZvcmNlTGFzdEluZGV4ID0gbGFzdEl0ZW1JbmRleFxuICAgIH1cblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcihmaXJzdEl0ZW1JbmRleCkpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tmaXJzdEl0ZW1JbmRleF0gKyB0aGlzLl9jYWxjdWxhdGVSZW5kZXJlZEhlaWdodCgpICsgJ3B4JztcbiAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tmaXJzdEl0ZW1JbmRleF07XG4gICAgICBmb3JjZVJlbmRlci5mb3JjZUZpcnN0SW5kZXggPSBmaXJzdEl0ZW1JbmRleDtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX3JlbmRlcihmb3JjZVJlbmRlcik7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2luaGVyaXQnO1xuICB9XG5cbiAgX3JlbmRlcih7Zm9yY2VTY3JvbGxEb3duID0gZmFsc2UsIGZvcmNlRmlyc3RJbmRleCwgZm9yY2VMYXN0SW5kZXh9ID0ge30pIHtcbiAgICBpZiAodGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGVja0l0ZW1IZWlnaHQodGhpcy5fcmVuZGVyLmJpbmQodGhpcywgYXJndW1lbnRzWzBdKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNTY3JvbGxVcCA9ICFmb3JjZVNjcm9sbERvd24gJiYgdGhpcy5sYXN0U2Nyb2xsVG9wID4gdGhpcy5fcGFnZUNvbnRlbnQuc2Nyb2xsVG9wO1xuICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHRoaXMuX3BhZ2VDb250ZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCBrZWVwID0ge307XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgY29uc3QgbGltaXQgPSA0ICogd2luZG93LmlubmVySGVpZ2h0IC0gb2Zmc2V0O1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fY291bnRJdGVtcygpO1xuXG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IGZvcmNlRmlyc3RJbmRleCB8fCBNYXRoLm1heCgwLCB0aGlzLl9jYWxjdWxhdGVTdGFydEluZGV4KG9mZnNldCkgLSAzMCk7IC8vIFJlY2FsY3VsYXRlIGZvciAwIG9yIHVuZGVmaW5lZFxuICAgIGxldCBpID0gc3RhcnQ7XG5cbiAgICBmb3IobGV0IHRvcCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpXTsgaSA8IGNvdW50ICYmIHRvcCA8IGxpbWl0OyBpKyspIHtcbiAgICAgIGlmIChpID49IHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGgpIHsgLy8gcGVyZiBvcHRpbWl6YXRpb25cbiAgICAgICAgdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCArPSAxMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpXSA9IHRvcDtcbiAgICAgIHRvcCArPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWxlZ2F0ZS5oYXNSZW5kZXJGdW5jdGlvbiAmJiB0aGlzLl9kZWxlZ2F0ZS5oYXNSZW5kZXJGdW5jdGlvbigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuX3JlbmRlcihzdGFydCwgaSwgKCkgPT4ge1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLl90b3BQb3NpdGlvbnNbc3RhcnRdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2Nyb2xsVXApIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gMTsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICAgIGtlZXBbal0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJFbGVtZW50KGosIGlzU2Nyb2xsVXApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBmb3JjZUxhc3RJbmRleCB8fCBNYXRoLm1heChpIC0gMSwgLi4uT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykpOyAvLyBSZWNhbGN1bGF0ZSBmb3IgMCBvciB1bmRlZmluZWRcbiAgICAgIGZvciAobGV0IGogPSBzdGFydDsgaiA8PSBsYXN0SW5kZXg7IGorKykge1xuICAgICAgICBrZWVwW2pdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRWxlbWVudChqLCBpc1Njcm9sbFVwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiBrZWVwW2tleV0gfHwgdGhpcy5fcmVtb3ZlRWxlbWVudChrZXksIGlzU2Nyb2xsVXApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1Njcm9sbFVwXG4gICAqL1xuICBfcmVuZGVyRWxlbWVudChpbmRleCwgaXNTY3JvbGxVcCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUudXBkYXRlSXRlbShpbmRleCwgaXRlbSk7IC8vIHVwZGF0ZSBpZiBpdCBleGlzdHNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoaW5kZXgsIGl0ZW0gPT4ge1xuICAgICAgaWYgKGlzU2Nyb2xsVXApIHtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuaW5zZXJ0QmVmb3JlKGl0ZW0uZWxlbWVudCwgdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bdGhpcy5faW5zZXJ0SW5kZXhdKVxuICAgICAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICBpdGVtLmhlaWdodCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpbmRleCArIDFdIC0gdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdID0gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1Njcm9sbFVwXG4gICAqL1xuICBfcmVtb3ZlRWxlbWVudChpbmRleCwgaXNTY3JvbGxVcCA9IHRydWUpIHtcbiAgICBpbmRleCA9ICsoaW5kZXgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG5cbiAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4ICsgMV0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMucGFkZGluZyArIHRoaXMuX2dldEl0ZW1IZWlnaHQoaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgaXRlbS5lbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gIH1cblxuICBfcmVtb3ZlQWxsRWxlbWVudHMoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4gdGhpcy5fcmVtb3ZlRWxlbWVudChrZXkpKTtcbiAgfVxuXG4gIF9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucyhzdGFydCwgZW5kKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaSArIDFdID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpKTtcbiAgICB9XG4gIH1cblxuICBfY2FsY3VsYXRlU3RhcnRJbmRleChjdXJyZW50KSB7XG4gICAgY29uc3QgZmlyc3RJdGVtSW5kZXggPSB0aGlzLl9maXJzdEl0ZW1SZW5kZXJlZCgpO1xuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSB0aGlzLl9sYXN0SXRlbVJlbmRlcmVkKCk7XG5cbiAgICAvLyBGaXggZm9yIFNhZmFyaSBzY3JvbGwgYW5kIEFuZ3VsYXIgMlxuICAgIHRoaXMuX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKGZpcnN0SXRlbUluZGV4LCBsYXN0SXRlbUluZGV4KTtcblxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IHRoaXMuX2NvdW50SXRlbXMoKSAtIDE7XG5cbiAgICAvLyBCaW5hcnkgc2VhcmNoIGZvciBpbmRleCBhdCB0b3Agb2Ygc2NyZWVuIHNvIHdlIGNhbiBzcGVlZCB1cCByZW5kZXJpbmcuXG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnQgKyB0aGlzLl90b3BQb3NpdGlvbnNbbWlkZGxlXTtcblxuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSAwICYmIHZhbHVlICsgdGhpcy5fZ2V0SXRlbUhlaWdodChtaWRkbGUpID4gMCkge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPj0gMCkge1xuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9kZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9kb3VibGVGaXJlT25Ub3VjaGVuZCgpIHtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB0aGlzLl9kZWJvdW5jZSh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSwgMTAwKTtcbiAgfVxuXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB1dGlsLmJpbmRMaXN0ZW5lcnModGhpcywgWydfb25DaGFuZ2UnLCAnX2RvdWJsZUZpcmVPblRvdWNoZW5kJ10pO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9kZWJvdW5jZSh0aGlzLl9ib3VuZE9uQ2hhbmdlLCAzMCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9wYXJlbnRFbGVtZW50ID0gdGhpcy5fZGVsZWdhdGUgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICB9XG59XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7IExhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyIH0gZnJvbSAnLi4vb25zL2ludGVybmFsL2xhenktcmVwZWF0JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGF6eS1yZXBlYXRcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFVzaW5nIHRoaXMgY29tcG9uZW50IGEgbGlzdCB3aXRoIG1pbGxpb25zIG9mIGl0ZW1zIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IGEgZHJvcCBpbiBwZXJmb3JtYW5jZS5cbiAqICAgICBJdCBkb2VzIHRoYXQgYnkgXCJsYXppbHlcIiBsb2FkaW5nIGVsZW1lbnRzIGludG8gdGhlIERPTSB3aGVuIHRoZXkgY29tZSBpbnRvIHZpZXcgYW5kXG4gKiAgICAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgRE9NIHdoZW4gdGhleSBhcmUgbm90IHZpc2libGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXjgafmj4/nlLvjgZXjgozjgovjgqLjgqTjg4bjg6Djga5ET03opoHntKDjga7oqq3jgb/ovrzjgb/jga/jgIHnlLvpnaLjgavopovjgYjjgZ3jgYbjgavjgarjgaPjgZ/mmYLjgb7jgafoh6rli5XnmoTjgavpgYXlu7bjgZXjgozjgIFcbiAqICAgICDnlLvpnaLjgYvjgonopovjgYjjgarjgY/jgarjgaPjgZ/loLTlkIjjgavjga/jgZ3jga7opoHntKDjga/li5XnmoTjgavjgqLjg7Pjg63jg7zjg4njgZXjgozjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/jgYbjgZPjgajjgafjgIHjg5Hjg5Xjgqnjg7zjg57jg7PjgrnjgpLliqPljJbjgZXjgZvjgovjgZPjgajnhKHjgZfjgavlt6jlpKfjgarmlbDjga7opoHntKDjgpLmj4/nlLvjgafjgY3jgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIFF3ckdCbVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xhenktcmVwZWF0XG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgbGlzdC5bL2VuXVxuICogICBbamFdYDxvbnMtbGlzdD5g6KaB57Sg44Gv44Oq44K544OI44KS5o+P55S744GZ44KL44Gu44Gr5L2/44KP44KM44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYSBhbmQgYWxzbyBub3QgZG9jdW1lbnRlZFxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGVsZWdhdGUnKSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGEgZGVsZWdhdGUgb2JqZWN0IHRvIGxvYWQgYW5kIHVubG9hZCBpdGVtIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqICAgICBUbyBoZWxwIHJlbmRlcmluZyB0aGUgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXggYW5kIGEgdGVtcGxhdGUgaXMgc3VwcGxpZWQgYXMgYXJndW1lbnRzLiBUaGUgdGVtcGxhdGUgaXMgdGhlIGluaXRpYWwgY29udGVudCBvZiB0aGUgYDxvbnMtbGF6eS1yZXBlYXQ+YCBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44GvYEhUTUxFbGVtZW50YOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglxuICAgKiAgICAg6KaB57Sg44KS55Sf5oiQ44GX44KE44GZ44GP44GZ44KL44Gf44KB44Gr44CB54++5Zyo44Gu44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K544Go44OG44Oz44OX44Os44O844OI44GM5byV5pWw44Gr5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jb3VudEl0ZW1zXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTaG91bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgYW4gaXRlbS4gVGhlIGluZGV4IGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiByZW5kZXJpbmcgbGlzdHMgd2hlcmUgdGhlIGl0ZW1zIGhhdmUgZGlmZmVyZW50IGhlaWdodC5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44Gd44KM44Ge44KM44Gu44Ki44Kk44Og44GM6YGV44Gj44Gf6auY44GV44KS5oyB44Gk44Oq44K544OI44KS44Os44Oz44OA44Oq44Oz44Kw44GZ44KL6Zqb44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgILjgoLjgZfjgZPjga7plqLmlbDjgYznhKHjgYTloLTlkIjjgavjga/jgIFcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuZGVzdHJveUl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYnV0IG1heSBiZSBpbXBvcnRhbnQgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44GC44KL44Ki44Kk44OG44Og44GMRE9N44OE44Oq44O844GL44KJ6Zmk44GL44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44G+44GZ44CCXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOBjOOAgeWQhOOCouOCpOODhuODoOOBruW+jOWHpueQhuOBjOW/heimgeOBquWgtOWQiOOBq+OBr+ODoeODouODquODvOODquODvOOCr+OCkumBv+OBkeOCi+OBn+OCgeOBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIHNldCBkZWxlZ2F0ZSh1c2VyRGVsZWdhdGUpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVFbGVtZW50ICYmIHRoaXMuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG5ldyBMYXp5UmVwZWF0UHJvdmlkZXIodGhpcy5wYXJlbnRFbGVtZW50LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHByb3BlcnR5IGNhbiBvbmx5IGJlIHVzZWQgdG8gc2V0IHRoZSBkZWxlZ2F0ZSBvYmplY3QuJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjgpLmm7TmlrDjgZfjgb7jgZnjgILjgoLjgZfjg4fjg7zjgr/jgYzlpInjgo/jgaPjgZ/loLTlkIjjgavjga/jgZPjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgaPjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcblxub25zLmVsZW1lbnRzLkxhenlSZXBlYXQgPSBMYXp5UmVwZWF0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxhenktcmVwZWF0JywgTGF6eVJlcGVhdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QtaGVhZGVyJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtaGVhZGVyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaGVhZGVyXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1IZWFkZXIgZWxlbWVudCBmb3IgbGlzdCBpdGVtcy4gTXVzdCBiZSBwdXQgaW5zaWRlIHRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jopoHntKDjgavkvb/nlKjjgZnjgovjg5jjg4Pjg4Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5dVGhlIGA8b25zLWxpc3QtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGxpc3QgaGVhZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0IGhlYWRlci5bL2VuXVxuICAgKiAgIFtqYV3jg5jjg4Pjg4Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuTGlzdEhlYWRlciA9IExpc3RIZWFkZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC1oZWFkZXInLCBMaXN0SGVhZGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbGlzdC10aXRsZSc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LXRpdGxlLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtdGl0bGVcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBsaXN0IHRpdGxlLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7jgr/jgqTjg4jjg6vjgpLooajnj77jgZfjgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdC10aXRsZT5MaXN0IFRpdGxlPC9vbnMtbGlzdC10aXRsZT5cbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCB0aXRsZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0VGl0bGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5MaXN0VGl0bGUgPSBMaXN0VGl0bGVFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC10aXRsZScsIExpc3RUaXRsZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QtaXRlbSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcubGlzdC1pdGVtJzogJ2xpc3QtaXRlbS0tKicsXG4gICcubGlzdC1pdGVtX19sZWZ0JzogJ2xpc3QtaXRlbS0tKl9fbGVmdCcsXG4gICcubGlzdC1pdGVtX19jZW50ZXInOiAnbGlzdC1pdGVtLS0qX19jZW50ZXInLFxuICAnLmxpc3QtaXRlbV9fcmlnaHQnOiAnbGlzdC1pdGVtLS0qX19yaWdodCcsXG4gICcubGlzdC1pdGVtX19sYWJlbCc6ICdsaXN0LWl0ZW0tLSpfX2xhYmVsJyxcbiAgJy5saXN0LWl0ZW1fX3RpdGxlJzogJ2xpc3QtaXRlbS0tKl9fdGl0bGUnLFxuICAnLmxpc3QtaXRlbV9fc3VidGl0bGUnOiAnbGlzdC1pdGVtLS0qX19zdWJ0aXRsZScsXG4gICcubGlzdC1pdGVtX190aHVtYm5haWwnOiAnbGlzdC1pdGVtLS0qX190aHVtYm5haWwnLFxuICAnLmxpc3QtaXRlbV9faWNvbic6ICdsaXN0LWl0ZW0tLSpfX2ljb24nXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWl0ZW1cbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgdGFwcGFibGVcbiAqICAgW2VuXU1ha2UgdGhlIGxpc3QgaXRlbSBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIGl0J3MgdGFwcGVkLiBPbiBpT1MgaXQgaXMgYmV0dGVyIHRvIHVzZSB0aGUgXCJ0YXBwYWJsZVwiIGFuZCBcInRhcC1iYWNrZ3JvdW5kLWNvbG9yXCIgYXR0cmlidXRlIGZvciBiZXR0ZXIgYmVoYXZpb3Igd2hlbiBzY3JvbGxpbmcuWy9lbl1cbiAqICAgW2phXeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBl+OBn+aZguOBq+WKueaenOOBjOihqOekuuOBleOCjOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgY2hldnJvblxuICogICBbZW5dRGlzcGxheSBhIGNoZXZyb24gYXQgdGhlIHJpZ2h0IGVuZCBvZiB0aGUgbGlzdCBpdGVtIGFuZCBtYWtlIGl0IGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gdGFwcGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIGxvbmdkaXZpZGVyXG4gKiAgIFtlbl1EaXNwbGF5cyBhIGxvbmcgaG9yaXpvbnRhbCBkaXZpZGVyIGJldHdlZW4gaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9kaXZpZGVyXG4gKiAgIFtlbl1SZW1vdmVzIHRoZSBkaXZpZGVyIGJldHdlZW4gbGlzdCBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGl0ZW0uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgZWFjaCBpdGVtIGluIGEgbGlzdC4gVGhlIGxpc3QgaXRlbSBpcyBjb21wb3NlZCBvZiB0aHJlZSBwYXJ0cyB0aGF0IGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBgbGVmdGAsIGBjZW50ZXJgIGFuZCBgcmlnaHRgIGNsYXNzZXMuIFRoZXNlIGNsYXNzZXMgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbnRlbnQgb2YgdGhlIGxpc3QgaXRlbXMgaXMgcHJvcGVybHkgYWxpZ25lZC5cbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPkxlZnQ8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5DZW50ZXI8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlJpZ2h0PC9kaXY+XG4gKiAgICAgPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIGBgYFxuICpcbiAqICAgICBUaGVyZSBpcyBhbHNvIGEgbnVtYmVyIG9mIGNsYXNzZXMgKHByZWZpeGVkIHdpdGggYGxpc3QtaXRlbV9fKmApIHRoYXQgaGVscCB3aGVuIHB1dHRpbmcgdGhpbmdzIGxpa2UgaWNvbnMgYW5kIHRodW1ibmFpbHMgaW50byB0aGUgbGlzdCBpdGVtcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5db25zLWxpc3QgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWhlYWRlclxuICogICBbZW5db25zLWxpc3QtaGVhZGVyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1oZWFkZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0LWl0ZW0+XG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJtZC1mYWNlXCIgY2xhc3M9XCJsaXN0LWl0ZW1fX2ljb25cIj48L29ucy1pY29uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0LWl0ZW1fX3RpdGxlXCI+VGl0bGU8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGlzdC1pdGVtX19zdWJ0aXRsZVwiPlN1YnRpdGxlPC9kaXY+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICA8b25zLXN3aXRjaD48L29ucy1zd2l0Y2g+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtbGlzdC1pdGVtPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0IGl0ZW0uWy9lbl1cbiAgICogICBbamFd5ZCE6KaB57Sg44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbG9jay1vbi1kcmFnXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyB3aGVuIHRoZSB1c2VyIGRyYWdzIGhvcml6b250YWxseS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg6bjg7zjgrbjg7zjgYzjgZPjga7opoHntKDjgpLmqKrmlrnlkJHjgavjg4njg6njg4PjgrDjgZfjgabjgYTjgovmmYLjgavjgIHnuKbmlrnlkJHjga7jgrnjgq/jg63jg7zjg6vjgYzotbfjgY3jgarjgYTjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0YXBwYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU1ha2VzIHRoZSBlbGVtZW50IHJlYWN0IHRvIHRhcHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGFwLWJhY2tncm91bmQtY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dIENoYW5nZXMgdGhlIGJhY2tncm91bmQgY29sb3Igd2hlbiB0YXBwZWQuIEZvciB0aGlzIHRvIHdvcmssIHRoZSBhdHRyaWJ1dGUgXCJ0YXBwYWJsZVwiIG5lZWRzIHRvIGJlIHNldC4gVGhlIGRlZmF1bHQgY29sb3IgaXMgXCIjZDlkOWQ5XCIuIEl0IHdpbGwgZGlzcGxheSBhcyBhIHJpcHBsZSBlZmZlY3Qgb24gQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgbGV0IGxlZnQsIGNlbnRlciwgcmlnaHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnbGVmdCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fbGVmdCcpO1xuICAgICAgICBsZWZ0ID0gZWw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NlbnRlcicpKSB7XG4gICAgICAgIGNlbnRlciA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdyaWdodCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fcmlnaHQnKTtcbiAgICAgICAgcmlnaHQgPSBlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNlbnRlcikge1xuICAgICAgY2VudGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgIGNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgaWYgKGVsICE9PSBsZWZ0ICYmIGVsICE9PSByaWdodCkge1xuICAgICAgICAgICAgY2VudGVyLmluc2VydEJlZm9yZShlbCwgY2VudGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydEJlZm9yZShjZW50ZXIsIHJpZ2h0IHx8IG51bGwpO1xuICAgIH1cblxuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdjZW50ZXInKTtcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19jZW50ZXInKTtcblxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnLCAncmlwcGxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHRydWUpO1xuICAgIHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKGZhbHNlKTtcbiAgfVxuXG4gIF9zZXR1cExpc3RlbmVycyhhZGQpIHtcbiAgICBjb25zdCBhY3Rpb24gPSAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgdGhpc1thY3Rpb25dKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICB0aGlzW2FjdGlvbl0oJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNlZG93bicsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXNbYWN0aW9uXSgndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXNbYWN0aW9uXSgndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2VvdXQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXNbYWN0aW9uXSgndG91Y2hsZWF2ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgY29uc3QgZ2VzdHVyZSA9IGV2ZW50Lmdlc3R1cmU7XG4gICAgLy8gUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgaWYgdGhlIHVzZXJzIHBhbnMgbGVmdCBvciByaWdodC5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZ2VzdHVyZS5kaXJlY3Rpb24pID4gLTEpIHtcbiAgICAgIGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBfb25Ub3VjaCgpIHtcbiAgICBpZiAodGhpcy50YXBwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRhcHBlZCA9IHRydWU7XG4gICAgY29uc3QgdG91Y2hTdHlsZSA9IHsgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgMC4wcyBsaW5lYXIgMC4wMnMsIGJveC1zaGFkb3cgMC4wcyBsaW5lYXIgMC4wMnMnIH07XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuXG4gICAgICB0b3VjaFN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YXAtYmFja2dyb3VuZC1jb2xvcicpIHx8ICcjZDlkOWQ5JztcbiAgICAgIHRvdWNoU3R5bGUuYm94U2hhZG93ID0gYDBweCAtMXB4IDBweCAwcHggJHt0b3VjaFN0eWxlLmJhY2tncm91bmRDb2xvcn1gO1xuICAgIH1cblxuICAgIHN0eWxlcih0aGlzLCB0b3VjaFN0eWxlKTtcbiAgfVxuXG4gIF9vblJlbGVhc2UoKSB7XG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgIHN0eWxlci5jbGVhcih0aGlzLCAndHJhbnNpdGlvbiBib3hTaGFkb3cnKTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuTGlzdEl0ZW0gPSBMaXN0SXRlbUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0LWl0ZW0nLCBMaXN0SXRlbUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QnO1xuY29uc3Qgc2NoZW1lID0geycnOiAnbGlzdC0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0XG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQG1vZGlmaWVyIGluc2V0XG4gKiAgIFtlbl1JbnNldCBsaXN0IHRoYXQgZG9lc24ndCBjb3ZlciB0aGUgd2hvbGUgd2lkdGggb2YgdGhlIHBhcmVudC5bL2VuXVxuICogICBbamFd6Kaq6KaB57Sg44Gu55S76Z2i44GE44Gj44Gx44GE44Gr5bqD44GM44KJ44Gq44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBub2JvcmRlclxuICogICBbZW5dQSBsaXN0IHdpdGggbm8gYm9yZGVycyBhdCB0aGUgdG9wIGFuZCBib3R0b20uWy9lbl1cbiAqICAgW2phXeODquOCueODiOOBruS4iuS4i+OBruODnOODvOODgOODvOOBjOeEoeOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNvbXBvbmVudCB0byBkZWZpbmUgYSBsaXN0LCBhbmQgdGhlIGNvbnRhaW5lciBmb3Igb25zLWxpc3QtaXRlbShzKS5bL2VuXVxuICogICBbamFd44Oq44K544OI44KS6KGo54++44GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3QtaXRlbeOBruOCs+ODs+ODhuODiuOBqOOBl+OBpuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gKiAgIFtlbl1vbnMtbGlzdC1pdGVtIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWhlYWRlclxuICogICBbZW5db25zLWxpc3QtaGVhZGVyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1oZWFkZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxhenktcmVwZWF0XG4gKiAgIFtlbl1vbnMtbGF6eS1yZXBlYXQgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1sYXp5LXJlcGVhdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuTGlzdCA9IExpc3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdCcsIExpc3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvY2FwaXRhbGl6ZScsXG4gICdhdXRvY29tcGxldGUnLFxuICAnYXV0b2NvcnJlY3QnLFxuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWF4bGVuZ3RoJyxcbiAgJ21pbicsXG4gICdtaW5sZW5ndGgnLFxuICAnbmFtZScsXG4gICdwYXR0ZXJuJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3JlYWRvbmx5JyxcbiAgJ3JlcXVpcmVkJyxcbiAgJ3NpemUnLFxuICAnc3RlcCcsXG4gICd2YWxpZGF0b3InLFxuICAndmFsdWUnXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIF91cGRhdGUoKSB7fSAvLyBPcHRpb25hbGx5IGltcGxlbWVudGVkXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfc2NoZW1lIGdldHRlciBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ190ZW1wbGF0ZSBnZXR0ZXIgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBnZXR0ZXIgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQgPSB0aGlzLl9kZWxlZ2F0ZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lICYmIHRoaXMuY2xhc3NMaXN0LmFkZCh0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodXRpbC5jcmVhdGVGcmFnbWVudCh0aGlzLl90ZW1wbGF0ZSkpO1xuXG4gICAgdGhpcy5fc2V0SW5wdXRJZCgpO1xuICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpIHtcbiAgICBJTlBVVF9BVFRSSUJVVEVTLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX2RlbGVnYXRlRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50LnR5cGUsIHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgfVxuXG4gIF9zZXRJbnB1dElkKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5wdXQtaWQnKSkge1xuICAgICAgdGhpcy5faW5wdXQuaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaW5wdXQtaWQnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dCA9PT0gbnVsbFxuICAgICAgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgICAgOiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgdmFsID0gdmFsLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2lucHV0LWlkJywgJ2NsYXNzJywgLi4uSU5QVVRfQVRUUklCVVRFU107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3NldElucHV0SWQoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lLCB0aGlzLl9zY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IEJhc2VJbnB1dEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtaW5wdXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy50ZXh0LWlucHV0JzogJ3RleHQtaW5wdXQtLSonLFxuICAnLnRleHQtaW5wdXRfX2xhYmVsJzogJ3RleHQtaW5wdXQtLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaW5wdXRcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgdGV4dCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgW2VuXURpc3BsYXlzIGEgdHJhbnNwYXJlbnQgaW5wdXQuIFdvcmtzIGZvciBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEFuIGlucHV0IGVsZW1lbnQuIFRoZSBgdHlwZWAgYXR0cmlidXRlIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgaW5wdXQgdHlwZS4gQWxsIHRleHQgaW5wdXQgdHlwZXMgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQgb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLWNoZWNrYm94XG4gKiAgIFtlbl1UaGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGNoZWNrYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWlucHV0IHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiBmbG9hdD48L29ucy1pbnB1dD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUlucHV0RWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25Gb2N1c2luID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKiBJbmhlcml0ZWQgcHJvcHMgKi9cblxuICBfdXBkYXRlKCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsKCk7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxpbnB1dCB0eXBlPVwiJHt0aGlzLnR5cGV9XCIgY2xhc3M9XCJ0ZXh0LWlucHV0XCI+XG4gICAgICA8c3BhbiBjbGFzcz1cInRleHQtaW5wdXRfX2xhYmVsXCI+PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICByZXR1cm4gKFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHR5cGUpIDwgMCkgJiYgdHlwZSB8fCAndGV4dCc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfdXBkYXRlTGFiZWwoKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCAnJztcblxuICAgIGlmICh0eXBlb2YgdGhpcy5faGVscGVyLnRleHRDb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faGVscGVyLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hlbHBlci5pbm5lclRleHQgPSBsYWJlbDtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGFiZWxDbGFzcygpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWlucHV0LS1tYXRlcmlhbF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICBpZiAoWydjaGVja2JveCcsICdyYWRpbyddLmluZGV4T2YodHlwZSkgPj0gMCkge1xuICAgICAgdXRpbC53YXJuKGBXYXJuOiA8b25zLWlucHV0IHR5cGU9XCIke3R5cGV9XCI+IGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuNC4wLiBVc2UgPG9ucy0ke3R5cGV9PiBpbnN0ZWFkLmApXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICd0eXBlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhY2Vob2xkZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBsYWNlaG9sZGVyIHRleHQuIEluIE1hdGVyaWFsIERlc2lnbiwgdGhpcyBwbGFjZWhvbGRlciB3aWxsIGJlIGEgZmxvYXRpbmcgbGFiZWwuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZmxvYXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgYW5pbWF0ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5pmC44CB44Op44OZ44Or44Gv44Ki44OL44Oh44O844K344On44Oz44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdHlwZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgU3BlY2lmeSB0aGUgaW5wdXQgdHlwZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgXCJ0eXBlXCIgYXR0cmlidXRlIGZvciBub3JtYWwgaW5wdXRzLiBJdCBleHBlY3RzIHN0cmljdCB0ZXh0IHR5cGVzIHN1Y2ggYXMgYHRleHRgLCBgcGFzc3dvcmRgLCBldGMuIEZvciBjaGVja2JveCwgcmFkaW8gYnV0dG9uLCBzZWxlY3Qgb3IgcmFuZ2UsIHBsZWFzZSBoYXZlIGEgbG9vayBhdCB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cy5cbiAgICpcbiAgICogICAgUGxlYXNlIHRha2UgYSBsb29rIGF0IFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLXR5cGUpIGZvciBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzLiBEZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtIGFuZCBicm93c2VyIHZlcnNpb24gc29tZSBvZiB0aGVzZSBtaWdodCBub3Qgd29yay5cbiAgICogIFsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG59XG5cbm9ucy5lbGVtZW50cy5JbnB1dCA9IElucHV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlucHV0JywgSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UtaW5wdXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdjaGVja2VkJywgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBJbmhlcml0ZWQgcHJvcHMgKi9cblxuICBnZXQgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8aW5wdXQgdHlwZT1cIiR7dGhpcy50eXBlfVwiIGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faW5wdXRcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9fY2hlY2ttYXJrXCI+PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIH1cblxuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gdmFsO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICdjaGVja2VkJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmNoZWNrYm94JzogJ2NoZWNrYm94LS0qJyxcbiAgJy5jaGVja2JveF9faW5wdXQnOiAnY2hlY2tib3gtLSpfX2lucHV0JyxcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jaGVja2JveFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgW2VuXWlPUyBib3JkZXJsZXNzIGNoZWNrYm94LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNoZWNrYm94IGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2lucHV0XG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYWRpb1xuICogICBbZW5dVGhlIGA8b25zLXJhZGlvPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYWRpbyBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWFyY2gtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWFyY2gtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlYXJjaCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jaGVja2JveCBjaGVja2VkPjwvb25zLWNoZWNrYm94PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAnY2hlY2tib3gnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdjaGVja2JveCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY2hlY2tib3guWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zLmVsZW1lbnRzLkNoZWNrYm94ID0gQ2hlY2tib3hFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2hlY2tib3gnLCBDaGVja2JveEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnJhZGlvLWJ1dHRvbic6ICdyYWRpby1idXR0b24tLSonLFxuICAnLnJhZGlvLWJ1dHRvbl9faW5wdXQnOiAncmFkaW8tYnV0dG9uLS0qX19pbnB1dCcsXG4gICcucmFkaW8tYnV0dG9uX19jaGVja21hcmsnOiAncmFkaW8tYnV0dG9uLS0qX19jaGVja21hcmsnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yYWRpb1xuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiByYWRpbyBidXR0b24uWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgcmFkaW8gYnV0dG9uIGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiByYWRpbyBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0IHR5cGU9XCJyYWRpb1wiPmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1yYWRpbz5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLXNlbGVjdFxuICogICBbZW5dVGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgc2VsZWN0IGJveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jaGVja2JveFxuICogICBbZW5dVGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBjaGVja2JveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zd2l0Y2hcbiAqICAgW2VuXVRoZSBgPG9ucy1zd2l0Y2g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSB0b2dnbGUgc3dpdGNoLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VhcmNoLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VhcmNoLWlucHV0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWFyY2ggaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yYWRpbyBjaGVja2VkPjwvb25zLXJhZGlvPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpb0VsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAncmFkaW8tYnV0dG9uJztcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAncmFkaW8nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgY2hlY2tlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHJhZGlvIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG59XG5cbm9ucy5lbGVtZW50cy5SYWRpbyA9IFJhZGlvRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhZGlvJywgUmFkaW9FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1pbnB1dCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5zZWFyY2gtaW5wdXQnOiAnc2VhcmNoLWlucHV0LS0qJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc2VhcmNoLWlucHV0XG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIHNlYXJjaCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBzZWFyY2ggaW5wdXQgZWxlbWVudC4gVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVuZGVyIGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlYXJjaCBpbnB1dCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQ+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLXNlYXJjaC1pbnB1dD5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWNoZWNrYm94XG4gKiAgIFtlbl1UaGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGNoZWNrYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc2VhcmNoLWlucHV0IHBsYWNlaG9sZGVyPVwiU2VhcmNoXCI+PC9vbnMtc2VhcmNoLWlucHV0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hJbnB1dEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cInNlYXJjaC1pbnB1dFwiPlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zLmVsZW1lbnRzLlNlYXJjaElucHV0ID0gU2VhcmNoSW5wdXRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc2VhcmNoLWlucHV0JywgU2VhcmNoSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IE1vZGFsQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIG1vZGFsLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZnRNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvclxue1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciggLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoe1xuICAgICAgICBjc3M6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIGNzczoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgIGFuaW1pdChtb2RhbClcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIGNzczoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICB9LFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBGYWRlTW9kYWxBbmltYXRvciBmcm9tICcuL2ZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IExpZnRNb2RhbEFuaW1hdG9yIGZyb20gJy4vbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRGlhbG9nRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZGlhbG9nJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnbW9kYWwtLSonLFxuICAnbW9kYWxfX2NvbnRlbnQnOiAnbW9kYWwtLSpfX2NvbnRlbnQnXG59O1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ21vZGFsJztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBNb2RhbEFuaW1hdG9yLFxuICAnZmFkZSc6IEZhZGVNb2RhbEFuaW1hdG9yLFxuICAnbGlmdCc6IExpZnRNb2RhbEFuaW1hdG9yLFxuICAnbm9uZSc6IE1vZGFsQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLW1vZGFsXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIE1vZGFsIGNvbXBvbmVudCB0aGF0IG1hc2tzIGN1cnJlbnQgc2NyZWVuLiBVbmRlcmx5aW5nIGNvbXBvbmVudHMgYXJlIG5vdCBzdWJqZWN0IHRvIGFueSBldmVudHMgd2hpbGUgdGhlIG1vZGFsIGNvbXBvbmVudCBpcyBzaG93bi5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYmxvY2sgdXNlciBpbnB1dCB3aGlsZSBzb21lIG9wZXJhdGlvbiBpcyBydW5uaW5nIG9yIHRvIHNob3cgc29tZSBpbmZvcm1hdGlvbiB0byB0aGUgdXNlci5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOeUu+mdouWFqOS9k+OCkuODnuOCueOCr+OBmeOCi+ODouODvOODgOODq+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguS4i+WBtOOBq+OBguOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBr+OAgVxuICogICAgIOODouODvOODgOODq+OBjOihqOekuuOBleOCjOOBpuOBhOOCi+mWk+OBr+OCpOODmeODs+ODiOmAmuefpeOBjOihjOOCj+OCjOOBvuOBm+OCk+OAglxuICogICBbL2phXVxuICogQHNlZWFsc28gb25zLWRpYWxvZ1xuICogICBbZW5dVGhlIGA8b25zLWRpYWxvZz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBtb2RhbCBkaWFsb2cuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkZXZJZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvcmVmZXJlbmNlL21vZGFsXG4gKiBAZXhhbXBsZVxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XG4gKiAgIE1vZGFsIGNvbnRlbnRcbiAqIDwvb25zLW1vZGFsPlxuICogPHNjcmlwdD5cbiAqICAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsJyk7XG4gKiAgIG1vZGFsLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBtb2RhbCBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBtb2RhbCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tb2RhbFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBtb2RhbCBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODouODvOODgOODq+OBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tb2RhbFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgbW9kYWwgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6Z2e6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIG1vZGFsIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgLCBgXCJmYWRlXCJgIG9yIGBcImxpZnRcImAuWy9lbl1cbiAgICogIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZmFkZVwiLFwibGlmdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fZGVmYXVsdERCQiA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogTW9kYWxBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdNb2RhbEFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLm1vZGFsX19jb250ZW50JykpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnbW9kYWxfX2NvbnRlbnQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICBjb250ZW50Lmluc2VydEJlZm9yZShub2RlLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdG9nZ2xlU3R5bGUoc2hvdWxkU2hvdykge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHNob3VsZFNob3cgPyAndGFibGUnIDogJ25vbmUnO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHN1cGVyLl9wcmV2ZW50U2Nyb2xsLCBmYWxzZSk7IC8vIGlPUyBmaXhcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBzdXBlci5fcHJldmVudFNjcm9sbCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1vZGFsIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG1vZGFsLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgbW9kYWwgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBtb2RhbCB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBruihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBtb2RhbCBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGFsQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zTW9kYWxFbGVtZW50Lk1vZGFsQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IE1vZGFsQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIE1vZGFsQW5pbWF0b3I7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLk1vZGFsID0gTW9kYWxFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbW9kYWwnLCBNb2RhbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi8uLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IHdpZHRoVG9QeCA9ICh3aWR0aCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2lwZVJldmVhbCB7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgJ2VsZW1lbnQgaWdub3JlU3dpcGUgaXNJbml0aWFsU3RhdGUgb25EcmFnQ2FsbGJhY2sgc3dpcGVNYXggc3dpcGVNaW4gc3dpcGVNaWQnXG4gICAgICAuc3BsaXQoL1xccysvKS5mb3JFYWNoKGtleSA9PiB0aGlzW2tleV0gPSBwYXJhbXNba2V5XSk7XG5cbiAgICB0aGlzLmVsZW1lbnRIYW5kbGVyID0gcGFyYW1zLmVsZW1lbnRIYW5kbGVyIHx8IHBhcmFtcy5lbGVtZW50O1xuICAgIHRoaXMuZ2V0VGhyZXNob2xkID0gcGFyYW1zLmdldFRocmVzaG9sZCB8fCAoKCkgPT4gLjUpO1xuICAgIHRoaXMuZ2V0U2lkZSA9IHBhcmFtcy5nZXRTaWRlIHx8ICgoKSA9PiAnbGVmdCcpO1xuXG4gICAgdGhpcy5oYW5kbGVHZXN0dXJlID0gdGhpcy5oYW5kbGVHZXN0dXJlLmJpbmQodGhpcyk7XG4gIH1cblxuICB1cGRhdGUoc3dpcGVhYmxlID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJykpIHtcbiAgICBpZiAoIXRoaXMuZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICB0aGlzLmdlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5lbGVtZW50SGFuZGxlciwge2RyYWdNaW5EaXN0YW5jZTogMX0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbiA9IHN3aXBlYWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgICB0aGlzLmdlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnIGRyYWdzdGFydCBkcmFnZW5kJywgdGhpcy5oYW5kbGVHZXN0dXJlKTtcbiAgfVxuXG4gIGhhbmRsZUdlc3R1cmUoZSkge1xuICAgIGlmIChlLmdlc3R1cmUpIHtcbiAgICAgIGlmIChlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAgIHRoaXMub25EcmFnU3RhcnQoZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICAgIGUudHlwZSA9PT0gJ2RyYWdlbmQnID8gdGhpcy5vbkRyYWdFbmQoZSkgOiB0aGlzLm9uRHJhZyhlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRyYWdTdGFydChldmVudCkge1xuICAgIGNvbnN0IGdldERpc3RhbmNlID0gKCkgPT4gdGhpcy5nZXRTaWRlKCkgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFg7XG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkIHx8ICF1dGlsLmlzVmFsaWRHZXN0dXJlKGV2ZW50KSB8fCB0aGlzLmlnbm9yZVN3aXBlKGV2ZW50LCBnZXREaXN0YW5jZSgpKTtcblxuICAgIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgZXZlbnQuY29uc3VtZSAmJiBldmVudC5jb25zdW1lKCk7XG4gICAgICBldmVudC5jb25zdW1lZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGhUb1B4KHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCB8fCAnMTAwJScpO1xuICAgICAgdGhpcy5fc3RhcnREaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlID0gKCEodGhpcy5pc0luaXRpYWxTdGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0aGlzLmlzSW5pdGlhbFN0YXRlKCkpID8gMCA6IHRoaXMuX3dpZHRoO1xuXG4gICAgICB1dGlsLnByZXZlbnRTY3JvbGwodGhpcy5nZXN0dXJlRGV0ZWN0b3IpO1xuICAgIH1cbiAgfVxuXG4gIG9uRHJhZyhldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5nZXRTaWRlKCkgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fd2lkdGgsIHRoaXMuX3N0YXJ0RGlzdGFuY2UgKyBkZWx0YSkpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdGhpcy5fZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB0aGlzLnN3aXBlTWlkKHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl93aWR0aCk7XG4gICAgfVxuICB9XG5cbiAgb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgY29uc3QgaXNTd2lwZU1heCA9IHRoaXMuZ2V0U2lkZSgpICE9PSBkaXJlY3Rpb24gJiYgdGhpcy5fZGlzdGFuY2UgPiB0aGlzLl93aWR0aCAqIHRoaXMuZ2V0VGhyZXNob2xkKCk7XG4gICAgaXNTd2lwZU1heCA/IHRoaXMuc3dpcGVNYXgoKSA6IHRoaXMuc3dpcGVNaW4oKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgJiYgdGhpcy5nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gdGhpcy5lbGVtZW50ID0gdGhpcy5lbGVtZW50SGFuZGxlciA9IG51bGw7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgYmxvY2socGFnZSkge1xuICAgIGNvbnN0IGJsb2NrZXIgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDEwMDAwMFwiPjwvZGl2PlxuICAgIGApO1xuICAgIHBhZ2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChibG9ja2VyKTtcbiAgICByZXR1cm4gKCkgPT4gYmxvY2tlci5yZW1vdmUoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIG5hdmlnYXRvciB0cmFuc2l0aW9uIGxpa2UgaU9TJ3Mgc2NyZWVuIHNsaWRlIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoMC4zLCAuNCwgMCwgLjkpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuNH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyB6LWluZGV4OiAyXCI+PC9kaXY+XG4gICAgYCk7XG5cbiAgfVxuXG4gIF9kZWNvbXBvc2UocGFnZSkge1xuICAgIGNvbnN0IHRvb2xiYXIgPSBwYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuICAgIGNvbnN0IGxlZnQgPSB0b29sYmFyLl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdG9vbGJhci5fZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50KCk7XG5cbiAgICBjb25zdCBleGNsdWRlQmFja0J1dHRvbiA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudHNbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1iYWNrLWJ1dHRvbicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3RoZXIgPSBbXVxuICAgICAgLmNvbmNhdChsZWZ0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IGxlZnQgOiBleGNsdWRlQmFja0J1dHRvbihsZWZ0LmNoaWxkcmVuKSlcbiAgICAgIC5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbihyaWdodC5jaGlsZHJlbikpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xiYXJDZW50ZXI6IHRvb2xiYXIuX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSxcbiAgICAgIGJhY2tCdXR0b25JY29uOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uTGFiZWw6IHRvb2xiYXIuX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50KCksXG4gICAgICBvdGhlcjogb3RoZXIsXG4gICAgICBjb250ZW50OiBwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLFxuICAgICAgYmFja2dyb3VuZDogcGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSxcbiAgICAgIHRvb2xiYXI6IHRvb2xiYXIsXG4gICAgICBib3R0b21Ub29sYmFyOiBwYWdlLl9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpXG4gICAgfTtcbiAgfVxuXG4gIF9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIGNvbnN0IGVudGVyVG9vbGJhciA9IGVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWF2ZVRvb2xiYXIgPSBsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCk7XG5cbiAgICBjb25zdCB0b29sYmFycyA9IGVudGVyUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKSAmJiBsZWF2ZVBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCk7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB1dGlsLmhhc01vZGlmaWVyKGVudGVyVG9vbGJhciwgJ21hdGVyaWFsJykgfHwgdXRpbC5oYXNNb2RpZmllcihsZWF2ZVRvb2xiYXIsICdtYXRlcmlhbCcpO1xuICAgIGNvbnN0IHRyYW5zcGFyZW50ID0gdXRpbC5oYXNNb2RpZmllcihlbnRlclRvb2xiYXIsICd0cmFuc3BhcmVudCcpIHx8IHV0aWwuaGFzTW9kaWZpZXIobGVhdmVUb29sYmFyLCAndHJhbnNwYXJlbnQnKTtcblxuICAgIHJldHVybiB0b29sYmFycyAmJiAhbWF0ZXJpYWwgJiYgIXRyYW5zcGFyZW50O1xuICB9XG5cbiAgX2NhbGN1bGF0ZURlbHRhKGVsZW1lbnQsIGRlY29tcG9zaXRpb24pIHtcbiAgICBsZXQgdGl0bGUsIGxhYmVsO1xuXG4gICAgY29uc3QgcGFnZVJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2JhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbFJlY3QgPSBkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRpdGxlID0gTWF0aC5yb3VuZChwYWdlUmVjdC53aWR0aCAvIDIgLSBsYWJlbFJlY3Qud2lkdGggLyAyIC0gbGFiZWxSZWN0LmxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9IE1hdGgucm91bmQoKHBhZ2VSZWN0LndpZHRoIC8gMikgKiAwLjYpO1xuICAgIH1cblxuICAgIGlmIChkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgbGFiZWwgPSBkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IC0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4ge3RpdGxlLCBsYWJlbH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgY29udGVudFJlYWR5KGVudGVyUGFnZSwgKCkgPT4ge1xuICAgICAgY29uc3QgZW50ZXJQYWdlVGFyZ2V0ID0gdXRpbC5maW5kVG9vbGJhclBhZ2UoZW50ZXJQYWdlKSB8fCBlbnRlclBhZ2U7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShsZWF2ZVBhZ2UpIHx8IGxlYXZlUGFnZTtcbiAgICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLl9jYWxjdWxhdGVEZWx0YShsZWF2ZVBhZ2UsIGVudGVyUGFnZURlY29tcG9zaXRpb24pO1xuXG4gICAgICBjb25zdCBzaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZVRhcmdldCwgbGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgICAgaWYgKHNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEyNSUsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2RlbHRhLnRpdGxlfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7ZGVsdGEudGl0bGV9cHgsIDAsIDApYCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhLmxhYmVsICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiAnbGluZWFyJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuXG4gICAgICAgICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCBlbnRlclBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShlbnRlclBhZ2UpIHx8IGVudGVyUGFnZTtcbiAgICBjb25zdCBsZWF2ZVBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShsZWF2ZVBhZ2UpIHx8IGxlYXZlUGFnZTtcbiAgICBjb25zdCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZVRhcmdldCk7XG4gICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2VUYXJnZXQpO1xuXG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLl9jYWxjdWxhdGVEZWx0YShsZWF2ZVBhZ2UsIGxlYXZlUGFnZURlY29tcG9zaXRpb24pO1xuXG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2VUYXJnZXQsIGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KFtlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjAsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YS5sYWJlbCArICdweCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogJ2xpbmVhcidcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCgwKVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEyNSUsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIGRlbHRhLnRpdGxlICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vaW9zLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogU3dpcGUgYW5pbWF0b3IgZm9yIGlPUyBuYXZpZ2F0b3IgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TU3dpcGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgZHVyYXRpb24gPSAwLjE1LCB0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKHtkdXJhdGlvbiwgdGltaW5nLCBkZWxheX0pO1xuICAgIHRoaXMuZHVyYXRpb25SZXN0b3JlID0gMC4xO1xuXG4gICAgdGhpcy5zd2lwZVNoYWRvdyA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMnB4OyByaWdodDogMTAwJTsgdG9wOiAwOyBib3R0b206IDA7IHotaW5kZXg6IC0xO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHRyYW5zcGFyZW50IDAsIHJnYmEoMCwwLDAsLjA0KSA0MCUsIHJnYmEoMCwwLDAsLjEyKSA4MCUsIHJnYmEoMCwwLDAsLjE2KSAxMDAlKTtcIj48L2Rpdj5cbiAgICBgKTtcblxuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSB0cnVlO1xuICB9XG5cbiAgX2RyYWdTdGFydFNldHVwKGVudGVyUGFnZSwgbGVhdmVQYWdlKSB7XG4gICAgdGhpcy5pc0RyYWdTdGFydCA9IGZhbHNlO1xuXG4gICAgLy8gQXZvaWQgY29udGVudCBjbGlja3NcbiAgICB0aGlzLnVuYmxvY2sgPSBzdXBlci5ibG9jayhsZWF2ZVBhZ2UpO1xuXG4gICAgLy8gTWFza1xuICAgIGVudGVyUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgLy8gRGVjb21wb3NpdGlvblxuICAgIHRoaXMudGFyZ2V0ID0ge1xuICAgICAgZW50ZXI6IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlLFxuICAgICAgbGVhdmU6IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlLFxuICAgIH07XG4gICAgdGhpcy5kZWNvbXAgPSB7XG4gICAgICBlbnRlcjogdGhpcy5fZGVjb21wb3NlKHRoaXMudGFyZ2V0LmVudGVyKSxcbiAgICAgIGxlYXZlOiB0aGlzLl9kZWNvbXBvc2UodGhpcy50YXJnZXQubGVhdmUpXG4gICAgfTtcblxuICAgIC8vIEFuaW1hdGlvbiB2YWx1ZXNcbiAgICB0aGlzLmRlbHRhID0gdGhpcy5fY2FsY3VsYXRlRGVsdGEobGVhdmVQYWdlLCB0aGlzLmRlY29tcC5sZWF2ZSk7XG4gICAgdGhpcy5zaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG5cbiAgICAvLyBTaGFkb3cgJiYgc3R5bGVzXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIHRoaXMuc3dpcGVTaGFkb3cuc3R5bGUudG9wID0gdGhpcy5kZWNvbXAubGVhdmUudG9vbGJhci5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgdGhpcy50YXJnZXQubGVhdmUuYXBwZW5kQ2hpbGQodGhpcy5zd2lwZVNoYWRvdyk7XG4gICAgICB0aGlzLl9zYXZlU3R5bGUodGhpcy50YXJnZXQuZW50ZXIsIHRoaXMudGFyZ2V0LmxlYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVhdmVQYWdlLmFwcGVuZENoaWxkKHRoaXMuc3dpcGVTaGFkb3cpO1xuICAgICAgdGhpcy5fc2F2ZVN0eWxlKGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICB9XG4gICAgbGVhdmVQYWdlLmNsYXNzTGlzdC5hZGQoJ292ZXJmbG93LXZpc2libGUnKTtcbiAgICB0aGlzLm92ZXJmbG93RWxlbWVudCA9IGxlYXZlUGFnZTtcbiAgICB0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LmNsYXNzTGlzdC5hZGQoJ2NvbnRlbnQtc3dpcGluZycpO1xuXG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UsIG1heFdpZHRoLCBlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIGlmICh0aGlzLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICB0aGlzLl9kcmFnU3RhcnRTZXR1cChlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3dpcGVSYXRpbyA9IChkaXN0YW5jZSAtIG1heFdpZHRoKSAvIG1heFdpZHRoO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAvKiBFbnRlciBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5lbnRlci5jb250ZW50LCB0aGlzLmRlY29tcC5lbnRlci5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5lbnRlci5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtzd2lwZVJhdGlvICogMjV9JSwgMCwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gKiAxMCAvIDEwMCAvLyAwLjkgLT4gMVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMuZGVsdGEudGl0bGUgKiBzd2lwZVJhdGlvfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAvLyAwIC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAqIDEwIC8gMTAwLCAvLyAwLjkgLT4gMVxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLmxhYmVsICogc3dpcGVSYXRpb31weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLm90aGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAvLyAwIC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kLCB0aGlzLnN3aXBlU2hhZG93XSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtkaXN0YW5jZX1weCwgMHB4LCAwcHgpYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7KDEgKyBzd2lwZVJhdGlvKSAqIDEyNX0lLCAwLCAwKWBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8sIC8vIDEgLT4gMFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlICogKDEgKyBzd2lwZVJhdGlvKX1weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2Rpc3RhbmNlfXB4LCAwcHgsIDBweClgXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtzd2lwZVJhdGlvICogMjV9JSwgMCwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gKiAxMCAvIDEwMCAvLyAwLjkgLT4gMVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVzdG9yZShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5pc0RyYWdTdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG5cbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgLyogRW50ZXIgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAuZW50ZXIuY29udGVudCwgdGhpcy5kZWNvbXAuZW50ZXIuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAuZW50ZXIuYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0yNSUsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7dGhpcy5kZWx0YS50aXRsZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvblJlc3RvcmV9cyAke3RoaXMudGltaW5nfWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7dGhpcy5kZWx0YS5sYWJlbH1weCwgMCwgMClgXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uUmVzdG9yZVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kLCB0aGlzLnN3aXBlU2hhZG93XSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMHB4LCAwcHgpYFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uUmVzdG9yZVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb25SZXN0b3JlfXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgIH0pLFxuXG5cbiAgICAgICAgLyogT3RoZXIgKi9cblxuICAgICAgICBhbmltaXQodGhpcy5zd2lwZVNoYWRvdylcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG5cbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0KGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAvKiBFbnRlciBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5lbnRlci5jb250ZW50LCB0aGlzLmRlY29tcC5lbnRlci5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5lbnRlci5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLm90aGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgLyogTGVhdmUgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAubGVhdmUuY29udGVudCwgdGhpcy5kZWNvbXAubGVhdmUuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAubGVhdmUuYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDEwMCUsIDBweCwgMHB4KWBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25cbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgxMjUlLCAwLCAwKWBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25cbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWBcbiAgICAgICAgICB9KSxcblxuXG4gICAgICAgIC8qIE90aGVyICovXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuc3dpcGVTaGFkb3cpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWF4V2lkdGh9cHgsIDBweCwgMHB4KWBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVzZXQoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBfc2F2ZVN0eWxlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9zYXZlZFN0eWxlID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBzYXZlID0gZWwgPT4gdGhpcy5fc2F2ZWRTdHlsZS5zZXQoZWwsIGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSk7XG4gICAgYXJncy5mb3JFYWNoKHNhdmUpO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5kZWNvbXApLmZvckVhY2gocCA9PiB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmRlY29tcFtwXSkuZm9yRWFjaChrID0+IHtcbiAgICAgICAgKHRoaXMuZGVjb21wW3BdW2tdIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLmRlY29tcFtwXVtrXSA6IFt0aGlzLmRlY29tcFtwXVtrXV0pLmZvckVhY2goc2F2ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9yZXN0b3JlU3R5bGUoLi4uYXJncykge1xuICAgIGNvbnN0IHJlc3RvcmUgPSBlbCA9PiB7XG4gICAgICB0aGlzLl9zYXZlZFN0eWxlLmdldChlbCkgPT09IG51bGwgPyBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJykgOiBlbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5fc2F2ZWRTdHlsZS5nZXQoZWwpKVxuICAgICAgdGhpcy5fc2F2ZWRTdHlsZS5kZWxldGUoZWwpXG4gICAgfTtcbiAgICBhcmdzLmZvckVhY2gocmVzdG9yZSk7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmRlY29tcCkuZm9yRWFjaChwID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGVjb21wW3BdKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAodGhpcy5kZWNvbXBbcF1ba10gaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuZGVjb21wW3BdW2tdIDogW3RoaXMuZGVjb21wW3BdW2tdXSkuZm9yRWFjaChyZXN0b3JlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Jlc2V0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9zYXZlZFN0eWxlICYmIHRoaXMuX3Jlc3RvcmVTdHlsZSguLi5hcmdzKTtcbiAgICB0aGlzLnVuYmxvY2sgJiYgdGhpcy51bmJsb2NrKCk7XG4gICAgdGhpcy5zd2lwZVNoYWRvdy5yZW1vdmUoKTtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIHRoaXMub3ZlcmZsb3dFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJmbG93LXZpc2libGUnKTtcbiAgICB0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbnRlbnQtc3dpcGluZycpO1xuICAgIHRoaXMuZGVjb21wID0gdGhpcy50YXJnZXQgPSB0aGlzLm92ZXJmbG93RWxlbWVudCA9IHRoaXMuX3NhdmVkU3R5bGUgPSBudWxsO1xuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSB0cnVlO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0xpZnROYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoYmxhY2ssIHdoaXRlKTtcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC00M3B4LCAwKScsIC8vIFNtYWxsZXIgdGhhbiBpT1MgdG9vbGJhciAtIGZpeGVzIGdsaXRjaFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChbZW50ZXJQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBlbnRlclBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChbbGVhdmVQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBsZWF2ZVBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgei1pbmRleDogMjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7XCI+PC9kaXY+XG4gICAgYCk7XG4gICAgdGhpcy5ibGFja01hc2tPcGFjaXR5ID0gMC40O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC53YWl0KDAuMilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHksXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNDUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4yKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURMaWZ0TmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAuMDUsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIEZhZGUtaW4gKyBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNREZhZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKScsIHRpbWluZ09uUG9wID0gJ2N1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG4gICAgdGhpcy50aW1pbmdPblBvcCA9IHRpbWluZ09uUG9wO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgNDJweCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4xNSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDM4cHgsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdPblBvcCxcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbmVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBTd2lwZVJldmVhbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvc3dpcGUtcmV2ZWFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc3dpcGUtYW5pbWF0b3InO1xuaW1wb3J0IElPU0xpZnROYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2lvcy1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3MtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTURTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9tZC1mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBOb25lTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9ub25lLWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyLCBpbnN0YW50UGFnZUxvYWRlcn0gZnJvbSAnLi4vLi4vb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ3NsaWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnbGlmdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURMaWZ0TmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NMaWZ0TmF2aWdhdG9yQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JBbmltYXRvciA6IElPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ3NsaWRlLWlvcyc6IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdzbGlkZS1tZCc6IE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2xpZnQtaW9zJzogSU9TTGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnbGlmdC1tZCc6IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnZmFkZS1pb3MnOiBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdub25lJzogTm9uZU5hdmlnYXRvckFuaW1hdG9yXG59O1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmF2aWdhdG9yU2lkZUVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KG5hdmlnYXRvckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbmF2aWdhdG9yXG4gKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBIGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIHBhZ2Ugc3RhY2sgbWFuYWdlbWVudCBhbmQgbmF2aWdhdGlvbi4gU3RhY2sgbmF2aWdhdGlvbiBpcyB0aGUgbW9zdCBjb21tb24gbmF2aWdhdGlvbiBwYXR0ZXJuIGZvciBtb2JpbGUgYXBwcy5cbiAqXG4gKiAgICAgV2hlbiBhIHBhZ2UgaXMgcHVzaGVkIG9uIHRvcCBvZiB0aGUgc3RhY2sgaXQgaXMgZGlzcGxheWVkIHdpdGggYSB0cmFuc2l0aW9uIGFuaW1hdGlvbi4gV2hlbiB0aGUgdXNlciByZXR1cm5zIHRvIHRoZSBwcmV2aW91cyBwYWdlIHRoZSB0b3AgcGFnZSB3aWxsIGJlIHBvcHBlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIGFuZCBoaWRkZW4gd2l0aCBhbiBvcHBvc2l0ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbi5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB5cmh0dlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25hdmlnYXRvclxuICogQGd1aWRlIGxpZmVjeWNsZS5odG1sI2V2ZW50c1xuICogICBbZW5dT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2VuXVxuICogICBbamFdT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRvb2xiYXIgb24gdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBsZXRzIHRoZSB1c2VyIHJldHVybiB0byB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLW5hdmlnYXRvciBpZD1cIm5hdmlnYXRvclwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBUaXRsZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgICA8cD5cbiAqICAgICAgIDxvbnMtYnV0dG9uXG4gKiAgICAgICAgIG9uY2xpY2s9XCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2aWdhdG9yJykucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpXCI+XG4gKiAgICAgICAgIFB1c2ggcGFnZVxuICogICAgICAgPC9vbnMtYnV0dG9uPlxuICogICAgIDwvcD5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwicGFnZS5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBBbm90aGVyIHBhZ2VcbiAqICAgICAgIDwvZGl2PlxuICogICAgIDwvb25zLXRvb2xiYXI+XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgcGFnZSB0byBzaG93IHdoZW4gbmF2aWdhdG9yIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAqICAgW2phXeODiuODk+OCsuODvOOCv+ODvOOBjOWIneacn+WMluOBleOCjOOBn+aZguOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUVuYWJsZSBpT1MgXCJzd2lwZSB0byBwb3BcIiBmZWF0dXJlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAyMHB4XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXG4gICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRocmVzaG9sZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBob3cgbXVjaCB0aGUgcGFnZSBuZWVkcyB0byBiZSBzd2lwZWQgYmVmb3JlIHBvcHBpbmcuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcHVzaC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwdXNo5Yem55CG44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHBvcC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwYWdl44GucG9w44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC5LqG44GX44Gm44GL44KJ55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcHVzaOOBleOCjOOBn3BhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guOCj+OBo+OBn+W+jOOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpuihqOekuuOBleOCjOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpua2iOOBiOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBhbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yRmFjdG9yeTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9wYWdlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtQYWdlTG9hZGVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZUxvYWRlciBpbnN0YW5jZS4gSXQgY2FuIGJlIG92ZXJyaWRlbiB0byBjaGFuZ2UgdGhlIHdheSBwYWdlcyBhcmUgbG9hZGVkIGJ5IHRoaXMgZWxlbWVudC4gVXNlZnVsIGZvciBsaWIgZGV2ZWxvcGVycy5bL2VuXVxuICAgKiAgIFtqYV1QYWdlTG9hZGVy44Kk44Oz44K544K/44Oz44K544KS5qC857SN44GX44Gm44GE44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIocGFnZUxvYWRlcikge1xuICAgIGlmICghKHBhZ2VMb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFBhZ2VMb2FkZXIuJyk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIHBhZ2UgdG8gYmUgbG9hZGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gVGhpcyB2YWx1ZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGBwYWdlYCBhdHRyaWJ1dGUuIFVzZWZ1bCBmb3IgbGliIGRldmVsb3BlcnMuWy9lbl1cbiAgICogICBbamFd5Yid5pyf5YyW5pmC44Gr6Kqt44G/6L6844KA44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCYHBhZ2Vg5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCk44KI44KK44KCYHBhZ2Vg44OX44Ot44OR44OG44Kj44Gr5oyH5a6a44GX44Gf5YCk44KS5YSq5YWI44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcblxuICAgIGlmICghcGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpID09PSAnZm9yY2UnKSB7XG4gICAgICB0aGlzLl9zd2lwZUFuaW1hdG9yID0gbmV3IElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IoKTtcblxuICAgICAgdGhpcy5fc3dpcGUgPSBuZXcgU3dpcGVSZXZlYWwoe1xuICAgICAgICBlbGVtZW50OiB0aGlzLFxuICAgICAgICBzd2lwZU1heDogKCkgPT4gdGhpc1t0aGlzLnN3aXBlTWF4ID8gJ3N3aXBlTWF4JyA6ICdwb3BQYWdlJ10oeyBhbmltYXRvcjogdGhpcy5fc3dpcGVBbmltYXRvciB9KSxcbiAgICAgICAgc3dpcGVNaWQ6IChkaXN0YW5jZSwgd2lkdGgpID0+IHRoaXMuX3N3aXBlQW5pbWF0b3IudHJhbnNsYXRlKGRpc3RhbmNlLCB3aWR0aCwgdGhpcy50b3BQYWdlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcsIHRoaXMudG9wUGFnZSksXG4gICAgICAgIHN3aXBlTWluOiAoKSA9PiB0aGlzLl9zd2lwZUFuaW1hdG9yLnJlc3RvcmUodGhpcy50b3BQYWdlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcsIHRoaXMudG9wUGFnZSksXG4gICAgICAgIGdldFRocmVzaG9sZDogKCkgPT4gTWF0aC5tYXgoMC4yLCBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10aHJlc2hvbGQnKSkgfHwgMCksXG4gICAgICAgIGlnbm9yZVN3aXBlOiAoZXZlbnQsIGRpc3RhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKC9vbnMtYmFjay1idXR0b24vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSB8fCB1dGlsLmZpbmRQYXJlbnQoZXZlbnQudGFyZ2V0LCAnb25zLWJhY2stYnV0dG9uJywgcCA9PiAvb25zLXBhZ2UvaS50ZXN0KHAudGFnTmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXJlYSA9IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSB8fCAyNSwgMTApO1xuICAgICAgICAgIHJldHVybiBldmVudC5nZXN0dXJlLmRpcmVjdGlvbiAhPT0gICdyaWdodCcgfHwgYXJlYSA8PSBkaXN0YW5jZSB8fCB0aGlzLl9pc1J1bm5pbmcgfHwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdzd2lwZWFibGUnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBzaG93ID0gIXV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQodGhpcyk7XG4gICAgICBjb25zdCBvcHRpb25zID0geyBhbmltYXRpb246ICdub25lJywgc2hvdyB9O1xuXG4gICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5fZ2V0UGFnZVRhcmdldCgpLCBvcHRpb25zKS50aGVuKCgpID0+IGRlZmVycmVkLnJlc29sdmUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5wYWdlc1tpXS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2hpbGRyZW4gb2YgPG9ucy1uYXZpZ2F0b3I+IG5lZWQgdG8gYmUgb2YgdHlwZSA8b25zLXBhZ2U+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9wUGFnZSkge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLnRvcFBhZ2UsICgpID0+XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICBzaG93ICYmIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcbiAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hQYWdlKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSwgb3B0aW9ucykudGhlbigoKSA9PiBkZWZlcnJlZC5yZXNvbHZlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE5hdmlnYXRvckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ05hdmlnYXRvckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIHRoaXMuX3N3aXBlICYmIHRoaXMuX3N3aXBlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9zd2lwZSA9IHRoaXMuX3N3aXBlQW5pbWF0b3IgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnYW5pbWF0aW9uJywgJ3N3aXBlYWJsZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2gobmFtZSkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3dpcGVhYmxlJzpcbiAgICAgICAgdGhpcy5fc3dpcGUgJiYgdGhpcy5fc3dpcGUudXBkYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBvcFBhZ2VcbiAgICogQHNpZ25hdHVyZSBwb3BQYWdlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mmI7jgonjgYvjgavjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBvcHMgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBwYWdlIHN0YWNrLiBUaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgILkuIDjgaTliY3jga7jg5rjg7zjgrjjgavmiLvjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcG9wUGFnZShvcHRpb25zID0ge30pIHtcbiAgICAoe29wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKG51bGwsIG9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHBvcFVwZGF0ZSA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX3BvcFBhZ2Uob3B0aW9ucywgcG9wVXBkYXRlKTtcbiAgfVxuXG4gIF9wb3BQYWdlKG9wdGlvbnMsIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSB7XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwb3BQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdvbnMtbmF2aWdhdG9yXFwncyBwYWdlIHN0YWNrIGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUG9wRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwb3AgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5wYWdlc1tsZW5ndGggLSAyXS51cGRhdGVCYWNrQnV0dG9uKChsZW5ndGggLSAyKSA+IDApO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGVudGVyUGFnZSA9IHRoaXMucGFnZXNbbGVuZ3RoIC0gMl07XG5cbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gfHwgKGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zID8gbGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMuYW5pbWF0aW9uIDogdW5kZWZpbmVkKTtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgbGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMgPyBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb25PcHRpb25zIDoge30sXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICBlbnRlclBhZ2UuZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UuZGF0YSB8fCB7fSwgb3B0aW9ucy5kYXRhIHx8IHt9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgZW50ZXJQYWdlLl9zaG93KCk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cG9wJywge2xlYXZlUGFnZSwgZW50ZXJQYWdlLCBuYXZpZ2F0b3I6IHRoaXN9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoZW50ZXJQYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBsZWF2ZVBhZ2UuX2hpZGUoKTtcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gb3B0aW9ucy5hbmltYXRvciB8fCB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG4gICAgICBhbmltYXRvci5wb3AodGhpcy5wYWdlc1tsZW5ndGggLSAyXSwgdGhpcy5wYWdlc1tsZW5ndGggLSAxXSwgY2FsbGJhY2spO1xuICAgIH0pLmNhdGNoKCgpID0+IHRoaXMuX2lzUnVubmluZyA9IGZhbHNlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHVzaFBhZ2VcbiAgICogQHNpZ25hdHVyZSBwdXNoUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGEgSFRNTCBkb2N1bWVudCBvciBhIHRlbXBsYXRlIGRlZmluZWQgd2l0aCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gT25seSBuZWNlc3NhcnkgaWYgYHBhZ2VgIHBhcmFtZXRlciBpcyBudWxsIG9yIHVuZGVmaW5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZUhUTUxdXG4gICAqICAgW2VuXUhUTUwgY29kZSB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYXMgYSBuZXcgcGFnZS4gT3ZlcndyaXRlcyBgcGFnZWAgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV1wdXNoUGFnZSgp44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcHVzaGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd6L+95Yqg44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QdXNoZXMgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2XjgpLmlrDjgZfjgYTjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgavov73liqDjgZfjgb7jgZnjgILmlrDjgZfjgYTjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcHVzaFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBjb25zdCBwcmVwYXJlID0gcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgdGhpcy5fdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgICAgdGhpcy5fcGFnZU1hcC5zZXQocGFnZUVsZW1lbnQsIHBhZ2UpO1xuICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGFcbiAgICAgIH0pO1xuICAgICAgcGFnZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5wYWdlSFRNTCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBpbnN0YW50UGFnZUxvYWRlci5sb2FkKHtwYWdlOiBvcHRpb25zLnBhZ2VIVE1MLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb3B0aW9ucy5kYXRhfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICAgIHByZXBhcmUocGFnZUVsZW1lbnQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb3B0aW9ucy5kYXRhfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBwcmVwYXJlKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG5cbiAgX3B1c2hQYWdlKG9wdGlvbnMgPSB7fSwgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKTtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwge2FuaW1hdGlvbk9wdGlvbnN9LCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgcGFnZUxlbmd0aCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuXG4gICAgICBjb25zdCBlbnRlclBhZ2UgID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBsZWF2ZVBhZ2UgPSBvcHRpb25zLmxlYXZlUGFnZSB8fCB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAyXTtcblxuICAgICAgaWYgKGVudGVyUGFnZS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZWxlbWVudHMgb2YgdHlwZSA8b25zLXBhZ2U+IGNhbiBiZSBwdXNoZWQgdG8gdGhlIG5hdmlnYXRvcicpO1xuICAgICAgfVxuXG4gICAgICBlbnRlclBhZ2UudXBkYXRlQmFja0J1dHRvbihwYWdlTGVuZ3RoID4gKG9wdGlvbnMuX3JlcGxhY2VQYWdlID8gMiA6IDEpKTtcblxuICAgICAgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgfHwge30sIG9wdGlvbnMgfHwge30pO1xuICAgICAgZW50ZXJQYWdlLmRhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLmRhdGEgfHwge30sIG9wdGlvbnMuZGF0YSB8fCB7fSk7XG4gICAgICBlbnRlclBhZ2UudW5sb2FkID0gZW50ZXJQYWdlLnVubG9hZCB8fCBvcHRpb25zLnVubG9hZDtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgb3B0aW9ucy5zaG93ICE9PSBmYWxzZSAmJiBzZXRJbW1lZGlhdGUoKCkgPT4gZW50ZXJQYWdlLl9zaG93KCkpO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHB1c2gnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGVyUGFnZS5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcbiAgICAgICAgICBsZWF2ZVBhZ2UuX2hpZGUoKTtcbiAgICAgICAgICBhbmltYXRvci5wdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlcGxhY2VQYWdlXG4gICAqIEBzaWduYXR1cmUgcmVwbGFjZVBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlcGxhY2VzIHRoZSBjdXJyZW50IHRvcCBwYWdlIHdpdGggdGhlIHNwZWNpZmllZCBvbmUuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44KS5oyH5a6a44GX44Gf44Oa44O844K444Gr572u44GN5o+b44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlcGxhY2VQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpXG4gICAgICAudGhlbihyZXNvbHZlZFZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNvbHZlZFZhbHVlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW5zZXJ0UGFnZVxuICAgKiBAc2lnbmF0dXJlIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgaW5zZXJ0ZWQuWy9lbl1cbiAgICogICBbamFd44K544K/44OD44Kv44Gr5oy/5YWl44GZ44KL5L2N572u44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaW5zZXJ0ZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUluc2VydCB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2sgd2l0aCBhdCBhIHBvc2l0aW9uIGRlZmluZWQgYnkgdGhlIGBpbmRleGAgYXJndW1lbnQuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBrmluZGV444Gn5oyH5a6a44GX44Gf5L2N572u44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICh7cGFnZSwgb3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4ID49IHRoaXMucGFnZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShwYWdlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBwYWdlID0gdHlwZW9mIG9wdGlvbnMucGFnZUhUTUwgPT09ICdzdHJpbmcnID8gb3B0aW9ucy5wYWdlSFRNTCA6IHBhZ2U7XG4gICAgY29uc3QgbG9hZGVyID0gdHlwZW9mIG9wdGlvbnMucGFnZUhUTUwgPT09ICdzdHJpbmcnID8gaW5zdGFudFBhZ2VMb2FkZXIgOiB0aGlzLl9wYWdlTG9hZGVyO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wYWdlTWFwLnNldChwYWdlRWxlbWVudCwgcGFnZSk7XG4gICAgICAgIHBhZ2VFbGVtZW50ID0gdXRpbC5leHRlbmQocGFnZUVsZW1lbnQsIHtcbiAgICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgcHVzaGVkT3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShwYWdlRWxlbWVudCwgdGhpcy5wYWdlc1tpbmRleF0pO1xuICAgICAgICB0aGlzLnRvcFBhZ2UudXBkYXRlQmFja0J1dHRvbih0cnVlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwYWdlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVBhZ2VcbiAgICogQHNpZ25hdHVyZSByZW1vdmVQYWdlKGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UaGUgaW5kZXggd2hlcmUgaXQgc2hvdWxkIGJlIHJlbW92ZWQuWy9lbl1cbiAgICogICBbamFd44K544K/44OD44Kv44GL44KJ5YmK6Zmk44GZ44KL44Oa44O844K444Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3liYrpmaTjgavjgojjgaPjgabooajnpLrjgZXjgozjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlbW92ZSB0aGUgc3BlY2lmaWVkIHBhZ2UgYXQgYSBwb3NpdGlvbiBpbiB0aGUgc3RhY2sgZGVmaW5lZCBieSB0aGUgYGluZGV4YCBhcmd1bWVudC4gRXh0ZW5kcyBgcG9wUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+OCpOODs+ODh+ODg+OCr+OCueOBq+OBguOCi+ODmuODvOOCuOOCkuWJiumZpOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZW1vdmVQYWdlKGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpbmRleCA9IHRoaXMuX25vcm1hbGl6ZUluZGV4KGluZGV4KTtcblxuICAgIGlmIChpbmRleCA8IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW2luZGV4XTtcbiAgICAgICAgY29uc3QgZW50ZXJQYWdlID0gdGhpcy50b3BQYWdlO1xuXG4gICAgICAgIHRoaXMuX3BhZ2VNYXAuZGVsZXRlKGxlYXZlUGFnZSk7XG4gICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKGxlYXZlUGFnZSk7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMSkgeyAvLyBlZGdlIGNhc2VcbiAgICAgICAgICB0aGlzLnRvcFBhZ2UudXBkYXRlQmFja0J1dHRvbihmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucG9wUGFnZShvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZXNldFRvUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlc2V0VG9QYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHRvcCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2xlYXJzIHBhZ2Ugc3RhY2sgYW5kIGFkZHMgdGhlIHNwZWNpZmllZCBwYWdlIHRvIHRoZSBzdGFjay4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgpLjg6rjgrvjg4Pjg4jjgZfjgIHmjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVzZXRUb1BhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuYW5pbWF0b3IgJiYgIW9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9ICdub25lJztcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICBvcHRpb25zLmNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgd2hpbGUgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzWzBdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWdlc1swXS51cGRhdGVCYWNrQnV0dG9uKGZhbHNlKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5wYWdlICYmICFvcHRpb25zLnBhZ2VIVE1MICYmIHRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgcGFnZSA9IG9wdGlvbnMucGFnZSA9IHRoaXMuX2dldFBhZ2VUYXJnZXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShwYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJyaW5nUGFnZVRvcFxuICAgKiBAc2lnbmF0dXJlIGJyaW5nUGFnZVRvcChpdGVtLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbVxuICAgKiAgIFtlbl1QYWdlIFVSTCBvciBpbmRleCBvZiBhbiBleGlzdGluZyBwYWdlIGluIG5hdmlnYXRvcidzIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBrlVSTOOBi+OCguOBl+OBj+OBr29ucy1uYXZpZ2F0b3Ljga7jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CcmluZ3MgdGhlIGdpdmVuIHBhZ2UgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSBzdGFjayBpZiBpdCBhbHJlYWR5IGV4aXN0cyBvciBwdXNoZXMgaXQgaW50byB0aGUgc3RhY2sgaWYgZG9lc24ndC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga7kuIDnlarkuIrjgavnp7vli5XjgZfjgb7jgZnjgILjgoLjgZfmjIflrprjgZfjgZ/jg5rjg7zjgrjjgYznhKHjgYvjgaPjgZ/loLTlkIjmlrDjgZfjgY9wdXNo44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGJyaW5nUGFnZVRvcChpdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoWydudW1iZXInLCAnc3RyaW5nJ10uaW5kZXhPZih0eXBlb2YgaXRlbSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwYWdlIG5hbWUgb3IgdGhlIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UuIFlvdSBzdXBwbGllZCAnICsgaXRlbSk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInID8gdGhpcy5fbm9ybWFsaXplSW5kZXgoaXRlbSkgOiB0aGlzLl9sYXN0SW5kZXhPZlBhZ2UoaXRlbSk7XG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UoaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgICh7b3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFnZSk7XG4gICAgfVxuICAgIGlmICghcGFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCBpdGVtICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBwYWdlLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFnZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMpO1xuICB9XG5cbiAgX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoKHBhZ2UgPT09IG51bGwgfHwgcGFnZSA9PT0gdW5kZWZpbmVkKSAmJiBvcHRpb25zLnBhZ2UpIHtcbiAgICAgIHBhZ2UgPSBvcHRpb25zLnBhZ2U7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMsIHtwYWdlfSk7XG5cbiAgICByZXR1cm4ge3BhZ2UsIG9wdGlvbnN9O1xuICB9XG5cbiAgX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5wYWdlc1tpbmRleF0udXBkYXRlQmFja0J1dHRvbihpbmRleCA+IDApO1xuICAgIH1cbiAgfVxuXG4gIF9ub3JtYWxpemVJbmRleChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA+PSAwID8gaW5kZXggOiBNYXRoLmFicyh0aGlzLnBhZ2VzLmxlbmd0aCArIGluZGV4KSAlIHRoaXMucGFnZXMubGVuZ3RoO1xuICB9XG5cbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMucG9wUGFnZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xuICAgIH1cbiAgfVxuXG4gIF9sYXN0SW5kZXhPZlBhZ2UocGFnZU5hbWUpIHtcbiAgICBsZXQgaW5kZXg7XG4gICAgZm9yIChpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgaWYgKCF0aGlzLl9wYWdlTWFwLmhhcyh0aGlzLnBhZ2VzW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RoaXMgaXMgYnVnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZU5hbWUgPT09IHRoaXMuX3BhZ2VNYXAuZ2V0KHRoaXMucGFnZXNbaW5kZXhdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgX2VtaXRQcmVFdmVudChuYW1lLCBkYXRhID0ge30pIHtcbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmUnICsgbmFtZSwgdXRpbC5leHRlbmQoe1xuICAgICAgbmF2aWdhdG9yOiB0aGlzLFxuICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSxcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcbiAgICB9LCBkYXRhKSk7XG5cbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgfVxuXG4gIF9lbWl0UHJlUHVzaEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3B1c2gnKTtcbiAgfVxuXG4gIF9lbWl0UHJlUG9wRXZlbnQoKSB7XG4gICAgY29uc3QgbCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3BvcCcsIHtcbiAgICAgIGxlYXZlUGFnZTogdGhpcy5wYWdlc1tsIC0gMV0sXG4gICAgICBlbnRlclBhZ2U6IHRoaXMucGFnZXNbbCAtIDJdXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiDmm7jjgY3nm7TjgZlcbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCkge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKHRlbXBsYXRlSFRNTCkpO1xuICAgIHRoaXMuX3ZlcmlmeVBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50KTtcbiAgICByZXR1cm4gcGFnZUVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBfdmVyaWZ5UGFnZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIFwib25zLXBhZ2VcIiBlbGVtZW50IHRvIFwib25zLW5hdmlnYXRvclwiLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0b3BQYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHRvcCBwYWdlIGVsZW1lbnQuIFVzZSB0aGlzIG1ldGhvZCB0byBhY2Nlc3Mgb3B0aW9ucyBwYXNzZWQgYnkgYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5rjg7zjgrjjgpLlj5blvpfjgZfjgb7jgZnjgIJwdXNoUGFnZSgp44KEcmVzZXRUb1BhZ2UoKeODoeOCveODg+ODieOBruW8leaVsOOCkuWPluW+l+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgdG9wUGFnZSgpIHtcbiAgICBsZXQgbGFzdCA9IHRoaXMubGFzdEVsZW1lbnRDaGlsZDtcbiAgICB3aGlsZSAobGFzdCAmJiBsYXN0LnRhZ05hbWUgIT09ICdPTlMtUEFHRScpIHsgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZzsgfVxuICAgIHJldHVybiBsYXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlc1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29weSBvZiB0aGUgbmF2aWdhdG9yJ3MgcGFnZSBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKVxuICAgICAgLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09OUy1QQUdFJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURlZmF1bHQgb3B0aW9ucyBvYmplY3QuIEF0dHJpYnV0ZXMgaGF2ZSBwcmlvcml0eSBvdmVyIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5jYWxsYmFja1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIHNldCBfaXNSdW5uaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJywgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgfVxuICBnZXQgX2lzUnVubmluZygpIHtcbiAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycpKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMubG9hZGVkLnRoZW4oKCkgPT4gdGhpcy50b3BQYWdlICYmIHRoaXMudG9wUGFnZS5fc2hvdygpKVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy50b3BQYWdlICYmIHRoaXMudG9wUGFnZS5faGlkZSgpXG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBOYXZpZ2F0b3JBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBOYXZpZ2F0b3JFbGVtZW50Lk5hdmlnYXRvckFuaW1hdG9yJyk7XG4gICAgfVxuXG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IE5hdmlnYXRvckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBOYXZpZ2F0b3JBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZXB1c2gnLCAncG9zdHB1c2gnLCAncHJlcG9wJywgJ3Bvc3Rwb3AnXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5OYXZpZ2F0b3IgPSBOYXZpZ2F0b3JFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbmF2aWdhdG9yJywgTmF2aWdhdG9yRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3Rvb2xiYXInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndG9vbGJhci0tKicsXG4gICcudG9vbGJhcl9fbGVmdCc6ICd0b29sYmFyLS0qX19sZWZ0JyxcbiAgJy50b29sYmFyX19jZW50ZXInOiAndG9vbGJhci0tKl9fY2VudGVyJyxcbiAgJy50b29sYmFyX19yaWdodCc6ICd0b29sYmFyLS0qX19yaWdodCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvb2xiYXJcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgIFtlbl1UcmFuc3BhcmVudCB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV3pgI/mmI7jgarog4zmma/jgpLmjIHjgaTjg4Tjg7zjg6vjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGNvdmVyLWNvbnRlbnRcbiAqICAgW2VuXURpc3BsYXlzIHRoZSB0b29sYmFyIG9uIHRvcCBvZiB0aGUgcGFnZSdzIGNvbnRlbnQuIFNob3VsZCBiZSBjb21iaW5lZCB3aXRoIGB0cmFuc3BhcmVudGAgbW9kaWZpZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9zaGFkb3dcbiAqICAgW2VuXVRvb2xiYXIgd2l0aG91dCBzaGFkb3cuWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBq+W9seOCkuS7mOOBkeOBmuOBq+ihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRvb2xiYXIgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBuYXZpZ2F0aW9uLlxuICpcbiAqICAgICBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGNsYXNzIG5hbWVzLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYXMgYSBNYXRlcmlhbCBEZXNpZ24gdG9vbGJhciB3aGVuIHJ1bm5pbmcgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44OK44OT44Ky44O844K344On44Oz44Gn5L2/55So44GZ44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Kv44Op44K55ZCN44Gr44KI44KK44CB5bem44CB5Lit5aSu44CB5Y+z44Gu44Kz44Oz44OG44OK44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGNvbXBpbGF0aW9uLmh0bWwjdG9vbGJhci1jb21waWxhdGlvbiBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYm90dG9tLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1ib3R0b20tdG9vbGJhcj5gIGRpc3BsYXlzIGEgdG9vbGJhciBvbiB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtYm90dG9tLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWJhY2stYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtYmFjay1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhci1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyLWJ1dHRvbj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIHRvb2xiYXIgYnV0dG9uIGluc2lkZSB0aGUgdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLXRvb2xiYXItYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgICAgQmFja1xuICogICAgICAgPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgVGl0bGVcbiAqICAgICA8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICAgIDxvbnMtaWNvbiBpY29uPVwibWQtbWVudVwiPjwvb25zLWljb24+XG4gKiAgICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9vbnMtdG9vbGJhcj5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5saW5lXG4gICAqIEBpbml0b25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGlzcGxheSB0aGUgdG9vbGJhciBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjgpLjgqTjg7Pjg6njgqTjg7Pjgavnva7jgY3jgb7jgZnjgILjgrnjgq/jg63jg7zjg6vpoJjln5/lhoXjgavjgZ3jga7jgb7jgb7ooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmxlZnQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5jZW50ZXInKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLnJpZ2h0JykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9fbGFiZWwnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbiAuYmFjay1idXR0b25fX2ljb24nKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICB0aGlzLl9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgIC8vIGNhc2Ugb2Ygbm90IGVsZW1lbnRcbiAgICAgIGlmICh0aGlzLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGROb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ2NlbnRlcicpO1xuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCd0b29sYmFyX190aXRsZScpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICF0aGlzLmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnbGVmdCcpO1xuICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgncmlnaHQnKTtcblxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bMF0gIT09IGxlZnQgfHwgdGhpcy5jaGlsZHJlblsxXSAhPT0gY2VudGVyIHx8IHRoaXMuY2hpbGRyZW5bMl0gIT09IHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGVmdCk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChyaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Vuc3VyZVRvb2xiYXJFbGVtZW50KG5hbWUpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy50b29sYmFyX18nICsgbmFtZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRvb2xiYXJfXycgKyBuYW1lKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLicgKyBuYW1lKSB8fCB1dGlsLmNyZWF0ZSgnLicgKyBuYW1lKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Rvb2xiYXJfXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5Ub29sYmFyID0gVG9vbGJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10b29sYmFyJywgVG9vbGJhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vb25zL2ludGVybmFsL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5pbXBvcnQgJy4vb25zLXRvb2xiYXInOyAvLyBlbnN1cmVzIHRoYXQgJ29ucy10b29sYmFyJyBlbGVtZW50IGlzIHJlZ2lzdGVyZWRcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdwYWdlJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdwYWdlLS0qJyxcbiAgJy5wYWdlX19jb250ZW50JzogJ3BhZ2UtLSpfX2NvbnRlbnQnLFxuICAnLnBhZ2VfX2JhY2tncm91bmQnOiAncGFnZS0tKl9fYmFja2dyb3VuZCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXBhZ2VcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIHRoZSByb290IG9mIGVhY2ggcGFnZS4gSWYgdGhlIGNvbnRlbnQgaXMgbGFyZ2UgaXQgd2lsbCBiZWNvbWUgc2Nyb2xsYWJsZS5cbiAqXG4gKiAgICAgQSBuYXZpZ2F0aW9uIGJhciBjYW4gYmUgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSB1c2luZyB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjlrprnvqnjga7jgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7lhoXlrrnjga/jgrnjgq/jg63jg7zjg6vjgYzoqLHlj6/jgZXjgozjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBsaWZlY3ljbGUuaHRtbCNldmVudHNcbiAqICAgW2VuXU92ZXJ2aWV3IG9mIHBhZ2UgZXZlbnRzWy9lbl1cbiAqICAgW2phXU92ZXJ2aWV3IG9mIHBhZ2UgZXZlbnRzWy9qYV1cbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVVzZSB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQgdG8gYWRkIGEgbmF2aWdhdGlvbiBiYXIgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8cD5QYWdlIGNvbnRlbnQ8L3A+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICBteUFwcC5oYW5kbGVyID0gZnVuY3Rpb24oZG9uZSkge1xuICogICAgIGxvYWRNb3JlKCkudGhlbihkb25lKTtcbiAqICAgfVxuICogPC9zY3JpcHQ+XG4gKlxuICogPG9ucy1wYWdlIG9uLWluZmluaXRlLXNjcm9sbD1cIm15QXBwLmhhbmRsZXJcIj5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5MaXN0PC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8b25zLWxpc3Q+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzE8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzI8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzM8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLWxpc3Q+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGluaXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGF0dGFjaGVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOOCouOCv+ODg+ODgeOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgc2hvd24uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6KGo56S644GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBkZXN0cm95XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBiZWZvcmUgdGhlIHBhZ2UgaXMgZGVzdHJveWVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOegtOajhOOBleOCjOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IG1vZGlmaWVyIG5hbWUgdG8gc3BlY2lmeSBjdXN0b20gc3R5bGVzLlsvZW5dXG4gICAqICAgW2phXeOCueOCv+OCpOODq+Wumue+qeOCkuOCq+OCueOCv+ODnuOCpOOCuuOBmeOCi+OBn+OCgeOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9uLWluZmluaXRlLXNjcm9sbFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGF0aCBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gaW5maW5pdGUgc2Nyb2xsaW5nLiBFeGFtcGxlOiBgYXBwLmxvYWREYXRhYC4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fZGVyaXZlSG9va3MoKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fY29udGVudE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fdHJ5VG9TdXBwcmVzc0xheWVyQ3JlYXRpb24oKTtcbiAgICB9KTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG5cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRFbGVtZW50ID0gdGhpcy5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKTtcblxuICAgICAgdGhpcy5fY29udGVudE9ic2VydmVyLm9ic2VydmUodGhpcy5fY29udGVudEVsZW1lbnQsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgIHRoaXMuX3RyeVRvU3VwcHJlc3NMYXllckNyZWF0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICBfdHJ5VG9TdXBwcmVzc0xheWVyQ3JlYXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jb250ZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudDtcbiAgICBjb25zdCBzY3JvbGxlclNldCA9IG5ldyBTZXQoW1xuICAgICAgJ29ucy1uYXZpZ2F0b3InLFxuICAgICAgJ29ucy1wYWdlJyxcbiAgICAgICdvbnMtdGFiYmFyJyxcbiAgICAgICdvbnMtc3BsaXR0ZXInXG4gICAgXSk7XG5cbiAgICBjb25zdCBzaG91bGRTdXBwcmVzcyA9IGNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHNjcm9sbGVyU2V0Lmhhcyhjb250ZW50LmNoaWxkcmVuWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgLy8gSWYgY29udGVudCBlbGVtZW50IGhhcyBvbmx5IG9uZSBlbGVtZW50IGFuZCB0aGUgZWxlbWVudCBoYXMgc2Nyb2xsIGNvbnRlbnQsIHRoZXJlIGlzIG5vIG5lZWQgZm9yIGxheWVyIGNyZWF0aW9uIGluIHRoaXMgY29udGVudCBlbGVtZW50LlxuICAgIGlmIChzaG91bGRTdXBwcmVzcykge1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdwYWdlX19jb250ZW50LS1zdXBwcmVzcy1sYXllci1jcmVhdGlvbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3BhZ2VfX2NvbnRlbnQtLXN1cHByZXNzLWxheWVyLWNyZWF0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBjb25zdCB0b29sYmFyID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJyk7XG5cbiAgICBjb25zdCBiYWNrZ3JvdW5kID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJykgfHwgdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrZ3JvdW5kJykgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFja2dyb3VuZC5jbGFzc0xpc3QuYWRkKCdwYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgdGhpcy5pbnNlcnRCZWZvcmUoYmFja2dyb3VuZCwgIXRvb2xiYXIgJiYgdGhpcy5maXJzdENoaWxkIHx8IHRvb2xiYXIgJiYgdG9vbGJhci5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCBjb250ZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19jb250ZW50JykgfHwgdXRpbC5maW5kQ2hpbGQodGhpcywgJy5jb250ZW50JykgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdwYWdlX19jb250ZW50Jyk7XG4gICAgaWYgKCFjb250ZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEgfHwgdGhpcy5fZWxlbWVudFNob3VsZEJlTW92ZWQobm9kZSkpIHtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUpOyAvLyBDYW4gdHJpZ2dlciBkZXRhY2hlZCBjb25uZWN0ZWRDYWxsYmFja3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJ5VG9GaWxsU3RhdHVzQmFyKGNvbnRlbnQpOyAvLyBNdXN0IHJ1biBiZWZvcmUgY2hpbGQgcGFnZXMgdHJ5IHRvIGZpbGwgc3RhdHVzIGJhci5cbiAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50LCBiYWNrZ3JvdW5kLm5leHRTaWJsaW5nKTsgLy8gQ2FuIHRyaWdnZXIgYXR0YWNoZWQgY29ubmVjdGVkQ2FsbGJhY2tzXG5cbiAgICAvLyBNYWtlIHdyYXBwZXIgcGFnZXMgdHJhbnNwYXJlbnQgZm9yIGFuaW1hdGlvbnNcbiAgICBpZiAoIWJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yXG4gICAgICAmJiAoIXRvb2xiYXIgfHwgIXV0aWwuaGFzTW9kaWZpZXIodG9vbGJhciwgJ3RyYW5zcGFyZW50JykpXG4gICAgICAmJiBjb250ZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMVxuICAgICAgJiYgdXRpbC5pc1BhZ2VDb250cm9sKGNvbnRlbnQuY2hpbGRyZW5bMF0pXG4gICAgKSB7XG4gICAgICAgIGJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZWxlbWVudFNob3VsZEJlTW92ZWQoZWwpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlX19iYWNrZ3JvdW5kJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJ29ucy1mYWInKSB7XG4gICAgICByZXR1cm4gIWVsLmhhc0F0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZml4ZWRFbGVtZW50cyA9IFsnc2NyaXB0JywgJ29ucy10b29sYmFyJywgJ29ucy1ib3R0b20tdG9vbGJhcicsICdvbnMtbW9kYWwnLCAnb25zLXNwZWVkLWRpYWwnLCAnb25zLWRpYWxvZycsICdvbnMtYWxlcnQtZGlhbG9nJywgJ29ucy1wb3BvdmVyJywgJ29ucy1hY3Rpb24tc2hlZXQnXTtcbiAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKCdpbmxpbmUnKSB8fCBmaXhlZEVsZW1lbnRzLmluZGV4T2YodGFnTmFtZSkgPT09IC0xO1xuICB9XG5cbiAgX3RyeVRvRmlsbFN0YXR1c0Jhcihjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQpIHtcbiAgICBpbnRlcm5hbC5hdXRvU3RhdHVzQmFyRmlsbCgoKSA9PiB7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJyxcbiAgICAgICAgIXV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSkgLy8gTm90IGFscmVhZHkgZmlsbGVkXG4gICAgICAgICYmICh0aGlzLl9jYW5BbmltYXRlVG9vbGJhcihjb250ZW50KSB8fCAhdXRpbC5maW5kQ2hpbGQoY29udGVudCwgdXRpbC5pc1BhZ2VDb250cm9sKSkgLy8gSGFzIHRvb2xiYXIgb3IgY2Fubm90IGRlbGVnYXRlXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgX2NhbkFuaW1hdGVUb29sYmFyKGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudCkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKGNvbnRlbnQsIGVsID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGVsLCAnb25zLXRvb2xiYXInKSAmJiAhZWwuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5pc0F0dGFjaGVkKHRoaXMpKSB7IC8vIEF2b2lkIGRldGFjaGVkIGNhbGxzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3RyeVRvRmlsbFN0YXR1c0JhcigpOyAvLyBFbnN1cmUgc3RhdHVzIGJhciB3aGVuIHRoZSBlbGVtZW50IHdhcyBjb21waWxlZCBiZWZvcmUgY29ubmVjdGVkXG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ29uLWluZmluaXRlLXNjcm9sbCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbkluaXQgJiYgdGhpcy5vbkluaXQoKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2luaXQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF1dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50KHRoaXMpKSB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQmFja0J1dHRvbihzaG93KSB7XG4gICAgaWYgKHRoaXMuYmFja0J1dHRvbikge1xuICAgICAgc2hvdyA/IHRoaXMuYmFja0J1dHRvbi5zaG93KCkgOiB0aGlzLmJhY2tCdXR0b24uaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIHNldCBuYW1lKHN0cikge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJywgc3RyKTtcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICB9XG5cbiAgZ2V0IGJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uSW5maW5pdGVTY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBzY3JvbGxpbmcgdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayBhcyBhbiBhcmd1bWVudCB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgb25JbmZpbml0ZVNjcm9sbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uSW5maW5pdGVTY3JvbGwgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX29uSW5maW5pdGVTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5faW5maW5pdGVTY3JvbGxMaW1pdCA9IDAuOTtcbiAgICAgICAgdGhpcy5fYm91bmRPblNjcm9sbCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9jb250ZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgb25JbmZpbml0ZVNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25JbmZpbml0ZVNjcm9sbDtcbiAgfVxuXG4gIF9vblNjcm9sbCgpIHtcbiAgICBjb25zdCBjID0gdGhpcy5fY29udGVudEVsZW1lbnQsXG4gICAgICBvdmVyTGltaXQgPSAoYy5zY3JvbGxUb3AgKyBjLmNsaWVudEhlaWdodCkgLyBjLnNjcm9sbEhlaWdodCA+PSB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0O1xuXG4gICAgaWYgKHRoaXMuX29uSW5maW5pdGVTY3JvbGwgJiYgIXRoaXMuX2xvYWRpbmdDb250ZW50ICYmIG92ZXJMaW1pdCkge1xuICAgICAgdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCgoKSA9PiB0aGlzLl9sb2FkaW5nQ29udGVudCA9IGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGdldCBzY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIHNldCBzY3JvbGxUb3AobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9jb250ZW50RWxlbWVudC5zY3JvbGxUb3AgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIF9nZXRDb250ZW50RWxlbWVudCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcignZmFpbCB0byBnZXQgXCIucGFnZV9fY29udGVudFwiIGVsZW1lbnQuJyk7XG4gIH1cblxuICBfZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ2ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2JhY2tncm91bmRcIiBlbGVtZW50LicpO1xuICB9XG5cbiAgX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICBfZ2V0VG9vbGJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy10b29sYmFyJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdvbi1pbmZpbml0ZS1zY3JvbGwnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvbi1pbmZpbml0ZS1zY3JvbGwnOlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkluZmluaXRlU2Nyb2xsID0gKGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IGY7XG4gICAgICAgICAgICBmKGRvbmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duICYmIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSkge1xuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgICB0aGlzLm9uU2hvdyAmJiB0aGlzLm9uU2hvdygpO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdzaG93Jyk7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5vbkhpZGUgJiYgdGhpcy5vbkhpZGUoKTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnaGlkZScpO1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5faGlkZSgpO1xuXG4gICAgdGhpcy5vbkRlc3Ryb3kgJiYgdGhpcy5vbkRlc3Ryb3koKTtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Rlc3Ryb3knKTtcblxuICAgIGlmICh0aGlzLm9uRGV2aWNlQmFja0J1dHRvbikge1xuICAgICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIF9kZXJpdmVIb29rcygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICdvbicgKyBldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHRoaXNbYF8ke2tleX1gXSxcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9IGhvb2sgbXVzdCBiZSBhIGZ1bmN0aW9uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNbYF8ke2tleX1gXSA9IHZhbHVlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnaW5pdCcsICdzaG93JywgJ2hpZGUnLCAnZGVzdHJveSddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlcidzIGN1c3RvbSBkYXRhIHBhc3NlZCB0byBgcHVzaFBhZ2UoKWAtbGlrZSBtZXRob2RzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5vbnMuZWxlbWVudHMuUGFnZSA9IFBhZ2VFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcGFnZScsIFBhZ2VFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBjbGFzcyBQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgX2FuaW1hdGUoZWxlbWVudCwge2Zyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaywgcmVzdG9yZSA9IGZhbHNlLCBhbmltYXRpb259KSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgZnJvbSA9IGFuaW1hdGlvbi5mcm9tO1xuICAgICAgdG8gPSBhbmltYXRpb24udG87XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uID0gYW5pbWl0KGVsZW1lbnQpO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uc2F2ZVN0eWxlKCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZShmcm9tKS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgIGNzczogdG8sXG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICB9KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnJlc3RvcmVTdHlsZSgpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIF9hbmltYXRlQWxsKGVsZW1lbnQsIGFuaW1hdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhbmltYXRpb25zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9hbmltYXRlKGVsZW1lbnRba2V5XSwgYW5pbWF0aW9uc1trZXldKS5wbGF5KCkpO1xuICB9XG5cbn1cblxuY29uc3QgZmFkZSA9IHtcbiAgb3V0OiB7XG4gICAgZnJvbToge29wYWNpdHk6IDEuMH0sXG4gICAgdG86IHtvcGFjaXR5OiAwfVxuICB9LFxuICBpbjoge1xuICAgIGZyb206IHtvcGFjaXR5OiAwfSxcbiAgICB0bzoge29wYWNpdHk6IDEuMH1cbiAgfVxufTtcblxuZXhwb3J0IGNsYXNzIE1ERmFkZVBvcG92ZXJBbmltYXRvciBleHRlbmRzIFBvcG92ZXJBbmltYXRvciB7XG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLmluLFxuICAgICAgX3BvcG92ZXI6IHthbmltYXRpb246IGZhZGUuaW4sIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG5cbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUub3V0LFxuICAgICAgX3BvcG92ZXI6IHthbmltYXRpb246IGZhZGUub3V0LCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSU9TRmFkZVBvcG92ZXJBbmltYXRvciBleHRlbmRzIE1ERmFkZVBvcG92ZXJBbmltYXRvciB7XG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLmluLFxuICAgICAgX3BvcG92ZXI6IHtcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4zLCAxLjMsIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMCwgMS4wLCAgMS4wKScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3RvcmU6IHRydWUsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8vIFRoaXMgb2JqZWN0IHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2Vycy4gUGxlYXNlIGtlZXAgdGhpcyBwcml2YXRlLlxuY29uc3QgaVBob25lWFBhdGNoID0ge307XG5cbmlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlID0gKCkgPT4ge1xuICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnb25zZmxhZy1pcGhvbmV4LXBvcnRyYWl0JykgIT0gbnVsbCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodDtcbn1cblxuaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlID0gKCkgPT4ge1xuICAvLyBJZiB3aWR0aCA9PT0gaGVpZ2h0LCB0cmVhdCBpdCBhcyBsYW5kc2NhcGVcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29uc2ZsYWctaXBob25leC1sYW5kc2NhcGUnKSAhPSBudWxsICYmIHdpbmRvdy5pbm5lcldpZHRoID49IHdpbmRvdy5pbm5lckhlaWdodDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzYWZlIGFyZWEgbGVuZ3RocyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2FmZSBhcmVhcy5cbiAqL1xuaVBob25lWFBhdGNoLmdldFNhZmVBcmVhTGVuZ3RocyA9ICgpID0+IHtcbiAgbGV0IHNhZmVBcmVhTGVuZ3RocztcbiAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICBzYWZlQXJlYUxlbmd0aHMgPSB7XG4gICAgICB0b3A6IDQ0LFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDM0LFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICBzYWZlQXJlYUxlbmd0aHMgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogNDQsXG4gICAgICBib3R0b206IDIxLFxuICAgICAgbGVmdDogNDRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNhZmVBcmVhTGVuZ3RocyA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc2FmZUFyZWFMZW5ndGhzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNhZmUgYXJlYSByZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzYWZlIGFyZWFzLlxuICovXG5pUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFET01SZWN0ID0gKCkgPT4ge1xuICBsZXQgc2FmZUFyZWFSZWN0O1xuICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgIHNhZmVBcmVhUmVjdCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiA0NCwgLyogMCArIDQ0ICh0b3Agc2FmZSBhcmVhKSAqL1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSA3OCAvKiBoZWlnaHQgLSA0NCAodG9wIHNhZmUgYXJlYSkgLSAzNCAoYm90dG9tIHNhZmUgYXJlYSkgKi9cbiAgICB9O1xuICB9IGVsc2UgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSgpKSB7XG4gICAgc2FmZUFyZWFSZWN0ID0ge1xuICAgICAgeDogNDQsIC8qIDAgKyA0NCAobGVmdCBzYWZlIGFyZWEpICovXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC0gODgsIC8qIHdpZHRoIC0gNDQgKGxlZnQgc2FmZSBhcmVhKSAtIDM0IChyaWdodCBzYWZlIGFyZWEpICovXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAtIDIxIC8qIGhlaWdodCAtIDIxIChib3R0b20gc2FmZSBhcmVhKSAqL1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2FmZUFyZWFSZWN0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnNhZmVBcmVhUmVjdCxcbiAgICBsZWZ0OiBzYWZlQXJlYVJlY3QueCxcbiAgICB0b3A6IHNhZmVBcmVhUmVjdC55LFxuICAgIHJpZ2h0OiBzYWZlQXJlYVJlY3QueCArIHNhZmVBcmVhUmVjdC53aWR0aCxcbiAgICBib3R0b206IHNhZmVBcmVhUmVjdC55ICsgc2FmZUFyZWFSZWN0LmhlaWdodFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpUGhvbmVYUGF0Y2g7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7IFBvcG92ZXJBbmltYXRvciwgSU9TRmFkZVBvcG92ZXJBbmltYXRvciwgTURGYWRlUG9wb3ZlckFuaW1hdG9yIH0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBpUGhvbmVYUGF0Y2ggZnJvbSAnLi4vLi4vb25zL2lwaG9uZXgtcGF0Y2gnO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wb3BvdmVyJzogJ3BvcG92ZXItLSonLFxuICAnLnBvcG92ZXItbWFzayc6ICdwb3BvdmVyLW1hc2stLSonLFxuICAnLnBvcG92ZXJfX2NvbnRlbnQnOiAncG9wb3Zlci0tKl9fY29udGVudCcsXG4gICcucG9wb3Zlcl9fYXJyb3cnOiAncG9wb3Zlci0tKl9fYXJyb3cnXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgJ25vbmUnOiBQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlUG9wb3ZlckFuaW1hdG9yXG59O1xuXG5jb25zdCBwb3NpdGlvbnMgPSB7XG4gIHVwOiAnYm90dG9tJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgZG93bjogJ3RvcCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuLyoqXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cbiAqXG4gKiAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVQb3BvdmVyKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC4gRm9yIE1hdGVyaWFsIERlc2lnbiwgcG9wb3ZlciBsb29rcyBleGFjdGx5IGFzIGEgZHJvcGRvd24gbWVudS5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcG9wb3ZlclxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XG4gKiAgIENsaWNrIG1lIVxuICogPC9vbnMtYnV0dG9uPlxuICpcbiAqIDxvbnMtcG9wb3ZlciBkaXJlY3Rpb249XCJkb3duXCIgaWQ9XCJwb3BvdmVyXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBwb3BvdmVyITwvcD5cbiAqIDwvb25zLXBvcG92ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHZhciBwb3BvdmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcG92ZXInKTtcbiAqICAgICBwb3BvdmVyLnNob3coZWxlbWVudCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAg5oyH5a6a44Gn44GN44KL5pa55ZCR44Gv44CBXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBrjTjgaTjgafjgZnjgILnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJcbiAgICogICAg6KSH5pWw5oyH5a6a44GV44KM44Gf5aC05ZCI44CB5a++6LGh44Go44GZ44KL6KaB57Sg44Gr5ZCI44KP44Gb44Gm5oyH5a6a44GX44Gf5YCk44GL44KJ6Ieq5YuV55qE44Gr6YG45oqe44GV44KM44G+44GZ44CCXG4gICAqICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHNldCB0aGUgcG9wb3ZlciB3aWxsIGNvdmVyIHRoZSB0YXJnZXQgb24gdGhlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXItbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9wb3BvdmVyKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXInKTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgX2Fycm93KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2Fycm93Jyk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogUG9wb3ZlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1BvcG92ZXJBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gIH1cblxuICBfdG9nZ2xlU3R5bGUoc2hvdWxkU2hvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIob3B0aW9ucy50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLl9jbGVhclN0eWxlcygpO1xuICAgIH1cbiAgfVxuXG4gIF9wb3NpdGlvblBvcG92ZXIodGFyZ2V0KSB7XG4gICAgY29uc3Qge19yYWRpdXM6IHJhZGl1cywgX2NvbnRlbnQ6IGNvbnRlbnRFbGVtZW50LCBfbWFyZ2luOiBtYXJnaW59ID0gdGhpcztcbiAgICBjb25zdCBzYWZlQXJlYUxlbmd0aHMgPSBpUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFMZW5ndGhzKCk7XG4gICAgY29uc3Qgc2FmZUFyZWFSZWN0ID0gaVBob25lWFBhdGNoLmdldFNhZmVBcmVhRE9NUmVjdCgpO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaXNNRCA9IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJyk7XG4gICAgY29uc3QgY292ZXIgPSBpc01EICYmIHRoaXMuaGFzQXR0cmlidXRlKCdjb3Zlci10YXJnZXQnKTtcblxuICAgIC8vIERpc3RhbmNlIGZyb20gZWFjaCBzaWRlIG9mIHRoZSBzYWZlIGFyZWEgKHdpdGggbWFyZ2luKSB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBjb25zdCB0YXJnZXREaXN0YW5jZSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgLSAoc2FmZUFyZWFSZWN0LnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgLSAoc2FmZUFyZWFSZWN0LmxlZnQgKyBtYXJnaW4pLFxuICAgICAgYm90dG9tOiAoc2FmZUFyZWFSZWN0LmJvdHRvbSAtIG1hcmdpbikgLSB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHJpZ2h0OiAoc2FmZUFyZWFSZWN0LnJpZ2h0IC0gbWFyZ2luKSAtIHRhcmdldFJlY3QucmlnaHRcbiAgICB9O1xuXG4gICAgLy8gRGlzdGFuY2UgZnJvbSBlYWNoIHNpZGUgb2YgdGhlIHNhZmUgYXJlYSAod2l0aCBtYXJnaW4pIHRvIHRoZSBnZW9tZXRyaWMgY2VudGVyIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIGNvbnN0IHRhcmdldENlbnRlckRpc3RhbmNlRnJvbSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3QuaGVpZ2h0IC8gMikgLSAoc2FmZUFyZWFSZWN0LnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3Qud2lkdGggLyAyKSAtIChzYWZlQXJlYVJlY3QubGVmdCArIG1hcmdpbiksXG4gICAgICBib3R0b206IChzYWZlQXJlYVJlY3QuYm90dG9tIC0gbWFyZ2luKSAtIHRhcmdldFJlY3QuYm90dG9tICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LmhlaWdodCAvIDIpLFxuICAgICAgcmlnaHQ6IChzYWZlQXJlYVJlY3QucmlnaHQgLSBtYXJnaW4pIC0gdGFyZ2V0UmVjdC5yaWdodCArIE1hdGgucm91bmQodGFyZ2V0UmVjdC53aWR0aCAvIDIpXG4gICAgfTtcblxuICAgIGNvbnN0IHt2ZXJ0aWNhbCwgcHJpbWFyeTogcHJpbWFyeURpcmVjdGlvbiwgc2Vjb25kYXJ5OiBzZWNvbmRhcnlEaXJlY3Rpb259ID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyh0YXJnZXREaXN0YW5jZSk7XG4gICAgdGhpcy5fY3VycmVudERpcmVjdGlvbiA9IHByaW1hcnlEaXJlY3Rpb247XG4gICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCBwcmltYXJ5RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IHNpemVOYW1lID0gdmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgLy8gR2V0IC5wb3BvdmVyX19jb250ZW50IHNpemVcbiAgICBjb25zdCBjb250ZW50U2l6ZSA9IChzdHlsZSA9PiAoe1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyksIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JyksIDEwKVxuICAgIH0pKSh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50RWxlbWVudCkpO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3ZlciBwb3NpdGlvbi5cbiAgICBjb25zdCB0YXJnZXRBbmRBcnJvd0xlbmd0aCA9IGNvdmVyID8gMCA6ICh2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCkgKyAoaXNNRCA/IDAgOiAxNCk7XG4gICAgY29uc3QgcHJpbWFyeU9mZnNldCA9IE1hdGgubWF4KFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luLFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0RGlzdGFuY2VbcHJpbWFyeURpcmVjdGlvbl0gKyB0YXJnZXRBbmRBcnJvd0xlbmd0aFxuICAgICk7XG4gICAgY29uc3Qgc2Vjb25kYXJ5T2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgICBzYWZlQXJlYUxlbmd0aHNbc2Vjb25kYXJ5RGlyZWN0aW9uXSArIG1hcmdpbixcbiAgICAgIHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0Q2VudGVyRGlzdGFuY2VGcm9tW3NlY29uZGFyeURpcmVjdGlvbl0gLSAoY29udGVudFNpemVbc2l6ZU5hbWVdIC8gMilcbiAgICApO1xuICAgIHRoaXMuX3BvcG92ZXIuc3R5bGVbcHJpbWFyeURpcmVjdGlvbl0gPSBwcmltYXJ5T2Zmc2V0ICsgJ3B4JztcbiAgICB0aGlzLl9wb3BvdmVyLnN0eWxlW3NlY29uZGFyeURpcmVjdGlvbl0gPSBzZWNvbmRhcnlPZmZzZXQgKyAncHgnO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3Zlcl9fYXJyb3cgcG9zaXRpb24uXG4gICAgdGhpcy5fYXJyb3cuc3R5bGVbc2Vjb25kYXJ5RGlyZWN0aW9uXSA9IE1hdGgubWF4KFxuICAgICAgcmFkaXVzLFxuICAgICAgKHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luKSArIHRhcmdldENlbnRlckRpc3RhbmNlRnJvbVtzZWNvbmRhcnlEaXJlY3Rpb25dIC0gc2Vjb25kYXJ5T2Zmc2V0XG4gICAgKSArICdweCc7XG4gIH1cblxuICBfY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpIHx8ICd1cCBkb3duIGxlZnQgcmlnaHQnKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IHBvc2l0aW9uc1tlXSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gZGlzdGFuY2VbYV0gLSBkaXN0YW5jZVtiXSlbMF07XG4gICAgY29uc3QgdmVydGljYWwgPSAndG9wJyA9PSBwcmltYXJ5IHx8ICdib3R0b20nID09IHByaW1hcnk7XG4gICAgbGV0IHNlY29uZGFyeTtcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UubGVmdCA8IGRpc3RhbmNlLnJpZ2h0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UudG9wIDwgZGlzdGFuY2UuYm90dG9tID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4ge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9O1xuICB9XG5cbiAgX2NsZWFyU3R5bGVzKCkge1xuICAgIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuX2Fycm93LnN0eWxlW2VdID0gdGhpcy5fY29udGVudC5zdHlsZVtlXSA9IHRoaXMuX3BvcG92ZXIuc3R5bGVbZV0gPSAnJztcbiAgICAgIHV0aWwucmVtb3ZlTW9kaWZpZXIodGhpcywgZSk7XG4gICAgfSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3Zlcih0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3BvcG92ZXIgJiYgdGhpcy5fbWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0RlZmF1bHRDb250YWluZXIgPSB0aGlzLl9wb3BvdmVyICYmIHRoaXMuX2NvbnRlbnQ7XG5cbiAgICBpZiAoaGFzRGVmYXVsdENvbnRhaW5lcikge1xuXG4gICAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItbWFzaycpO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2Fycm93KSB7XG4gICAgICAgIGNvbnN0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFycm93LmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXJfX2Fycm93Jyk7XG4gICAgICAgIHRoaXMuX3BvcG92ZXIuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3ZlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250ZW50XCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2Fycm93XCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnBvcG92ZXJfX2NvbnRlbnQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FIVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgdGhpcy5fcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3codGFyZ2V0LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuIENhbiBiZSBlaXRoZXIgYSBDU1Mgc2VsZWN0b3IsIGFuIGV2ZW50IG9iamVjdCBvciBhIERPTSBlbGVtZW50LiBJdCBjYW4gYmUgYWxzbyBwcm92aWRlZCBhcyAnb3B0aW9ucy50YXJnZXQnIGluc3RlYWQuIFsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCv+ODvOOCsuODg+ODiOOBqOOBquOCi+imgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAgkNTU+OCu+ODrOOCr+OCv+OBi2V2ZW5044Kq44OW44K444Kn44Kv44OI44GLRE9N6KaB57Sg44Gu44GE44Ga44KM44GL44KS5rih44Gb44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIHRoZSBwb3BvdmVyIGFuZCBwb2ludCBpdCBhdCBhIHRhcmdldC4gVGhlIHRhcmdldCBjYW4gYmUgZWl0aGVyIGFuIGV2ZW50LCBhIENTUyBzZWxlY3RvciBvciBhIERPTSBlbGVtZW50Li5bL2VuXVxuICAgKiAgIFtqYV3lr77osaHjgajjgZnjgovopoHntKDjgavjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJ0YXJnZXTlvJXmlbDjgavjga/jgIEkZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgoRET03jgqjjg6zjg6Hjg7Pjg4jjgoRDU1Pjgrvjg6zjgq/jgr/jgpLmuKHjgZnjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIENvcHkgb3B0aW9ucyBhbmQgaW5jbHVkZSBvcHRpb25zLnRhcmdldFxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSB7IC4uLnRhcmdldCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0YXJnZXQgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvbnMudGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50YXJnZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGFyZ2V0IG9yIG9wdGlvbnMudGFyZ2V0IGFyZ3VtZW50IG11c3QgYmUgZGVmaW5lZCBmb3IgdGhlIHBvcG92ZXIuJyk7XG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucy50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhcmdldCBmb3IgcG9wb3Zlci4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc2hvdyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIHRoZSBwb3BvdmVyLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgY2FuY2VsYWJsZSBvciBub3QuXG4gICAqXG4gICAqICAgICBXaGVuIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgaXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgdGhpcy5fbWFyZ2luID0gdGhpcy5fbWFyZ2luIHx8IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoJ3RvcCcpKTtcbiAgICB0aGlzLl9tYXJnaW4gPSB0aGlzLl9tYXJnaW4gfHwgNjsgLy8gRml4IGZvciBpZnJhbWVzXG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fcmFkaXVzID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAnZGlyZWN0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnZGlyZWN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kT25DaGFuZ2UoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24gJiYgdXRpbC5hZGRNb2RpZmllcih0aGlzLCB0aGlzLl9jdXJyZW50RGlyZWN0aW9uKTtcbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7UG9wb3ZlckFuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb3BvdmVyQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgUG9wb3ZlckFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBQb3BvdmVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXJBbmltYXRvcjtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuUG9wb3ZlciA9IFBvcG92ZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcG9wb3ZlcicsIFBvcG92ZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucHJvZ3Jlc3MtYmFyJzogJ3Byb2dyZXNzLWJhci0tKicsXG4gICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWJhci0tKl9fcHJpbWFyeScsXG4gICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknOiAncHJvZ3Jlc3MtYmFyLS0qX19zZWNvbmRhcnknXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnlcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19wcmltYXJ5XCI+PC9kaXY+XG4gIDwvZGl2PlxuYCk7XG5cbmNvbnN0IElOREVUID0gJ2luZGV0ZXJtaW5hdGUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wcm9ncmVzcy1iYXJcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhlIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBsaW5lYXIgcHJvZ3Jlc3MgYmFyLiBJdCBjYW4gZWl0aGVyIGRpc3BsYXkgYSBwcm9ncmVzcyBiYXIgdGhhdCBzaG93cyB0aGUgdXNlciBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkLiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgcGVyY2VudGFnZSBpcyBub3Qga25vd24gaXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhbiBhbmltYXRlZCBwcm9ncmVzcyBiYXIgc28gdGhlIHVzZXIgY2FuIHNlZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB6dlFiR2pcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wcm9ncmVzc1xuICogQHNlZWFsc28gb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1iYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxuICpcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NCYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NvbXBpbGVkKCkpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fcHJpbWFyeScpO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5Jyk7XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9pc0NvbXBpbGVkKCkge1xuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhckVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZChiYXJFbGVtZW50LCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3ZhbHVlJywgJ3NlY29uZGFyeS12YWx1ZScsIElOREVUXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpICYmIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdzZWNvbmRhcnktdmFsdWUnKSB7XG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gSU5ERVQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB1dGlsLnRvZ2dsZU1vZGlmaWVyKHRoaXMsIElOREVULCB7IGZvcmNlOiB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCkgfSkpO1xuICB9XG5cbiAgX3VwZGF0ZVZhbHVlKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlLndpZHRoID0gKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICAgIHRoaXMuX3NlY29uZGFyeS5zdHlsZS53aWR0aCA9IHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSArICclJyA6ICcwJSc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHNlY29uZGFyeVZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5kZXRlcm1pbmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoSU5ERVQsICcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShJTkRFVCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKElOREVUKTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuUHJvZ3Jlc3NCYXIgPSBQcm9ncmVzc0JhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1iYXInLCBQcm9ncmVzc0JhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcic6ICdwcm9ncmVzcy1jaXJjdWxhci0tKicsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX2JhY2tncm91bmQnOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX2JhY2tncm91bmQnLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qX19wcmltYXJ5JyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qX19zZWNvbmRhcnknXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxzdmcgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhclwiPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fYmFja2dyb3VuZFwiIC8+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnlcIiAvPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeVwiIC8+XG4gIDwvc3ZnPlxuYCk7XG5cbmNvbnN0IElOREVUID0gJ2luZGV0ZXJtaW5hdGUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyBhIGNpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvci4gSXQgY2FuIGVpdGhlciBiZSB1c2VkIHRvIHNob3cgaG93IG11Y2ggb2YgYSB0YXNrIGhhcyBiZWVuIGNvbXBsZXRlZCBvciB0byBzaG93IGEgbG9vcGluZyBhbmltYXRpb24gdG8gaW5kaWNhdGUgdGhhdCBhbiBvcGVyYXRpb24gaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gRVZ6TWpSXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHJvZ3Jlc3NcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1iYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1wcm9ncmVzcy1iYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBiYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gKlxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCBJTkRFVF07XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKElOREVUKSAmJiB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IElOREVUKSB7XG4gICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdXRpbC50b2dnbGVNb2RpZmllcih0aGlzLCBJTkRFVCwgeyBmb3JjZTogdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpIH0pKTtcbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9IE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyID0gIE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNlY29uZGFyeVZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgc2Vjb25kYXJ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgc2Vjb25kYXJ5VmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmRldGVybWluYXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShJTkRFVCwgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKElOREVUKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29tcGlsZWQoKSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaW1hcnkgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSwgJy5wcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeScpO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknKTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2lzQ29tcGlsZWQoKSB7XG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdmcgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHN2ZywgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHN2ZywgJy5wcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlByb2dyZXNzQ2lyY3VsYXIgPSBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXByb2dyZXNzLWNpcmN1bGFyJywgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCBTVEFURV9JTklUSUFMID0gJ2luaXRpYWwnO1xuY29uc3QgU1RBVEVfUFJFQUNUSU9OID0gJ3ByZWFjdGlvbic7XG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHVsbC1ob29rXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdGhhdCBhZGRzICoqUHVsbCB0byByZWZyZXNoKiogZnVuY3Rpb25hbGl0eSB0byBhbiBgPG9ucy1wYWdlPmAgZWxlbWVudC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBhIHRhc2sgd2hlbiB0aGUgdXNlciBwdWxscyBkb3duIGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2UuIEEgY29tbW9uIHVzYWdlIGlzIHRvIHJlZnJlc2ggdGhlIGRhdGEgZGlzcGxheWVkIGluIGEgcGFnZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBXYkpvZ01cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wdWxsLWhvb2tcbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtcHVsbC1ob29rPlxuICogICAgIFJlbGVhc2UgdG8gcmVmcmVzaFxuICogICA8L29ucy1wdWxsLWhvb2s+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wdWxsLWhvb2snKS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAqICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDApO1xuICogICB9O1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1bGxIb29rRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGNoYW5nZXN0YXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkLiBUaGUgc3RhdGUgY2FuIGJlIGVpdGhlciBcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiBvciBcImFjdGlvblwiLlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrueKtuaFi+OBjOWkieOCj+OBo+OBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAgueKtuaFi+OBr+OAgVwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiLCBcImFjdGlvblwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucHVsbEhvb2tcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQuc3RhdGVcbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7nirbmhYvlkI3jgpLlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBcInB1bGwtdG8tcmVmcmVzaFwiIGZ1bmN0aW9uYWxpdHkgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZGlzYWJsZWTnirbmhYvjgavjgarjgorjgqLjgq/jgrfjg6fjg7PjgYzlrp/ooYzjgZXjgozjgarjgY/jgarjgorjgb7jgZlbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBoZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50LiBXaGVuIHB1bGxlZCBkb3duIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlIGl0IHdpbGwgc3dpdGNoIHRvIHRoZSBcInByZWFjdGlvblwiIHN0YXRlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjY0cHhcIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7pq5jjgZXku6XkuIrjgatwdWxsIGRvd27jgZnjgovjgahcInByZWFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44Gu5YCk44GvXCI2NHB4XCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0aHJlc2hvbGQtaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSB0aHJlc2hvbGQgaGVpZ2h0LiBUaGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgc3dpdGNoZXMgdG8gdGhlIFwiYWN0aW9uXCIgc3RhdGUgd2hlbiBwdWxsZWQgZnVydGhlciB0aGFuIHRoaXMgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiOTZweFwiLiBBIG5lZ2F0aXZlIHZhbHVlIG9yIGEgdmFsdWUgbGVzcyB0aGFuIHRoZSBoZWlnaHQgd2lsbCBkaXNhYmxlIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFd6Za+5YCk44Go44Gq44KL6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5YCk44Gn5oyH5a6a44GX44Gf6auY44GV44KI44KK44KCcHVsbCBkb3du44GZ44KL44Go44CB44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gv6Ieq5YuV55qE44GrXCJhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZpeGVkLWNvbnRlbnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY29udGVudCBvZiB0aGUgcGFnZSB3aWxsIG5vdCBtb3ZlIHdoZW4gcHVsbGluZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgabjgYTjgovmmYLjgavjgoLjgrPjg7Pjg4bjg7Pjg4Tjga/li5XjgY3jgb7jgZvjgpPjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRHJhZ0VuZCA9IHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9wcmV2ZW50U2Nyb2xsID0gdGhpcy5fcHJldmVudFNjcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCwgdHJ1ZSk7XG4gICAgdGhpcy5faGlkZSgpOyAvLyBGaXggZm9yIHRyYW5zcGFyZW50IHRvb2xiYXIgdHJhbnNpdGlvbnNcbiAgfVxuXG4gIF9zZXRTdHlsZSgpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgc3R5bGVyKHRoaXMsIHsgaGVpZ2h0LCBsaW5lSGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID09PSAnJyAmJiB0aGlzLl9zaG93KCk7XG4gIH1cblxuICBfb25TY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCAwKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgX2NhbkNvbnN1bWVHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICByZXR1cm4gZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICd1cCcgfHwgZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICdkb3duJztcbiAgfVxuXG4gIF9vbkRyYWdTdGFydChldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkO1xuXG4gICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBjb25zdCBjb25zdW1lID0gZXZlbnQuY29uc3VtZTtcbiAgICAgIGV2ZW50LmNvbnN1bWUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN1bWUgJiYgY29uc3VtZSgpO1xuICAgICAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyBlbGVtZW50cyByZXNpemVzIC5wYWdlX19jb250ZW50IHNvIGl0IGlzIHNhZmVyXG4gICAgICAgIC8vIHRvIGhpZGUgaXQgd2hlbiBvdGhlciBjb21wb25lbnRzIGFyZSBkcmFnZ2VkLlxuICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fY2FuQ29uc3VtZUdlc3R1cmUoZXZlbnQuZ2VzdHVyZSkpIHtcbiAgICAgICAgY29uc3VtZSAmJiBjb25zdW1lKCk7XG4gICAgICAgIGV2ZW50LmNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvdygpOyAvLyBOb3QgZW5vdWdoIGR1ZSB0byAnZHJhZ0xvY2tBeGlzJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0U2Nyb2xsID0gdGhpcy5fcGFnZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkIHx8IHRoaXMuX2lnbm9yZURyYWcgfHwgIXRoaXMuX2NhbkNvbnN1bWVHZXN0dXJlKGV2ZW50Lmdlc3R1cmUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmVjZXNzYXJ5IGR1ZSB0byAnZHJhZ0xvY2tBeGlzJyAoMjVweClcbiAgICBpZiAodGhpcy5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHRoaXMuX3Nob3coKTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIC8vIEhhY2sgdG8gbWFrZSBpdCB3b3JrIG9uIEFuZHJvaWQgNC40IFdlYlZpZXcgYW5kIGlPUyBVSVdlYlZpZXcuIFNjcm9sbHMgbWFudWFsbHlcbiAgICAvLyBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc28gdGhlcmUgd2lsbCBiZSBubyBpbmVydGlhbCBzY3JvbGwgd2hlbiBzY3JvbGxpbmcgZG93bi5cbiAgICAvLyBBbGxvd2luZyBkZWZhdWx0IHNjcm9sbGluZyB3aWxsIGtpbGwgYWxsICd0b3VjaG1vdmUnIGV2ZW50cy5cbiAgICB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9zdGFydFNjcm9sbCAtIGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuICAgIGlmICh0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gIT09ICd1cCcpIHtcbiAgICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGwgPSBNYXRoLm1heChldmVudC5nZXN0dXJlLmRlbHRhWSAtIHRoaXMuX3N0YXJ0U2Nyb2xsLCAwKTtcbiAgICBpZiAoc2Nyb2xsICE9PSB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24pIHtcbiAgICAgIGlmICh0aGlzLl90aHJlc2hvbGRIZWlnaHRFbmFibGVkKCkgJiYgc2Nyb2xsID49IHRoaXMudGhyZXNob2xkSGVpZ2h0KSB7XG4gICAgICAgIGV2ZW50Lmdlc3R1cmUuc3RvcERldGVjdCgpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fZmluaXNoKCkpO1xuXG4gICAgICB9IGVsc2UgaWYgKHNjcm9sbCA+PSB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9QUkVBQ1RJT04pO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHVsbGluZyA9IHRydWU7XG4gICAgICB0aGlzLl90cmFuc2xhdGVUbyhzY3JvbGwpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICB0aGlzLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA+IDApIHtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcblxuICAgICAgaWYgKHNjcm9sbCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcHJldmVudFNjcm9sbChldmVudCkge1xuICAgIC8vIEZpeCBmb3IgQW5kcm9pZCAmIGlPUyB3aGVuIHN0YXJ0aW5nIGZyb20gc2Nyb2xsVG9wID4gMCBvciBwdWxsaW5nIGJhY2tcbiAgICB0aGlzLl9wdWxsaW5nICYmIGV2ZW50LmNhbmNlbGFibGUgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25BY3Rpb25cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYGFjdGlvbmAgc3RhdGUgaWYgaXQgZXhpc3RzLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBnaXZlbiBhIGBkb25lYCBjYWxsYmFjayBhcyBpdCdzIGZpcnN0IGFyZ3VtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQWN0aW9uO1xuICB9XG5cbiAgc2V0IG9uQWN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29uQWN0aW9uJyBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbGApO1xuICAgIH1cbiAgICB0aGlzLl9vbkFjdGlvbiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblB1bGxcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSG9vayBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcHVsbHMgdGhlIGVsZW1lbnQuIEl0IGdldHMgdGhlIHB1bGxlZCBkaXN0YW5jZSByYXRpbyAoc2Nyb2xsIC8gaGVpZ2h0KSBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25QdWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9vblB1bGw7XG4gIH1cblxuICBzZXQgb25QdWxsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29uUHVsbCcgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG51bGwuYClcbiAgICB9XG4gICAgdGhpcy5fb25QdWxsID0gdmFsdWU7XG4gIH1cblxuICBfZmluaXNoKCkge1xuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0FDVElPTik7XG4gICAgdGhpcy5fdHJhbnNsYXRlVG8odGhpcy5oZWlnaHQsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5vbkFjdGlvbiB8fCAoZG9uZSA9PiBkb25lKCkpO1xuICAgIGFjdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDY0cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGhlaWdodCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnNjQnLCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHRocmVzaG9sZEhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHRocmVzaG9sZEhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDk2cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgdGhyZXNob2xkSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRocmVzaG9sZCBoZWlnaHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xuICB9XG5cbiAgZ2V0IHRocmVzaG9sZEhlaWdodCgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnKSB8fCAnOTYnLCAxMCk7XG4gIH1cblxuICBfdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCgpIHtcbiAgICBjb25zdCB0aCA9IHRoaXMudGhyZXNob2xkSGVpZ2h0O1xuICAgIHJldHVybiB0aCA+IDAgJiYgdGggPj0gdGhpcy5oZWlnaHQ7XG4gIH1cblxuICBfc2V0U3RhdGUoc3RhdGUsIG5vRXZlbnQpIHtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgc3RhdGUpO1xuXG4gICAgaWYgKCFub0V2ZW50ICYmIGxhc3RTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjaGFuZ2VzdGF0ZScsIHtcbiAgICAgICAgcHVsbEhvb2s6IHRoaXMsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgbGFzdFN0YXRlOiBsYXN0U3RhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc3RhdGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwdWxsRGlzdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBudW1iZXIgb2YgcGl4ZWxzIHRoZSBwdWxsIGhvb2sgaGFzIG1vdmVkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODl+ODq+ODleODg+OCr+OBjOW8leOBjeWHuuOBleOCjOOBn+i3nembouOCkuODlOOCr+OCu+ODq+aVsOOAglsvamFdXG4gICAqL1xuICBnZXQgcHVsbERpc3RhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgLy8gUnVuIGFzeW5jcmhvbm91c2x5IHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIEFuaW1pdCdzIHN0eWxlIGNsZWFuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgaWYgKHRoaXMuX3BhZ2VFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3BhZ2VFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9IGAtJHt0aGlzLmhlaWdodH1weGA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWYgKHRoaXMuX3BhZ2VFbGVtZW50KSB7XG4gICAgICB0aGlzLl9wYWdlRWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICovXG4gIF90cmFuc2xhdGVUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPT0gMCAmJiBzY3JvbGwgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IHNjcm9sbDtcbiAgICBjb25zdCBvcHQgPSBvcHRpb25zLmFuaW1hdGUgPyB7IGR1cmF0aW9uOiAuMywgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyB9IDoge307XG4gICAgdGhpcy5fb25QdWxsICYmIHRoaXMuX29uUHVsbCgoc2Nyb2xsIC8gdGhpcy5oZWlnaHQpLnRvRml4ZWQoMiksIG9wdCk7XG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9ICB0aGlzLmhhc0F0dHJpYnV0ZSgnZml4ZWQtY29udGVudCcpID8gdGhpcyA6IHRoaXMuX3BhZ2VFbGVtZW50O1xuXG4gICAgYW5pbWl0KHNjcm9sbEVsZW1lbnQpXG4gICAgICAucXVldWUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwcHgsICR7c2Nyb2xsfXB4LCAwcHgpYCB9LCBvcHQpXG4gICAgICAucGxheSgoKSA9PiB7XG4gICAgICAgIHNjcm9sbCA9PT0gMCAmJiBzdHlsZXIuY2xlYXIoc2Nyb2xsRWxlbWVudCwgJ3RyYW5zaXRpb24gdHJhbnNmb3JtJyk7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICBfZGlzYWJsZURyYWdMb2NrKCkgeyAvLyBlMmUgdGVzdHMgbmVlZCBpdFxuICAgIHRoaXMuX2RyYWdMb2NrRGlzYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHRydWUpO1xuICB9XG5cbiAgX3NldHVwTGlzdGVuZXJzKGFkZCkge1xuICAgIGNvbnN0IHNjcm9sbFRvZ2dsZSA9IGFjdGlvbiA9PiB0aGlzLl9wYWdlRWxlbWVudFtgJHthY3Rpb259RXZlbnRMaXN0ZW5lcmBdKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgZmFsc2UpO1xuICAgIGNvbnN0IGdkVG9nZ2xlID0gYWN0aW9uID0+IHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ0VuZCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgndG91Y2htb3ZlJywgdGhpcy5fcHJldmVudFNjcm9sbCk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGdkVG9nZ2xlKCdvZmYnKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuICAgIH1cbiAgICBzY3JvbGxUb2dnbGUoJ3JlbW92ZScpO1xuXG4gICAgaWYgKGFkZCkge1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLl9wYWdlRWxlbWVudCwge1xuICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEsXG4gICAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IGZhbHNlLFxuICAgICAgICBkcmFnTG9ja1RvQXhpczogIXRoaXMuX2RyYWdMb2NrRGlzYWJsZWRcbiAgICAgIH0pO1xuXG4gICAgICBnZFRvZ2dsZSgnb24nKTtcbiAgICAgIHNjcm9sbFRvZ2dsZSgnYWRkJyk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLl9wYWdlRWxlbWVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHRydWUpO1xuICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9oaWRlKCk7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnMoZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaGVpZ2h0J107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnaGVpZ2h0JyAmJiB0aGlzLl9wYWdlRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydjaGFuZ2VzdGF0ZSddXG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlB1bGxIb29rID0gUHVsbEhvb2tFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHVsbC1ob29rJywgUHVsbEhvb2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1pbnB1dCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdyYW5nZS0tKicsXG4gICcucmFuZ2VfX2lucHV0JzogJ3JhbmdlLS0qX19pbnB1dCcsXG4gICcucmFuZ2VfX2ZvY3VzLXJpbmcnOiAncmFuZ2UtLSpfX2ZvY3VzLXJpbmcnXG59O1xuXG5jb25zdCBhY3RpdmVDbGFzc1Rva2VuID0gJ3JhbmdlX19pbnB1dC0tYWN0aXZlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmFuZ2VcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzbGlkZXJbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgUmFuZ2UgaW5wdXQgY29tcG9uZW50LiBVc2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgc2xpZGVyLlxuICpcbiAqICAgICBXb3JrcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIGA8aW5wdXQgdHlwZT1cInJhbmdlXCI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhaUW9tTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JhbmdlXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLWlucHV0PmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSB0ZXh0IGlucHV0cywgcmFkaW8gYnV0dG9ucyBhbmQgY2hlY2tib3hlcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXJhbmdlIHZhbHVlPVwiMjBcIj48L29ucy1yYW5nZT5cbiAqIDxvbnMtcmFuZ2UgbW9kaWZpZXI9XCJtYXRlcmlhbFwiIHZhbHVlPVwiMTBcIj48L3JhbmdlPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlRWxlbWVudCBleHRlbmRzIEJhc2VJbnB1dEVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uTW91c2VVcCA9IHRoaXMuX29uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPblRvdWNoRW5kID0gdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnc3RhcnQgPSB0aGlzLl9vbkRyYWdzdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnZW5kID0gdGhpcy5fb25EcmFnZW5kLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBzdXBlci5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKTtcbiAgfVxuXG4gIC8qIEluaGVyaXRlZCBwcm9wcyAqL1xuXG4gIF91cGRhdGUoKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICBjb25zdCBmb2N1c1JpbmcgPSB0aGlzLl9mb2N1c1Jpbmc7XG5cbiAgICBpbnB1dC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGAkezEwMCAqIHRoaXMuX3JhdGlvfSUgMnB4YDtcbiAgICBmb2N1c1JpbmcudmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgLy8gTk9URTogXCJfemVyb1wiIGF0dHJpYnV0ZSBpcyB1c2VkIGZvciBDU1Mgc3R5bGluZy5cbiAgICBpZiAoKGlucHV0Lm1pbiA9PT0gJycgJiYgaW5wdXQudmFsdWUgPT09ICcwJykgfHwgaW5wdXQubWluID09PSBpbnB1dC52YWx1ZSkge1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdfemVybycsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdfemVybycpO1xuICAgIH1cblxuICAgIFsnbWluJywgJ21heCddLmZvckVhY2goYXR0ciA9PiBmb2N1c1JpbmdbYXR0cl0gPSBpbnB1dFthdHRyXSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJyYW5nZV9fZm9jdXMtcmluZ1wiIHRhYkluZGV4PVwiLTFcIj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAncmFuZ2UnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdyYW5nZSc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2lucHV0LmZvY3VzKCkpO1xuICB9XG5cbiAgX29uVG91Y2hTdGFydChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZURvd24oKTtcbiAgfVxuXG4gIF9vbk1vdXNlVXAoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gIH1cblxuICBfb25Ub3VjaEVuZChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZVVwKGUpO1xuICB9XG5cbiAgX29uRHJhZ3N0YXJ0KGUpIHtcbiAgICBlLmNvbnN1bWVkID0gdHJ1ZTtcbiAgICBlLmdlc3R1cmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZChhY3RpdmVDbGFzc1Rva2VuKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIF9vbkRyYWdlbmQoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgfVxuXG4gIGdldCBfZm9jdXNSaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzFdO1xuICB9XG5cbiAgZ2V0IF9yYXRpbygpIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhdGlvLlxuICAgIGNvbnN0IG1pbiA9IHRoaXMuX2lucHV0Lm1pbiA9PT0gJycgPyAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWluKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9pbnB1dC5tYXggPT09ICcnID8gMTAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWF4KTtcblxuICAgIHJldHVybiAodGhpcy52YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2Rpc2FibGVkJywgLi4uQmFzZUlucHV0RWxlbWVudC5vYnNlcnZlZEF0dHJpYnV0ZXNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY3VycmVudCk7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBfdXBkYXRlRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9ib3VuZE9uTW91c2VEb3duKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9ib3VuZE9uTW91c2VVcCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fYm91bmRPblRvdWNoU3RhcnQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZE9uVG91Y2hFbmQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdzdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdlbmQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9ib3VuZE9uTW91c2VEb3duKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9ib3VuZE9uTW91c2VVcCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fYm91bmRPblRvdWNoU3RhcnQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZE9uVG91Y2hFbmQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdzdGFydCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdlbmQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5vbnMuZWxlbWVudHMuUmFuZ2UgPSBSYW5nZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yYW5nZScsIFJhbmdlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNiBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcblxuLyoqXG4gKiBAY2xhc3MgQW5pbWF0b3JDU1MgLSBpbXBsZW1lbnRhdGlvbiBvZiBBbmltYXRvciBjbGFzcyB1c2luZyBjc3MgdHJhbnNpdGlvbnNcbiAqL1xuY2xhc3MgQW5pbWF0b3JDU1Mge1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFuaW1hdGVcbiAgICogQGRlc2MgbWFpbiBhbmltYXRpb24gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaW5hbENTU1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gLSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC50aGVuKGNhbGxiYWNrKSAtIHNldHMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBzdG9wcGVkXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3RvcChvcHRpb25zKSAtIHN0b3BzIHRoZSBhbmltYXRpb247IGlmIG9wdGlvbnMuc3RvcE5leHQgaXMgdHJ1ZSB0aGVuIGl0IGRvZXNuJ3QgY2FsbCB0aGUgY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5maW5pc2gobXMpIC0gZmluaXNoZXMgdGhlIGFuaW1hdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3BlZWQobXMpIC0gc2V0cyB0aGUgYW5pbWF0aW9uIHNwZWVkIHNvIHRoYXQgaXQgZmluaXNoZXMgYXMgaWYgdGhlIG9yaWdpbmFsIGR1cmF0aW9uIHdhcyB0aGUgb25lIHNwZWNpZmllZCBoZXJlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGBcbiAgICogIHZhciByZXN1bHQgPSBhbmltYXRvci5hbmltYXRlKGVsLCB7b3BhY2l0eTogMC41fSwgMTAwMCk7XG4gICAqXG4gICAqICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgKiAgICByZXN1bHQuc3BlZWQoMjAwKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAqICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgICogICAgfSk7XG4gICAqICB9LCAzMDApO1xuICAgKiBgYGBgXG4gICAqL1xuICBhbmltYXRlKGVsLCBmaW5hbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICB2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICBpbml0aWFsID0ge30sXG4gICAgICAgIHN0b3BwZWQgPSBmYWxzZSxcbiAgICAgICAgbmV4dCA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0ID0gZmFsc2UsXG4gICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmaW5hbCk7XG5cbiAgICB2YXIgdXBkYXRlU3R5bGVzID0gKCkgPT4ge1xuICAgICAgbGV0IHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocy5nZXRQcm9wZXJ0eVZhbHVlLmJpbmQocykpO1xuICAgICAgcyA9IGVsLm9mZnNldEhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0b3A6IChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHZhciBrID0gTWF0aC5taW4oMSwgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbik7XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RvcE5leHQpIHtcbiAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRoZW46IChjYikgPT4ge1xuICAgICAgICBuZXh0ID0gY2I7XG4gICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBzcGVlZDogKG5ld0R1cmF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbmV3RHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgY29uc3QgcGFzc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICAgICAgICAgIGNvbnN0ICBrID0gcGFzc2VkIC8gZHVyYXRpb247XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gbmV3RHVyYXRpb24gKiAoMSAtIGspO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB1cGRhdGVTdHlsZXMoKTtcblxuICAgICAgICAgIHN0YXJ0ID0gZWwuc3BlZWRVcFRpbWU7XG4gICAgICAgICAgZHVyYXRpb24gPSByZW1haW5pbmc7XG5cbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9IGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiAobWlsbGlzZWNvbmRzID0gNTApID0+IHtcbiAgICAgICAgdmFyIGsgPSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICAgIHJlc3VsdC5zcGVlZChtaWxsaXNlY29uZHMgLyAoMSAtIGspKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBzdG9wcGVkIHx8IGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoZSkpO1xuICAgICAgaW5pdGlhbFtlXSA9IGlzTmFOKHYpID8gMCA6IHY7XG4gICAgfSk7XG5cblxuICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gcHJvcGVydGllcy5qb2luKCcsJyk7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgZWwuc3R5bGVbZV0gPSBmaW5hbFtlXSArIChlID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgZHVyYXRpb24pO1xuICAgIHRoaXMuX29uU3RvcEFuaW1hdGlvbnMoZWwsIHJlc3VsdC5zdG9wKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgfVxuXG4gIF9vblN0b3BBbmltYXRpb25zKGVsLCBsaXN0ZW5lcikge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpID0gdGhpcy5faW5kZXgrKztcbiAgICBxdWV1ZVtlbF0gPSBxdWV1ZVtlbF0gfHwgW107XG4gICAgcXVldWVbZWxdW2ldID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGRlbGV0ZSBxdWV1ZVtlbF1baV07XG4gICAgICBpZiAocXVldWVbZWxdICYmIHF1ZXVlW2VsXS5sZW5ndGggPT0gMCkge1xuICAgICAgICBkZWxldGUgcXVldWVbZWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVyKG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbmltYXRpb25zXG4gICogQGRlc2Mgc3RvcHMgYWN0aXZlIGFuaW1hdGlvbnMgb24gYSBzcGVjaWZpZWQgZWxlbWVudFxuICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWxlbWVudCAtIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgIHJldHVybiBlbC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAodGhpcy5fcXVldWVbZWxdIHx8IFtdKS5mb3JFYWNoKGUgPT4geyBlKG9wdGlvbnMgfHwge30pOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFsbFxuICAqIEBkZXNjIHN0b3BzIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFsbChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0b3BBbmltYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIGZhZGVcbiAgKiBAZGVzYyBmYWRlcyB0aGUgZWxlbWVudCAoc2hvcnQgdmVyc2lvbiBmb3IgYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9KSlcbiAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF1cbiAgKi9cbiAgZmFkZShlbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKGVsLCB7b3BhY2l0eTogMH0sIGR1cmF0aW9uKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdG9yQ1NTO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci1jc3MnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdyaXBwbGUnO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3JpcHBsZS0tKicsXG4gICcucmlwcGxlX193YXZlJzogJ3JpcHBsZS0tKl9fd2F2ZScsXG4gICcucmlwcGxlX19iYWNrZ3JvdW5kJzogJ3JpcHBsZS0tKl9fYmFja2dyb3VuZCcsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yaXBwbGVcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWRkcyBhIE1hdGVyaWFsIERlc2lnbiBcInJpcHBsZVwiIGVmZmVjdCB0byBhbiBlbGVtZW50LiBUaGUgcmlwcGxlIGVmZmVjdCB3aWxsIHNwcmVhZCBmcm9tIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgdXNlciB0YXBzLlxuICpcbiAqICAgICBTb21lIGVsZW1lbnRzIHN1Y2ggYXMgYDxvbnMtYnV0dG9uPmAgYW5kIGA8b25zLWZhYj5gICBzdXBwb3J0IGEgYHJpcHBsZWAgYXR0cmlidXRlLlxuICogICBbL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oq44OD44OX44Or5Yq55p6c44KSRE9N6KaB57Sg44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHdLUVdkWlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JpcHBsZVxuICogQG1vZGlmaWVyIGxpZ2h0LWdyYXlcbiAqICAgW2VuXUNoYW5nZSB0aGUgY29sb3Igb2YgZWZmZWN0cyB0byBsaWdodCBncmF5LlsvZW5dXG4gKiAgIFtqYV3jgqjjg5Xjgqfjgq/jg4jjga7oibLjgYzmmI7jgovjgYTngbDoibLjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nXG4gKiAgW2VuXUNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVxuICogIFtqYV1Dcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8ZGl2IGNsYXNzPVwibXktZGl2XCI+XG4gKiAgPG9ucy1yaXBwbGU+PC9vbnMtcmlwcGxlPlxuICogPC9kaXY+XG4gKlxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIHJpcHBsZT5DbGljayBtZSE8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJpcHBsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICAgW2phXeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqjjg5Xjgqfjgq/jg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBiYWNrZ3JvdW5kXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZC5bL2VuXVxuICAgKiAgIFtqYV3og4zmma/jga7oibLjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaXppbmcgb2YgdGhlIHdhdmUgb24gcmlwcGxlIGVmZmVjdC4gU2V0IFwiY292ZXJcIiBvciBcImNvbnRhaW5cIi4gRGVmYXVsdCBpcyBcImNvdmVyXCIuWy9lbl1cbiAgICogICBbamFd44Ko44OV44Kn44Kv44OI44Gu44K144Kk44K644KS5oyH5a6a44GX44G+44GZ44CCXCJjb3Zlclwi44KC44GX44GP44GvXCJjb250YWluXCLjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImNvdmVyXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjZW50ZXJcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBwcmVzZW50cywgY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB3YXZlIGVmZmVjdCB0byBjZW50ZXIgb2YgdGhlIHRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOCkuioreWumuOBmeOCi+OBqOOAgeOCqOODleOCp+OCr+ODiOOBruS9jee9ruOBjOimgee0oOOBruecn+OCk+S4reOBi+OCieWni+OBvuOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gv54Sh5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuICAgIFsnY29sb3InLCAnY2VudGVyJywgJ3N0YXJ0LXJhZGl1cycsICdiYWNrZ3JvdW5kJywgJ21vZGlmaWVyJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIHRoaXMuX3dhdmUgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fd2F2ZScpWzBdO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fYmFja2dyb3VuZCcpWzBdO1xuXG4gICAgaWYgKCEodGhpcy5fYmFja2dyb3VuZCAmJiB0aGlzLl93YXZlKSkge1xuICAgICAgdGhpcy5fd2F2ZSA9IHV0aWwuY3JlYXRlKCcucmlwcGxlX193YXZlJyk7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdXRpbC5jcmVhdGUoJy5yaXBwbGVfX2JhY2tncm91bmQnKTtcblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl93YXZlKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2dldEVmZmVjdFNpemUoKSB7XG4gICAgY29uc3Qgc2l6ZXMgPSBbJ2NvdmVyJywgJ2NvbnRhaW4nXTtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3NpemUnKSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzaXplJyk7XG4gICAgICBpZiAoc2l6ZXMuaW5kZXhPZihzaXplKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICdjb3Zlcic7XG4gIH1cblxuICBfY2FsY3VsYXRlQ29vcmRzKGUpIHtcbiAgICBsZXQgeCwgeSwgaCwgdywgcjtcbiAgICBjb25zdCBiID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0RWZmZWN0U2l6ZSgpO1xuXG4gICAgaWYgKHRoaXMuX2NlbnRlcikge1xuICAgICAgeCA9IGIud2lkdGggLyAyO1xuICAgICAgeSA9IGIuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbih4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlLiBJZiB0aGlzIGVycm9ycyBpcyBzaG93biwgbGVwb3J0IHRvIEdpdEh1YiBpc3N1ZXMuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAodHlwZW9mIGUuY2xpZW50WCA9PT0gJ251bWJlcicgPyBlLmNsaWVudFggOiBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgpIC0gYi5sZWZ0O1xuICAgICAgeSA9ICh0eXBlb2YgZS5jbGllbnRZID09PSAnbnVtYmVyJyA/IGUuY2xpZW50WSA6IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydChoICogaCArIHcgKiB3KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbihNYXRoLnJvdW5kKGggLyAyKSwgTWF0aC5yb3VuZCh3IC8gMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc3RhdGUuIElmIHRoaXMgZXJyb3JzIGlzIHNob3duLCBsZXBvcnQgdG8gR2l0SHViIGlzc3Vlcy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge3gsIHksIHJ9O1xuICB9XG5cbiAgX3JpcHBsZUFuaW1hdGlvbihlLCBkdXJhdGlvbiA9IDMwMCkge1xuICAgIGNvbnN0IHtfYW5pbWF0b3IsIF93YXZlLCBfYmFja2dyb3VuZCwgX21pblJ9ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICB0aGlzLl9ob2xkaW5nLnNwZWVkKDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faG9sZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xuICAgIH1cbiAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgdGhpcy5fb25UYXAoZSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHBuID0gdGhpcy5fcGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGU7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX2JvdW5kT25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N0YXJ0LXJhZGl1cycsICdjb2xvcicsICdiYWNrZ3JvdW5kJywgJ2NlbnRlcicsICdjbGFzcycsICdtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcblxuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0YXJ0LXJhZGl1cyc6XG4gICAgICAgIHRoaXMuX21pblIgPSBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KGN1cnJlbnQpIHx8IDApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93YXZlLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnYmFja2dyb3VuZCcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JhY2tncm91bmQnOlxuICAgICAgICBpZiAoY3VycmVudCB8fCBsYXN0KSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09ICdub25lJykge1xuICAgICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGhpcy5fY2VudGVyID0gY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQgIT0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlJpcHBsZSA9IFJpcHBsZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yaXBwbGUnLCBSaXBwbGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcm93XG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sXG4gKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jb2xcbiAqICAgW2VuXVRoZSBgPG9ucy1jb2w+YCBjb21wb25lbnQgaXMgdXNlZCBhcyBjaGlsZHJlbiBvZiBgPG9ucy1yb3c+YC5bL2VuXVxuICogICBbamFdb25zLWNvbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgdmVydGljYWwtYWxpZ24uWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29s44KS57WE44G/5ZCI44KP44Gb44Gm44Gd44KM44Ge44KM44Gub25zLWNvbOimgee0oOOBrnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr5Yil44CF44Gu5YCk44KS5oyH5a6a44GZ44KL44Go44CB5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCdmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavjga/kuIDjgaTjga7lgKTjgaDjgZHjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3J0IGhhbmQgYXR0cmlidXRlIGZvciBhbGlnbmluZyB2ZXJ0aWNhbGx5LiBWYWxpZCB2YWx1ZXMgYXJlIHRvcCwgYm90dG9tLCBhbmQgY2VudGVyLlsvZW5dXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvd0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG59XG5cbm9ucy5lbGVtZW50cy5Sb3cgPSBSb3dFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcm93JywgUm93RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzZWdtZW50JztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWdtZW50LS0qJyxcbiAgJy5zZWdtZW50X19pdGVtJzogJ3NlZ21lbnQtLSpfX2l0ZW0nLFxuICAnLnNlZ21lbnRfX2lucHV0JzogJ3NlZ21lbnQtLSpfX2lucHV0JyxcbiAgJy5zZWdtZW50X19idXR0b24nOiAnc2VnbWVudC0tKl9fYnV0dG9uJ1xufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgoKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuICgpID0+ICdvbnMtc2VnbWVudC1nZW4tJyArIChpKyspO1xufSkoKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc2VnbWVudFxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnRbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU2VnbWVudCBjb21wb25lbnQuIFVzZSB0aGlzIGNvbXBvbmVudCB0byBoYXZlIGEgYnV0dG9uIGJhciB3aXRoIGF1dG9tYXRpYyBzdHlsZXMgdGhhdCBzd2l0Y2ggb24gY2xpY2sgb2YgYW5vdGhlciBidXR0b24uXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnQgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlZ21lbnRcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWdtZW50PlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAxPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAyPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAzPC9vbnMtYnV0dG9uPlxuICogPC9vbnMtc2VnbWVudD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWdtZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGFmdGVyIHRoZSBhY3RpdmUgYnV0dG9uIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dVGFwcGVkIGJ1dHRvbiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2VnbWVudEl0ZW1cbiAgICogICBbZW5dU2VnbWVudCBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgc2VnbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYmJhci1pZFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSUQgb2YgdGhlIHRhYmJhciBlbGVtZW50IHRvIFwiY29ubmVjdFwiIHRvIHRoZSBzZWdtZW50LiBNdXN0IGJlIGluc2lkZSB0aGUgc2FtZSBwYWdlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWluZGV4XG4gICAqIEBpbml0b25seVxuICAgKiBAZGVmYXVsdCAwXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUluZGV4IG9mIHRoZSBmaXJzdCBhY3RpdmUgYnV0dG9uLCBvbmx5IHdvcmtzIGlmIHRoZXJlIGlzIG5vIGNvbm5lY3RlZCB0YWJiYXIgKGluIHdoaWNoIGNhc2UgdGhlIGFjdGl2ZSB0YWIgc2V0cyB0aGUgYWN0aXZlIGJ1dHRvbikuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBzZWdtZW50IHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9zZWdtZW50SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5fdGFiYmFyID0gbnVsbDtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UgPSB0aGlzLl9vblRhYmJhclByZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IHRoaXMuX3RhYmJhciA/IHRoaXMuX3RhYmJhci5nZXRBY3RpdmVUYWJJbmRleCgpIDogdGhpcy5nZXRBY3RpdmVCdXR0b25JbmRleCgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3NlZ21lbnRfX2l0ZW0nKTtcblxuICAgICAgY29uc3QgaW5wdXQgPSB1dGlsLmZpbmRDaGlsZChpdGVtLCAnLnNlZ21lbnRfX2lucHV0JykgfHwgdXRpbC5jcmVhdGUoJ2lucHV0LnNlZ21lbnRfX2lucHV0Jyk7XG4gICAgICBpbnB1dC50eXBlID0gJ3JhZGlvJztcbiAgICAgIGlucHV0LnZhbHVlID0gaW5kZXg7XG4gICAgICBpbnB1dC5uYW1lID0gaW5wdXQubmFtZSB8fCB0aGlzLl9zZWdtZW50SWQ7XG4gICAgICBpbnB1dC5jaGVja2VkID0gIXRoaXMuaGFzQXR0cmlidXRlKCd0YWJiYXItaWQnKSAmJiBpbmRleCA9PT0gKHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUtaW5kZXgnKSkgfHwgMCk7XG5cbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKGl0ZW0sICcuc2VnbWVudF9fYnV0dG9uJykgfHwgdXRpbC5jcmVhdGUoJy5zZWdtZW50X19idXR0b24nKTtcbiAgICAgIGlmIChidXR0b24ucGFyZW50RWxlbWVudCAhPT0gaXRlbSkge1xuICAgICAgICB3aGlsZSAoaXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGl0ZW0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlbS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICBpdGVtLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd0YWJiYXItaWQnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICAgICAgdGhpcy5fdGFiYmFyID0gcGFnZSAmJiBwYWdlLnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmJhci1pZCcpKTtcbiAgICAgICAgaWYgKCF0aGlzLl90YWJiYXIgfHwgdGhpcy5fdGFiYmFyLnRhZ05hbWUgIT09ICdPTlMtVEFCQkFSJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgPG9ucy1zZWdtZW50PiBlcnJvcjogbm8gdGFiYmFyIHdpdGggaWQgJHt0aGlzLmdldEF0dHJpYnV0ZSgndGFiYmFyLWlkJyl9IHdhcyBmb3VuZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RhYmJhci5zZXRBdHRyaWJ1dGUoJ2hpZGUtdGFicycsICcnKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3NldENoZWNrZWQodGhpcy5fdGFiYmFyLmdldEFjdGl2ZVRhYkluZGV4KCkpKTtcblxuICAgICAgICB0aGlzLl90YWJiYXIuYWRkRXZlbnRMaXN0ZW5lcigncHJlY2hhbmdlJywgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3RhYmJhcikge1xuICAgICAgICB0aGlzLl90YWJiYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlY2hhbmdlJywgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UpO1xuICAgICAgICB0aGlzLl90YWJiYXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICB9XG5cbiAgX3NldENoZWNrZWQoaW5kZXgpIHtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4XS5maXJzdEVsZW1lbnRDaGlsZC5jaGVja2VkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUJ1dHRvblxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZUJ1dHRvbihpbmRleCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dQnV0dG9uIGluZGV4LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdCwgd29ya3Mgb25seSBpZiB0aGVyZSBpcyBhIGNvbm5lY3RlZCB0YWJiYXIuIFN1cHBvcnRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgYG9ucy10YWJiYXJgJ3MgYHNldEFjdGl2ZVRhYmAgbWV0aG9kLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlIGJ1dHRvbiB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggYWN0aXZlLiBJZiB0aGVyZSBpcyBhIGNvbm5lY3RlZCB0YWJiYXIgaXQgc2hvd3MgdGhlIGNvcnJlc3BvbmRpbmcgdGFiIHBhZ2UuIEluIHRoaXMgY2FzZSBhbmltYXRpb25zIGFuZCB0aGVpciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNlbGVjdGVkIGluZGV4IG9yIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50IGlmIHRoZXJlIGlzIGEgY29ubmVjdGVkIHRhYmJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlQnV0dG9uKGluZGV4LCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX3RhYmJhcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhYmJhci5zZXRBY3RpdmVUYWIoaW5kZXgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldENoZWNrZWQoaW5kZXgpO1xuICAgIHRoaXMuX3Bvc3RDaGFuZ2UoaW5kZXgpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0QWN0aXZlQnV0dG9uSW5kZXhcbiAgICogQHNpZ25hdHVyZSBnZXRBY3RpdmVCdXR0b25JbmRleCgpXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICBbZW5dVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyBidXR0b24gaW5kZXggb2YgY3VycmVudCBhY3RpdmUgYnV0dG9uLiBJZiBhY3RpdmUgYnV0dG9uIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgLy8gQXJyYXkuZmluZEluZGV4XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5maXJzdEVsZW1lbnRDaGlsZC5jaGVja2VkKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBfb25DaGFuZ2UoZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl90YWJiYXJcbiAgICAgID8gdGhpcy5fdGFiYmFyLnNldEFjdGl2ZVRhYih0aGlzLmdldEFjdGl2ZUJ1dHRvbkluZGV4KCksIHsgcmVqZWN0OiBmYWxzZSB9KVxuICAgICAgOiB0aGlzLl9wb3N0Q2hhbmdlKHRoaXMuZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKSk7XG4gIH1cblxuICBfb25UYWJiYXJQcmVDaGFuZ2UoZXZlbnQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgaWYgKCFldmVudC5kZXRhaWwuY2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0Q2hlY2tlZChldmVudC5pbmRleCk7XG4gICAgICAgIHRoaXMuX3Bvc3RDaGFuZ2UoZXZlbnQuaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3Bvc3RDaGFuZ2UoaW5kZXgpIHtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCB7XG4gICAgICBpbmRleCxcbiAgICAgIGFjdGl2ZUluZGV4OiBpbmRleCxcbiAgICAgIGxhc3RBY3RpdmVJbmRleDogdGhpcy5fbGFzdEFjdGl2ZUluZGV4LFxuICAgICAgc2VnbWVudEl0ZW06IHRoaXMuY2hpbGRyZW5baW5kZXhdXG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc2VnbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncG9zdGNoYW5nZSddO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5TZWdtZW50ID0gU2VnbWVudEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zZWdtZW50JywgU2VnbWVudEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWxlY3QtKicsXG4gICcuc2VsZWN0LWlucHV0JzogJ3NlbGVjdC1pbnB1dC0tKidcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc2VsZWN0JztcblxuY29uc3QgSU5QVVRfQVRUUklCVVRFUyA9IFtcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdmb3JtJyxcbiAgJ211bHRpcGxlJyxcbiAgJ25hbWUnLFxuICAncmVxdWlyZWQnLFxuICAnc2l6ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNlbGVjdFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzZWxlY3QgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgc2VsZWN0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFNlbGVjdCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgc2VsZWN0IHdpdGggYW4gSUQgb2YgYG15LWlkYCBvbiBhIHBhZ2UsIHVzZSBgPG9ucy1zZWxlY3Qgc2VsZWN0LWlkPVwibXktaWRcIj5gLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlbGVjdCBvbiBBbmRyb2lkLlxuICpcbiAqICAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxzZWxlY3Q+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJgc2VsZWN0YCDopoHntKDjgavkvb/nlKjjgafjgY3jgovlsZ7mgKfjga7lpJrjgY/jgYwgYG9ucy1zZWxlY3RgIOimgee0oOOBp+OCguWIqeeUqOOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlbGVjdFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNlbGVjdD5cbiAqICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj4xPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIyXCI+Mm5kPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIzXCI+M3JkIG9wdGlvbjwvb3B0aW9uPlxuICogPC9vbnMtc2VsZWN0PlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0b2ZvY3VzXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbGVtZW50IGF1dG9tYXRpY2FsbHkgZ2FpbnMgZm9jdXMgb24gcGFnZSBsb2FkLlsvZW5dXG4gICAqICBbamFd44Oa44O844K444Ot44O844OJ5pmC44Gr44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr44OV44Kp44O844Kr44K544GM56e744KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIHNlbGVjdCBpbnB1dCBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZm9ybVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQXNzb2NpYXRlIGEgc2VsZWN0IGVsZW1lbnQgdG8gYW4gZXhpc3RpbmcgZm9ybSBvbiB0aGUgcGFnZSwgZXZlbiBpZiBub3QgbmVzdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkuOAgeaMh+WumuOBl+OBnyBgZm9ybWAg6KaB57Sg44Gr57SQ5LuY44GR44G+44GZ44CC44K744Os44Kv44OI44Oc44OD44Kv44K544KSIGBmb3JtYCDopoHntKDjga7lpJblgbTjgavphY3nva7jgZnjgovpmpvjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtdWx0aXBsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgbXVsdGlwbGUgb3B0aW9ucyBjYW4gYmUgc2VsZWN0ZWQgYXQgb25jZS5bL2VuXVxuICAgKiAgW2phXemBuOaKnuiCouOBruikh+aVsOmBuOaKnuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG5hbWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU5hbWUgdGhlIHNlbGVjdCBlbGVtZW50LCB1c2VmdWwgZm9yIGluc3RhbmNlIGlmIGl0IGlzIHBhcnQgb2YgYSBmb3JtLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAgumAmuW4uCBgZm9ybWAg6KaB57Sg44Go5YWx44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlIHRoZSBzZWxlY3QgaW5wdXQgcmVxdWlyZWQgZm9yIHN1Ym1pdHRpbmcgdGhlIGZvcm0gaXQgaXMgcGFydCBvZi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLlhaXlipvlv4XpoIjjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgILpgJrluLggYGZvcm1gIOimgee0oOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlbGVjdC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSUQgZ2l2ZW4gdG8gdGhlIGlubmVyIHNlbGVjdCwgdXNlZnVsIGZvciBkeW5hbWljIG1hbmlwdWxhdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgYzlhoXpg6jjgavmjIHjgaQgc2VsZWN0IOimgee0oOOBq+S4juOBiOOCiyBJRCDjgpLmjIflrprjgZfjgb7jgZnjgILjgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjga7lhoXlrrnjgpLli5XnmoTjgavlpInmm7TjgZnjgovlv4XopoHjgYzjgYLjgovloLTlkIjjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvdyBtYW55IG9wdGlvbnMgYXJlIGRpc3BsYXllZDsgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0aGUgc2l6ZSB0aGVuIGEgc2Nyb2xsIGFwcGVhcnMgdG8gbmF2aWdhdGUgdGhlbS5bL2VuXVxuICAgKiAgIFtqYV3kuIDluqbjgavooajnpLrjgZnjgovpgbjmip7ogqLjga7lgIvmlbDjgpLmjIflrprjgZfjgb7jgZnjgILpgbjmip7ogqLjgYzjgZPjga7lsZ7mgKfjgafmjIflrprjgZfjgZ/lgIvmlbDjgojjgorjgoLlpJrjgYTloLTlkIjjgIHjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl9kZXJpdmVHZXR0ZXJzKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9zZWxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGxlbmd0aFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIG9wdGlvbnMgaW4gdGhlIHNlbGVjdCBib3guWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr5ZCr44G+44KM44KL6YG45oqe6IKi44Gu5YCL5pWw44KS6L+U44GX44G+44GZ44CCIGBzZWxlY3RgIOimgee0oFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2V2ZXJhbCBvcHRpb25zIGZvciBoYW5kbGluZyB0aGUgc2VsZWN0IERPTSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr5ZCr44G+44KM44KLIGBvcHRpb25gIOimgee0oOOBrumFjeWIl+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2VsZWN0ZWRJbmRleFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24uWy9lbl1cbiAgICogICBbamFd54++5Zyo6YG45oqe44GV44KM44Gm44GE44KL6YG45oqe6IKi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVmFsdWUgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24uWy9lbl1cbiAgICogICBbamFd54++5Zyo6YG45oqe44GV44KM44Gm44GE44KL6YG45oqe6IKi44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIGNvbnN0IHNlbCA9IHRoaXMuX3NlbGVjdCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBpZiAoIXNlbC5pZCAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnc2VsZWN0LWlkJykpIHtcbiAgICAgIHNlbC5pZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzZWxlY3QtaWQnKTtcbiAgICB9XG4gICAgc2VsLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdC1pbnB1dCcpO1xuICAgIGlmICghdGhpcy5fc2VsZWN0KSB7XG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiBzZWwuYXBwZW5kQ2hpbGQoZWxlbWVudCkpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChzZWwpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9kZXJpdmVHZXR0ZXJzKCkge1xuICAgIFsnZGlzYWJsZWQnLCAnbGVuZ3RoJywgJ211bHRpcGxlJywgJ25hbWUnLCAnb3B0aW9ucycsICdzZWxlY3RlZEluZGV4JywgJ3NpemUnLCAndmFsdWUnLCAnZm9ybScsICd0eXBlJ11cbiAgICAgIC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogKCkgPT4gdGhpcy5fc2VsZWN0W2tleV0sXG4gICAgICAgICAgc2V0OiBbJ2Zvcm0nLCAndHlwZSddLmluZGV4T2Yoa2V5KSA9PT0gLTFcbiAgICAgICAgICAgID8gdmFsdWUgPT4gKHRoaXMuX3NlbGVjdFtrZXldID0gdmFsdWUpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgYWRkKG9wdGlvbiwgaW5kZXggPSBudWxsKSB7XG4gICAgdGhpcy5fc2VsZWN0LmFkZChvcHRpb24sIGluZGV4KTtcbiAgfVxuXG4gIHJlbW92ZShpbmRleCkge1xuICAgIHRoaXMuX3NlbGVjdC5yZW1vdmUoaW5kZXgpO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5TZWxlY3QgPSBTZWxlY3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc2VsZWN0JywgU2VsZWN0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2ZhYiBmYWItLW1pbmkgc3BlZWQtZGlhbF9faXRlbSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdmYWItLSogc3BlZWQtZGlhbF9faXRlbS0tKidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWwtaXRlbVxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgZGlhbCBjb21wb25lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICBNYXRlcmlhbCBEZXNpZ27jga5TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo54++44GZ44KL6KaB57Sg44Gn44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbFxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWw+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1zcGVlZC1kaWFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICB1dGlsLmFkZE1vZGlmaWVyKHRoaXMsICdtaW5pJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBkZWZhdWx0Q2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuZm9yRWFjaCh0b2tlbiA9PiB0aGlzLmNsYXNzTGlzdC5hZGQodG9rZW4pKTtcblxuICAgIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ21pbmknKTtcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuU3BlZWREaWFsSXRlbSA9IFNwZWVkRGlhbEl0ZW1FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BlZWQtZGlhbC1pdGVtJywgU3BlZWREaWFsSXRlbUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzcGVlZC1kaWFsJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzcGVlZC1kaWFsLS0qJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWxcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEVsZW1lbnQgdGhhdCBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBEaWFsb2cgY29tcG9uZW50LiBJdCBpcyB1c2VmdWwgd2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBwcmltYXJ5IGFjdGlvbiB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgaW4gYSBwYWdlLlxuICpcbiAqICAgICBUaGUgU3BlZWQgZGlhbCBsb29rcyBsaWtlIGEgYDxvbnMtZmFiPmAgZWxlbWVudCBidXQgd2lsbCBleHBhbmQgYSBtZW51IHdoZW4gdGFwcGVkLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+YCByZXByZXNlbnRzIGEgbWVudSBpdGVtLlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBoaWRkZW4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqICAgICBJLmUuIHRvIGRpc3BsYXkgaXQgaW4gdGhlIHRvcCByaWdodCBjb3JuZXIgc3BlY2lmeSBcInJpZ2h0IHRvcFwiLlxuICAgKiAgICAgQ2hvb3NlIGZyb20gXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiBhbmQgXCJib3R0b21cIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBruimgee0oOOCkuihqOekuuOBmeOCi+W3puWPs+OBqOS4iuS4i+OBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5L6L44GI44Gw44CB5Y+z5LiK44Gr6KGo56S644GZ44KL5aC05ZCI44Gr44GvXCJyaWdodCB0b3BcIuOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5bem5Y+z44Go5LiK5LiL44Gu5L2N572u44Gu5oyH5a6a44Gr44Gv44CBcmlnaHTjgahsZWZ044CBdG9w44GoYm90dG9t44GM44Gd44KM44Ge44KM5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBkaXJlY3Rpb24gdGhlIGl0ZW1zIGFyZSBkaXNwbGF5ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIi5bL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOimgee0oOOBjOihqOekuuOBmeOCi+aWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAgnVwLCBkb3duLCBsZWZ0LCByaWdodOOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInLCAncmlwcGxlJywgJ2RpcmVjdGlvbicsICdwb3NpdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURpcmVjdGlvbihjdXJyZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtc3BlZWQtZGlhbC1pdGVtJykpO1xuICB9XG5cbiAgZ2V0IF9mYWIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtZmFiJyk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2dnbGVJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5oaWRlKCkudGhlbihyZXNvbHZlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgaWYgKHRoaXMuX2ZhYikge1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gdGhpcy5fZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogdGhpcy5fZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiBpICsgJ21zJyxcbiAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgICBsZWZ0OiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAndXAnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdXAsIGRvd24sIGxlZnQgb3IgcmlnaHQuJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ2ZhYi0tdG9wX19sZWZ0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19sZWZ0JyxcbiAgICAgICdmYWItLXRvcF9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tdG9wX19jZW50ZXInLFxuICAgICAgJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICBzd2l0Y2gocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRUcmFuc2xhdGUoKSB7XG4gICAgY29uc3QgaXNCb3R0b20gPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykgfHwgJycpLmluZGV4T2YoJ2JvdHRvbScpID49IDA7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gaXNCb3R0b20gPyBgdHJhbnNsYXRlM2QoMHB4LCAtJHt1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0IHx8IDB9cHgsIDBweCkgYCA6ICcnO1xuICAgIHJldHVybiB0cmFuc2xhdGU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLl9mYWIuc2hvdygpO1xuICAgIHN0eWxlcih0aGlzLCB7IHRyYW5zZm9ybTogdGhpcy5fZ2V0VHJhbnNsYXRlIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmhpZGVJdGVtcygpLnRoZW4oKCk9PiB0aGlzLl9mYWIuaGlkZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dJdGVtc1xuICAgKiBAc2lnbmF0dXJlIHNob3dJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2hvd0l0ZW1zKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbih0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgfVxuXG4gICAgbGV0IHRvdGFsRGVsYXkgPSAwO1xuICAgIGlmICghdGhpcy5faXRlbVNob3duKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMjUgKiBpO1xuICAgICAgICB0b3RhbERlbGF5ICs9IGRlbGF5O1xuICAgICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXG4gICAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSArICdtcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0b3RhbERlbGF5ICs9IDUwO1xuXG4gICAgICB0aGlzLl9pdGVtU2hvd24gPSB0cnVlO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvcGVuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgc2V0VGltZW91dChkZWZlcnJlZC5yZXNvbHZlLCB0b3RhbERlbGF5KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVJdGVtc1xuICAgKiBAc2lnbmF0dXJlIGhpZGVJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBzcGVlZCBkaWFsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaGlkZUl0ZW1zKCkge1xuICAgIGxldCB0b3RhbERlbGF5ID0gMDtcbiAgICBpZiAodGhpcy5faXRlbVNob3duKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMjUgKiAoY2hpbGRyZW4ubGVuZ3RoIC0gaSk7XG4gICAgICAgIHRvdGFsRGVsYXkgKz0gZGVsYXk7XG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJyxcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5ICsgJ21zJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRvdGFsRGVsYXkgKz0gNTA7XG5cbiAgICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjbG9zZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHNldFRpbWVvdXQoZGVmZXJyZWQucmVzb2x2ZSwgdG90YWxEZWxheSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5oaWRlSXRlbXMoKTtcbiAgICB9XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZHJlbikuZm9yRWFjaChlID0+IHtcbiAgICAgIHV0aWwubWF0Y2goZSwgJy5mYWInKSAmJiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZShlLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5saW5lXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgaW5saW5lIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg7Pjg6njgqTjg7PopoHntKDjga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGlubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2lubGluZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9mYWIudmlzaWJsZSAmJiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzT3BlblxuICAgKiBAc2lnbmF0dXJlIGlzT3BlbigpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIG1lbnUgaXMgb3BlbiBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbVNob3duO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7ooajnpLrpnZ7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlSXRlbXNcbiAgICogQHNpZ25hdHVyZSB0b2dnbGVJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgaXRlbSB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjga7ooajnpLrpnZ7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlSXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuKCkgPyB0aGlzLmhpZGVJdGVtcygpIDogdGhpcy5zaG93SXRlbXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ29wZW4nLCAnY2xvc2UnXTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuU3BlZWREaWFsID0gU3BlZWREaWFsRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwnLCBTcGVlZERpYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlIHdoaWxlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb250YWlucyB0aGUgbGlzdC5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgZWxlbWVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJDb250ZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSB1cmwgb2YgdGhlIGNvbnRlbnQgcGFnZS4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgdXNlZCB0aGUgY29udGVudCB3aWxsIGJlIGxvYWRlZCBmcm9tIGEgYDxvbnMtdGVtcGxhdGU+YCB0YWcgb3IgYSByZW1vdGUgZmlsZS5cbiAgICpcbiAgICogICAgIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcHV0IGA8b25zLXBhZ2U+YCBlbGVtZW50IGFzIGEgY2hpbGQgb2YgdGhlIGVsZW1lbnQuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHRoaXMuX2dldFBhZ2VUYXJnZXQoKTtcblxuICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgIHRoaXMubG9hZChwYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJvbnMtc3BsaXR0ZXItY29udGVudFwiIG11c3QgaGF2ZSBcIm9ucy1zcGxpdHRlclwiIGFzIHBhcmVudE5vZGUuYCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRvIGxvYWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gcGFnZVxuICAgKi9cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgZWxlbWVudCBsb2FkZWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyJyk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBsb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlLCBbb3B0aW9uc11cbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiBgPG9ucy10ZW1wbGF0ZT5gIGlkLlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBgcGFnZWAgaW4gdGhlIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBgPG9ucy1wYWdlPmAgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXWA8b25zLXBhZ2U+YOimgee0oOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBvbGRDb250ZW50ID0gdGhpcy5fY29udGVudCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKG9sZENvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRDb250ZW50KTtcbiAgICAgICAgICBvbGRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuXG4gICAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5fY29udGVudCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuU3BsaXR0ZXJDb250ZW50ID0gU3BsaXR0ZXJDb250ZW50RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLWNvbnRlbnQnLCBTcGxpdHRlckNvbnRlbnRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlck1hc2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuX3NpZGVzLmV2ZXJ5KHNpZGUgPT4gc2lkZS5tb2RlID09PSAnc3BsaXQnKSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZSAhaW1wb3J0YW50Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfb25DbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgfSBlbHNlIGlmICh1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUuX3NpZGVzLmZvckVhY2goc2lkZSA9PiBzaWRlLmNsb3NlKCdsZWZ0JykuY2F0Y2goKCkgPT4ge30pKTtcbiAgICB9XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBfcHJldmVudFNjcm9sbChlKSB7XG4gICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTsgLy8gRml4IGZvciBpT1MuIFByZXZlbnRzIHNjcm9sbGluZyBjb250ZW50IGJlaGluZCBtYXNrLlxuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fcHJldmVudFNjcm9sbCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3ByZXZlbnRTY3JvbGwpO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5TcGxpdHRlck1hc2sgPSBTcGxpdHRlck1hc2tFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItbWFzaycsIFNwbGl0dGVyTWFza0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi8uLi9vbnMvc3R5bGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGR1cmF0aW9uID0gMC4zLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZHVyYXRpb24sIGRlbGF5IH0pO1xuICB9XG5cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLCB7XG4gICAgICB0aW1pbmc6IHRoaXMudGltaW5nLCBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgZGVsYXk6IHRoaXMuZGVsYXlcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNpZGVFbGVtZW50XG4gICAqL1xuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xuICAgIGNvbnN0IHNwbGl0dGVyID0gc2lkZUVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2lkZSA9IHNpZGVFbGVtZW50O1xuICAgICAgdGhpcy5fb3Bwb3NpdGVTaWRlID0gc3BsaXR0ZXIucmlnaHQgIT09IHNpZGVFbGVtZW50ICYmIHNwbGl0dGVyLnJpZ2h0IHx8IHNwbGl0dGVyLmxlZnQgIT09IHNpZGVFbGVtZW50ICYmIHNwbGl0dGVyLmxlZnQ7XG4gICAgICB0aGlzLl9jb250ZW50ID0gc3BsaXR0ZXIuY29udGVudDtcbiAgICAgIHRoaXMuX21hc2sgPSBzcGxpdHRlci5tYXNrO1xuICAgIH0pO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyVHJhbnNpdGlvbigpO1xuICAgIHRoaXMuX21hc2sgJiYgdGhpcy5jbGVhck1hc2soKTtcbiAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fc2lkZSA9IHRoaXMuX29wcG9zaXRlU2lkZSA9IHRoaXMuX21hc2sgPSBudWxsO1xuICB9XG5cbiAgZ2V0IG1pbnVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWRlLnNpZGUgPT09ICdyaWdodCcgPyAnLScgOiAnJztcbiAgfVxuXG4gIGNsZWFyVHJhbnNpdGlvbigpIHtcbiAgICAnc2lkZSBtYXNrIGNvbnRlbnQnLnNwbGl0KC9cXHMrLylcbiAgICAgIC5mb3JFYWNoKGUgPT4gdGhpc1snXycgKyBlXSAmJiBzdHlsZXIuY2xlYXIodGhpc1snXycgKyBlXSwgJ3RyYW5zZm9ybSB0cmFuc2l0aW9uJykpXG4gIH1cblxuICBjbGVhck1hc2soKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG90aGVyIHNpZGUgbmVlZHMgdGhlIG1hc2sgYmVmb3JlIGNsZWFyaW5nXG4gICAgaWYgKCF0aGlzLl9vcHBvc2l0ZVNpZGUgfHwgdGhpcy5fb3Bwb3NpdGVTaWRlLm1vZGUgPT09ICdzcGxpdCcgfHwgIXRoaXMuX29wcG9zaXRlU2lkZS5pc09wZW4pIHtcbiAgICAgIHRoaXMuX21hc2suc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IgZXh0ZW5kcyBTcGxpdHRlckFuaW1hdG9yIHtcblxuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBBdm9pZCBjb250ZW50IGNsaWNrc1xuXG4gICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAucXVldWUoe1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMHB4LCAwcHgpYFxuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51c30xMDAlLCAwcHgsIDBweClgXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAnMSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2hTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgU3BsaXR0ZXJBbmltYXRvciB7XG5cbiAgX2dldFNsaWRpbmdFbGVtZW50cygpIHtcbiAgICBjb25zdCBzbGlkaW5nRWxlbWVudHMgPSBbdGhpcy5fc2lkZSwgdGhpcy5fY29udGVudF07XG4gICAgaWYgKHRoaXMuX29wcG9zaXRlU2lkZSAmJiB0aGlzLl9vcHBvc2l0ZVNpZGUubW9kZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgc2xpZGluZ0VsZW1lbnRzLnB1c2godGhpcy5fb3Bwb3NpdGVTaWRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpZGluZ0VsZW1lbnRzO1xuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgaWYgKCF0aGlzLl9zbGlkaW5nRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2suc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IC8vIEF2b2lkIGNvbnRlbnQgY2xpY2tzXG5cbiAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgZGlzdGFuY2V9cHgsIDBweCwgMHB4KWBcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX3NpZGUub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBtYXh9cHgsIDBweCwgMHB4KWBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG4gICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgIHN1cGVyLmNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJldmVhbFNwbGl0dGVyQW5pbWF0b3IgZXh0ZW5kcyBTcGxpdHRlckFuaW1hdG9yIHtcblxuICBfZ2V0U2xpZGluZ0VsZW1lbnRzKCkge1xuICAgIGNvbnN0IHNsaWRpbmdFbGVtZW50cyA9IFt0aGlzLl9jb250ZW50LCB0aGlzLl9tYXNrXTtcbiAgICBpZiAodGhpcy5fb3Bwb3NpdGVTaWRlICYmIHRoaXMuX29wcG9zaXRlU2lkZS5tb2RlID09PSAnc3BsaXQnKSB7XG4gICAgICBzbGlkaW5nRWxlbWVudHMucHVzaCh0aGlzLl9vcHBvc2l0ZVNpZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGlkaW5nRWxlbWVudHM7XG4gIH1cblxuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xuICAgIHN1cGVyLmFjdGl2YXRlKHNpZGVFbGVtZW50KTtcbiAgICB0aGlzLm1heFdpZHRoID0gdGhpcy5fZ2V0TWF4V2lkdGgoKTtcbiAgICBpZiAoc2lkZUVsZW1lbnQubW9kZSA9PT0gJ2NvbGxhcHNlJykge1xuICAgICAgdGhpcy5fc2V0U3R5bGVzKHNpZGVFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuX3NpZGUgJiYgdGhpcy5fdW5zZXRTdHlsZXModGhpcy5fc2lkZSk7XG4gICAgc3VwZXIuZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgX3NldFN0eWxlcyhzaWRlRWxlbWVudCkge1xuICAgIHN0eWxlcihzaWRlRWxlbWVudCwge1xuICAgICAgbGVmdDogc2lkZUVsZW1lbnQuc2lkZSA9PT0gJ3JpZ2h0JyA/ICdhdXRvJyA6IDAsXG4gICAgICByaWdodDogc2lkZUVsZW1lbnQuc2lkZSA9PT0gJ3JpZ2h0JyAgPyAwIDogJ2F1dG8nLFxuICAgICAgekluZGV4OiAwLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmxhY2snLFxuICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZSgwKS5jb250YWluZXIudHJhbnNmb3JtLFxuICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgfSk7XG5cbiAgICBjb25zdCBzcGxpdHRlciA9IHNpZGVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29udGVudFJlYWR5KHNwbGl0dGVyLCAoKSA9PiBzcGxpdHRlci5jb250ZW50ICYmIHN0eWxlcihzcGxpdHRlci5jb250ZW50LCB7IGJveFNoYWRvdzogJzAgMCAxMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjIpJyB9KSk7XG4gIH1cblxuICBfdW5zZXRTdHlsZXMoc2lkZUVsZW1lbnQpIHtcbiAgICBzdHlsZXIuY2xlYXIoc2lkZUVsZW1lbnQsICdsZWZ0IHJpZ2h0IHpJbmRleCBiYWNrZ3JvdW5kQ29sb3IgZGlzcGxheScpO1xuICAgIGlmIChzaWRlRWxlbWVudC5fY29udGVudCkge1xuICAgICAgc2lkZUVsZW1lbnQuX2NvbnRlbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBvdGhlciBzaWRlIG5lZWRzIHRoZSBjb21tb24gc3R5bGVzXG4gICAgaWYgKCF0aGlzLl9vcHBvc2l0ZVNpZGUgfHwgdGhpcy5fb3Bwb3NpdGVTaWRlLm1vZGUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHNpZGVFbGVtZW50LnBhcmVudEVsZW1lbnQuY29udGVudCAmJiBzdHlsZXIuY2xlYXIoc2lkZUVsZW1lbnQucGFyZW50RWxlbWVudC5jb250ZW50LCAnYm94U2hhZG93Jyk7XG4gICAgfVxuICB9XG5cbiAgX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKGRpc3RhbmNlKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXhXaWR0aDtcblxuICAgIGxldCBiZWhpbmREaXN0YW5jZSA9IChkaXN0YW5jZSAtIG1heCkgLyBtYXggKiAxMDtcbiAgICBiZWhpbmREaXN0YW5jZSA9IGlzTmFOKGJlaGluZERpc3RhbmNlKSA/IDAgOiBNYXRoLm1heChNYXRoLm1pbihiZWhpbmREaXN0YW5jZSwgMCksIC0xMCk7XG5cbiAgICBjb25zdCBiZWhpbmRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHsodGhpcy5taW51cyA/IC0xIDogMSkgKiBiZWhpbmREaXN0YW5jZX0lLCAwLCAwKWA7XG4gICAgY29uc3Qgb3BhY2l0eSA9IDEgKyBiZWhpbmREaXN0YW5jZSAvIDEwMDtcblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIG9wYWNpdHlcbiAgICAgIH0sXG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgdHJhbnNmb3JtOiBiZWhpbmRUcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgdGhpcy5fc2lkZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgdGhpcy5fc2lkZS5zdHlsZS56SW5kZXggPSAxO1xuICAgIHRoaXMubWF4V2lkdGggPSB0aGlzLm1heFdpZHRoIHx8IHRoaXMuX2dldE1heFdpZHRoKCk7XG4gICAgY29uc3QgbWVudVN0eWxlID0gdGhpcy5fZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUoTWF0aC5taW4oZGlzdGFuY2UsIHRoaXMubWF4V2lkdGgpKTtcblxuICAgIGlmICghdGhpcy5fc2xpZGluZ0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBBdm9pZCBjb250ZW50IGNsaWNrc1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgZGlzdGFuY2V9cHgsIDBweCwgMHB4KWBcbiAgICAgICAgfSksXG4gICAgICBhbmltaXQodGhpcy5fc2lkZS5fY29udGVudClcbiAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250ZW50KSxcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRhaW5lcilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuekluZGV4ID0gMTtcbiAgICB0aGlzLm1heFdpZHRoID0gdGhpcy5tYXhXaWR0aCB8fCB0aGlzLl9nZXRNYXhXaWR0aCgpO1xuICAgIGNvbnN0IG1lbnVTdHlsZSA9IHRoaXMuX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIEZpeDogVGltZSB0byB1cGRhdGUgcHJldmlvdXMgdHJhbnNsYXRlM2QgYWZ0ZXIgY2hhbmdpbmcgc3R5bGUuZGlzcGxheVxuICAgICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyB0aGlzLm1heFdpZHRofXB4LCAwcHgsIDBweClgXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLl9zaWRlLl9jb250ZW50KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250ZW50LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGFpbmVyLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG4gICAgY29uc3QgbWVudVN0eWxlID0gdGhpcy5fZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUoMCk7XG4gICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUuX2NvbnRlbnQpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGVudCwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRhaW5lciwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3NpZGUuc3R5bGUuekluZGV4ID0gMDtcbiAgICAgICAgICB0aGlzLl9zaWRlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5fc2lkZS5fY29udGVudC5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRNYXhXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5vZmZzZXRXaWR0aDtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi8uLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBPdmVybGF5U3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL292ZXJsYXktYW5pbWF0b3InO1xuaW1wb3J0IFB1c2hTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vcHVzaC1hbmltYXRvcic7XG5pbXBvcnQgUmV2ZWFsU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL3JldmVhbC1hbmltYXRvcic7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgZGVmYXVsdDogT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IsXG4gIG92ZXJsYXk6IE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yLFxuICBwdXNoOiBQdXNoU3BsaXR0ZXJBbmltYXRvcixcbiAgcmV2ZWFsOiBSZXZlYWxTcGxpdHRlckFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlclxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgY29tcG9uZW50IHRoYXQgZW5hYmxlcyByZXNwb25zaXZlIGxheW91dCBieSBpbXBsZW1lbnRpbmcgYm90aCBhIHR3by1jb2x1bW4gbGF5b3V0IGFuZCBhIHNsaWRpbmcgbWVudSBsYXlvdXQuXG4gKlxuICogICAgSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBleHBhbmQgaW50byBhIGNvbHVtbiBsYXlvdXQgb24gbGFyZ2Ugc2NyZWVucyBhbmQgY29sbGFwc2UgdGhlIG1lbnUgb24gc21hbGxlciBzY3JlZW5zLiBXaGVuIHRoZSBtZW51IGlzIGNvbGxhcHNlZCB0aGUgdXNlciBjYW4gb3BlbiBpdCBieSBzd2lwaW5nLlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtZW51LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyIGlkPVwic3BsaXR0ZXJcIj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZSBzd2lwZWFibGU+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICB2YXIgc3BsaXR0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BsaXR0ZXInKTtcbiAqICAgc3BsaXR0ZXIubGVmdC5vcGVuKCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIF9nZXRTaWRlKHNpZGUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgZSA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlLmdldEF0dHJpYnV0ZSgnc2lkZScpID09PSBzaWRlO1xuICAgIH0pO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBsZWZ0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1MZWZ0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgnbGVmdCcpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcmlnaHRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJpZ2h0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ3JpZ2h0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNpZGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcnN0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IHJlZ2FyZGxlc3MgdGhlIGFjdHVhbCBzaWRlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgc2lkZSgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1zaWRlJyk7XG4gIH1cblxuICBnZXQgX3NpZGVzKCkge1xuICAgIHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0XS5maWx0ZXIoZSA9PiBlKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IGNvbnRlbnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5fY29udGVudDtcbiAgfVxuXG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLW1hc2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xuICAgIHRoaXMuX3NpZGVzLnNvbWUocyA9PiBzLmlzT3BlbiA/IHMuY2xvc2UoKSA6IGZhbHNlKSB8fCBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xuICB9XG5cbiAgX29uTW9kZUNoYW5nZShlKSB7XG4gICAgaWYgKGUudGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2xheW91dCgpIHtcbiAgICB0aGlzLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgaWYgKHRoaXMuY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGVbc2lkZS5zaWRlXSA9IHNpZGUubW9kZSA9PT0gJ3NwbGl0JyA/IHNpZGUuc3R5bGUud2lkdGggOiAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX29uTW9kZUNoYW5nZSA9IHRoaXMuX29uTW9kZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICF0aGlzLm1hc2sgJiYgdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtc3BsaXR0ZXItbWFzaycpKTtcbiAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCB0aGlzLl9vbk1vZGVDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgdGhpcy5fb25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBfc2hvdygpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmltYXRvciBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBTcGxpdHRlckFuaW1hdG9yLicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNwbGl0dGVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFNwbGl0dGVyQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuU3BsaXR0ZXIgPSBTcGxpdHRlckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlcicsIFNwbGl0dGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuLi9vbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vb25zLXNwbGl0dGVyL2FuaW1hdG9yJztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0IFN3aXBlUmV2ZWFsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9zd2lwZS1yZXZlYWwnO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IFNwbGl0dGVyRWxlbWVudCBmcm9tICcuL29ucy1zcGxpdHRlcic7XG5cbmNvbnN0IFNQTElUX01PREUgPSAnc3BsaXQnO1xuY29uc3QgQ09MTEFQU0VfTU9ERSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTE9TRURfU1RBVEUgPSAnY2xvc2VkJztcbmNvbnN0IE9QRU5fU1RBVEUgPSAnb3Blbic7XG5jb25zdCBDSEFOR0lOR19TVEFURSA9ICdjaGFuZ2luZyc7XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShzcGxpdHRlclNpZGVFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmNsYXNzIENvbGxhcHNlRGV0ZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fb25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRhcmdldCAmJiB0aGlzLmNoYW5nZVRhcmdldCh0YXJnZXQpO1xuICB9XG5cbiAgY2hhbmdlVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10uaW5kZXhPZih0YXJnZXQpICE9PSAtMTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfbWF0Y2godmFsdWUpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXQgPT09ICh2YWx1ZS5pc1BvcnRyYWl0ID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoZXM7XG4gIH1cblxuICBfb25DaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVNb2RlKHRoaXMuX21hdGNoKHZhbHVlKSA/IENPTExBUFNFX01PREUgOiBTUExJVF9NT0RFKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHtpc1BvcnRyYWl0OiBvcmllbnRhdGlvbi5pc1BvcnRyYWl0KCl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSB3aW5kb3cubWF0Y2hNZWRpYSh0aGlzLl90YXJnZXQpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQuYWRkTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5fcXVlcnlSZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3F1ZXJ5UmVzdWx0KSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHdpZHRoVG9QeCA9ICh3aWR0aCwgcGFyZW50KSA9PiB7XG4gIGNvbnN0IFt2YWx1ZSwgcHhdID0gW3BhcnNlSW50KHdpZHRoLCAxMCksIC9weC8udGVzdCh3aWR0aCldO1xuICByZXR1cm4gcHggPyB2YWx1ZSA6IE1hdGgucm91bmQocGFyZW50Lm9mZnNldFdpZHRoICogdmFsdWUgLyAxMDApO1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItc2lkZVxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IHdpbGwgYmUgZGlzcGxheWVkIG9uIGVpdGhlciB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5cbiAqXG4gKiAgICBJdCBzdXBwb3J0cyB0d28gbW9kZXM6IGNvbGxhcHNlZCBhbmQgc3BsaXQuIFdoZW4gaXQncyBpbiBjb2xsYXBzZWQgbW9kZSBpdCB3aWxsIGJlIGhpZGRlbiBmcm9tIHZpZXcgYW5kIGNhbiBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBzd2lwZXMgdGhlIHNjcmVlbiBvciB0YXBzIGEgYnV0dG9uLiBJbiBzcGxpdCBtb2RlIHRoZSBlbGVtZW50IGlzIGFsd2F5cyBzaG93bi4gSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBzd2l0Y2ggYmV0d2VlbiB0aGUgdHdvIG1vZGVzIGRlcGVuZGluZyBvbiB0aGUgc2NyZWVuIHNpemUuXG4gKiAgWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGlzIHRoZSBwYXJlbnQgY29tcG9uZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyU2lkZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBtb2RlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjb21wb25lbnQncyBtb2RlIGNoYW5nZXMuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu44Oi44O844OJ44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5tb2RlXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGN1cnJlbnQgbW9kZS4gQ2FuIGJlIGVpdGhlciBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg6Ljg7zjg4njgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZW9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZyBtZW51LlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0b3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmctbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovjga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0ICBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbi4gVXNlIG9uZSBvZiBgb3ZlcmxheWAsIGBwdXNoYCwgYHJldmVhbGAgb3IgIGBkZWZhdWx0YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwib3ZlcmxheVwiLCBcInB1c2hcIiwgXCJyZXZlYWxcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3Blbi10aHJlc2hvbGRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgIDAuM1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGhvdyBtdWNoIHRoZSBtZW51IG5lZWRzIHRvIGJlIHN3aXBlZCBiZWZvcmUgb3BlbmluZy4gQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDFgLlsvZW5dXG4gICAqICBbamFd44Gp44Gu44GP44KJ44GE44K544Ov44Kk44OX44GZ44KM44Gw44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844KS6ZaL44GP44GL44Gp44GG44GL44Gu5Ymy5ZCI44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTHjga7plpPjga7mlbDlgKTjgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg6/jgqTjg5fjga7ot53pm6LjgYzjgZPjgZPjgafmjIflrprjgZfjgZ/mlbDlgKTmjpvjgZHjgovjgZPjga7opoHntKDjga7luYXjgojjgorjgoLlpKfjgY3jgZHjgozjgbDjgIHjgrnjg6/jgqTjg5fjgYzntYLjgo/jgaPjgZ/mmYLjgavjgZPjga7opoHntKDjgpLplovjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8wLjPjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb2xsYXBzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSBjb2xsYXBzZSBiZWhhdmlvci4gVmFsaWQgdmFsdWVzIGFyZSBgXCJwb3J0cmFpdFwiYCwgYFwibGFuZHNjYXBlXCJgIG9yIGEgbWVkaWEgcXVlcnkuXG4gICAqICAgICBUaGUgc3RyaW5ncyBgXCJwb3J0cmFpdFwiYCBhbmQgYFwibGFuZHNjYXBlXCJgIG1lYW5zIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiBkZXZpY2UgaXMgaW4gbGFuZHNjYXBlIG9yIHBvcnRyYWl0IG9yaWVudGF0aW9uLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIGEgbWVkaWEgcXVlcnksIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiB0aGUgbWVkaWEgcXVlcnkgcmVzb2x2ZXMgdG8gYHRydWVgLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIG5vdCBkZWZpbmVkLCB0aGUgdmlldyBhbHdheXMgYmUgaW4gYFwiY29sbGFwc2VcImAgbW9kZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOW3puWBtOOBruODmuODvOOCuOOCkumdnuihqOekuuOBq+OBmeOCi+adoeS7tuOCkuaMh+WumuOBl+OBvuOBmeOAgnBvcnRyYWl0LCBsYW5kc2NhcGXjgIF3aWR0aCAjcHjjgoLjgZfjgY/jga/jg6Hjg4fjgqPjgqLjgq/jgqjjg6rjga7mjIflrprjgYzlj6/og73jgafjgZnjgIJcbiAgICogICAgIHBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GZ44KL44Go44CB44OH44OQ44Kk44K544Gu55S76Z2i44GM57im5ZCR44GN44KC44GX44GP44Gv5qiq5ZCR44GN44Gr44Gq44Gj44Gf5pmC44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDjg6Hjg4fjgqPjgqLjgq/jgqjjg6rjgpLmjIflrprjgZnjgovjgajjgIHmjIflrprjgZfjgZ/jgq/jgqjjg6rjgavpganlkIjjgZfjgabjgYTjgovloLTlkIjjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOWApOOBq+S9leOCguaMh+WumuOBl+OBquOBhOWgtOWQiOOBq+OBr+OAgeW4uOOBq2NvbGxhcHNl44Oi44O844OJ44Gr44Gq44KK44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGUtdGFyZ2V0LXdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXG4gICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgc3BlY2lmaWVkIGluIGVpdGhlciBwaXhlbHMgb3IgYXMgYSBwZXJjZW50YWdlLCBlLmcuIGA5MCVgIG9yIGAyMDBweGAuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu5qiq5bmF44KS5oyH5a6a44GX44G+44GZ44CCcHjjgagl44Gn44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCZWcuIDkwJSwgMjAwcHhbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaWRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGxlZnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgd2hpY2ggc2lkZSBvZiB0aGUgc2NyZWVuIHRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyBsb2NhdGVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImxlZnRcImAgYW5kIGBcInJpZ2h0XCJgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBjOW3puOBi+WPs+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+WApOOBr1wibGVmdFwi44GLXCJyaWdodFwi44Gu44G/44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImNvbGxhcHNlXCJgIG9yIGBcInNwbGl0XCJgLiBUaGlzIGF0dHJpYnV0ZSBpcyByZWFkIG9ubHkuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44GM6Kit5a6a44GV44KM44G+44GZ44CCXCJjb2xsYXBzZVwi44KC44GX44GP44GvXCJzcGxpdFwi44GM5oyH5a6a44GV44KM44G+44GZ44CC44GT44Gu5bGe5oCn44Gv6Kqt44G/6L6844G/5bCC55So44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBVUkwgb2YgdGhlIG1lbnUgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdG8gZW5hYmxlIHN3aXBlIGludGVyYWN0aW9uIG9uIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4nmmYLjgavjgrnjg6/jgqTjg5fmk43kvZzjgpLmnInlirnjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGUgPSBDTE9TRURfU1RBVEU7XG4gICAgdGhpcy5fbG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbiA9IG5ldyBDb2xsYXBzZURldGVjdGlvbih0aGlzKTtcblxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBTcGxpdHRlckVsZW1lbnQuYW5pbWF0b3JzLFxuICAgICAgYmFzZUNsYXNzOiBTcGxpdHRlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1NwbGl0dGVyQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgLy8gVGhlc2UgYXR0cmlidXRlcyBhcmUgdXNlZCBlYXJseSBieSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCd3aWR0aCcpO1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnc2lkZScpKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzaWRlJywgJ2xlZnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICAgICAgICBwYWdlICYmIHRoaXMubG9hZChwYWdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBtdXN0IGJlIGFuIG9ucy1zcGxpdHRlciBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N3aXBlID0gbmV3IFN3aXBlUmV2ZWFsKHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMsXG4gICAgICBlbGVtZW50SGFuZGxlcjogdGhpcy5wYXJlbnRFbGVtZW50LFxuICAgICAgc3dpcGVNYXg6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgc3dpcGVNaWQ6IGRpc3RhbmNlID0+IHRoaXMuX2FuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSksXG4gICAgICBzd2lwZU1pbjogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxuICAgICAgZ2V0VGhyZXNob2xkOiAoKSA9PiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdvcGVuLXRocmVzaG9sZCcpKSB8fCAwLjMpKSxcbiAgICAgIGdldFNpZGU6ICgpID0+IHRoaXMuc2lkZSxcbiAgICAgIGlzSW5pdGlhbFN0YXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb3NlZCA9IHRoaXMuX3N0YXRlID09PSBDTE9TRURfU1RBVEU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgICAgIHJldHVybiBjbG9zZWQ7XG4gICAgICB9LFxuICAgICAgaWdub3JlU3dpcGU6IChldmVudCwgZGlzdGFuY2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNPcGVuID0gdGhpcy5pc09wZW47XG4gICAgICAgIGNvbnN0IHZhbGlkRHJhZyA9IGQgPT4gdGhpcy5zaWRlID09PSAnbGVmdCdcbiAgICAgICAgICA/ICgoZCA9PT0gJ2xlZnQnICYmIGlzT3BlbikgfHwgKGQgPT09ICdyaWdodCcgJiYgIWlzT3BlbikpXG4gICAgICAgICAgOiAoKGQgPT09ICdsZWZ0JyAmJiAhaXNPcGVuKSB8fCAoZCA9PT0gJ3JpZ2h0JyAmJiBpc09wZW4pKTtcblxuICAgICAgICBjb25zdCBhcmVhID0gTWF0aC5tYXgoMCwgcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRhcmdldC13aWR0aCcpLCAxMCkgfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGUgPT09IFNQTElUX01PREUgfHwgdGhpcy5fbG9jay5pc0xvY2tlZCgpIHx8IHRoaXMuX2lzT3RoZXJTaWRlT3BlbigpXG4gICAgICAgICAgfHwgIXZhbGlkRHJhZyhldmVudC5nZXN0dXJlLmRpcmVjdGlvbilcbiAgICAgICAgICB8fCAoIWlzT3BlbiAmJiBhcmVhICE9PSAwICYmIGRpc3RhbmNlID4gYXJlYSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnc3dpcGVhYmxlJyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5vYnNlcnZlZEF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgc2lkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gJ3JpZ2h0JyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9zd2lwZSA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydhbmltYXRpb24nLCAnd2lkdGgnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ2FuaW1hdGlvbi1vcHRpb25zJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnc3dpcGVhYmxlJzpcbiAgICAgICAgdGhpcy5fc3dpcGUgJiYgdGhpcy5fc3dpcGUudXBkYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gL15cXGQrKHB4fCUpJC8udGVzdChjdXJyZW50KSA/IGN1cnJlbnQgOiAnODAlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzW3V0aWwuY2FtZWxpemUoYF91cGRhdGUtJHtuYW1lfWApXShjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBfZW1pdEV2ZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zbGljZSgwLCAzKSAhPT0gJ3ByZScpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge3NpZGU6IHRoaXN9KTtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7XG4gICAgICBzaWRlOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfaXNPdGhlclNpZGVPcGVuKCkge1xuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKHRoaXMucGFyZW50RWxlbWVudCxcbiAgICAgIGVsID0+IGVsIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciAmJiBlbCAhPT0gdGhpcyAmJiBlbC5fbW9kZSA9PT0gQ09MTEFQU0VfTU9ERSAmJiBlbC5pc09wZW5cbiAgICApO1xuICB9XG5cbiAgX3VwZGF0ZUNvbGxhcHNlKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbGxhcHNlJykpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKFNQTElUX01PREUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnY29sbGFwc2UnKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTW9kZShDT0xMQVBTRV9NT0RFKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5jaGFuZ2VUYXJnZXQodmFsdWUpO1xuICB9XG5cbiAgX3VwZGF0ZU1vZGUobW9kZSkge1xuICAgIGlmIChtb2RlICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RlJywgbW9kZSk7IC8vIHJlYWRvbmx5IGF0dHJpYnV0ZSBmb3IgdGhlIHVzZXJzXG5cbiAgICAgIGlmIChtb2RlID09PSBTUExJVF9NT0RFKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yICYmIHRoaXMuX2FuaW1hdG9yLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDTE9TRURfU1RBVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPT09IE9QRU5fU1RBVEUgJiYgdGhpcy5fYW5pbWF0b3Iub3BlbigpO1xuICAgICAgfVxuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ21vZGVjaGFuZ2UnLCB7IHNpZGU6IHRoaXMsIG1vZGUgfSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbihhbmltYXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykpIHtcbiAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5kZWFjdGl2YXRlKCk7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Ioe2FuaW1hdGlvbn0pO1xuICAgIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbk9wdGlvbnModmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yLnVwZGF0ZU9wdGlvbnMoQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBsb2NhdGlvbiB0byBsb2FkIGluIHRoZSBzcGxpdHRlciBzaWRlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHBhZ2VcbiAgICovXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpc09wZW5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgd2hlbiB0aGUgbWVudSBpcyBvcGVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlID09PSBDT0xMQVBTRV9NT0RFICYmIHRoaXMuX3N0YXRlICE9PSBDTE9TRURfU1RBVEU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBvcGVuXG4gICAqIEBzaWduYXR1cmUgb3Blbihbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW4gbWVudSBpbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ44Gr44Gq44Gj44Gm44GE44KLb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIG9wZW4ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZShvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb3NlXG4gICAqIEBzaWduYXR1cmUgY2xvc2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY2xvc2Uob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZShvcHRpb25zLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVucyBpZiBpdCdzIGNsb3NlZC4gQ2xvc2VzIGlmIGl0J3Mgb3Blbi5bL2VuXVxuICAgKiAgIFtqYV3plovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplonjgZjjgb7jgZnjgZ3jgZfjgabplovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShvcHRpb25zID0ge30sIGZvcmNlKSB7XG4gICAgY29uc3Qgc2hvdWxkT3BlbiA9IHR5cGVvZiBmb3JjZSA9PT0gJ2Jvb2xlYW4nID8gZm9yY2UgOiAhdGhpcy5pc09wZW47XG4gICAgY29uc3QgYWN0aW9uID0gc2hvdWxkT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScsXG4gICAgICBGSU5BTF9TVEFURSA9IHNob3VsZE9wZW4gPyBPUEVOX1NUQVRFIDogQ0xPU0VEX1NUQVRFO1xuXG4gICAgaWYgKHRoaXMuX21vZGUgPT09IFNQTElUX01PREUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgc3BsaXR0ZXItc2lkZSBhY3Rpb24gaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkT3BlbiAmJiB0aGlzLl9pc090aGVyU2lkZU9wZW4oKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIG1lbnUgaXMgYWxyZWFkeSBvcGVuLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdEV2ZW50KGBwcmUke2FjdGlvbn1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke2FjdGlvbn0gZXZlbnQuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5sb2NrID0gdGhpcy5fbG9jay5sb2NrKCk7XG4gICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yW2FjdGlvbl0oKCkgPT4ge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEZJTkFMX1NUQVRFO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgdGhpcy5fZW1pdEV2ZW50KGBwb3N0JHthY3Rpb259YCk7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmNhbGxiYWNrKHRoaXMpO1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZG9jdW1lbnQgb3IgYW4gPG9ucy10ZW1wbGF0ZT4uWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgW9ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHBhZ2Ugc3BlY2lmaWVkIGluIHBhZ2VVcmwgaW4gdGhlIHJpZ2h0IHNlY3Rpb25bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9VUkzjgpLjg6HjgqTjg7Pjg5rjg7zjgrjjgpLoqq3jgb/ovrzjgb/jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBsb2FkKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCAoKCkgPT4ge30pO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IG9sZENvbnRlbnQgPSB0aGlzLl9jb250ZW50IHx8IG51bGw7XG5cbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAob2xkQ29udGVudCkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKG9sZENvbnRlbnQpO1xuICAgICAgICAgIG9sZENvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG5cbiAgICAgICAgY2FsbGJhY2socGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX3Nob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZW9wZW4nLCAncG9zdG9wZW4nLCAncHJlY2xvc2UnLCAncG9zdGNsb3NlJywgJ21vZGVjaGFuZ2UnXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5TcGxpdHRlclNpZGUgPSBTcGxpdHRlclNpZGVFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItc2lkZScsIFNwbGl0dGVyU2lkZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VDaGVja2JveEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtY2hlY2tib3gnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3N3aXRjaC0tKicsXG4gICcuc3dpdGNoX19pbnB1dCc6ICdzd2l0Y2gtLSpfX2lucHV0JyxcbiAgJy5zd2l0Y2hfX2hhbmRsZSc6ICdzd2l0Y2gtLSpfX2hhbmRsZScsXG4gICcuc3dpdGNoX190b2dnbGUnOiAnc3dpdGNoLS0qX190b2dnbGUnXG59O1xuXG5jb25zdCBsb2NhdGlvbnMgPSB7XG4gIGlvczogWzEsIDIxXSxcbiAgbWF0ZXJpYWw6IFswLCAxNl1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXN3aXRjaFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU3dpdGNoIGNvbXBvbmVudC4gVGhlIHN3aXRjaCBjYW4gYmUgdG9nZ2xlZCBib3RoIGJ5IGRyYWdnaW5nIGFuZCB0YXBwaW5nLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc3dpdGNoIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOCueOCpOODg+ODgeOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzd2l0Y2hbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIExwWFpRUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3N3aXRjaFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zd2l0Y2ggY2hlY2tlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBkaXNhYmxlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBtb2RpZmllcj1cIm1hdGVyaWFsXCI+PC9vbnMtc3dpdGNoPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN3aXRjaEVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdtb2RpZmllcicsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAnc3dpdGNoJztcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxpbnB1dCB0eXBlPVwiJHt0aGlzLnR5cGV9XCIgY2xhc3M9XCIke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19pbnB1dFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX3RvZ2dsZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faGFuZGxlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX3RvdWNoXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnY2hlY2tib3gnO1xuICB9XG5cbiAgLyogT3duIHByb3BzICovXG5cbiAgX2dldFBvc2l0aW9uKGUpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fbG9jYXRpb25zO1xuICAgIHJldHVybiBNYXRoLm1pbihsWzFdLCBNYXRoLm1heChsWzBdLCB0aGlzLl9zdGFydFggKyBlLmdlc3R1cmUuZGVsdGFYKSk7XG4gIH1cblxuICBfZW1pdENoYW5nZUV2ZW50KCkge1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlJywge1xuICAgICAgdmFsdWU6IHRoaXMuY2hlY2tlZCxcbiAgICAgIHN3aXRjaDogdGhpcyxcbiAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9vbkNoYW5nZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgX29uQ2xpY2soZXYpIHtcbiAgICBpZiAoZXYudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhgJHt0aGlzLmRlZmF1bHRFbGVtZW50Q2xhc3N9X190b3VjaGApKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgTW9kaWZpZXJVdGlsLmFkZE1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGUpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLmNvbnN1bWVkID0gdHJ1ZTtcblxuICAgIE1vZGlmaWVyVXRpbC5hZGRNb2RpZmllcih0aGlzLCAnYWN0aXZlJyk7XG4gICAgdGhpcy5fc3RhcnRYID0gdGhpcy5fbG9jYXRpb25zW3RoaXMuY2hlY2tlZCA/IDEgOiAwXTsvLyAtIGUuZ2VzdHVyZS5kZWx0YVg7XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gdGhpcy5fZ2V0UG9zaXRpb24oZSkgKyAncHgnO1xuICB9XG5cbiAgX29uUmVsZWFzZShlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKGUpO1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLmNoZWNrZWQ7XG5cbiAgICB0aGlzLmNoZWNrZWQgPSBwb3NpdGlvbiA+PSAobFswXSArIGxbMV0pIC8gMjtcblxuICAgIGlmICh0aGlzLmNoZWNrZWQgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcblxuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgfVxuXG4gIGNsaWNrKCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfaGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19oYW5kbGVgKTtcbiAgfVxuXG4gIGdldCBjaGVja2JveCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQ7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9vbkhvbGQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcywge2RyYWdNaW5EaXN0YW5jZTogMSwgaG9sZFRpbWVvdXQ6IDI1MX0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIGNvbnN0IG1kID0gKGN1cnJlbnQgfHwgJycpLmluZGV4T2YoJ21hdGVyaWFsJykgIT09IC0xO1xuICAgICAgdGhpcy5fbG9jYXRpb25zID0gbG9jYXRpb25zW21kID8gJ21hdGVyaWFsJyA6ICdpb3MnXTtcbiAgICB9XG5cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQGV2ZW50IGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3dpdGNoIGlzIHRvZ2dsZWQuWy9lbl1cbiAgICogICBbamFdT04vT0ZG44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc3dpdGNoXG4gICAqICAgW2VuXVN3aXRjaCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfU3dpdGNo44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC52YWx1ZVxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruWApOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNJbnRlcmFjdGl2ZVxuICAgKiAgIFtlbl1UcnVlIGlmIHRoZSBjaGFuZ2Ugd2FzIHRyaWdnZXJlZCBieSB0aGUgdXNlciBjbGlja2luZyBvbiB0aGUgc3dpdGNoLlsvZW5dXG4gICAqICAgW2phXeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBquOBqeOBruODpuODvOOCtuOBruaTjeS9nOOBq+OCiOOBo+OBpuWkieOCj+OBo+OBn+WgtOWQiOOBq+OBr3RydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgc3dpdGNoLlsvZW5dXG4gICAqICBbamFd44K544Kk44OD44OB44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgpLnhKHlirnjga7nirbmhYvjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjaGVja2VkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgY2hlY2tlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgYxPTuOBrueKtuaFi+OBq+OBmeOCi+OBqOOBjeOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBgaWRgIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgdmFsdWUgaXMgYHRydWVgIGlmIHRoZSBzd2l0Y2ggaXMgY2hlY2tlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgYxPTuOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2JveFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHVuZGVybHlpbmcgY2hlY2tib3ggZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXpg6jjga5jaGVja2JveOimgee0oOOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG59XG5cbm9ucy5lbGVtZW50cy5Td2l0Y2ggPSBTd2l0Y2hFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3dpdGNoJywgU3dpdGNoRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBTd2lwZXIgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL3N3aXBlcic7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRhYmJhcl9fY29udGVudCc6ICd0YWJiYXItLSpfX2NvbnRlbnQnLFxuICAnLnRhYmJhcl9fYm9yZGVyJzogJ3RhYmJhci0tKl9fYm9yZGVyJyxcbiAgJy50YWJiYXInOiAndGFiYmFyLS0qJ1xufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHRhYmJhckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuY29uc3QgbnVsbFBhZ2UgPSBpbnRlcm5hbC5udWxsRWxlbWVudDtcbmNvbnN0IGxlcnAgPSAoeDAsIHgxLCB0KSA9PiAoMSAtIHQpICogeDAgKyB0ICogeDE7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYmJhclxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1BIGNvbXBvbmVudCB0byBkaXNwbGF5IGEgdGFiIGJhciBvbiB0aGUgYm90dG9tIG9mIGEgcGFnZS4gVXNlZCB3aXRoIGA8b25zLXRhYj5gIHRvIG1hbmFnZSBwYWdlcyB1c2luZyB0YWJzLlsvZW5dXG4gKiAgIFtqYV3jgr/jg5bjg5Djg7zjgpLjg5rjg7zjgrjkuIvpg6jjgavooajnpLrjgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJvbnMtdGFi44Go57WE44G/5ZCI44KP44Gb44Gm5L2/44GG44GT44Go44Gn44CB44Oa44O844K444KS566h55CG44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHBHdURMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXUEgdGFiYmFyIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBhdXRvZ3Jvd1xuICogICBbZW5dVGFicyBhdXRvbWF0aWNhbGx5IGdyb3cgZGVwZW5kaW5nIG9uIHRoZWlyIGNvbnRlbnQgaW5zdGVhZCBvZiBoYXZpbmcgYSBmaXhlZCB3aWR0aC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0b3AtYm9yZGVyXG4gKiAgIFtlbl1TaG93cyBhIHN0YXRpYyBib3JkZXItYm90dG9tIGluIHRhYnMgZm9yIGlPUyB0b3AgdGFiYmFycy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRhYlxuICogICBbZW5dVGhlIGA8b25zLXRhYj5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXRhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5dVGhlIGA8b25zLXBhZ2U+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBiZWZvcmUgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIGNoYW5nZSBldmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjga7lpInmm7TjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGp1c3QgYWZ0ZXIgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OBo+OBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCByZWFjdGl2ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMgaWYgdGhlIGFscmVhZHkgb3BlbiB0YWIgaXMgdGFwcGVkIGFnYWluLlsvZW5dXG4gICAqICAgW2phXeOBmeOBp+OBq+OCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBjOOCguOBhuS4gOW6puOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBleOCjOOBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IG5vbmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGJvdHRvbVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGFiYmFyJ3MgcG9zaXRpb24uIEF2YWlsYWJsZSB2YWx1ZXMgYXJlIGBcImJvdHRvbVwiYCBhbmQgYFwidG9wXCJgLiBVc2UgYFwiYXV0b1wiYCB0byBjaG9vc2UgcG9zaXRpb24gZGVwZW5kaW5nIG9uIHBsYXRmb3JtIChpT1MgYm90dG9tLCBBbmRyb2lkIHRvcCkuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXCJib3R0b21cIuOCguOBl+OBj+OBr1widG9wXCLjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImJvdHRvbVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHRhYiBiYXIgY2FuIGJlIHNjcm9sbGVkIGJ5IGRyYWcgb3Igc3dpcGUuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OW44OQ44O844KS44K544Ov44Kk44OX44KE44OJ44Op44OD44Kw44Gn56e75YuV44Gn44GN44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWdub3JlLWVkZ2Utd2lkdGhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMjBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3RhbmNlIGluIHBpeGVscyBmcm9tIGJvdGggZWRnZXMuIFN3aXBpbmcgb24gdGhlc2UgYXJlYXMgd2lsbCBwcmlvcml0aXplIHBhcmVudCBjb21wb25lbnRzIHN1Y2ggYXMgYG9ucy1zcGxpdHRlcmAgb3IgYG9ucy1uYXZpZ2F0b3JgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGhpZGUtdGFic1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0byBoaWRlIHRoZSB0YWJzLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluOCkumdnuihqOekuuOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYi1ib3JkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgdGFicyBzaG93IGEgZHluYW1pYyBib3R0b20gYm9yZGVyLiBPbmx5IHdvcmtzIGZvciBpT1Mgc2luY2UgdGhlIGJvcmRlciBpcyBhbHdheXMgdmlzaWJsZSBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0YWJiYXIuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5fc3dpcGVyKSB7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBuZXcgU3dpcGVyKHtcbiAgICAgICAgZ2V0RWxlbWVudDogKCkgPT4gdGhpcy5fY29udGVudEVsZW1lbnQsXG4gICAgICAgIGdldEluaXRpYWxJbmRleDogKCkgPT4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZUluZGV4JykgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZS1pbmRleCcpLFxuICAgICAgICBnZXRBdXRvU2Nyb2xsUmF0aW86IHRoaXMuX2dldEF1dG9TY3JvbGxSYXRpby5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRCdWJibGVXaWR0aDogKCkgPT4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2lnbm9yZS1lZGdlLXdpZHRoJykgfHwgMjUsIDEwKSxcbiAgICAgICAgaXNBdXRvU2Nyb2xsYWJsZTogKCkgPT4gdHJ1ZSxcbiAgICAgICAgcHJlQ2hhbmdlSG9vazogdGhpcy5fb25QcmVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgcG9zdENoYW5nZUhvb2s6IHRoaXMuX29uUG9zdENoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICByZWZyZXNoSG9vazogdGhpcy5fb25SZWZyZXNoLmJpbmQodGhpcyksXG4gICAgICAgIHNjcm9sbEhvb2s6IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcylcbiAgICAgIH0pO1xuXG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl90YWJiYXJCb3JkZXIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLl90YWJiYXJFbGVtZW50LCAnLnRhYmJhcl9fYm9yZGVyJyk7XG4gICAgICAgIHRoaXMuX3N3aXBlci5pbml0KHsgc3dpcGVhYmxlOiB0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJykgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5fc3dpcGVyICYmIHRoaXMuX3N3aXBlci5pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5fc3dpcGVyLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX3N3aXBlciA9IG51bGw7XG4gICAgICB0aGlzLl90YWJiYXJCb3JkZXIgPSBudWxsO1xuICAgICAgdGhpcy5fdGFic1JlY3QgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9ub3JtYWxpemVFdmVudChldmVudCkge1xuICAgIHJldHVybiB7IC4uLmV2ZW50LCBpbmRleDogZXZlbnQuYWN0aXZlSW5kZXgsIHRhYkl0ZW06IHRoaXMudGFic1tldmVudC5hY3RpdmVJbmRleF0gfTtcbiAgfVxuXG4gIF9vblBvc3RDaGFuZ2UoZXZlbnQpIHtcbiAgICBldmVudCA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50KGV2ZW50KTtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCBldmVudCk7XG4gICAgY29uc3QgcGFnZSA9IGV2ZW50LnRhYkl0ZW0ucGFnZUVsZW1lbnQ7XG4gICAgcGFnZSAmJiBwYWdlLl9zaG93KCk7XG4gIH1cblxuICBfb25QcmVDaGFuZ2UoZXZlbnQpIHtcbiAgICBldmVudCA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50KGV2ZW50KTtcbiAgICBldmVudC5jYW5jZWwgPSAoKSA9PiBldmVudC5jYW5jZWxlZCA9IHRydWU7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWNoYW5nZScsIGV2ZW50KTtcblxuICAgIGlmICghZXZlbnQuY2FuY2VsZWQpIHtcbiAgICAgIGNvbnN0IHsgYWN0aXZlSW5kZXgsIGxhc3RBY3RpdmVJbmRleCB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzO1xuXG4gICAgICB0YWJzW2FjdGl2ZUluZGV4XS5zZXRBY3RpdmUodHJ1ZSk7XG4gICAgICBpZiAobGFzdEFjdGl2ZUluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgcHJldlRhYiA9IHRhYnNbbGFzdEFjdGl2ZUluZGV4XTtcbiAgICAgICAgcHJldlRhYi5zZXRBY3RpdmUoZmFsc2UpO1xuICAgICAgICBwcmV2VGFiLnBhZ2VFbGVtZW50ICYmIHByZXZUYWIucGFnZUVsZW1lbnQuX2hpZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQuY2FuY2VsZWRcbiAgfVxuXG4gIF9vblNjcm9sbChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3RhYmJhckJvcmRlcikge1xuICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7b3B0aW9ucy5kdXJhdGlvbiB8fCAwfXMgJHtvcHRpb25zLnRpbWluZyB8fCAnJ31gO1xuXG4gICAgICBpZiAodGhpcy5fYXV0b2dyb3cgJiYgdGhpcy5fdGFic1JlY3QubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhID0gTWF0aC5mbG9vcihpbmRleCksIGIgPSBNYXRoLmNlaWwoaW5kZXgpLCByID0gaW5kZXggJSAxO1xuICAgICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUud2lkdGggPSBsZXJwKHRoaXMuX3RhYnNSZWN0W2FdLndpZHRoLCB0aGlzLl90YWJzUmVjdFtiXS53aWR0aCwgcikgKyAncHgnO1xuICAgICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7bGVycCh0aGlzLl90YWJzUmVjdFthXS5sZWZ0LCB0aGlzLl90YWJzUmVjdFtiXS5sZWZ0LCByKX1weCwgMCwgMClgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2luZGV4ICogMTAwfSUsIDAsIDApYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9vblN3aXBlICYmIHRoaXMuX29uU3dpcGUoaW5kZXgsIG9wdGlvbnMpO1xuICB9XG5cbiAgX29uUmVmcmVzaCgpIHtcbiAgICB0aGlzLl9hdXRvZ3JvdyA9IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ2F1dG9ncm93Jyk7XG4gICAgdGhpcy5fdGFic1JlY3QgPSB0aGlzLnRhYnMubWFwKHRhYiA9PiB0YWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgIGlmICh0aGlzLl90YWJiYXJCb3JkZXIpIHtcbiAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS5kaXNwbGF5ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ3RhYi1ib3JkZXInKSB8fCBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKTtcbiAgICAgIGlmICh0aGlzLl90YWJzUmVjdC5sZW5ndGggPiAwICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLndpZHRoID0gdGhpcy5fdGFic1JlY3RbaW5kZXhdLndpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0QXV0b1Njcm9sbFJhdGlvKG1hdGNoZXMsIHZlbG9jaXR5LCBzaXplKSB7XG4gICAgY29uc3QgcmF0aW8gPSAuNjsgLy8gQmFzZSByYXRpb1xuICAgIGNvbnN0IG1vZGlmaWVyID0gc2l6ZSAvIDMwMCAqIChtYXRjaGVzID8gLTEgOiAxKTsgLy8gQmFzZWQgb24gc2NyZWVuIHNpemVcbiAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgcmF0aW8gKyB2ZWxvY2l0eSAqIG1vZGlmaWVyKSk7XG4gIH1cblxuICBnZXQgX3RhYmJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiYmFyJyk7XG4gIH1cblxuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYmJhcl9fY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IF90YXJnZXRFbGVtZW50KCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudDtcbiAgICByZXR1cm4gY29udGVudCAmJiBjb250ZW50LmNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudCB8fCB1dGlsLmNyZWF0ZSgnLnRhYmJhcl9fY29udGVudCcpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnb25zLXRhYmJhcl9fY29udGVudCcpO1xuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhckVsZW1lbnQgfHwgdXRpbC5jcmVhdGUoJy50YWJiYXInKTtcbiAgICB0YWJiYXIuY2xhc3NMaXN0LmFkZCgnb25zLXRhYmJhcl9fZm9vdGVyJyk7XG5cbiAgICBpZiAoIXRhYmJhci5wYXJlbnROb2RlKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gTnVtYmVyKHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpKTsgLy8gMCBieSBkZWZhdWx0XG4gICAgaWYgKHRhYmJhci5jaGlsZHJlbi5sZW5ndGggPiBhY3RpdmVJbmRleCAmJiAhdXRpbC5maW5kQ2hpbGQodGFiYmFyLCAnW2FjdGl2ZV0nKSkge1xuICAgICAgdGFiYmFyLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICcnKTtcbiAgICB9XG5cbiAgICB0aGlzLl90YWJiYXJCb3JkZXIgPSB1dGlsLmZpbmRDaGlsZCh0YWJiYXIsICcudGFiYmFyX19ib3JkZXInKSB8fCB1dGlsLmNyZWF0ZSgnLnRhYmJhcl9fYm9yZGVyJyk7XG4gICAgdGFiYmFyLmFwcGVuZENoaWxkKHRoaXMuX3RhYmJhckJvcmRlcik7XG4gICAgdGFiYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy1zd2lwZXItdGFiYmFyJyk7IC8vIEhpZGVzIG1hdGVyaWFsIGJvcmRlclxuXG4gICAgIWNvbnRlbnQuY2hpbGRyZW5bMF0gJiYgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgIWNvbnRlbnQuY2hpbGRyZW5bMV0gJiYgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgY29udGVudC5hcHBlbmRDaGlsZCA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQuYmluZChjb250ZW50LmNoaWxkcmVuWzBdKTtcbiAgICBjb250ZW50Lmluc2VydEJlZm9yZSA9IGNvbnRlbnQuaW5zZXJ0QmVmb3JlLmJpbmQoY29udGVudC5jaGlsZHJlblswXSk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGFiYmFyKTsgLy8gVHJpZ2dlcnMgb25zLXRhYiBjb25uZWN0ZWRDYWxsYmFja1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgcGxhdGZvcm0uaXNBbmRyb2lkKCkpO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRvcCA/IHV0aWwuYWRkTW9kaWZpZXIgOiB1dGlsLnJlbW92ZU1vZGlmaWVyO1xuXG4gICAgYWN0aW9uKHRoaXMsICd0b3AnKTtcblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIGNvbnRlbnRSZWFkeShwYWdlLCAoKSA9PiB7XG4gICAgICAgIGxldCBwID0gMDtcbiAgICAgICAgaWYgKHBhZ2UuY2hpbGRyZW5bMF0gJiYgdXRpbC5tYXRjaChwYWdlLmNoaWxkcmVuWzBdLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgICAgIGFjdGlvbihwYWdlLmNoaWxkcmVuWzBdLCAnbm9zaGFkb3cnKTtcbiAgICAgICAgICBwID0gMTsgLy8gVmlzdWFsIGZpeCBmb3Igc29tZSBkZXZpY2VzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBudWxsKVxuXG4gICAgICAgIHRoaXMuc3R5bGUudG9wID0gdG9wID8gcGFyc2VJbnQoY3MuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSwgMTApIC0gcCArICdweCcgOiAnJztcblxuICAgICAgICAvLyBSZWZyZXNoIGNvbnRlbnQgdG9wIC0gRml4IGZvciBpT1MgOFxuICAgICAgICBjb250ZW50LnN0eWxlLnRvcCA9IGNzLnRvcDtcbiAgICAgICAgY29udGVudC5zdHlsZS50b3AgPSAnJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgdG9wICYmICFmaWxsZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgY29uc3QgdGFicyA9IHRoaXMudGFicyxcbiAgICAgIGluZGV4ID0gdGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpO1xuICAgIHJldHVybiB0YWJzW2luZGV4XVxuICAgICAgPyB0YWJzW2luZGV4XS5wYWdlRWxlbWVudCB8fCB0aGlzLnBhZ2VzWzBdIHx8IG51bGxcbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fdGFyZ2V0RWxlbWVudC5jaGlsZHJlbik7XG4gIH1cblxuICBnZXQgdGFicygpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuX3RhYmJhckVsZW1lbnQuY2hpbGRyZW4sIGUgPT4gZS50YWdOYW1lID09PSAnT05TLVRBQicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlVGFiXG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlVGFiKGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UYWIgaW5kZXguWy9lbl1cbiAgICogICBbamFd44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IHJ1bnMgd2hlbiB0aGUgbmV3IHBhZ2UgaGFzIGxvYWRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIG9wdGlvbiBpcyBcIm5vbmVcIiwgdGhlIHRyYW5zaXRpb24gd29uJ3Qgc2xpZGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHNwZWNpZmllZCB0YWIgcGFnZS4gQW5pbWF0aW9ucyBhbmQgdGhlaXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+OCpOODs+ODh+ODg+OCr+OCueOBruOCv+ODluOCkuihqOekuuOBl+OBvuOBmeOAguOCouODi+ODoeODvOOCt+ODp+ODs+OBquOBqeOBruOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVUYWIobmV4dEluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgY29uc3QgcHJldlRhYiA9IHRoaXMudGFic1twcmV2SW5kZXhdLFxuICAgICAgbmV4dFRhYiA9IHRoaXMudGFic1tuZXh0SW5kZXhdO1xuXG4gICAgaWYgKCFuZXh0VGFiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwZWNpZmllZCBpbmRleCBkb2VzIG5vdCBtYXRjaCBhbnkgdGFiLicpO1xuICAgIH1cblxuICAgIGlmIChuZXh0SW5kZXggPT09IHByZXZJbmRleCkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWFjdGl2ZScsIHsgaW5kZXg6IG5leHRJbmRleCwgYWN0aXZlSW5kZXg6IG5leHRJbmRleCwgdGFiSXRlbTogbmV4dFRhYiB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV4dFRhYi5wYWdlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IG5leHRUYWIubG9hZGVkIGlzIGJyb2tlbiBpbiBab25lLmpzIHByb21pc2VzIChBbmd1bGFyMilcbiAgICBjb25zdCBuZXh0UGFnZSA9IG5leHRUYWIucGFnZUVsZW1lbnQ7XG4gICAgcmV0dXJuIChuZXh0UGFnZSA/IFByb21pc2UucmVzb2x2ZShuZXh0UGFnZSkgOiBuZXh0VGFiLmxvYWRlZClcbiAgICAgIC50aGVuKG5leHRQYWdlID0+IHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChuZXh0SW5kZXgsIHtcbiAgICAgICAgcmVqZWN0OiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBhbmltYXRpb246IHByZXZUYWIgJiYgbmV4dFBhZ2UgPyBvcHRpb25zLmFuaW1hdGlvbiB8fCB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgOiAnbm9uZScsXG4gICAgICAgIGFuaW1hdGlvbk9wdGlvbnM6IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgIHsgZHVyYXRpb246IC4zLCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjQsIC43LCAuNSwgMSknIH0sXG4gICAgICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykgPyB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkgOiB7fSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmNhbGxiYWNrKG5leHRQYWdlKTtcbiAgICAgICAgcmV0dXJuIG5leHRQYWdlO1xuICAgICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0VGFiYmFyVmlzaWJpbGl0eVxuICAgKiBAc2lnbmF0dXJlIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSlcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIGhpZGUgb3Igc2hvdyB0aGUgdGFiIGJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnN0eWxlW3RoaXMuX3RvcCA/ICd0b3AnIDogJ2JvdHRvbSddID0gdmlzaWJsZSA/ICcnIDogJzBweCc7XG4gICAgICB0aGlzLl90YWJiYXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eSh0cnVlKTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zZXRUYWJiYXJWaXNpYmlsaXR5KGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSB0YWJiYXIgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90YWJiYXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc3dpcGVhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRW5hYmxlIHN3aXBlIGludGVyYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXN3aXBlYWJsZeOBp+OBguOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHN3aXBlYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpO1xuICB9XG5cbiAgc2V0IHN3aXBlYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3dpcGVhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblN3aXBlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvb2sgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIHNsaWRlcyB0aGUgdGFiYmFyLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29uU3dpcGUnIG11c3QgYmUgYSBmdW5jdGlvbi5gKVxuICAgIH1cbiAgICB0aGlzLl9vblN3aXBlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVUYWJJbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZVRhYkluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHRhYiBpbmRleCBvbiBjdXJyZW50IGFjdGl2ZSB0YWIuIElmIGFjdGl2ZSB0YWIgaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAguePvuWcqOOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOOBquOBhOWgtOWQiOOBq+OBry0x44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZVRhYkluZGV4KCkge1xuICAgIGZvciAobGV0IHRhYnMgPSB0aGlzLnRhYnMsIGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhYnNbaV0gJiYgdGFic1tpXS50YWdOYW1lID09PSAnT05TLVRBQicgJiYgdGFic1tpXS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLl9zd2lwZXIuc2hvdygpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnRhYnMubGVuZ3RoID4gMCAmJiB0aGlzLnRhYnNbdGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpXS5sb2FkZWQudGhlbihlbCA9PiBlbCAmJiBzZXRJbW1lZGlhdGUoKCkgPT4gZWwuX3Nob3coKSkpKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHRoaXMuX3N3aXBlci5oaWRlKCk7XG4gICAgY29uc3QgdG9wUGFnZSA9IHRoaXMudG9wUGFnZTtcbiAgICB0b3BQYWdlICYmIHRvcFBhZ2UuX2hpZGUoKTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMudGFicy5mb3JFYWNoKHRhYiA9PiB0YWIucmVtb3ZlKCkpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdwb3NpdGlvbicsICdzd2lwZWFibGUnLCAndGFiLWJvcmRlcicsICdoaWRlLXRhYnMnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgY29uc3QgaXNUb3AgPSBtID0+IC8oXnxcXHMrKXRvcCgkfFxccyspL2kudGVzdChtKTtcbiAgICAgIGlzVG9wKGxhc3QpICE9PSBpc1RvcChjdXJyZW50KSAmJiB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3Bvc2l0aW9uJykge1xuICAgICAgdXRpbC5pc0F0dGFjaGVkKHRoaXMpICYmIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnc3dpcGVhYmxlJykge1xuICAgICAgdGhpcy5fc3dpcGVyICYmIHRoaXMuX3N3aXBlci51cGRhdGVTd2lwZWFibGUodGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdoaWRlLXRhYnMnKSB7XG4gICAgICB0aGlzLnNldFRhYmJhclZpc2liaWxpdHkoIXRoaXMuaGFzQXR0cmlidXRlKCdoaWRlLXRhYnMnKSB8fCBjdXJyZW50ID09PSAnZmFsc2UnKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZWNoYW5nZScsICdwb3N0Y2hhbmdlJywgJ3JlYWN0aXZlJ107XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlRhYmJhciA9IFRhYmJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWJiYXInLCBUYWJiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBUYWJiYXJFbGVtZW50IGZyb20gJy4vb25zLXRhYmJhcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyIH0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0YWJiYXJfX2l0ZW0nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndGFiYmFyLS0qX19pdGVtJyxcbiAgJy50YWJiYXJfX2J1dHRvbic6ICd0YWJiYXItLSpfX2J1dHRvbidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYlxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgdGFiIGluc2lkZSB0YWIgYmFyLiBFYWNoIGA8b25zLXRhYj5gIHJlcHJlc2VudHMgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgr/jg5bjg5Djg7zjgavphY3nva7jgZXjgozjgovlkITjgqLjgqTjg4bjg6Djga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZ3jgozjgZ7jgozjga5vbnMtdGFi44Gv44Oa44O844K444KS6KGo44GX44G+44GZ44CCXG4gKiAgICAgb25zLXRhYuimgee0oOOBruS4reOBq+OBr+OAgeOCv+ODluOBq+ihqOekuuOBleOCjOOCi+OCs+ODs+ODhuODs+ODhOOCkuebtOaOpeiomOi/sOOBmeOCi+OBk+OBqOOBjOWHuuadpeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gcEd1RExcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90YWJiYXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXVxuICogQGd1aWRlIGFwcHNpemUuaHRtbCNyZW1vdmluZy1pY29uLXBhY2tzIFtlbl1SZW1vdmluZyBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgZmFxLmh0bWwjaG93LWNhbi1pLXVzZS1jdXN0b20taWNvbi1wYWNrcyBbZW5dQWRkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1vbnMtdGFiYmFyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtdGFiYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wYWdlXG4gKiAgIFtlbl1vbnMtcGFnZSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWljb25cbiAqICAgW2VuXW9ucy1pY29uIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtaWNvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHBhZ2UgdGhhdCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgdGFiIGlzIHRhcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1vbnMtdGFi44GM5Y+C54Wn44GZ44KL44Oa44O844K444G444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgaWNvbiBuYW1lIGZvciB0aGUgdGFiLiBDYW4gc3BlY2lmeSB0aGUgc2FtZSBpY29uIG5hbWUgYXMgYDxvbnMtaWNvbj5gLiBDaGVjayBbU2VlIGFsc29dKCNzZWVhbHNvKSBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCb25zLWljb27jgajlkIzjgZjjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAgIOWAi+WIpeOBq+OCouOCpOOCs+ODs+OCkuOCq+OCueOCv+ODnuOCpOOCuuOBmeOCi+WgtOWQiOOBr+OAgWJhY2tncm91bmQtaW1hZ2Xjgarjganjga5DU1Pjgrnjgr/jgqTjg6vjgpLnlKjjgYTjgabmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhY3RpdmUtaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIG5hbWUgb2YgdGhlIGljb24gd2hlbiB0aGUgdGFiIGlzIGFjdGl2ZS5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjga7pmpvjga7jgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsYWJlbFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGxhYmVsIG9mIHRoZSB0YWIgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PkuIvjgavooajnpLrjgZXjgozjgovjg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBiYWRnZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGlzcGxheSBhIG5vdGlmaWNhdGlvbiBiYWRnZSBvbiB0b3Agb2YgdGhlIHRhYi5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4PjgrjjgavooajnpLrjgZnjgovlhoXlrrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhY3RpdmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgYXR0cmlidXRlIHNob3VsZCBiZSBzZXQgdG8gdGhlIHRhYiB0aGF0IGlzIGFjdGl2ZSBieSBkZWZhdWx0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAoWydsYWJlbCcsICdpY29uJywgJ2JhZGdlJ10uc29tZSh0aGlzLmhhc0F0dHJpYnV0ZS5iaW5kKHRoaXMpKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAodGhpcy5fYnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5jcmVhdGUoJ2J1dHRvbi50YWJiYXJfX2J1dHRvbicpO1xuICAgIHdoaWxlKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQgPSB1dGlsLmNyZWF0ZSgnaW5wdXQnLCB7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICBpbnB1dC50eXBlID0gJ3JhZGlvJztcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgIHRoaXMuX3VwZGF0ZUJ1dHRvbkNvbnRlbnQoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHRoaXMuX2J1dHRvbiAmJiB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzLl9idXR0b24sIHRoaXMuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSk7XG4gIH1cblxuICBfdXBkYXRlQnV0dG9uQ29udGVudCgpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLl9idXR0b247XG5cbiAgICBsZXQgaWNvbldyYXBwZXIgPSB0aGlzLl9pY29uO1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpKSB7XG4gICAgICBpY29uV3JhcHBlciA9IGljb25XcmFwcGVyIHx8IHV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInRhYmJhcl9faWNvblwiPjxvbnMtaWNvbj48L29ucy1pY29uPjwvZGl2PicpO1xuICAgICAgY29uc3QgaWNvbiA9IGljb25XcmFwcGVyLmNoaWxkcmVuWzBdO1xuICAgICAgY29uc3QgZml4ID0gKGxhc3QgPT4gKCkgPT4gaWNvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2ljb24nLCBsYXN0LCB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpKSkoaWNvbi5nZXRBdHRyaWJ1dGUoJ2ljb24nKSk7XG4gICAgICBpY29uLnNldEF0dHJpYnV0ZSgnaWNvbicsIHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJykpO1xuICAgICAgaWNvbldyYXBwZXIucGFyZW50RWxlbWVudCAhPT0gYnV0dG9uICYmIGJ1dHRvbi5pbnNlcnRCZWZvcmUoaWNvbldyYXBwZXIsIGJ1dHRvbi5maXJzdENoaWxkKTtcblxuICAgICAgLy8gZGlydHkgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vT25zZW5VSS9PbnNlblVJL2lzc3Vlcy8xNjU0XG4gICAgICBpY29uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gZml4KClcbiAgICAgICAgOiBzZXRJbW1lZGlhdGUoKCkgPT4gaWNvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBmaXgoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGljb25XcmFwcGVyICYmIGljb25XcmFwcGVyLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIFsnbGFiZWwnLCAnYmFkZ2UnXS5mb3JFYWNoKChhdHRyLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IHByb3AgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYC50YWJiYXJfXyR7YXR0cn1gKTtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICBwcm9wID0gcHJvcCB8fCB1dGlsLmNyZWF0ZShgLnRhYmJhcl9fJHthdHRyfWAgKyAoYXR0ciA9PT0gJ2JhZGdlJyA/ICcgbm90aWZpY2F0aW9uJyA6ICcnKSk7XG4gICAgICAgIHByb3AudGV4dENvbnRlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgcHJvcC5wYXJlbnRFbGVtZW50ICE9PSBidXR0b24gJiYgYnV0dG9uLmFwcGVuZENoaWxkKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcCAmJiBwcm9wLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgX2J1dHRvbigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXJfX2J1dHRvbicpO1xuICB9XG5cbiAgZ2V0IF9pY29uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy50YWJiYXJfX2ljb24nKTtcbiAgfVxuXG4gIGdldCBfdGFiYmFyKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy10YWJiYXInKTtcbiAgfVxuXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4sIHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMub25DbGljayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLm9uQ2xpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGFiYmFyLnNldEFjdGl2ZVRhYih0aGlzLmluZGV4LCB7IHJlamVjdDogZmFsc2UgfSk7XG4gICAgfVxuICB9XG5cbiAgc2V0QWN0aXZlKGFjdGl2ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gYWN0aXZlO1xuICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgYWN0aXZlKTtcbiAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnYWN0aXZlJywgYWN0aXZlKVxuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpY29uJykgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FjdGl2ZS1pY29uJykpIHtcbiAgICAgIHRoaXMuX2ljb24uY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKCdpY29uJywgdGhpcy5nZXRBdHRyaWJ1dGUoYWN0aXZlID8gJ2FjdGl2ZS1pY29uJyA6ICdpY29uJykpO1xuICAgIH1cbiAgfVxuXG4gIF9sb2FkUGFnZUVsZW1lbnQocGFyZW50LCBwYWdlKSB7XG4gICAgdGhpcy5faGFzTG9hZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoeyBwYXJlbnQsIHBhZ2UgfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHBhZ2VFbGVtZW50LCBwYXJlbnQuY2hpbGRyZW5bdGhpcy5pbmRleF0pOyAvLyBFbnN1cmUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5fbG9hZGVkUGFnZSA9IHBhZ2VFbGVtZW50O1xuICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHBhZ2VFbGVtZW50KCkge1xuICAgIC8vIEl0IGhhcyBiZWVuIGxvYWRlZCBieSBvbnMtdGFiXG4gICAgaWYgKHRoaXMuX2xvYWRlZFBhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkZWRQYWdlO1xuICAgIH1cbiAgICAvLyBNYW51YWxseSBhdHRhY2hlZCB0byBET00sIDEgcGVyIHRhYlxuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhcjtcbiAgICBpZiAodGFiYmFyLnBhZ2VzLmxlbmd0aCA9PT0gdGFiYmFyLnRhYnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGFiYmFyLnBhZ2VzW3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICAvLyBMb2FkZWQgaW4gYW5vdGhlciB3YXlcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMubG9hZGVkID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuX2xvYWRlZFBhZ2UpIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMuX2xvYWRlZFBhZ2UpO1xuICAgICAgdGhpcy5fbG9hZGVkUGFnZSA9IG51bGw7XG4gICAgICB0aGlzLl9oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwuaXNBdHRhY2hlZCh0aGlzKSB8fCB0aGlzLmxvYWRlZCkge1xuICAgICAgcmV0dXJuOyAvLyBvbnMtdGFiYmFyIGNvbXBpbGF0aW9uIG1heSB0cmlnZ2VyIHRoaXNcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fdGFiYmFyO1xuICAgICAgaWYgKCF0YWJiYXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG9ucy10YWIgZWxlbWVudCBtdXN0IGJlIGNoaWxkIG9mIG9ucy10YWJiYXIgZWxlbWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9oYXNMb2FkZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUnKSkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICAgICAgICAgIHRhYmJhci5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZUluZGV4JywgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSB0YWJiYXIudGFicy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGFiYmFyLl9vblJlZnJlc2goKTtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGFiYmFyLl9vblJlZnJlc2goKSk7XG4gICAgICAgIH1cblxuICAgICAgICBUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLnJlYWR5KHRhYmJhciwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhZ2VUYXJnZXQgPSB0aGlzLnBhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgICAgICAgICBpZiAoIXRoaXMucGFnZUVsZW1lbnQgJiYgcGFnZVRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50VGFyZ2V0ID0gdGFiYmFyLl90YXJnZXRFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZHVtbXlQYWdlID0gdXRpbC5jcmVhdGUoJ2RpdicsIHsgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAnMTAwJScsIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyB9KTtcbiAgICAgICAgICAgIHBhcmVudFRhcmdldC5pbnNlcnRCZWZvcmUoZHVtbXlQYWdlLCBwYXJlbnRUYXJnZXQuY2hpbGRyZW5baW5kZXhdKTsgLy8gRW5zdXJlIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFBhZ2VFbGVtZW50KHBhcmVudFRhcmdldCwgcGFnZVRhcmdldCkudGhlbihkZWZlcnJlZC5yZXNvbHZlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHRoaXMucGFnZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2ljb24nLCAnbGFiZWwnLCAncGFnZScsICdiYWRnZScsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpY29uJzpcbiAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgIGNhc2UgJ2JhZGdlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUJ1dHRvbkNvbnRlbnQoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFnZSc6XG4gICAgICAgIHRoaXMucGFnZSA9IGN1cnJlbnQgfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuVGFiID0gVGFiRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRhYicsIFRhYkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZVRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KHRvYXN0LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQodG9hc3QpXG4gICAgICAuc2F2ZVN0eWxlKClcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KHRvYXN0KVxuICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBpUGhvbmVYUGF0Y2ggZnJvbSAnLi4vLi4vb25zL2lwaG9uZXgtcGF0Y2gnO1xuaW1wb3J0IFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbi8qKlxuICogQXNjZW5kIFRvYXN0IEFuaW1hdG9yLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBc2NlbmRUb2FzdEFuaW1hdG9yIGV4dGVuZHMgVG9hc3RBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoeyB0aW1pbmcgPSAnZWFzZScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjI1IH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG5cbiAgICB0aGlzLm1lc3NhZ2VEZWxheSA9IHRoaXMuZHVyYXRpb24gKiAwLjQgKyB0aGlzLmRlbGF5OyAvLyBEZWxheSBtZXNzYWdlIG9wYWNpdHkgY2hhbmdlXG4gICAgaWYgKHBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICB0aGlzLmFzY2Vuc2lvbiA9IDQ4OyAvLyBUb2FzdHMgYXJlIGFsd2F5cyAxIGxpbmVcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5hc2NlbnNpb24gPSA5ODsgLy8gNjQgKyAzNFxuICAgICAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLmFzY2Vuc2lvbiA9IDg1OyAvLyA2NCArIDIxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFzY2Vuc2lvbiA9IDY0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcbiAgICB1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0ID0gdGhpcy5hc2NlbnNpb247XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0KVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMuYXNjZW5zaW9ufXB4LCAwKWBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRGYWJzKCkpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgLSR7dGhpcy5hc2NlbnNpb259cHgsIDApIHNjYWxlKDEpYFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHV0aWwuYXJyYXlGcm9tKHRvYXN0LmNoaWxkcmVuKSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLm1lc3NhZ2VEZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuICAgIHV0aWwuZ2xvYmFscy5mYWJPZmZzZXQgPSAwO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdClcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmFzY2Vuc2lvbn1weCwgMClgXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fZ2V0RmFicygpKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApIHNjYWxlKDEpJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHV0aWwuYXJyYXlGcm9tKHRvYXN0LmNoaWxkcmVuKSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICApO1xuICB9XG5cbiAgX2dldEZhYnMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ29ucy1mYWJbcG9zaXRpb25+PWJvdHRvbV0sIG9ucy1zcGVlZC1kaWFsW3Bvc2l0aW9ufj1ib3R0b21dJykpLmZpbHRlcihmYWIgPT4gZmFiLnZpc2libGUpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIExpZnQtZmFkZSBUb2FzdCBBbmltYXRvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaWZ0VG9hc3RBbmltYXRvciBleHRlbmRzIFRvYXN0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zNSB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyAzNHB4KSc7XG4gICAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gJ2NhbGMoMTAwJSArIDIxcHgpJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gJzEwMCUnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5saWZ0QW1vdW50fSwgMClgLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdClcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5saWZ0QW1vdW50fSwgMClgLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHRvYXN0KSB7XG4gICAgaWYgKHBhcnNlSW50KHRvYXN0LnN0eWxlLnRvcCwgMTApID09PSAwKSB7XG4gICAgICB0b2FzdC5zdHlsZS50b3AgPSB0b2FzdC5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB9XG4gIH1cbn1cbiIsIlxuLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBpUGhvbmVYUGF0Y2ggZnJvbSAnLi4vLi4vb25zL2lwaG9uZXgtcGF0Y2gnO1xuaW1wb3J0IFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbi8qKlxuICogRmFsbC1mYWRlIFRvYXN0IEFuaW1hdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhbGxUb2FzdEFuaW1hdG9yIGV4dGVuZHMgVG9hc3RBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoeyB0aW1pbmcgPSAnZWFzZScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjM1IH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuZmFsbEFtb3VudCA9ICdjYWxjKC0xMDAlIC0gNDRweCknO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZhbGxBbW91bnQgPSAnLTEwMCUnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbih0b2FzdCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0KVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMuZmFsbEFtb3VudH0sIDApYCxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbih0b2FzdCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0KVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmZhbGxBbW91bnR9LCAwKWAsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvYXN0LCB0cnVlKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHRvYXN0LCBjbGVhblVwKSB7XG4gICAgbGV0IGNvcnJlY3RUb3A7XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIGNvcnJlY3RUb3AgPSAnNDRweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcnJlY3RUb3AgPSAnMCc7XG4gICAgfVxuXG4gICAgaWYgKHRvYXN0LnN0eWxlLnRvcCAhPT0gY29ycmVjdFRvcCkge1xuICAgICAgdG9hc3Quc3R5bGUudG9wID0gY29ycmVjdFRvcDtcbiAgICAgIHRvYXN0LnN0eWxlLmJvdHRvbSA9ICdpbml0aWFsJztcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgRmFkZVRvYXN0QW5pbWF0b3IgZnJvbSAnLi9mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBBc2NlbmRUb2FzdEFuaW1hdG9yIGZyb20gJy4vYXNjZW5kLWFuaW1hdG9yJztcbmltcG9ydCBMaWZ0VG9hc3RBbmltYXRvciBmcm9tICcuL2xpZnQtYW5pbWF0b3InO1xuaW1wb3J0IEZhbGxUb2FzdEFuaW1hdG9yIGZyb20gJy4vZmFsbC1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRGlhbG9nRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZGlhbG9nJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudG9hc3QnOiAndG9hc3QtLSonLFxuICAnLnRvYXN0X19tZXNzYWdlJzogJ3RvYXN0LS0qX19tZXNzYWdlJyxcbiAgJy50b2FzdF9fYnV0dG9uJzogJ3RvYXN0LS0qX19idXR0b24nXG59O1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3RvYXN0JztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFzY2VuZFRvYXN0QW5pbWF0b3IgOiBMaWZ0VG9hc3RBbmltYXRvcixcbiAgJ2ZhZGUnOiBGYWRlVG9hc3RBbmltYXRvcixcbiAgJ2FzY2VuZCc6IEFzY2VuZFRvYXN0QW5pbWF0b3IsXG4gICdsaWZ0JzogTGlmdFRvYXN0QW5pbWF0b3IsXG4gICdmYWxsJzogRmFsbFRvYXN0QW5pbWF0b3IsXG4gICdub25lJzogVG9hc3RBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9hc3RcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhlIFRvYXN0IG9yIFNuYWNrYmFyIGNvbXBvbmVudCBpcyB1c2VmdWwgZm9yIGRpc3BsYXlpbmcgZGlzbWlzc2FibGUgaW5mb3JtYXRpb24gb3Igc2ltcGxlIGFjdGlvbnMgYXQgKG5vcm1hbGx5KSB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCBkb2VzIG5vdCBibG9jayB1c2VyIGlucHV0LCBhbGxvd2luZyB0aGUgYXBwIHRvIGNvbnRpbnVlIGl0cyBmbG93LiBGb3Igc2ltcGxlIHRvYXN0cywgY29uc2lkZXIgYG9ucy5ub3RpZmljYXRpb24udG9hc3RgIGluc3RlYWQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQHNlZWFsc28gb25zLWFsZXJ0LWRpYWxvZ1xuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudCBpcyBwcmVmZXJyZWQgZm9yIGRpc3BsYXlpbmcgdW5kaXNtaXNzYWJsZSBpbmZvcm1hdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9hc3RFbGVtZW50IGV4dGVuZHMgQmFzZURpYWxvZ0VsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgdG9hc3QuIENhbiBiZSBlaXRoZXIgYFwiZGVmYXVsdFwiYCwgYFwiYXNjZW5kXCJgIChBbmRyb2lkKSwgYFwibGlmdFwiYCAoaU9TKSwgYFwiZmFsbFwiYCwgYFwiZmFkZVwiYCBvciBgXCJub25lXCJgLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fZGVmYXVsdERCQiA9IGUgPT4gZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfdG9hc3QoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsIGAuJHtkZWZhdWx0Q2xhc3NOYW1lfWApO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICAvLyBSZXNldCBwb3NpdGlvbiBzdHlsZVxuICAgIHRoaXMuX3RvYXN0ICYmICh0aGlzLl90b2FzdC5zdHlsZS50b3AgPSB0aGlzLl90b2FzdC5zdHlsZS5ib3R0b20gPSAnJyk7XG5cbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IFRvYXN0QW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnVG9hc3RBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDA7IC8vIExvd2VyIHRoYW4gZGlhbG9nc1xuXG4gICAgY29uc3QgbWVzc2FnZUNsYXNzTmFtZSA9ICd0b2FzdF9fbWVzc2FnZSc7XG4gICAgY29uc3QgYnV0dG9uQ2xhc3NOYW1lID0gJ3RvYXN0X19idXR0b24nO1xuXG4gICAgbGV0IHRvYXN0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgYC4ke2RlZmF1bHRDbGFzc05hbWV9YCk7XG4gICAgaWYgKCF0b2FzdCkge1xuICAgICAgdG9hc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIHRvYXN0LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRvYXN0LCBgLiR7YnV0dG9uQ2xhc3NOYW1lfWApO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0b2FzdCwgZSA9PiB1dGlsLm1hdGNoKGUsICcuYnV0dG9uJykgfHwgdXRpbC5tYXRjaChlLCAnYnV0dG9uJykpO1xuICAgICAgaWYgKGJ1dHRvbikge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGJ1dHRvbkNsYXNzTmFtZSk7XG4gICAgICAgIHRvYXN0LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0b2FzdCwgYC4ke21lc3NhZ2VDbGFzc05hbWV9YCkpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gdXRpbC5maW5kQ2hpbGQodG9hc3QsICcubWVzc2FnZScpO1xuICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRvYXN0LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAodG9hc3QuY2hpbGROb2Rlc1tpXSAhPT0gYnV0dG9uKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmluc2VydEJlZm9yZSh0b2FzdC5jaGlsZE5vZGVzW2ldLCBtZXNzYWdlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVzc2FnZS5jbGFzc0xpc3QuYWRkKG1lc3NhZ2VDbGFzc05hbWUpO1xuXG4gICAgICB0b2FzdC5pbnNlcnRCZWZvcmUobWVzc2FnZSwgdG9hc3QuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHRvYXN0LnBhcmVudE5vZGUgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodG9hc3QpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZGVmYXVsdFwiYCwgYFwiYXNjZW5kXCJgIChBbmRyb2lkKSwgYFwibGlmdFwiYCAoaU9TKSwgYFwiZmFsbFwiYCwgYFwiZmFkZVwiYCBvciBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJkZWZhdWx0XCJgLCBgXCJhc2NlbmRcImAgKEFuZHJvaWQpLCBgXCJsaWZ0XCJgIChpT1MpLCBgXCJmYWxsXCJgLCBgXCJmYWRlXCJgIG9yIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdG9hc3QgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdG9hc3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFRvYXN0QW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zVG9hc3RFbGVtZW50LlRvYXN0QW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFRvYXN0QW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFRvYXN0QW5pbWF0b3I7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlRvYXN0ID0gVG9hc3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9hc3QnLCBUb2FzdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3Rvb2xiYXItYnV0dG9uJztcblxuY29uc3Qgc2NoZW1lID0geycnOiAndG9vbGJhci1idXR0b24tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhci1idXR0b25cbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuOCguOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44GC44KL44GE44Gvb25zLWJvdHRvbS10b29sYmFy44Gr6Kit572u44Gn44GN44KL44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGNvbXBpbGF0aW9uLmh0bWwjdG9vbGJhci1jb21waWxhdGlvblxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgbmF2aWdhdGlvbiBiYXIgYXQgdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbiB0aGUgbmF2aWdhdGlvbiBiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICBCdXR0b25cbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLW5hdmljb25cIiBzaXplPVwiMjhweFwiPjwvb25zLWljb24+XG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcywgdW5kZWZpbmVkLCB7Y2VudGVyOiAnJywgJ3NpemUnOiAnY29udGFpbicsICdiYWNrZ3JvdW5kJzogJ3RyYW5zcGFyZW50J30pO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5Ub29sYmFyQnV0dG9uID0gVG9vbGJhckJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10b29sYmFyLWJ1dHRvbicsIFRvb2xiYXJCdXR0b25FbGVtZW50KTtcbiIsImltcG9ydCBvbnMgZnJvbSAnLi9vbnMnOyAvLyBBZGQgb25zIGludGVybmFsc1xuaW1wb3J0IHNldHVwIGZyb20gJy4vc2V0dXAnOyAvLyBBZGQgcG9seWZpbFxuXG4vLyBBZGQgYW5kIHJlZ2lzdGVyIEN1c3RvbSBFbGVtZW50c1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10ZW1wbGF0ZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWlmJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYnV0dG9uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2FyZCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNvbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWRpYWxvZyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWZhYic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWdlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pY29uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LWhlYWRlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxpc3QtdGl0bGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaW5wdXQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jaGVja2JveCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJhZGlvJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VhcmNoLWlucHV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbW9kYWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wYWdlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcG9wb3Zlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWNpcmN1bGFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcHVsbC1ob29rJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmFuZ2UnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yaXBwbGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yb3cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zZWdtZW50JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VsZWN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3dpdGNoJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdG9hc3QnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRvb2xiYXInO1xuXG5zZXR1cChvbnMpOyAvLyBTZXR1cCBpbml0aWFsIGxpc3RlbmVyc1xud2luZG93Ll9zdXBlclNlY3JldE9ucyA9IG9ucztcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIl0sIm5hbWVzIjpbInByZWZpeCIsInN0eWxlcyIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiam9pbiIsIm1hdGNoIiwiT0xpbmsiLCJuYW1lIiwidXRpbCIsImh5cGhlbmF0ZSIsInN0eWxlciIsImVsZW1lbnQiLCJzdHlsZSIsImtleXMiLCJmb3JFYWNoIiwia2V5Iiwid2FybiIsImNsZWFyIiwiY2xlYXJsaXN0Iiwic3BsaXQiLCJyZWR1Y2UiLCJyIiwicyIsImNvbmNhdCIsImkiLCJsZW5ndGgiLCJzb21lIiwiaW5kZXhPZiIsInB1c2giLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJOYXRpdmVIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiUGxhdGZvcm0iLCJfc2VsZWN0ZWRQbGF0Zm9ybSIsIl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCIsInBsYXRmb3JtIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiZm4iLCJyZXN1bHQiLCJyZWFkeVN0YXRlIiwiRXJyb3IiLCJjb3Jkb3ZhIiwicGhvbmVnYXAiLCJQaG9uZUdhcCIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lQaG9uZSIsInNjcmVlbiIsIndpZHRoIiwiaGVpZ2h0IiwiX2dldFNlbGVjdGVkUGxhdGZvcm0iLCJkZXZpY2UiLCJwYXJzZUludCIsInZlcnNpb24iLCJ2ZXIiLCJyZXBsYWNlIiwidWEiLCJpc0lPUyIsInN0YW5kYWxvbmUiLCJsdGU5Iiwid2Via2l0IiwibWVzc2FnZUhhbmRsZXJzIiwiaW5kZXhlZERCIiwiaXNJT1NTYWZhcmkiLCJpc1dLV2ViVmlldyIsIm9wZXJhIiwiSW5zdGFsbFRyaWdnZXIiLCJPYmplY3QiLCJ0b1N0cmluZyIsInAiLCJzYWZhcmkiLCJwdXNoTm90aWZpY2F0aW9uIiwiY2hyb21lIiwiZG9jdW1lbnRNb2RlIiwiaXNBbmRyb2lkIiwiaXNXUCIsImlzSVBhZCIsImlzSVBvZCIsInBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIiwidmFsdWUiLCJvdmVyd3JpdGUiLCJfdmFyaWFibGVzIiwiaGFzT3duUHJvcGVydHkiLCJwYXJ0IiwiYyIsImluSW50ZXJwb2xhdGlvbiIsImN1cnJlbnRJbmRleCIsInRva2VucyIsImNoYXJBdCIsInRva2VuIiwic3Vic3RyaW5nIiwicmUiLCJ2YXJpYWJsZSIsImdldFZhcmlhYmxlIiwicnYiLCJtYXAiLCJfcmVwbGFjZVRva2VuIiwiYmluZCIsImV4cHJlc3Npb24iLCJfcGFyc2VQYXJ0IiwiX3JlcGxhY2VUb2tlbnMiLCJfcGFyc2VFeHByZXNzaW9uIiwiZGVmaW5lVmFyaWFibGUiLCJnZXRNb2JpbGVPUyIsImdldElPU0RldmljZSIsImlzV2ViVmlldyIsImludGVybmFsIiwiY29uZmlnIiwibnVsbEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwiLCJhdXRvU3RhdHVzQmFyRmlsbCIsIm5vcm1hbGl6ZVBhZ2VIVE1MIiwiaHRtbCIsIndhaXRET01Db250ZW50TG9hZGVkIiwid3JhcHBlZENhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYWxsYmFjayIsIm9uUmVhZHkiLCJzaG91bGRGaWxsU3RhdHVzQmFyIiwiaXNJT1M3YWJvdmUiLCJpc0lQaG9uZVgiLCJib2R5IiwicXVlcnlTZWxlY3RvciIsInRlbXBsYXRlU3RvcmUiLCJfc3RvcmFnZSIsInRlbXBsYXRlIiwiZSIsInRhcmdldCIsIm5vZGVOYW1lIiwic2V0IiwidGVtcGxhdGVJZCIsInJlZ2lzdGVyIiwicXVlcnkiLCJ0ZW1wbGF0ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidGV4dENvbnRlbnQiLCJjb250ZW50IiwiZ2V0VGVtcGxhdGVIVE1MQXN5bmMiLCJwYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWNoZSIsImdldCIsIkRvY3VtZW50RnJhZ21lbnQiLCJsb2NhbCIsImdldEVsZW1lbnRCeUlkIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwib25sb2FkIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzIiwiZnJhZ21lbnQiLCJjcmVhdGVGcmFnbWVudCIsImFycmF5RnJvbSIsInNjcmlwdCIsInR5cGUiLCJlbCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJ0ZXh0IiwiaW5uZXJIVE1MIiwicGFyZW50Tm9kZSIsInJlcGxhY2VDaGlsZCIsIm9uZXJyb3IiLCJzZW5kIiwiZ2V0UGFnZUhUTUxBc3luYyIsInBhZ2VzIiwiZXZhbHVhdGUiLCJnZXRQYWdlIiwiY2F0Y2giLCJlcnJvciIsInNoaWZ0IiwiQW5pbWF0b3JGYWN0b3J5Iiwib3B0cyIsIl9hbmltYXRvcnMiLCJhbmltYXRvcnMiLCJfYmFzZUNsYXNzIiwiYmFzZUNsYXNzIiwiX2Jhc2VDbGFzc05hbWUiLCJiYXNlQ2xhc3NOYW1lIiwiX2FuaW1hdGlvbiIsImRlZmF1bHRBbmltYXRpb24iLCJfYW5pbWF0aW9uT3B0aW9ucyIsImRlZmF1bHRBbmltYXRpb25PcHRpb25zIiwib3B0aW9ucyIsImRlZmF1bHRBbmltYXRvciIsImFuaW1hdG9yIiwiYW5pbWF0aW9uIiwiQW5pbWF0b3IiLCJhbmltYXRpb25PcHRzIiwiZXh0ZW5kIiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbnNEaXNhYmxlZCIsImR1cmF0aW9uIiwiZGVsYXkiLCJqc29uU3RyaW5nIiwiYW5pbWF0aW9uT3B0aW9uc1BhcnNlIiwiYXV0b1N0eWxlRW5hYmxlZCIsIm1vZGlmaWVyc01hcCIsInBsYXRmb3JtcyIsImFuZHJvaWQiLCJlbGVtZW50TmFtZSIsInRhZ05hbWUiLCJoYXNNb2RpZmllciIsIm9sZE1vZGlmaWVyIiwibmV3TW9kaWZpZXIiLCJ1bnNoaWZ0Iiwic2V0QXR0cmlidXRlIiwiZWxlbWVudHMiLCJoYXNBdHRyaWJ1dGUiLCJpb3MiLCJyZW1vdmVNb2RpZmllciIsImFkZE1vZGlmaWVyIiwidW5sb2NrZWQiLCJnZXRQbGF0Zm9ybSIsImZvcmNlIiwibW9iaWxlT1MiLCJvbnNQbGF0Zm9ybSIsInByZXBhcmUiLCJtYXBNb2RpZmllciIsIm1vZGlmaWVyIiwibSIsInJlc3RvcmVNb2RpZmllciIsIk1vZGlmaWVyVXRpbCIsImxhc3QiLCJjdXJyZW50IiwibWFrZURpY3QiLCJyZW1vdmVkIiwiYWRkZWQiLCJkaWN0IiwiZGlmZiIsImNsYXNzTGlzdCIsImtsYXNzIiwiYWRkIiwiayIsInJlbW92ZSIsInNjaGVtZSIsInRhcmdldEVsZW1lbnRzIiwic2VsZWN0b3IiLCJmaWx0ZXIiLCJmaW5kUGFyZW50IiwidGFyZ2V0RWxlbWVudCIsInBhcmVudCIsImFwcGx5RGlmZlRvQ2xhc3NMaXN0IiwiYXBwbHlEaWZmVG9FbGVtZW50IiwibW9kaWZpZXJUb2tlbiIsImluZGV4Iiwic3BsaWNlIiwiX2RvbUNvbnRlbnRMb2FkZWQiLCJfcmVhZHkiLCJfb25ET01Db250ZW50TG9hZGVkIiwiSGFuZGxlclJlcG9zaXRvcnkiLCJoYW5kbGVyIiwiZGF0YXNldCIsImRldmljZUJhY2tCdXR0b25IYW5kbGVySWQiLCJpZCIsIl9nZW5JZCIsIl9zdG9yZSIsInVuZGVmaW5lZCIsIkRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIiwiX2lzRW5hYmxlZCIsIl9ib3VuZENhbGxiYWNrIiwiX2NhbGxiYWNrIiwiYWRkQmFja0J1dHRvbkxpc3RlbmVyIiwicmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyIiwiZXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQiLCJGdW5jdGlvbiIsIl9lbGVtZW50IiwiZW5hYmxlIiwidHJlZSIsIl9jYXB0dXJlVHJlZSIsIl9maW5kSGFuZGxlckxlYWZFbGVtZW50IiwiY3JlYXRlVHJlZSIsImFwcGx5IiwiYXJyYXlPZiIsImNoaWxkcmVuIiwiY2hpbGRFbGVtZW50IiwiZGlzcGxheSIsIl9pc1Nob3duIiwiaGFzIiwic3ViVHJlZSIsImZpbmQiLCJub2RlIiwiY2hpbGROb2RlIiwibGVmdCIsInJpZ2h0IiwibGVmdFoiLCJ6SW5kZXgiLCJyaWdodFoiLCJpc05hTiIsImRiYkRpc3BhdGNoZXIiLCJkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsInN0YXJ0c1dpdGgiLCJzdWJzdHIiLCJlbmRzV2l0aCIsInVud3JhcCIsImlzT2JqZWN0U3RyaW5nIiwiaXNBcnJheVN0cmluZyIsImlzUXVvdGVkU3RyaW5nIiwic3RyaW5nIiwib3JpZ2luYWxTdHJpbmciLCJwcm9jZXNzVG9rZW4iLCJwYXJzZU9iamVjdCIsInBhcnNlQXJyYXkiLCJuZXh0VG9rZW4iLCJsaW1pdCIsImNoYXJDb2RlQXQiLCJuZXN0ZWRPYmplY3QiLCJpc1ZhbGlkS2V5Iiwib2JqZWN0IiwicmVhZGluZ0tleSIsInByZXZpb3VzVG9rZW4iLCJhcnJheSIsInBhcnNlIiwiZ2xvYmFscyIsInByZXBhcmVRdWVyeSIsIm1hdGNoZXMiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImZpbmRDaGlsZCIsImNoaWxkTm9kZXMiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJ1bnRpbCIsImlzQXR0YWNoZWQiLCJjb250YWlucyIsImhhc0FueUNvbXBvbmVudEFzUGFyZW50IiwiaXNQYWdlQ29udHJvbCIsInByb3BhZ2F0ZUFjdGlvbiIsImFjdGlvbiIsImNoaWxkIiwiY2FtZWxpemUiLCJsIiwidG9VcHBlckNhc2UiLCJjcmVhdGUiLCJjbGFzc05hbWUiLCJ3cmFwcGVyIiwiaW1wb3J0Tm9kZSIsImRzdCIsImFyZ3MiLCJqIiwiYXJyYXlMaWtlIiwicGFyc2VKU09OT2JqZWN0U2FmZWx5IiwiZmFpbFNhZmUiLCJKU09OIiwiZmluZEZyb21QYXRoIiwicGF0aCIsImdldFRvcFBhZ2UiLCJjb250YWluZXIiLCJ0b3BQYWdlIiwiZmluZFRvb2xiYXJQYWdlIiwiX2NhbkFuaW1hdGVUb29sYmFyIiwiX2NvbnRlbnRFbGVtZW50IiwibmV4dFBhZ2UiLCJ0cmlnZ2VyRWxlbWVudEV2ZW50IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJtb2RpZmllck5hbWUiLCJSZWdFeHAiLCJhdXRvU3R5bGUiLCJmb3JjZUF1dG9TdHlsZSIsIm5ld01vZGlmaWVycyIsInRvZ2dsZU1vZGlmaWVyIiwidG9nZ2xlIiwicmVzdG9yZUNsYXNzIiwiZGVmYXVsdENsYXNzIiwicmVmcmVzaCIsInVwZGF0ZVBhcmVudFBvc2l0aW9uIiwiX3BhcmVudFVwZGF0ZWQiLCJwYXJlbnRFbGVtZW50IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInBvc2l0aW9uIiwidG9nZ2xlQXR0cmlidXRlIiwiYmluZExpc3RlbmVycyIsImxpc3RlbmVyTmFtZXMiLCJib3VuZE5hbWUiLCJlYWNoIiwib2JqIiwiZiIsInVwZGF0ZVJpcHBsZSIsImhhc1JpcHBsZSIsImF0dHJzIiwicmlwcGxlRWxlbWVudCIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJpc0ludGVnZXIiLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImRlZmVyIiwiZGVmZXJyZWQiLCJwcm9taXNlIiwid2FybmluZ3NEaXNhYmxlZCIsInByZXZlbnRTY3JvbGwiLCJwcmV2ZW50IiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0IiwiY2xlYW4iLCJvZmYiLCJvbiIsImlzVmFsaWRHZXN0dXJlIiwiZ2VzdHVyZSIsImRpc3RhbmNlIiwiZGVsdGFUaW1lIiwiVElNRU9VVF9SQVRJTyIsImNhcGl0YWxpemUiLCJzdHIiLCJidWlsZFRyYW5zaXRpb25WYWx1ZSIsInBhcmFtcyIsInByb3BlcnR5IiwidGltaW5nIiwicHJvcHMiLCJwcm9wIiwib25jZU9uVHJhbnNpdGlvbkVuZCIsInN0b3BQcm9wYWdhdGlvbiIsInJlbW92ZUxpc3RlbmVycyIsIl90cmFuc2l0aW9uRW5kRXZlbnRzIiwidmVuZG9yUHJlZml4IiwiX2Nzc1Byb3BlcnR5RGljdCIsImEiLCJ6IiwidXBwZXIiLCJoYXNDc3NQcm9wZXJ0eSIsInByZSIsImZvcmNlTGF5b3V0QXRPbmNlIiwiYmF0Y2hJbW1lZGlhdGUiLCJvZmZzZXRIZWlnaHQiLCJjYWxsYmFja3MiLCJjb25jcmVhdGVDYWxsYmFja3MiLCJiYXRjaEFuaW1hdGlvbkZyYW1lIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidHJhbnNpdGlvblByb3BlcnR5TmFtZSIsIkFuaW1pdCIsInRyYW5zaXRpb25RdWV1ZSIsImxhc3RTdHlsZUF0dHJpYnV0ZURpY3QiLCJkb25lIiwic3RhcnRBbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwicXVldWUiLCJjc3MiLCJUcmFuc2l0aW9uIiwiYnVpbGQiLCJzZWNvbmRzIiwic2VsZiIsInRyYW5zaXRpb25OYW1lIiwidHJhbnNpdGlvblZhbHVlIiwidGltZW91dElkIiwiY2xlYXJUcmFuc2l0aW9uIiwic2V0VGltZW91dCIsImxlbiIsInJlc2V0IiwiX2RlcXVldWVUcmFuc2l0aW9uIiwiX2N1cnJlbnRUcmFuc2l0aW9uIiwiY2FsbGVkIiwicnVuQWxsIiwiYXJndW1lbnRzIiwicGxheSIsImNyZWF0ZUFjdHVhbENzc1Byb3BzIiwidGltZW91dCIsInByZWZpeGVkIiwiRXZlbnQiLCJVdGlscyIsIkRldGVjdGlvbiIsIlBvaW50ZXJFdmVudCIsIkdlc3R1cmVEZXRlY3RvciIsIkluc3RhbmNlIiwiZGVmYXVsdHMiLCJET0NVTUVOVCIsIkhBU19QT0lOVEVSRVZFTlRTIiwicG9pbnRlckVuYWJsZWQiLCJtc1BvaW50ZXJFbmFibGVkIiwiSEFTX1RPVUNIRVZFTlRTIiwiSVNfTU9CSUxFIiwiTk9fTU9VU0VFVkVOVFMiLCJDQUxDVUxBVEVfSU5URVJWQUwiLCJFVkVOVF9UWVBFUyIsIkRJUkVDVElPTl9ET1dOIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fVVAiLCJESVJFQ1RJT05fUklHSFQiLCJQT0lOVEVSX01PVVNFIiwiUE9JTlRFUl9UT1VDSCIsIlBPSU5URVJfUEVOIiwiRVZFTlRfU1RBUlQiLCJFVkVOVF9NT1ZFIiwiRVZFTlRfRU5EIiwiRVZFTlRfUkVMRUFTRSIsIkVWRU5UX1RPVUNIIiwiUkVBRFkiLCJwbHVnaW5zIiwiZ2VzdHVyZXMiLCJzZXR1cCIsImRldGVybWluZUV2ZW50VHlwZXMiLCJvblRvdWNoIiwiZGV0ZWN0IiwidXRpbHMiLCJkZXN0Iiwic3JjIiwibWVyZ2UiLCJpdGVyYXRvciIsImNvbnRleHQiLCJpblN0ciIsImluQXJyYXkiLCJkZWVwIiwiZXZlcnkiLCJ0b0FycmF5IiwiaGFzUGFyZW50IiwiZ2V0Q2VudGVyIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJjbGllbnRYIiwiY2xpZW50WSIsIm1pbiIsIm1heCIsInRvdWNoIiwiZ2V0VmVsb2NpdHkiLCJkZWx0YVgiLCJkZWx0YVkiLCJhYnMiLCJnZXRBbmdsZSIsInRvdWNoMSIsInRvdWNoMiIsIngiLCJ5IiwiYXRhbjIiLCJQSSIsImdldERpcmVjdGlvbiIsImdldERpc3RhbmNlIiwic3FydCIsImdldFNjYWxlIiwic3RhcnQiLCJlbmQiLCJnZXRSb3RhdGlvbiIsImlzVmVydGljYWwiLCJkaXJlY3Rpb24iLCJzZXRQcmVmaXhlZENzcyIsInByZWZpeGVzIiwidG9DYW1lbENhc2UiLCJ0b2dnbGVCZWhhdmlvciIsImZhbHNlRm4iLCJ1c2VyU2VsZWN0Iiwib25zZWxlY3RzdGFydCIsInVzZXJEcmFnIiwib25kcmFnc3RhcnQiLCJob29rIiwidHlwZXMiLCJldmVudFR5cGUiLCJvblRvdWNoSGFuZGxlciIsImV2Iiwic3JjVHlwZSIsImlzUG9pbnRlciIsImlzTW91c2UiLCJ0cmlnZ2VyVHlwZSIsInByZXZlbnRNb3VzZUV2ZW50cyIsImJ1dHRvbiIsInNob3VsZERldGVjdCIsImJ1dHRvbnMiLCJtYXRjaFR5cGUiLCJ1cGRhdGVQb2ludGVyIiwiZG9EZXRlY3QiLCJ0b3VjaExpc3QiLCJnZXRUb3VjaExpc3QiLCJ0b3VjaExpc3RMZW5ndGgiLCJ0cmlnZ2VyQ2hhbmdlIiwidHJpZ2dlciIsImNoYW5nZWRMZW5ndGgiLCJjaGFuZ2VkVG91Y2hlcyIsInN0YXJ0ZWQiLCJldkRhdGEiLCJjb2xsZWN0RXZlbnREYXRhIiwiaWRlbnRpZmllcnMiLCJpZGVudGlmaWVyIiwicG9pbnRlclR5cGUiLCJEYXRlIiwibm93Iiwic3JjRXZlbnQiLCJwcmV2ZW50TWFuaXB1bGF0aW9uIiwic3RvcERldGVjdCIsInRvdWNobGlzdCIsInBvaW50ZXJzIiwicG9pbnRlciIsInBvaW50ZXJFdmVudCIsInBvaW50ZXJJZCIsInB0IiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsIk1TUE9JTlRFUl9UWVBFX1BFTiIsInJlc2V0TGlzdCIsImRldGVjdGlvbiIsInN0YXJ0RGV0ZWN0IiwiaW5zdCIsImV2ZW50RGF0YSIsInN0b3BwZWQiLCJleHRlbmRFdmVudERhdGEiLCJpbnN0T3B0aW9ucyIsInRyaWdnZXJHZXN0dXJlIiwiZW5hYmxlZCIsImxhc3RFdmVudCIsInByZXZpb3VzIiwiZ2V0Q2FsY3VsYXRlZERhdGEiLCJjZW50ZXIiLCJjdXIiLCJyZWNhbGMiLCJjYWxjRXYiLCJsYXN0Q2FsY0V2ZW50IiwiY2FsY0RhdGEiLCJsYXN0Q2FsY0RhdGEiLCJ0aW1lU3RhbXAiLCJmdXR1cmVDYWxjRXZlbnQiLCJ2ZWxvY2l0eSIsImFuZ2xlIiwidmVsb2NpdHlYIiwidmVsb2NpdHlZIiwiaW50ZXJpbUFuZ2xlIiwiaW50ZXJpbURpcmVjdGlvbiIsInN0YXJ0RXYiLCJzdGFydEV2ZW50IiwibGFzdEV2Iiwic29ydCIsImIiLCJiZWhhdmlvciIsImV2ZW50U3RhcnRIYW5kbGVyIiwiZXZlbnRIYW5kbGVycyIsIm9uRXZlbnQiLCJvZmZFdmVudCIsInRyaWdnZXJFdmVudCIsInN0YXRlIiwiZGlzcG9zZSIsImVoIiwidHJpZ2dlcmVkIiwiZHJhZ0dlc3R1cmUiLCJkcmFnTWF4VG91Y2hlcyIsImRyYWdNaW5EaXN0YW5jZSIsInN0YXJ0Q2VudGVyIiwiZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiIsImZhY3RvciIsImRyYWdMb2NrVG9BeGlzIiwiZHJhZ0xvY2tNaW5EaXN0YW5jZSIsImxhc3REaXJlY3Rpb24iLCJkcmFnQmxvY2tWZXJ0aWNhbCIsImRyYWdCbG9ja0hvcml6b250YWwiLCJEcmFnIiwiR2VzdHVyZSIsInJlbGVhc2VHZXN0dXJlIiwidGltZXIiLCJob2xkR2VzdHVyZSIsImhvbGRUaW1lb3V0IiwiaG9sZFRocmVzaG9sZCIsIkhvbGQiLCJSZWxlYXNlIiwiSW5maW5pdHkiLCJTd2lwZSIsInN3aXBlR2VzdHVyZSIsInN3aXBlTWluVG91Y2hlcyIsInN3aXBlTWF4VG91Y2hlcyIsInN3aXBlVmVsb2NpdHlYIiwic3dpcGVWZWxvY2l0eVkiLCJoYXNNb3ZlZCIsInRhcEdlc3R1cmUiLCJwcmV2Iiwic2luY2VQcmV2IiwiZGlkRG91YmxlVGFwIiwidGFwTWF4RGlzdGFuY2UiLCJ0YXBNYXhUaW1lIiwiZG91YmxlVGFwSW50ZXJ2YWwiLCJkb3VibGVUYXBEaXN0YW5jZSIsInRhcEFsd2F5cyIsIlRhcCIsIlRvdWNoIiwidG91Y2hHZXN0dXJlIiwicHJldmVudE1vdXNlIiwidHJhbnNmb3JtR2VzdHVyZSIsInNjYWxlVGhyZXNob2xkIiwic2NhbGUiLCJyb3RhdGlvblRocmVzaG9sZCIsInJvdGF0aW9uIiwidHJhbnNmb3JtTWluU2NhbGUiLCJ0cmFuc2Zvcm1NaW5Sb3RhdGlvbiIsIlRyYW5zZm9ybSIsInJlYWR5TWFwIiwiV2Vha01hcCIsInF1ZXVlTWFwIiwiaXNDb250ZW50UmVhZHkiLCJzZXRDb250ZW50UmVhZHkiLCJhZGRDYWxsYmFjayIsImNvbnN1bWVRdWV1ZSIsImRlbGV0ZSIsImNvbnRlbnRSZWFkeSIsIm9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiVG9hc3RRdWV1ZSIsInRoZW4iLCJfc2V0QXR0cmlidXRlcyIsIm5vdGlmaWNhdGlvbiIsIl9jcmVhdGVBbGVydERpYWxvZyIsImlucHV0U3RyaW5nIiwiaXNQcm9tcHQiLCJpbnB1dFR5cGUiLCJwbGFjZWhvbGRlciIsImRlZmF1bHRWYWx1ZSIsImJ1dHRvbkxhYmVscyIsImxhYmVsIiwicHJpbWFyeUJ1dHRvbkluZGV4IiwiX2Rlc3Ryb3lEaWFsb2ciLCJkaWFsb2ciLCJvbkRpYWxvZ0NhbmNlbCIsImRlc3Ryb3kiLCJ0aXRsZSIsIm1lc3NhZ2UiLCJtZXNzYWdlSFRNTCIsInN1Ym1pdE9uRW50ZXIiLCJpbnB1dCIsIm9ua2V5cHJlc3MiLCJrZXlDb2RlIiwiaGlkZSIsInJlc29sdmVWYWx1ZSIsImZvb3RlciIsImJ1dHRvbkVsZW1lbnQiLCJvbmNsaWNrIiwiY29tcGlsZSIsInNob3ciLCJhdXRvZm9jdXMiLCJmb2N1cyIsIl9ub3JtYWxpemVBcmd1bWVudHMiLCJidXR0b25MYWJlbCIsImlzQXJyYXkiLCJwYXJhbSIsImFsZXJ0IiwiY29uZmlybSIsInByb21wdCIsInRvYXN0IiwiX3RvYXN0IiwiY2hlY2tPcHRpb25zIiwiYWN0aW9uU2hlZXQiLCJtYXNrQ29sb3IiLCJjbGFzcyIsInJlc29sdmVyIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIml0ZW0iLCJidXR0b25PcHRpb25zIiwiZGVzdHJ1Y3RpdmUiLCJpY29uIiwiTWljcm9FdmVudCIsImZjdCIsIl9ldmVudHMiLCJfZmN0IiwibWl4aW4iLCJkZXN0T2JqZWN0IiwiX2lzUG9ydHJhaXQiLCJpc1BvcnRyYWl0IiwiX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfb25SZXNpemUiLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbiIsImVtaXQiLCJvcmllbnRhdGlvbiIsIm5JdGVyIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInciLCJoIiwiX2luaXQiLCJtb2RpZmllcnMiLCJzb2Z0d2FyZUtleWJvYXJkIiwiX3Zpc2libGUiLCJvblNob3ciLCJvbkhpZGUiLCJiaW5kRXZlbnRzIiwiS2V5Ym9hcmQiLCJvbnNob3ciLCJvbmhpZGUiLCJ2aXNpYmxlIiwiaXNWaXNpYmxlIiwibm9QbHVnaW5FcnJvciIsImdlbmVyYXRlSWQiLCJEb29yTG9jayIsIl9sb2NrTGlzdCIsIl93YWl0TGlzdCIsIl9sb2ciLCJsb2ciLCJ1bmxvY2siLCJfdW5sb2NrIiwiX3RyeVRvRnJlZVdhaXRMaXN0IiwiaXNMb2NrZWQiLCJsb2FkUGFnZSIsInBhZ2VFbGVtZW50IiwidW5sb2FkUGFnZSIsIl9kZXN0cm95IiwiUGFnZUxvYWRlciIsImxvYWRlciIsInVubG9hZGVyIiwiX2xvYWRlciIsIl91bmxvYWRlciIsIkVsZW1lbnQiLCJkZWZhdWx0UGFnZUxvYWRlciIsImluc3RhbnRQYWdlTG9hZGVyIiwib25zIiwic2VsZWN0IiwibG9jYXRpb24iLCJzZWFyY2giLCJ3YWl0RGV2aWNlUmVhZHkiLCJpc1JlYWR5IiwiX3JlYWR5TG9jayIsInJlYWR5Iiwid2FpdFVubG9jayIsInNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIiLCJsaXN0ZW5lciIsIl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJzZXRMaXN0ZW5lciIsImRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciIsImRpc2FibGUiLCJlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciIsImZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQiLCJlbmFibGVBdXRvU3RhdHVzQmFyRmlsbCIsImRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCIsIm1vY2tTdGF0dXNCYXIiLCJtb2NrIiwiZGlzYWJsZUFuaW1hdGlvbnMiLCJlbmFibGVBbmltYXRpb25zIiwiX2Rpc2FibGVXYXJuaW5ncyIsIl9lbmFibGVXYXJuaW5ncyIsImRpc2FibGVBdXRvU3R5bGluZyIsImVuYWJsZUF1dG9TdHlsaW5nIiwiZGlzYWJsZUljb25BdXRvUHJlZml4IiwiSWNvbiIsInNldEF1dG9QcmVmaXgiLCJmb3JjZVBsYXRmb3JtU3R5bGluZyIsIm5ld1BsYXRmb3JtIiwiX3V0aWwiLCJfcGxhdGZvcm1VcGRhdGUiLCJfdXBkYXRlUG9zaXRpb24iLCJwcmVsb2FkIiwiYWxsIiwiYXBwZW5kIiwibGluayIsImNyZWF0ZVBvcG92ZXIiLCJjcmVhdGVEaWFsb2ciLCJjcmVhdGVBbGVydERpYWxvZyIsIm9wZW5BY3Rpb25TaGVldCIsInJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIiLCJfcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciIsIl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMiLCJyZW1vdmVDaGlsZCIsInVubG9ja0RldmljZVJlYWR5IiwibG9jayIsImdldENTIiwiY3VycmVudFNjcmlwdCIsInNjcmlwdHMiLCJnZXRTY3JpcHRQYWdlIiwiY3VzdG9tRWxlbWVudHMiLCJmb3JjZVBvbHlmaWxsIiwiZ2xvYmFsIiwibW9kdWxlIiwiX19nIiwiY29yZSIsIl9fZSIsIml0IiwiaXNPYmplY3QiLCJUeXBlRXJyb3IiLCJleGVjIiwicmVxdWlyZSQkMCIsImRlZmluZVByb3BlcnR5IiwiaXMiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkMiIsIlMiLCJ2YWwiLCJ2YWx1ZU9mIiwiZFAiLCJPIiwiUCIsIkF0dHJpYnV0ZXMiLCJ0b1ByaW1pdGl2ZSIsIklFOF9ET01fREVGSU5FIiwiYml0bWFwIiwiY3JlYXRlRGVzYyIsInB4IiwicmFuZG9tIiwiU1JDIiwiVE9fU1RSSU5HIiwiJHRvU3RyaW5nIiwiVFBMIiwiaW5zcGVjdFNvdXJjZSIsInNhZmUiLCJpc0Z1bmN0aW9uIiwiU3RyaW5nIiwidGhhdCIsIlBST1RPVFlQRSIsIiRleHBvcnQiLCJzb3VyY2UiLCJJU19GT1JDRUQiLCJGIiwiSVNfR0xPQkFMIiwiRyIsIklTX1NUQVRJQyIsIklTX1BST1RPIiwiSVNfQklORCIsIkIiLCJleHBvcnRzIiwiZXhwUHJvdG8iLCJvd24iLCJvdXQiLCJleHAiLCJjdHgiLCJyZWRlZmluZSIsIlUiLCJXIiwiUiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY29mIiwiSU9iamVjdCIsImRlZmluZWQiLCJnT1BEIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidG9JT2JqZWN0IiwicElFIiwiY2hlY2siLCJwcm90byIsInNldFByb3RvdHlwZU9mIiwiYnVnZ3kiLCJfX3Byb3RvX18iLCJTSEFSRUQiLCJzdG9yZSIsIlN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsInVpZCIsIlRBRyIsIkFSRyIsInRyeUdldCIsIlQiLCJjYWxsZWUiLCJjbGFzc29mIiwiY2VpbCIsInBvcyIsInRvSW50ZWdlciIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJmcm9tSW5kZXgiLCJ0b0xlbmd0aCIsInRvQWJzb2x1dGVJbmRleCIsInNoYXJlZCIsImFycmF5SW5kZXhPZiIsIklFX1BST1RPIiwibmFtZXMiLCIka2V5cyIsImVudW1CdWdLZXlzIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJnZXRLZXlzIiwiRW1wdHkiLCJjcmVhdGVEaWN0IiwiaWZyYW1lIiwibHQiLCJndCIsImlmcmFtZURvY3VtZW50IiwiY29udGVudFdpbmRvdyIsIndyaXRlIiwiY2xvc2UiLCJhbk9iamVjdCIsImRQcyIsImRlZiIsInRhZyIsInN0YXQiLCJjb25maWd1cmFibGUiLCJJdGVyYXRvclByb3RvdHlwZSIsIkNvbnN0cnVjdG9yIiwiTkFNRSIsIm5leHQiLCJkZXNjcmlwdG9yIiwiT2JqZWN0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInRvT2JqZWN0IiwiY29uc3RydWN0b3IiLCJJVEVSQVRPUiIsIkJVR0dZIiwiRkZfSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwicmV0dXJuVGhpcyIsIkJhc2UiLCJERUZBVUxUIiwiSVNfU0VUIiwiRk9SQ0VEIiwiZ2V0TWV0aG9kIiwia2luZCIsInZhbHVlcyIsImVudHJpZXMiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIm1ldGhvZHMiLCJMSUJSQVJZIiwiJGF0IiwiaXRlcmF0ZWQiLCJfdCIsIl9pIiwicG9pbnQiLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG8iLCJfayIsInN0ZXAiLCJJdGVyYXRvcnMiLCJBcmd1bWVudHMiLCJhZGRUb1Vuc2NvcGFibGVzIiwid2tzIiwiVE9fU1RSSU5HX1RBRyIsIkFycmF5VmFsdWVzIiwiRE9NSXRlcmFibGVzIiwiY29sbGVjdGlvbnMiLCJleHBsaWNpdCIsIkNvbGxlY3Rpb24iLCIkaXRlcmF0b3JzIiwiZm9yYmlkZGVuRmllbGQiLCJyZXQiLCJnZXRJdGVyYXRvck1ldGhvZCIsIkJSRUFLIiwiUkVUVVJOIiwiaXRlcmFibGUiLCJpdGVyRm4iLCJnZXRJdGVyRm4iLCJpc0FycmF5SXRlciIsIlNQRUNJRVMiLCJLRVkiLCJDIiwiREVTQ1JJUFRPUlMiLCJNRVRBIiwic2V0RGVzYyIsImlzRXh0ZW5zaWJsZSIsIkZSRUVaRSIsInByZXZlbnRFeHRlbnNpb25zIiwic2V0TWV0YSIsImZhc3RLZXkiLCJnZXRXZWFrIiwib25GcmVlemUiLCJtZXRhIiwiTkVFRCIsIlRZUEUiLCJTSVpFIiwiZ2V0RW50cnkiLCJlbnRyeSIsIl9mIiwibiIsIklTX01BUCIsIkFEREVSIiwiX2wiLCJmb3JPZiIsInZhbGlkYXRlIiwiZGF0YSIsImNhbGxiYWNrZm4iLCJ2IiwiU0FGRV9DTE9TSU5HIiwicml0ZXIiLCJza2lwQ2xvc2luZyIsImFyciIsIml0ZXIiLCJjb21tb24iLCJJU19XRUFLIiwiZml4TWV0aG9kIiwiZmFpbHMiLCJnZXRDb25zdHJ1Y3RvciIsImluc3RhbmNlIiwiSEFTTlRfQ0hBSU5JTkciLCJUSFJPV1NfT05fUFJJTUlUSVZFUyIsIkFDQ0VQVF9JVEVSQUJMRVMiLCIkaXRlckRldGVjdCIsIkJVR0dZX1pFUk8iLCIkaW5zdGFuY2UiLCJpbmhlcml0SWZSZXF1aXJlZCIsInNldFN0cm9uZyIsIlNFVCIsIlNldCIsInN0cm9uZyIsInRvSlNPTiIsImZyb20iLCJDT0xMRUNUSU9OIiwib2YiLCJBIiwibWFwRm4iLCJtYXBwaW5nIiwiY2IiLCJhRnVuY3Rpb24iLCJuZXh0SXRlbSIsIk1BUCIsIk1hcCIsInJlc2VydmVkVGFnTGlzdCIsImlzVmFsaWRDdXN0b21FbGVtZW50TmFtZSIsImxvY2FsTmFtZSIsInJlc2VydmVkIiwidmFsaWRGb3JtIiwiaXNDb25uZWN0ZWQiLCJuYXRpdmVWYWx1ZSIsIl9fQ0VfaXNJbXBvcnREb2N1bWVudCIsIkRvY3VtZW50IiwiU2hhZG93Um9vdCIsImhvc3QiLCJuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nIiwicm9vdCIsIm5leHRTaWJsaW5nIiwibmV4dE5vZGUiLCJ3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyIsInZpc2l0ZWRJbXBvcnRzIiwiaW1wb3J0Iiwic2hhZG93Um9vdCIsIl9fQ0Vfc2hhZG93Um9vdCIsInNldFByb3BlcnR5VW5jaGVja2VkIiwiZGVzdGluYXRpb24iLCJDdXN0b21FbGVtZW50U3RhdGUiLCJDdXN0b21FbGVtZW50SW50ZXJuYWxzIiwiX2xvY2FsTmFtZVRvRGVmaW5pdGlvbiIsIl9jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbiIsIl9wYXRjaGVzIiwiX2hhc1BhdGNoZXMiLCJkZWZpbml0aW9uIiwicGF0Y2giLCJfX0NFX3BhdGNoZWQiLCJfX0NFX3N0YXRlIiwiQ0VTdGF0ZSIsImN1c3RvbSIsIlV0aWxpdGllcyIsImNvbm5lY3RlZENhbGxiYWNrIiwidXBncmFkZUVsZW1lbnQiLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsImdhdGhlckVsZW1lbnRzIiwiX19DRV9oYXNSZWdpc3RyeSIsIl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCIsInBhdGNoQW5kVXBncmFkZVRyZWUiLCJjdXJyZW50U3RhdGUiLCJsb2NhbE5hbWVUb0RlZmluaXRpb24iLCJjb25zdHJ1Y3Rpb25TdGFjayIsInBvcCIsImZhaWxlZCIsIl9fQ0VfZGVmaW5pdGlvbiIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsIm9ic2VydmVkQXR0cmlidXRlcyIsIl9fQ0VfaXNDb25uZWN0ZWRDYWxsYmFja0NhbGxlZCIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJuYW1lc3BhY2UiLCJEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIiwiaW50ZXJuYWxzIiwiZG9jIiwiX2ludGVybmFscyIsIl9kb2N1bWVudCIsIl9vYnNlcnZlciIsIl9oYW5kbGVNdXRhdGlvbnMiLCJkaXNjb25uZWN0IiwibXV0YXRpb25zIiwiYWRkZWROb2RlcyIsIkRlZmVycmVkIiwiX3ZhbHVlIiwiX3Jlc29sdmUiLCJfcHJvbWlzZSIsIkN1c3RvbUVsZW1lbnRSZWdpc3RyeSIsIl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyIsIl93aGVuRGVmaW5lZERlZmVycmVkIiwiX2ZsdXNoQ2FsbGJhY2siLCJfZmx1c2hQZW5kaW5nIiwiX3VuZmx1c2hlZExvY2FsTmFtZXMiLCJfZG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciIsIlN5bnRheEVycm9yIiwiYWRvcHRlZENhbGxiYWNrIiwiZ2V0Q2FsbGJhY2siLCJjYWxsYmFja1ZhbHVlIiwic2V0RGVmaW5pdGlvbiIsIl9mbHVzaCIsInByaW9yIiwidG9Qcm9taXNlIiwib3V0ZXIiLCJpbm5lciIsImZsdXNoIiwiZGVmaW5lIiwid2hlbkRlZmluZWQiLCJwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrIiwiY3JlYXRlRWxlbWVudE5TIiwiY2xvbmVOb2RlIiwiZ2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyIiwiY29uc3RydWN0b3JUb0RlZmluaXRpb24iLCJOYXRpdmUiLCJEb2N1bWVudF9jcmVhdGVFbGVtZW50IiwibGFzdEluZGV4IiwiYnVpbHRJbiIsIm5vZGVzIiwiY29ubmVjdGVkQmVmb3JlIiwicHJlcGVuZCIsImRpc2Nvbm5lY3RUcmVlIiwiY29ubmVjdFRyZWUiLCJjbG9uZSIsIkRvY3VtZW50X2ltcG9ydE5vZGUiLCJwYXRjaFRyZWUiLCJOU19IVE1MIiwiRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TIiwiRG9jdW1lbnRfcHJlcGVuZCIsIkRvY3VtZW50X2FwcGVuZCIsInJlZk5vZGUiLCJpbnNlcnRlZE5vZGVzIiwibmF0aXZlUmVzdWx0IiwiTm9kZV9pbnNlcnRCZWZvcmUiLCJub2RlV2FzQ29ubmVjdGVkIiwiTm9kZV9hcHBlbmRDaGlsZCIsIk5vZGVfY2xvbmVOb2RlIiwib3duZXJEb2N1bWVudCIsIk5vZGVfcmVtb3ZlQ2hpbGQiLCJub2RlVG9JbnNlcnQiLCJub2RlVG9SZW1vdmUiLCJOb2RlX3JlcGxhY2VDaGlsZCIsIm5vZGVUb0luc2VydFdhc0Nvbm5lY3RlZCIsInRoaXNJc0Nvbm5lY3RlZCIsInBhdGNoX3RleHRDb250ZW50IiwiYmFzZURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiYXNzaWduZWRWYWx1ZSIsIlRFWFRfTk9ERSIsInJlbW92ZWROb2RlcyIsImNoaWxkTm9kZXNMZW5ndGgiLCJOb2RlX3RleHRDb250ZW50IiwiYWRkUGF0Y2giLCJwYXJ0cyIsImJlZm9yZSIsImFmdGVyIiwid2FzQ29ubmVjdGVkIiwicmVwbGFjZVdpdGgiLCJFbGVtZW50X2F0dGFjaFNoYWRvdyIsImluaXQiLCJwYXRjaF9pbm5lckhUTUwiLCJodG1sU3RyaW5nIiwicmVtb3ZlZEVsZW1lbnRzIiwiRWxlbWVudF9pbm5lckhUTUwiLCJIVE1MRWxlbWVudF9pbm5lckhUTUwiLCJyYXdEaXYiLCJFbGVtZW50X3NldEF0dHJpYnV0ZSIsIkVsZW1lbnRfZ2V0QXR0cmlidXRlIiwiRWxlbWVudF9zZXRBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMiLCJFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZSIsIkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMiLCJwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQiLCJiYXNlTWV0aG9kIiwid2hlcmUiLCJpbnNlcnRlZEVsZW1lbnQiLCJIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQiLCJFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCIsIkVsZW1lbnRfcHJlcGVuZCIsIkVsZW1lbnRfYXBwZW5kIiwiRWxlbWVudF9iZWZvcmUiLCJFbGVtZW50X2FmdGVyIiwiRWxlbWVudF9yZXBsYWNlV2l0aCIsIkVsZW1lbnRfcmVtb3ZlIiwicHJpb3JDdXN0b21FbGVtZW50cyIsImNvdW50ZXIiLCJKc011dGF0aW9uT2JzZXJ2ZXIiLCJyZWdpc3RyYXRpb25zVGFibGUiLCJzZXRJbW1lZGlhdGUiLCJzZXRJbW1lZGlhdGVRdWV1ZSIsInNlbnRpbmVsIiwiZnVuYyIsInBvc3RNZXNzYWdlIiwiaXNTY2hlZHVsZWQiLCJzY2hlZHVsZWRPYnNlcnZlcnMiLCJzY2hlZHVsZUNhbGxiYWNrIiwiZGlzcGF0Y2hDYWxsYmFja3MiLCJ3cmFwSWZOZWVkZWQiLCJTaGFkb3dET01Qb2x5ZmlsbCIsIm9ic2VydmVycyIsIm8xIiwibzIiLCJ1aWRfIiwiYW55Tm9uRW1wdHkiLCJ0YWtlUmVjb3JkcyIsImNhbGxiYWNrXyIsInJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvciIsIm5vZGVzXyIsInJlZ2lzdHJhdGlvbnMiLCJyZWdpc3RyYXRpb24iLCJyZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMiLCJmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQiLCJzdWJ0cmVlIiwicmVjb3JkIiwiZW5xdWV1ZSIsInVpZENvdW50ZXIiLCJyZWNvcmRzXyIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVPbGRWYWx1ZSIsImF0dHJpYnV0ZUZpbHRlciIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsIlJlZ2lzdHJhdGlvbiIsImFkZExpc3RlbmVycyIsImNvcHlPZlJlY29yZHMiLCJNdXRhdGlvblJlY29yZCIsInByZXZpb3VzU2libGluZyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJjb3B5TXV0YXRpb25SZWNvcmQiLCJvcmlnaW5hbCIsImN1cnJlbnRSZWNvcmQiLCJyZWNvcmRXaXRoT2xkVmFsdWUiLCJnZXRSZWNvcmQiLCJnZXRSZWNvcmRXaXRoT2xkVmFsdWUiLCJjbGVhclJlY29yZHMiLCJyZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uIiwic2VsZWN0UmVjb3JkIiwibGFzdFJlY29yZCIsIm5ld1JlY29yZCIsInRyYW5zaWVudE9ic2VydmVkTm9kZXMiLCJyZWNvcmRzIiwicmVjb3JkVG9SZXBsYWNlTGFzdCIsImFkZExpc3RlbmVyc18iLCJyZW1vdmVMaXN0ZW5lcnNfIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYXR0ck5hbWUiLCJyZWxhdGVkTm9kZSIsIm5hbWVzcGFjZVVSSSIsImF0dHJDaGFuZ2UiLCJNdXRhdGlvbkV2ZW50IiwiQURESVRJT04iLCJwcmV2VmFsdWUiLCJhZGRUcmFuc2llbnRPYnNlcnZlciIsImNoYW5nZWROb2RlIiwiX2lzUG9seWZpbGxlZCIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyIsInBhcnRpYWxseUFwcGxpZWQiLCJydW5JZlByZXNlbnQiLCJoYW5kbGUiLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsIm5leHRUaWNrIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsIm9uR2xvYmFsTWVzc2FnZSIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsInByb2Nlc3MiLCJGYXN0Q2xpY2siLCJsYXllciIsIm9sZE9uQ2xpY2siLCJ0cmFja2luZ0NsaWNrIiwidHJhY2tpbmdDbGlja1N0YXJ0IiwidG91Y2hTdGFydFgiLCJ0b3VjaFN0YXJ0WSIsImxhc3RUb3VjaElkZW50aWZpZXIiLCJ0b3VjaEJvdW5kYXJ5IiwidGFwRGVsYXkiLCJ0YXBUaW1lb3V0Iiwibm90TmVlZGVkIiwibWV0aG9kIiwiZGV2aWNlSXNBbmRyb2lkIiwib25Nb3VzZSIsIm9uQ2xpY2siLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJvblRvdWNoQ2FuY2VsIiwiY2FwdHVyZSIsInJtdiIsImhpamFja2VkIiwiYWR2IiwicHJvcGFnYXRpb25TdG9wcGVkIiwiZGV2aWNlSXNXaW5kb3dzUGhvbmUiLCJkZXZpY2VJc0lPUyIsImRldmljZUlzSU9TNCIsImRldmljZUlzSU9TV2l0aEJhZFRhcmdldCIsImRldmljZUlzQmxhY2tCZXJyeTEwIiwibmVlZHNDbGljayIsImRpc2FibGVkIiwibmVlZHNGb2N1cyIsInJlYWRPbmx5Iiwic2VuZENsaWNrIiwiY2xpY2tFdmVudCIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwiaW5pdE1vdXNlRXZlbnQiLCJkZXRlcm1pbmVFdmVudFR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsImZvcndhcmRlZFRvdWNoRXZlbnQiLCJzZXRTZWxlY3Rpb25SYW5nZSIsInVwZGF0ZVNjcm9sbFBhcmVudCIsInNjcm9sbFBhcmVudCIsImZhc3RDbGlja1Njcm9sbFBhcmVudCIsInNjcm9sbEhlaWdodCIsImZhc3RDbGlja0xhc3RTY3JvbGxUb3AiLCJzY3JvbGxUb3AiLCJnZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0IiwiZXZlbnRUYXJnZXQiLCJzZWxlY3Rpb24iLCJ0YXJnZXRUb3VjaGVzIiwiaXNDb250ZW50RWRpdGFibGUiLCJnZXRTZWxlY3Rpb24iLCJyYW5nZUNvdW50IiwiaXNDb2xsYXBzZWQiLCJsYXN0Q2xpY2tUaW1lIiwidG91Y2hIYXNNb3ZlZCIsImJvdW5kYXJ5IiwiZmluZENvbnRyb2wiLCJsYWJlbEVsZW1lbnQiLCJjb250cm9sIiwiaHRtbEZvciIsImZvckVsZW1lbnQiLCJ0YXJnZXRUYWdOYW1lIiwiY2FuY2VsTmV4dENsaWNrIiwiZWxlbWVudEZyb21Qb2ludCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJ0b3AiLCJwZXJtaXR0ZWQiLCJtZXRhVmlld3BvcnQiLCJjaHJvbWVWZXJzaW9uIiwiYmxhY2tiZXJyeVZlcnNpb24iLCJmaXJlZm94VmVyc2lvbiIsIm9udG91Y2hzdGFydCIsInNjcm9sbFdpZHRoIiwib3V0ZXJXaWR0aCIsIm1zVG91Y2hBY3Rpb24iLCJ0b3VjaEFjdGlvbiIsImF0dGFjaCIsIkRFRkFVTFRfVklFV1BPUlQiLCJWaWV3cG9ydCIsInZpZXdwb3J0RWxlbWVudCIsImhlYWQiLCJlbnN1cmVWaWV3cG9ydEVsZW1lbnQiLCJmYXN0Q2xpY2siLCJzdXBwb3J0VG91Y2hBY3Rpb24iLCJfcnVuT25BY3R1YWxQbGF0Zm9ybSIsIl9pbnRlcm5hbCIsImNyZWF0ZUhhbmRsZXIiLCJhcHAiLCJleGl0QXBwIiwiX2dlc3R1cmVEZXRlY3RvciIsImdldEVsZW1lbnRDbGFzcyIsIkJhc2VFbGVtZW50IiwiVGVtcGxhdGVFbGVtZW50Iiwib3V0ZXJIVE1MIiwiYnViYmxlcyIsIlRlbXBsYXRlIiwiSWZFbGVtZW50IiwiX2lzQWxsb3dlZFBsYXRmb3JtIiwiY29uZGl0aW9uYWxPcmllbnRhdGlvbiIsImN1cnJlbnRPcmllbnRhdGlvbiIsIklmIiwiQmFzZUFuaW1hdG9yIiwicHJvcGVydGllcyIsImV4dGVuZGVkQW5pbWF0b3IiLCJuZXdBbmltYXRvciIsIkFjdGlvblNoZWV0QW5pbWF0b3IiLCJNREFjdGlvblNoZWV0QW5pbWF0b3IiLCJtYXNrVGltaW5nIiwibWFza0R1cmF0aW9uIiwiYW5pbWl0IiwiX21hc2siLCJ3YWl0IiwiX3NoZWV0Iiwic2F2ZVN0eWxlIiwicmVzdG9yZVN0eWxlIiwiSU9TQWN0aW9uU2hlZXRBbmltYXRvciIsImJvZHlIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJCYXNlRGlhbG9nRWxlbWVudCIsInNob3VsZFNob3ciLCJfZG9vckxvY2siLCJfY2FuY2VsIiwiX3NlbGZDYW1lbE5hbWUiLCJfZGVmYXVsdERCQiIsImNhbGxQYXJlbnRIYW5kbGVyIiwiX2FuaW1hdG9yRmFjdG9yeSIsIl91cGRhdGVBbmltYXRvckZhY3RvcnkiLCJfcnVubmluZyIsIl9zZXRWaXNpYmxlIiwicGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nIiwiY2FuY2VsZWQiLCJfdG9nZ2xlU3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvbkRldmljZUJhY2tCdXR0b24iLCJfcHJldmVudFNjcm9sbCIsIl9iYWNrQnV0dG9uSGFuZGxlciIsIm9uTW9kaWZpZXJDaGFuZ2VkIiwiX3NjaGVtZSIsIl91cGRhdGVNYXNrIiwiX2FuaW1hdG9yRGljdCIsIkFjdGlvblNoZWV0RWxlbWVudCIsIl9jb21waWxlIiwic2hlZXQiLCJfdGl0bGUiLCJtYXNrIiwiaW5pdE1vZGlmaWVyIiwiX3VwZGF0ZVRpdGxlIiwiQWN0aW9uU2hlZXQiLCJkZWZhdWx0Q2xhc3NOYW1lIiwiQWN0aW9uU2hlZXRCdXR0b25FbGVtZW50IiwiX2ljb24iLCJfdXBkYXRlSWNvbiIsIkFjdGlvblNoZWV0QnV0dG9uIiwiQWxlcnREaWFsb2dBbmltYXRvciIsIkFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIiwiX2RpYWxvZyIsIklPU0FsZXJ0RGlhbG9nQW5pbWF0b3IiLCJBbGVydERpYWxvZ0VsZW1lbnQiLCJBbGVydERpYWxvZyIsIkFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudCIsIkFsZXJ0RGlhbG9nQnV0dG9uIiwiQmFja0J1dHRvbkVsZW1lbnQiLCJfb3B0aW9ucyIsIl9ib3VuZE9uQ2xpY2siLCJfb25DbGljayIsIm1kQmFja0J1dHRvbkljb24iLCJpb3NCYWNrQnV0dG9uSWNvbiIsInBvcFBhZ2UiLCJCYWNrQnV0dG9uIiwiQm90dG9tVG9vbGJhckVsZW1lbnQiLCJCb3R0b21Ub29sYmFyIiwiQnV0dG9uRWxlbWVudCIsIl91cGRhdGVSaXBwbGUiLCJCdXR0b24iLCJDYXJkRWxlbWVudCIsIkNhcmQiLCJDYXJvdXNlbEl0ZW1FbGVtZW50IiwiQ2Fyb3VzZWxJdGVtIiwiZGlyZWN0aW9uTWFwIiwiU3dpcGVyIiwiRkFMU0UiLCJnZXRFbGVtZW50Iiwic2Nyb2xsSG9vayIsIml0ZW1TaXplIiwiZ2V0QXV0b1Njcm9sbFJhdGlvIiwicmF0aW8iLCJvbkRyYWdTdGFydCIsIm9uRHJhZyIsIm9uRHJhZ0VuZCIsIm9uUmVzaXplIiwic3dpcGVhYmxlIiwiYXV0b1JlZnJlc2giLCJpbml0aWFsaXplZCIsImJsb2NrZXIiLCJfbXV0YXRpb25PYnNlcnZlciIsInVwZGF0ZVN3aXBlYWJsZSIsInVwZGF0ZUF1dG9SZWZyZXNoIiwiX3Njcm9sbCIsIl9vZmZzZXQiLCJfbGFzdEFjdGl2ZUluZGV4IiwiX3VwZGF0ZUxheW91dCIsIl9zZXR1cEluaXRpYWxJbmRleCIsInNldHVwUmVzaXplIiwidGFyZ2V0U2l6ZSIsIl9yZXNldCIsInNldEFjdGl2ZUluZGV4Iiwicm91bmQiLCJOdW1iZXIiLCJnZXRJbml0aWFsSW5kZXgiLCJpdGVtQ291bnQiLCJpdGVtTnVtU2l6ZSIsIl9zY3JvbGxUbyIsInNjcm9sbCIsIm1heFNjcm9sbCIsImlzVUlXZWJWaWV3IiwiYXJyYXlPZkFycmF5IiwiY29udGVudHMiLCJfY2hhbmdlVG8iLCJjb3VudCIsInNpemUiLCJzaG91bGRVcGRhdGUiLCJzaG91bGRXYXRjaCIsIm5ld1NpemUiLCJibG9jayIsInBvaW50ZXJFdmVudHMiLCJkIiwiaXNGaXJzdCIsImlzT3ZlclNjcm9sbGFibGUiLCJpc0xhc3QiLCJfaWdub3JlRHJhZyIsImNvbnN1bWVkIiwiY29uc3VtZSIsIl9jYW5Db25zdW1lR2VzdHVyZSIsInN0YXJ0WCIsImRpc3RGcm9tRWRnZSIsImdldEJ1YmJsZVdpZHRoIiwiX3N0YXJ0ZWQiLCJ0b2dnbGVCbG9ja2VyIiwiX2NvbnRpbnVlZCIsIl9nZXREZWx0YSIsInRocm90dGxlIiwibm9ybWFsaXplZFNjcm9sbCIsIl9ub3JtYWxpemVTY3JvbGwiLCJfc3RhcnRNb21lbnR1bVNjcm9sbCIsIl9raWxsT3ZlclNjcm9sbCIsIl9nZXRWZWxvY2l0eSIsIm1hdGNoZXNEaXJlY3Rpb24iLCJkTSIsImRpciIsIm5leHRTY3JvbGwiLCJfZ2V0QXV0b1Njcm9sbCIsInN3aXBlIiwia2lsbE92ZXJTY3JvbGwiLCJvdmVyU2Nyb2xsSG9vayIsImFjdGl2ZUluZGV4IiwiZ2V0QWN0aXZlSW5kZXgiLCJsYXN0QWN0aXZlSW5kZXgiLCJjaGFuZ2UiLCJwcmVDaGFuZ2VIb29rIiwicG9zdENoYW5nZUhvb2siLCJvcHQiLCJ0b0ZpeGVkIiwidHJhbnNmb3JtIiwiX2dldFRyYW5zZm9ybSIsIm9mZnNldCIsImlzQXV0b1Njcm9sbGFibGUiLCJsYXN0U2Nyb2xsIiwic2Nyb2xsUmF0aW8iLCJfdGFyZ2V0U2l6ZSIsIl9pdGVtTnVtU2l6ZSIsInJlZnJlc2hIb29rIiwiYXhpcyIsInQzZCIsIm5leHRFbGVtZW50U2libGluZyIsImlzQ2VudGVyZWQiLCJfY2FsY3VsYXRlSXRlbVNpemUiLCJDYXJvdXNlbEVsZW1lbnQiLCJfc3dpcGVyIiwiYXV0b1Njcm9sbFJhdGlvIiwidmVydGljYWwiLCJvdmVyc2Nyb2xsYWJsZSIsImNlbnRlcmVkIiwiYXV0b1Njcm9sbCIsIl9vbk92ZXJTY3JvbGwiLCJfb25DaGFuZ2UiLCJfb25SZWZyZXNoIiwiX29uU3dpcGUiLCJ1cGRhdGVJdGVtU2l6ZSIsIndhaXRGb3JBY3Rpb24iLCJjYXJvdXNlbCIsIml0ZW1TaXplQXR0ciIsInBhcnNlRmxvYXQiLCJDYXJvdXNlbCIsIkNvbEVsZW1lbnQiLCJfdXBkYXRlV2lkdGgiLCJDb2wiLCJEaWFsb2dBbmltYXRvciIsIkFuZHJvaWREaWFsb2dBbmltYXRvciIsIklPU0RpYWxvZ0FuaW1hdG9yIiwiU2xpZGVEaWFsb2dBbmltYXRvciIsIkRpYWxvZ0VsZW1lbnQiLCJEaWFsb2ciLCJGYWJFbGVtZW50IiwiaXNCb3R0b20iLCJ0cmFuc2xhdGUiLCJmYWJPZmZzZXQiLCJGYWIiLCJHZXN0dXJlRGV0ZWN0b3JFbGVtZW50IiwiYXV0b1ByZWZpeCIsIkljb25FbGVtZW50IiwiX2NsZWFuQ2xhc3NBdHRyaWJ1dGUiLCJfdXBkYXRlIiwiX2J1aWxkQ2xhc3NBbmRTdHlsZSIsIl9wYXJzZUF0dHIiLCJhdHRyIiwibWQiLCJsYXN0SWNvbiIsImxhc3RNb2RpZmllciIsIl9wcmVmaXhJY29uIiwiY3VzdG9tUHJlZml4UkUiLCJpY29uTmFtZSIsInJlbW92ZVByb3BlcnR5IiwiZm9udFNpemUiLCJMYXp5UmVwZWF0RGVsZWdhdGUiLCJ1c2VyRGVsZWdhdGUiLCJ0ZW1wbGF0ZUVsZW1lbnQiLCJfdXNlckRlbGVnYXRlIiwiX3RlbXBsYXRlRWxlbWVudCIsIl9yZW5kZXIiLCJsb2FkSXRlbUVsZW1lbnQiLCJjcmVhdGVJdGVtQ29udGVudCIsImNvdW50SXRlbXMiLCJ1cGRhdGVJdGVtQ29udGVudCIsImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCJkZXN0cm95SXRlbSIsIml0ZW1IZWlnaHQiLCJMYXp5UmVwZWF0UHJvdmlkZXIiLCJ3cmFwcGVyRWxlbWVudCIsImRlbGVnYXRlIiwiX3dyYXBwZXJFbGVtZW50IiwiX2RlbGVnYXRlIiwiX2luc2VydEluZGV4IiwiX3BhZ2VDb250ZW50IiwiX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQiLCJsYXN0U2Nyb2xsVG9wIiwicGFkZGluZyIsIl90b3BQb3NpdGlvbnMiLCJfcmVuZGVyZWRJdGVtcyIsIl91bmtub3duSXRlbUhlaWdodCIsIl9hZGRFdmVudExpc3RlbmVycyIsInBhZ2VDb250ZW50IiwiX2l0ZW1IZWlnaHQiLCJ2aXNpYmlsaXR5Iiwic3RhdGljSXRlbUhlaWdodCIsIl9nZXRJdGVtSGVpZ2h0IiwiZm9yY2VSZW5kZXIiLCJmb3JjZVNjcm9sbERvd24iLCJsYXN0SXRlbUluZGV4IiwiX2xhc3RJdGVtUmVuZGVyZWQiLCJfY291bnRJdGVtcyIsImZpcnN0SXRlbUluZGV4IiwiX2ZpcnN0SXRlbVJlbmRlcmVkIiwiZm9yY2VMYXN0SW5kZXgiLCJfY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQiLCJmb3JjZUZpcnN0SW5kZXgiLCJfcmVtb3ZlQWxsRWxlbWVudHMiLCJfY2hlY2tJdGVtSGVpZ2h0IiwiaXNTY3JvbGxVcCIsImtlZXAiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfY2FsY3VsYXRlU3RhcnRJbmRleCIsImhhc1JlbmRlckZ1bmN0aW9uIiwiX3JlbmRlckVsZW1lbnQiLCJfcmVtb3ZlRWxlbWVudCIsInVwZGF0ZUl0ZW0iLCJfcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMiLCJtaWRkbGUiLCJpbW1lZGlhdGUiLCJjYWxsTm93IiwiX2RlYm91bmNlIiwiX2JvdW5kT25DaGFuZ2UiLCJfYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCIsIl9wYXJlbnRFbGVtZW50IiwiX3JlbW92ZUV2ZW50TGlzdGVuZXJzIiwicGFkZGluZ1RvcCIsIkxhenlSZXBlYXRFbGVtZW50IiwiX2xhenlSZXBlYXRQcm92aWRlciIsIkxhenlSZXBlYXQiLCJMaXN0SGVhZGVyRWxlbWVudCIsIkxpc3RIZWFkZXIiLCJMaXN0VGl0bGVFbGVtZW50IiwiTGlzdFRpdGxlIiwiTGlzdEl0ZW1FbGVtZW50IiwiX3NldHVwTGlzdGVuZXJzIiwiX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIiwidGFwcGVkIiwiX29uRHJhZyIsIl9vblRvdWNoIiwiX29uUmVsZWFzZSIsInRvdWNoU3R5bGUiLCJib3hTaGFkb3ciLCJMaXN0SXRlbSIsIkxpc3RFbGVtZW50IiwiTGlzdCIsIklOUFVUX0FUVFJJQlVURVMiLCJCYXNlSW5wdXRFbGVtZW50IiwiX2JvdW5kRGVsZWdhdGVFdmVudCIsIl9kZWxlZ2F0ZUV2ZW50IiwiX2RlZmF1bHRDbGFzc05hbWUiLCJfdGVtcGxhdGUiLCJfc2V0SW5wdXRJZCIsIl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMiLCJfaW5wdXQiLCJ0b0lTT1N0cmluZyIsIklucHV0RWxlbWVudCIsIl9ib3VuZE9uSW5wdXQiLCJfYm91bmRPbkZvY3VzaW4iLCJfdXBkYXRlTGFiZWwiLCJfdXBkYXRlTGFiZWxDbGFzcyIsIl9oZWxwZXIiLCJpbm5lclRleHQiLCJJbnB1dCIsIkJhc2VDaGVja2JveEVsZW1lbnQiLCJjaGVja2VkIiwiQ2hlY2tib3hFbGVtZW50IiwiQ2hlY2tib3giLCJSYWRpb0VsZW1lbnQiLCJSYWRpbyIsIlNlYXJjaElucHV0RWxlbWVudCIsIlNlYXJjaElucHV0IiwiTW9kYWxBbmltYXRvciIsIm1vZGFsIiwiRmFkZU1vZGFsQW5pbWF0b3IiLCJMaWZ0TW9kYWxBbmltYXRvciIsIk1vZGFsRWxlbWVudCIsIk1vZGFsIiwid2lkdGhUb1B4Iiwib2Zmc2V0V2lkdGgiLCJTd2lwZVJldmVhbCIsImVsZW1lbnRIYW5kbGVyIiwiZ2V0VGhyZXNob2xkIiwiZ2V0U2lkZSIsImhhbmRsZUdlc3R1cmUiLCJnZXN0dXJlRGV0ZWN0b3IiLCJpZ25vcmVTd2lwZSIsIl93aWR0aCIsIl9zdGFydERpc3RhbmNlIiwiX2Rpc3RhbmNlIiwiaXNJbml0aWFsU3RhdGUiLCJkZWx0YSIsInN3aXBlTWlkIiwiaXNTd2lwZU1heCIsInN3aXBlTWF4Iiwic3dpcGVNaW4iLCJOYXZpZ2F0b3JBbmltYXRvciIsImVudGVyUGFnZSIsImxlYXZlUGFnZSIsIklPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IiLCJiYWNrZ3JvdW5kTWFzayIsInRvb2xiYXIiLCJfZ2V0VG9vbGJhckVsZW1lbnQiLCJfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQiLCJfZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50IiwiZXhjbHVkZUJhY2tCdXR0b24iLCJvdGhlciIsIl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50IiwiX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQiLCJfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQiLCJfZ2V0Q29udGVudEVsZW1lbnQiLCJfZ2V0QmFja2dyb3VuZEVsZW1lbnQiLCJfZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQiLCJlbnRlclRvb2xiYXIiLCJsZWF2ZVRvb2xiYXIiLCJ0b29sYmFycyIsIm1hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJkZWNvbXBvc2l0aW9uIiwicGFnZVJlY3QiLCJiYWNrQnV0dG9uTGFiZWwiLCJsYWJlbFJlY3QiLCJiYWNrQnV0dG9uSWNvbiIsInVuYmxvY2siLCJlbnRlclBhZ2VUYXJnZXQiLCJsZWF2ZVBhZ2VUYXJnZXQiLCJlbnRlclBhZ2VEZWNvbXBvc2l0aW9uIiwiX2RlY29tcG9zZSIsImxlYXZlUGFnZURlY29tcG9zaXRpb24iLCJfY2FsY3VsYXRlRGVsdGEiLCJzaG91bGRBbmltYXRlVG9vbGJhciIsIl9zaG91bGRBbmltYXRlVG9vbGJhciIsImJvdHRvbVRvb2xiYXIiLCJiYWNrZ3JvdW5kIiwidG9vbGJhckNlbnRlciIsIm9wYWNpdHkiLCJJT1NTd2lwZU5hdmlnYXRvckFuaW1hdG9yIiwiZHVyYXRpb25SZXN0b3JlIiwic3dpcGVTaGFkb3ciLCJpc0RyYWdTdGFydCIsImRlY29tcCIsImVudGVyIiwibGVhdmUiLCJfc2F2ZVN0eWxlIiwib3ZlcmZsb3dFbGVtZW50IiwibWF4V2lkdGgiLCJfZHJhZ1N0YXJ0U2V0dXAiLCJzd2lwZVJhdGlvIiwiX3NhdmVkU3R5bGUiLCJzYXZlIiwicmVzdG9yZSIsIl9yZXN0b3JlU3R5bGUiLCJJT1NMaWZ0TmF2aWdhdG9yQW5pbWF0b3IiLCJJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IiLCJNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IiLCJibGFja01hc2tPcGFjaXR5IiwiTURMaWZ0TmF2aWdhdG9yQW5pbWF0b3IiLCJtYXNrQ2xlYXIiLCJNREZhZGVOYXZpZ2F0b3JBbmltYXRvciIsInRpbWluZ09uUG9wIiwiTm9uZU5hdmlnYXRvckFuaW1hdG9yIiwicmV3cml0YWJsZXMiLCJuYXZpZ2F0b3JFbGVtZW50IiwiTmF2aWdhdG9yRWxlbWVudCIsIl9pc1J1bm5pbmciLCJfaW5pdGlhbGl6ZWQiLCJfcGFnZUxvYWRlciIsIl9wYWdlTWFwIiwiX3BhZ2UiLCJfb25EZXZpY2VCYWNrQnV0dG9uIiwiX3N3aXBlQW5pbWF0b3IiLCJfc3dpcGUiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiYXJlYSIsImxvYWRlZCIsIl9nZXRQYWdlVGFyZ2V0IiwicHVzaFBhZ2UiLCJfc2hvdyIsIl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24iLCJ1cGRhdGUiLCJfcHJlcGFyZVBhZ2VBbmRPcHRpb25zIiwicG9wVXBkYXRlIiwidW5sb2FkIiwiX3BvcFBhZ2UiLCJfZW1pdFByZVBvcEV2ZW50IiwidXBkYXRlQmFja0J1dHRvbiIsInB1c2hlZE9wdGlvbnMiLCJfaGlkZSIsIl92ZXJpZnlQYWdlRWxlbWVudCIsInBhZ2VIVE1MIiwiX3B1c2hQYWdlIiwibG9hZCIsIl9lbWl0UHJlUHVzaEV2ZW50IiwicGFnZUxlbmd0aCIsIl9yZXBsYWNlUGFnZSIsInJlc29sdmVkVmFsdWUiLCJfbm9ybWFsaXplSW5kZXgiLCJfbGFzdEluZGV4T2ZQYWdlIiwicGFnZU5hbWUiLCJpc0NhbmNlbGVkIiwiX2VtaXRQcmVFdmVudCIsInRlbXBsYXRlSFRNTCIsInBhZ2VMb2FkZXIiLCJsYXN0RWxlbWVudENoaWxkIiwiTmF2aWdhdG9yIiwiVG9vbGJhckVsZW1lbnQiLCJfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cyIsIl9lbnN1cmVUb29sYmFyRWxlbWVudCIsIlRvb2xiYXIiLCJQYWdlRWxlbWVudCIsIl9kZXJpdmVIb29rcyIsIl9jb250ZW50T2JzZXJ2ZXIiLCJfdHJ5VG9TdXBwcmVzc0xheWVyQ3JlYXRpb24iLCJfYmFja2dyb3VuZEVsZW1lbnQiLCJzY3JvbGxlclNldCIsInNob3VsZFN1cHByZXNzIiwiX2VsZW1lbnRTaG91bGRCZU1vdmVkIiwiX3RyeVRvRmlsbFN0YXR1c0JhciIsImZpeGVkRWxlbWVudHMiLCJvbkluaXQiLCJiYWNrQnV0dG9uIiwib3ZlckxpbWl0IiwiX2luZmluaXRlU2Nyb2xsTGltaXQiLCJfb25JbmZpbml0ZVNjcm9sbCIsIl9sb2FkaW5nQ29udGVudCIsIm9uSW5maW5pdGVTY3JvbGwiLCJvbkRlc3Ryb3kiLCJldmVudHMiLCJfYm91bmRPblNjcm9sbCIsIl9vblNjcm9sbCIsIlBhZ2UiLCJQb3BvdmVyQW5pbWF0b3IiLCJwb3BvdmVyIiwidG8iLCJhbmltYXRpb25zIiwiX2FuaW1hdGUiLCJmYWRlIiwiTURGYWRlUG9wb3ZlckFuaW1hdG9yIiwiX2FuaW1hdGVBbGwiLCJpbiIsIklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IiLCJpUGhvbmVYUGF0Y2giLCJpc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlIiwiaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUiLCJnZXRTYWZlQXJlYUxlbmd0aHMiLCJzYWZlQXJlYUxlbmd0aHMiLCJnZXRTYWZlQXJlYURPTVJlY3QiLCJzYWZlQXJlYVJlY3QiLCJwb3NpdGlvbnMiLCJQb3BvdmVyRWxlbWVudCIsIl9jdXJyZW50VGFyZ2V0IiwiX3Bvc2l0aW9uUG9wb3ZlciIsIl9jbGVhclN0eWxlcyIsInJhZGl1cyIsIl9yYWRpdXMiLCJjb250ZW50RWxlbWVudCIsIl9jb250ZW50IiwibWFyZ2luIiwiX21hcmdpbiIsInRhcmdldFJlY3QiLCJpc01EIiwiY292ZXIiLCJ0YXJnZXREaXN0YW5jZSIsImJvdHRvbSIsInRhcmdldENlbnRlckRpc3RhbmNlRnJvbSIsIl9jYWxjdWxhdGVEaXJlY3Rpb25zIiwicHJpbWFyeURpcmVjdGlvbiIsInByaW1hcnkiLCJzZWNvbmRhcnlEaXJlY3Rpb24iLCJzZWNvbmRhcnkiLCJfY3VycmVudERpcmVjdGlvbiIsInNpemVOYW1lIiwiY29udGVudFNpemUiLCJ0YXJnZXRBbmRBcnJvd0xlbmd0aCIsInByaW1hcnlPZmZzZXQiLCJzZWNvbmRhcnlPZmZzZXQiLCJfcG9wb3ZlciIsIl9hcnJvdyIsImhhc0RlZmF1bHRDb250YWluZXIiLCJhcnJvdyIsIlBvcG92ZXIiLCJJTkRFVCIsIlByb2dyZXNzQmFyRWxlbWVudCIsIl9pc0NvbXBpbGVkIiwiX3ByaW1hcnkiLCJfc2Vjb25kYXJ5IiwiX3VwZGF0ZURldGVybWluYXRlIiwiX3VwZGF0ZVZhbHVlIiwiYmFyRWxlbWVudCIsIlByb2dyZXNzQmFyIiwiUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQiLCJwZXIiLCJzdmciLCJQcm9ncmVzc0NpcmN1bGFyIiwiU1RBVEVfSU5JVElBTCIsIlNUQVRFX1BSRUFDVElPTiIsIlNUQVRFX0FDVElPTiIsIlB1bGxIb29rRWxlbWVudCIsIl9vbkRyYWdTdGFydCIsIl9vbkRyYWdFbmQiLCJfc2V0U3RhdGUiLCJsaW5lSGVpZ2h0IiwiX3BhZ2VFbGVtZW50IiwiX3N0YXJ0U2Nyb2xsIiwiX2N1cnJlbnRUcmFuc2xhdGlvbiIsIl90aHJlc2hvbGRIZWlnaHRFbmFibGVkIiwidGhyZXNob2xkSGVpZ2h0IiwiX2ZpbmlzaCIsIl9wdWxsaW5nIiwiX3RyYW5zbGF0ZVRvIiwiYW5pbWF0ZSIsIm9uQWN0aW9uIiwidGgiLCJub0V2ZW50IiwibGFzdFN0YXRlIiwibWFyZ2luVG9wIiwiX29uUHVsbCIsInNjcm9sbEVsZW1lbnQiLCJfZHJhZ0xvY2tEaXNhYmxlZCIsInNjcm9sbFRvZ2dsZSIsImdkVG9nZ2xlIiwiX3NldFN0eWxlIiwiX29uQWN0aW9uIiwiUHVsbEhvb2siLCJhY3RpdmVDbGFzc1Rva2VuIiwiUmFuZ2VFbGVtZW50IiwiX2JvdW5kT25Nb3VzZURvd24iLCJfb25Nb3VzZURvd24iLCJfYm91bmRPbk1vdXNlVXAiLCJfb25Nb3VzZVVwIiwiX2JvdW5kT25Ub3VjaFN0YXJ0IiwiX29uVG91Y2hTdGFydCIsIl9ib3VuZE9uVG91Y2hFbmQiLCJfb25Ub3VjaEVuZCIsIl9ib3VuZE9uRHJhZ3N0YXJ0IiwiX29uRHJhZ3N0YXJ0IiwiX2JvdW5kT25EcmFnZW5kIiwiX29uRHJhZ2VuZCIsIl91cGRhdGVEaXNhYmxlZCIsImZvY3VzUmluZyIsIl9mb2N1c1JpbmciLCJiYWNrZ3JvdW5kU2l6ZSIsIl9yYXRpbyIsIlJhbmdlIiwiQW5pbWF0b3JDU1MiLCJmaW5hbCIsImdldFRpbWUiLCJpbml0aWFsIiwidXBkYXRlU3R5bGVzIiwiY2xlYXJUaW1lb3V0IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwic3RvcE5leHQiLCJuZXdEdXJhdGlvbiIsInBhc3NlZCIsInJlbWFpbmluZyIsInNwZWVkVXBUaW1lIiwic3RvcCIsIm1pbGxpc2Vjb25kcyIsInNwZWVkIiwidHJhbnNpdGlvblByb3BlcnR5IiwiX29uU3RvcEFuaW1hdGlvbnMiLCJfcXVldWUiLCJfaW5kZXgiLCJzdG9wQW5pbWF0aW9ucyIsIlJpcHBsZUVsZW1lbnQiLCJfYW5pbWF0b3IiLCJfd2F2ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYmFja2dyb3VuZCIsInNpemVzIiwiX2dldEVmZmVjdFNpemUiLCJfY2VudGVyIiwiX21pblIiLCJfY2FsY3VsYXRlQ29vcmRzIiwic3RvcEFsbCIsImNvbXB1dGVkU3R5bGUiLCJfdXBkYXRlUGFyZW50IiwiX3JpcHBsZUFuaW1hdGlvbiIsIl9ob2xkaW5nIiwiX2JvdW5kT25SZWxlYXNlIiwiX29uVGFwIiwiX3BhcmVudE5vZGUiLCJfYm91bmRPblRhcCIsIl9ib3VuZE9uSG9sZCIsIl9vbkhvbGQiLCJfYm91bmRPbkRyYWdTdGFydCIsInBuIiwiUmlwcGxlIiwiUm93RWxlbWVudCIsIlJvdyIsIlNlZ21lbnRFbGVtZW50IiwiX3NlZ21lbnRJZCIsIl90YWJiYXIiLCJfb25UYWJiYXJQcmVDaGFuZ2UiLCJnZXRBY3RpdmVUYWJJbmRleCIsImdldEFjdGl2ZUJ1dHRvbkluZGV4IiwiX3NldENoZWNrZWQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsInNldEFjdGl2ZVRhYiIsIl9wb3N0Q2hhbmdlIiwiU2VnbWVudCIsIlNlbGVjdEVsZW1lbnQiLCJfZGVyaXZlR2V0dGVycyIsIl9zZWxlY3QiLCJzZWwiLCJvcHRpb24iLCJTZWxlY3QiLCJTcGVlZERpYWxJdGVtRWxlbWVudCIsIlNwZWVkRGlhbEl0ZW0iLCJTcGVlZERpYWxFbGVtZW50IiwiX2l0ZW1TaG93biIsIl91cGRhdGVEaXJlY3Rpb24iLCJ0b2dnbGVJdGVtcyIsImlubGluZSIsIl9mYWIiLCJpdGVtcyIsIl9nZXRUcmFuc2xhdGUiLCJoaWRlSXRlbXMiLCJ0b3RhbERlbGF5IiwiaXNPcGVuIiwic2hvd0l0ZW1zIiwiU3BlZWREaWFsIiwiU3BsaXR0ZXJDb250ZW50RWxlbWVudCIsIm9sZENvbnRlbnQiLCJTcGxpdHRlckNvbnRlbnQiLCJTcGxpdHRlck1hc2tFbGVtZW50IiwiX3NpZGVzIiwic2lkZSIsIm1vZGUiLCJTcGxpdHRlck1hc2siLCJTcGxpdHRlckFuaW1hdG9yIiwic2lkZUVsZW1lbnQiLCJzcGxpdHRlciIsIl9zaWRlIiwiX29wcG9zaXRlU2lkZSIsImNsZWFyTWFzayIsIk92ZXJsYXlTcGxpdHRlckFuaW1hdG9yIiwibWludXMiLCJQdXNoU3BsaXR0ZXJBbmltYXRvciIsInNsaWRpbmdFbGVtZW50cyIsIl9zbGlkaW5nRWxlbWVudHMiLCJfZ2V0U2xpZGluZ0VsZW1lbnRzIiwiUmV2ZWFsU3BsaXR0ZXJBbmltYXRvciIsIl9nZXRNYXhXaWR0aCIsIl9zZXRTdHlsZXMiLCJfdW5zZXRTdHlsZXMiLCJfZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUiLCJiZWhpbmREaXN0YW5jZSIsImJlaGluZFRyYW5zZm9ybSIsIm1lbnVTdHlsZSIsIlNwbGl0dGVyRWxlbWVudCIsIl9sYXlvdXQiLCJfZ2V0U2lkZSIsIl9vbk1vZGVDaGFuZ2UiLCJTcGxpdHRlciIsIlNQTElUX01PREUiLCJDT0xMQVBTRV9NT0RFIiwiQ0xPU0VEX1NUQVRFIiwiT1BFTl9TVEFURSIsIkNIQU5HSU5HX1NUQVRFIiwic3BsaXR0ZXJTaWRlRWxlbWVudCIsIkNvbGxhcHNlRGV0ZWN0aW9uIiwiY2hhbmdlVGFyZ2V0IiwiX3RhcmdldCIsIl9vcmllbnRhdGlvbiIsImFjdGl2YXRlIiwiX3VwZGF0ZU1vZGUiLCJfbWF0Y2giLCJfcXVlcnlSZXN1bHQiLCJtYXRjaE1lZGlhIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIlNwbGl0dGVyU2lkZUVsZW1lbnQiLCJfc3RhdGUiLCJfbG9jayIsIl9jb2xsYXBzZURldGVjdGlvbiIsImNsb3NlZCIsInZhbGlkRHJhZyIsIl9tb2RlIiwiX2lzT3RoZXJTaWRlT3BlbiIsImRlYWN0aXZhdGUiLCJ1cGRhdGVPcHRpb25zIiwic2hvdWxkT3BlbiIsIkZJTkFMX1NUQVRFIiwiX2VtaXRFdmVudCIsIlNwbGl0dGVyU2lkZSIsImxvY2F0aW9ucyIsIlN3aXRjaEVsZW1lbnQiLCJfbG9jYXRpb25zIiwiX3N0YXJ0WCIsIl9lbWl0Q2hhbmdlRXZlbnQiLCJkZWZhdWx0RWxlbWVudENsYXNzIiwiX2hhbmRsZSIsIl9nZXRQb3NpdGlvbiIsInByZXZpb3VzVmFsdWUiLCJjbGljayIsIlN3aXRjaCIsInRhYmJhckVsZW1lbnQiLCJsZXJwIiwieDAiLCJ4MSIsInQiLCJUYWJiYXJFbGVtZW50IiwiX2dldEF1dG9TY3JvbGxSYXRpbyIsIl9vblByZUNoYW5nZSIsIl9vblBvc3RDaGFuZ2UiLCJfdGFiYmFyQm9yZGVyIiwiX3RhYmJhckVsZW1lbnQiLCJfdGFic1JlY3QiLCJ0YWJJdGVtIiwidGFicyIsIl9ub3JtYWxpemVFdmVudCIsImNhbmNlbCIsInNldEFjdGl2ZSIsInByZXZUYWIiLCJfYXV0b2dyb3ciLCJ0YWIiLCJ0YWJiYXIiLCJfdG9wIiwiY3MiLCJmaWxsZWQiLCJuZXh0SW5kZXgiLCJwcmV2SW5kZXgiLCJuZXh0VGFiIiwic2V0VGFiYmFyVmlzaWJpbGl0eSIsImlzQWN0aXZlIiwiaXNUb3AiLCJfdGFyZ2V0RWxlbWVudCIsIlRhYmJhciIsIlRhYkVsZW1lbnQiLCJfYnV0dG9uIiwiX3VwZGF0ZUJ1dHRvbkNvbnRlbnQiLCJpY29uV3JhcHBlciIsImZpeCIsImFjdGl2ZSIsIl9oYXNMb2FkZWQiLCJfbG9hZGVkUGFnZSIsInBhZ2VUYXJnZXQiLCJwYXJlbnRUYXJnZXQiLCJkdW1teVBhZ2UiLCJfbG9hZFBhZ2VFbGVtZW50IiwiVGFiIiwiVG9hc3RBbmltYXRvciIsIkZhZGVUb2FzdEFuaW1hdG9yIiwiQXNjZW5kVG9hc3RBbmltYXRvciIsIm1lc3NhZ2VEZWxheSIsImFzY2Vuc2lvbiIsIl9nZXRGYWJzIiwiZmFiIiwiTGlmdFRvYXN0QW5pbWF0b3IiLCJsaWZ0QW1vdW50IiwiRmFsbFRvYXN0QW5pbWF0b3IiLCJmYWxsQW1vdW50IiwiY2xlYW5VcCIsImNvcnJlY3RUb3AiLCJUb2FzdEVsZW1lbnQiLCJtZXNzYWdlQ2xhc3NOYW1lIiwiYnV0dG9uQ2xhc3NOYW1lIiwiVG9hc3QiLCJUb29sYmFyQnV0dG9uRWxlbWVudCIsIlRvb2xiYXJCdXR0b24iLCJfc3VwZXJTZWNyZXRPbnMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUVBOzs7Ozs7QUFNQSxJQUFNQSxTQUFVLFlBQVc7TUFDbkJDLFNBQVNDLE9BQU9DLGdCQUFQLENBQXdCQyxTQUFTQyxlQUFqQyxFQUFrRCxFQUFsRCxDQUFmO01BQ01MLFNBQVMsQ0FBQ00sTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FDYkMsSUFEYSxDQUNSUixNQURRLEVBRWJTLElBRmEsQ0FFUixFQUZRLEVBR2JDLEtBSGEsQ0FHUCxtQkFITyxLQUdrQlYsT0FBT1csS0FBUCxLQUFpQixFQUFqQixJQUF1QixDQUFDLEVBQUQsRUFBSyxHQUFMLENBSDFDLEVBSWIsQ0FKYSxDQUFmOztTQU1PLFVBQVNDLElBQVQsRUFBZTtXQUNiLE1BQU1iLE1BQU4sR0FBZSxHQUFmLEdBQXFCYyxLQUFLQyxTQUFMLENBQWVGLElBQWYsQ0FBNUI7R0FERjtDQVJhLEVBQWY7Ozs7Ozs7Ozs7QUFzQkEsSUFBTUcsU0FBUyxTQUFUQSxNQUFTLENBQVNDLE9BQVQsRUFBa0JDLEtBQWxCLEVBQXlCO1NBQy9CQyxJQUFQLENBQVlELEtBQVosRUFBbUJFLE9BQW5CLENBQTJCLFVBQVNDLEdBQVQsRUFBYztRQUNuQ0EsT0FBT0osUUFBUUMsS0FBbkIsRUFBMEI7Y0FD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
