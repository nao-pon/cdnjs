{"version":3,"file":"infinitegrid.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9e0381e31cced93e84e9","webpack:///./src/utils.js","webpack:///./src/consts.js","webpack:///./src/browser.js","webpack:///./src/index.js","webpack:///./src/InfiniteGrid.js","webpack:///external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}","webpack:///./src/eventHandler.js","webpack:///./src/ImageLoaded.js","webpack:///./src/LayoutManager.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@egjs/component\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"InfiniteGrid\", [\"@egjs/component\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfiniteGrid\"] = factory(require(\"@egjs/component\"));\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"InfiniteGrid\"] = factory(root[\"eg\"][\"Component\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9e0381e31cced93e84e9","\"use strict\";\n\nexports.__esModule = true;\nexports.utils = exports.Mixin = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _browser = require(\"./browser\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in _browser.window);\nvar SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in _browser.document);\nvar SUPPORT_PASSIVE = function () {\n\tvar supportsPassiveOption = false;\n\n\ttry {\n\t\tif (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n\t\t\t_browser.document.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n\t\t\t\tget: function get() {\n\t\t\t\t\tsupportsPassiveOption = true;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t} catch (e) {}\n\treturn supportsPassiveOption;\n}();\n\nvar utils = {\n\t/**\n  * Select or create element\n  * @param {String|HTMLElement|jQuery} param\n  *  when string given is as HTML tag, then create element\n  *  otherwise it returns selected elements\n  * @param {Boolean} multi\n  * @returns {HTMLElement}\n  */\n\t$: function $(param) {\n\t\tvar multi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\tvar el = void 0;\n\n\t\tif (typeof param === \"string\") {\n\t\t\t// String (HTML, Selector)\n\t\t\t// check if string is HTML tag format\n\t\t\tvar match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n\t\t\t// creating element\n\t\t\tif (match) {\n\t\t\t\t// HTML\n\t\t\t\tvar dummy = _browser.document.createElement(\"div\");\n\n\t\t\t\tdummy.innerHTML = param;\n\t\t\t\tel = this.toArray(dummy.childNodes);\n\t\t\t} else {\n\t\t\t\t// Selector\n\t\t\t\tel = this.toArray(_browser.document.querySelectorAll(param));\n\t\t\t}\n\t\t\tif (!multi) {\n\t\t\t\tel = el.length >= 1 ? el[0] : undefined;\n\t\t\t}\n\t\t} else if (param === _browser.window) {\n\t\t\t// window\n\t\t\tel = param;\n\t\t} else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n\t\t\t// HTMLElement, Document\n\t\t\tel = param;\n\t\t} else if (\"jQuery\" in _browser.window && param instanceof jQuery || param.constructor.prototype.jquery) {\n\t\t\t// jQuery\n\t\t\tel = multi ? param.toArray() : param.get(0);\n\t\t} else if (Array.isArray(param)) {\n\t\t\tel = param.map(function (v) {\n\t\t\t\treturn utils.$(v);\n\t\t\t});\n\t\t\tif (!multi) {\n\t\t\t\tel = el.length >= 1 ? el[0] : undefined;\n\t\t\t}\n\t\t}\n\t\treturn el;\n\t},\n\taddEvent: function addEvent(element, type, handler, eventListenerOptions) {\n\t\tif (SUPPORT_ADDEVENTLISTENER) {\n\t\t\tvar options = eventListenerOptions || false;\n\n\t\t\tif ((typeof eventListenerOptions === \"undefined\" ? \"undefined\" : _typeof(eventListenerOptions)) === \"object\") {\n\t\t\t\toptions = SUPPORT_PASSIVE ? eventListenerOptions : false;\n\t\t\t}\n\t\t\telement.addEventListener(type, handler, options);\n\t\t} else if (element.attachEvent) {\n\t\t\telement.attachEvent(\"on\" + type, handler);\n\t\t} else {\n\t\t\telement[\"on\" + type] = handler;\n\t\t}\n\t},\n\tremoveEvent: function removeEvent(element, type, handler) {\n\t\tif (element.removeEventListener) {\n\t\t\telement.removeEventListener(type, handler, false);\n\t\t} else if (element.detachEvent) {\n\t\t\telement.detachEvent(\"on\" + type, handler);\n\t\t} else {\n\t\t\telement[\"on\" + type] = null;\n\t\t}\n\t},\n\tscrollTop: function scrollTop(el) {\n\t\tif (el === _browser.window) {\n\t\t\treturn _browser.document.body.scrollTop || _browser.document.documentElement.scrollTop;\n\t\t} else {\n\t\t\treturn el.scrollTop;\n\t\t}\n\t},\n\tscrollTo: function scrollTo(el, x, y) {\n\t\tif (el === _browser.window) {\n\t\t\tel.scrollTo(x, y);\n\t\t} else {\n\t\t\tel.scrollLeft = x;\n\t\t\tel.scrollTop = y;\n\t\t}\n\t},\n\tgetSize: function getSize(el, name) {\n\t\tif (el === _browser.window) {\n\t\t\t// WINDOW\n\t\t\treturn el.document.documentElement[\"client\" + name];\n\t\t} else if (el.nodeType === 9) {\n\t\t\t// DOCUMENT_NODE\n\t\t\tvar doc = el.documentElement;\n\n\t\t\treturn Math.max(el.body[\"scroll\" + name], doc[\"scroll\" + name], el.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n\t\t} else {\n\t\t\t// NODE\n\t\t\tvar style = SUPPORT_COMPUTEDSTYLE ? _browser.window.getComputedStyle(el) : el.currentStyle;\n\t\t\tvar value = style[name.toLowerCase()];\n\n\t\t\treturn parseFloat(/auto|%/.test(value) ? el[\"offset\" + name] : style[name.toLowerCase()]);\n\t\t}\n\t},\n\tinnerWidth: function innerWidth(el) {\n\t\treturn this.getSize(el, \"Width\");\n\t},\n\tinnerHeight: function innerHeight(el) {\n\t\treturn this.getSize(el, \"Height\");\n\t},\n\tisEmptyObject: function isEmptyObject(obj) {\n\t\tvar name = void 0;\n\n\t\tfor (name in obj) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\ttoArray: function toArray(nodes) {\n\t\t// SCRIPT5014 in IE8\n\t\tvar array = [];\n\n\t\tif (nodes) {\n\t\t\tfor (var i = 0, len = nodes.length; i < len; i++) {\n\t\t\t\tarray.push(nodes[i]);\n\t\t\t}\n\t\t}\n\t\treturn array;\n\t}\n};\n\nvar MixinBuilder = function () {\n\tfunction MixinBuilder(superclass) {\n\t\t_classCallCheck(this, MixinBuilder);\n\n\t\tthis.superclass = superclass || function () {\n\t\t\tfunction _class() {\n\t\t\t\t_classCallCheck(this, _class);\n\t\t\t}\n\n\t\t\treturn _class;\n\t\t}();\n\t}\n\n\tMixinBuilder.prototype[\"with\"] = function _with() {\n\t\tfor (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\tmixins[_key] = arguments[_key];\n\t\t}\n\n\t\treturn mixins.reduce(function (c, m) {\n\t\t\treturn m(c);\n\t\t}, this.superclass);\n\t};\n\n\treturn MixinBuilder;\n}();\n\nvar Mixin = function Mixin(superclass) {\n\treturn new MixinBuilder(superclass);\n};\n\nexports.Mixin = Mixin;\nexports.utils = utils;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 0\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports.CONTAINER_CLASSNAME = exports.RETRY = exports.IS_ANDROID2 = exports.IS_IOS = exports.IS_IE = undefined;\n\nvar _browser = require(\"./browser\");\n\nvar ua = _browser.window.navigator.userAgent;\n\nvar IS_IE = exports.IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nvar IS_IOS = exports.IS_IOS = /iPhone|iPad/.test(ua);\nvar IS_ANDROID2 = exports.IS_ANDROID2 = /Android 2\\./.test(ua);\nvar RETRY = exports.RETRY = 3;\nvar CONTAINER_CLASSNAME = exports.CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/consts.js\n// module id = 1\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win = typeof window !== \"undefined\" && window.Math === Math ? window : typeof self !== \"undefined\" && self.Math === Math ? self : Function(\"return this\")();\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexports.window = win;\nvar document = exports.document = win.document;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser.js\n// module id = 2\n// module chunks = 0 1","\"use strict\";\n\nvar _InfiniteGrid = require(\"./InfiniteGrid\");\n\nvar _InfiniteGrid2 = _interopRequireDefault(_InfiniteGrid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.exports = _InfiniteGrid2[\"default\"]; /**\n                                             * Copyright (c) NAVER Corp.\n                                             * egjs-infinitegrid projects are licensed under the MIT license\n                                             */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 3\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * Copyright (c) 2017 NAVER Corp.\n                                                                                                                                                                                                                                                                               * egjs projects are licensed under the MIT license\n                                                                                                                                                                                                                                                                              */\n\n\nvar _component = require(\"@egjs/component\");\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _eventHandler = require(\"./eventHandler\");\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _browser = require(\"./browser\");\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nvar _ImageLoaded = require(\"./ImageLoaded\");\n\nvar _ImageLoaded2 = _interopRequireDefault(_ImageLoaded);\n\nvar _LayoutManager = require(\"./LayoutManager\");\n\nvar _LayoutManager2 = _interopRequireDefault(_LayoutManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n/* eslint-disable */\nif (typeof Object.create !== \"function\") {\n\tObject.create = function (o, properties) {\n\t\tif ((typeof o === \"undefined\" ? \"undefined\" : _typeof(o)) !== \"object\" && typeof o !== \"function\") {\n\t\t\tthrow new TypeError(\"Object prototype may only be an Object: \" + o);\n\t\t} else if (o === null) {\n\t\t\tthrow new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n\t\t}\n\t\tfunction F() {}\n\t\tF.prototype = o;\n\t\treturn new F();\n\t};\n}\n/* eslint-enable */\n\n/**\n * A module used to arrange card elements including content infinitely on a grid layout. With this module, you can implement a grid-pattern user interface composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko 콘텐츠가 있는 카드 엘리먼트를 그리드 레이아웃에 무한으로 배치하는 모듈. 다양한 크기의 카드 엘리먼트를 격자 모양으로 배치하는 UI를 만들 수 있다. 카드 엘리먼트의 개수가 계속 늘어나도 모듈이 처리하는 DOM의 개수를 일정하게 유지해 최적의 성능을 보장한다\n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n\t<li class=\"card\">\n\t\t<div>test1</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test2</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test3</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test4</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test5</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test6</div>\n\t</li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n\t// ...\n});\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\nvar InfiniteGrid = function (_Mixin$with) {\n\t_inherits(InfiniteGrid, _Mixin$with);\n\n\t/**\n  * @param {HTMLElement|String|jQuery} element A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n  * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n  * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>레이아웃을 구성하는 카드 엘리먼트를 선택할 선택자(selector)</ko>\n  * @param {Number} [options.count=30] The number of DOMs handled by module. If the count value is greater than zero, the number of DOMs is maintained. If the count value is zero or less than zero, the number of DOMs will increase as card elements are added. <ko>모듈이 유지할 실제 DOM의 개수. count 값이 0보다 크면 DOM 개수를 일정하게 유지한다. count 값이 0 이하면 카드 엘리먼트가 추가될수록 DOM 개수가 계속 증가한다.</ko>\n  * @param {String} [options.defaultGroupKey=null] The default group key configured in a card element contained in the markup upon initialization of a module object <ko>모듈 객체를 초기화할 때 마크업에 있는 카드 엘리먼트에 설정할 그룹 키 </ko>\n  * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>카드 엘리먼트의 크기가 동일한지 여부. 배치될 카드 엘리먼트의 크기가 모두 동일할 때 이 옵션을 'true'로 설정하면 레이아웃 배치 성능을 높일 수 있다</ko>\n  * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll 적용여부를 결정한다.</ko>\n  * @param {Number} [options.threshold=300] The threshold size of an event area where card elements are added to a layout.<br>- append event: If the current vertical position of the scroll bar is greater than \"the bottom property value of the card element at the top of the layout\" plus \"the value of the threshold option\", the append event will occur.<br>- prepend event: If the current vertical position of the scroll bar is less than \"the bottom property value of the card element at the top of the layout\" minus \"the value of the threshold option\", the prepend event will occur. <ko>−\t레이아웃에 카드 엘리먼트를 추가하는 이벤트가 발생하는 기준 영역의 크기.<br>- append 이벤트: 현재 스크롤의 y 좌표 값이 '레이아웃의 맨 아래에 있는 카드 엘리먼트의 top 속성의 값 + threshold 옵션의 값'보다 크면 append 이벤트가 발생한다.<br>- prepend 이벤트: 현재 스크롤의 y 좌표 값이 '레이아웃의 맨 위에 있는 카드 엘리먼트의 bottom 속성의 값 - threshold 옵션의 값'보다 작으면 prepend 이벤트가 발생한다</ko>\n  *\n  */\n\tfunction InfiniteGrid(el, options) {\n\t\t_classCallCheck(this, InfiniteGrid);\n\n\t\tvar _this = _possibleConstructorReturn(this, _Mixin$with.call(this, el, options));\n\n\t\t_extends(_this.options = {\n\t\t\tisEqualSize: false,\n\t\t\tdefaultGroupKey: null,\n\t\t\tcount: 100,\n\t\t\tisOverflowScroll: false,\n\t\t\titemSelector: \"*\",\n\t\t\tthreshold: 300\n\t\t}, options);\n\t\t_consts.IS_ANDROID2 && (_this.options.isOverflowScroll = false);\n\n\t\t_this._initElements(el);\n\t\t_this.layoutManager = new _LayoutManager2[\"default\"](_this.el, _this.options);\n\t\t_this._reset();\n\t\t_this._resizeViewport();\n\n\t\t// for IE8\n\t\tvar elements = [];\n\n\t\tfor (var i = 0, children = _this.el.children, len = children.length; i < len; i++) {\n\t\t\telements.push(children[i]);\n\t\t}\n\t\telements = _this._selectItems(elements);\n\t\tif (elements.length > 0) {\n\t\t\t_this.layout(true, _LayoutManager2[\"default\"].itemize(elements, _this.options.defaultGroupKey));\n\t\t}\n\t\t_this._attachEvent();\n\t\treturn _this;\n\t}\n\n\tInfiniteGrid.prototype._initElements = function _initElements(el) {\n\t\tvar base = _utils.utils.$(el);\n\n\t\tif (this.options.isOverflowScroll) {\n\t\t\tvar container = base.querySelector(\".\" + _consts.CONTAINER_CLASSNAME);\n\n\t\t\tif (!container) {\n\t\t\t\tcontainer = _browser.document.createElement(\"div\");\n\t\t\t\tcontainer.className = _consts.CONTAINER_CLASSNAME;\n\n\t\t\t\tvar children = base.children;\n\t\t\t\tvar length = children.length; // for IE8\n\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tcontainer.appendChild(children[0]);\n\t\t\t\t}\n\t\t\t\tbase.style.overflowY = \"scroll\";\n\t\t\t\tbase.appendChild(container);\n\t\t\t}\n\t\t\tthis.view = base;\n\t\t\tthis.el = container;\n\t\t} else {\n\t\t\tthis.view = _browser.window;\n\t\t\tthis.el = base;\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._resizeViewport = function _resizeViewport() {\n\t\tthis._status.clientHeight = _utils.utils.innerHeight(this.view);\n\t};\n\n\t/**\n  * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n  * @ko 카드의 위치 정보 등 모듈의 현재 상태 정보를 반환한다. 이 메서드가 반환한 정보를 저장해 두었다가 setStatus() 메서드로 복원할 수 있다\n  * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getStatus = function getStatus() {\n\t\tvar data = {};\n\t\tvar target = this.view === _browser.window ? this.el : this.view;\n\n\t\tfor (var p in this._status) {\n\t\t\tif (this._status.hasOwnProperty.call(p) && !(this._status[p] instanceof Element)) {\n\t\t\t\tdata[p] = this._status[p];\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\thtml: target.innerHTML,\n\t\t\tcssText: target.style.cssText,\n\t\t\tlayoutManager: this.layoutManager.getStatus(),\n\t\t\toptions: _extends({}, this.options),\n\t\t\tprop: data,\n\t\t\tscrollPos: _utils.utils.scrollTop(this.view)\n\t\t};\n\t};\n\n\t/**\n  * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n  * @ko getStatue() 메서드가 저장한 정보로 eg.InfiniteGrid 모듈의 상태를 설정한다.\n  * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n  * @param {boolean} applyScrollPos Checks whether to scroll<ko>스크롤의 위치를 복원할지 결정한다.</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.setStatus = function setStatus(status, applyScrollPos) {\n\t\tif (!status || !status.options || !status.prop || !status.layoutManager || !status.html || !status.cssText || !(\"scrollPos\" in status)) {\n\t\t\treturn this;\n\t\t}\n\t\tvar target = status.options.isOverflowScroll ? this.view : this.el;\n\n\t\tthis._detachEvent();\n\t\tthis._initElements(this.view === _browser.window ? this.el : this.view);\n\t\ttarget.style.cssText = status.cssText;\n\t\ttarget.innerHTML = status.html;\n\t\t_extends(this.options, status.options);\n\t\t_extends(this._status, status.prop);\n\t\tthis.layoutManager.setStatus(status.layoutManager);\n\t\tthis._status.topElement = this.getTopElement();\n\t\tthis._status.bottomElement = this.getBottomElement();\n\t\tthis._attachEvent();\n\t\tapplyScrollPos && _utils.utils.scrollTo(this.view, 0, status.scrollPos);\n\t\treturn this;\n\t};\n\n\t/**\n  * Checks whether a card element is being added.\n  * @ko 카드 엘리먼트 추가가 진행 중인지 확인한다\n  * @return {Boolean} Indicates whether a card element is being added <ko>카드 엘리먼트 추가 진행 중 여부</ko>\n  */\n\n\n\tInfiniteGrid.prototype.isProcessing = function isProcessing() {\n\t\treturn this._status.isProcessing;\n\t};\n\n\t/**\n  * Checks whether the total number of added card elements is greater than the value of the count option. Note that the value of the count option is always greater than zero. If it returns true, the number of DOMs won't increase even though card elements are added; instead of adding a new DOM, existing DOMs are recycled to maintain the number of DOMs.\n  * @ko 추가된 카드 엘리먼트의 전체 개수가 count 옵션의 값보다 큰지 확인한다. 단, count 옵션의 값은 0보다 크다. 'true'가 반환되면 카드 엘리먼트가 더 추가돼도 DOM의 개수를 증가하지 않고 기존 DOM을 재활용(recycle)해 DOM의 개수를 일정하게 유지한다\n  * @return {Boolean} Indicates whether the total number of added card elements is greater than the value of the count option. <ko>추가된 카드 엘리먼트의 전체 개수가 count 옵션의 값보다 큰지 여부</ko>\n  */\n\n\n\tInfiniteGrid.prototype.isRecycling = function isRecycling() {\n\t\treturn this.options.count > 0 && this._status.isRecycling;\n\t};\n\n\t/**\n  * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, it returns undefined as a group key.\n  * @ko 현재 유지하고 있는 카드 엘리먼트의 그룹 키 목록을 반환한다. 여러 개의 카드 엘리먼트를 묶어서 관리할 수 있도록 append() 메서드나 prepend() 메서드에서 그룹 키를 지정할 수 있다. append() 메서드나 prepend() 메서드에서 그룹 키를 지정하지 않았다면 'undefined'가 그룹 키로 반환된다\n  * @return {Array} List of group keys <ko>그룹 키의 목록</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getGroupKeys = function getGroupKeys() {\n\t\treturn this.layoutManager.getGroupKeys();\n\t};\n\n\t/**\n  * Rearranges a layout.\n  * @ko 레이아웃을 다시 배치한다.\n  * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>카드 엘리먼트 재배치 여부</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  *\n  */\n\n\n\tInfiniteGrid.prototype.layout = function layout() {\n\t\tvar isRelayout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\t\tvar _addItems = arguments[1];\n\t\tvar _options = arguments[2];\n\n\t\t/**\n   * [private parameter]\n   * _addItems: added items\n   * _options: {\n   *\t isAppend: Checks whether the append() method is used to add a card element.\n   *\t removedCount: The number of deleted card elements to maintain the number of DOMs.\n   *   isTrusted: Returns true if an event was generated by the user action, or false if it was caused by a script or API call\n   * }\n   */\n\t\tthis._status.isProcessing = true;\n\t\tvar options = _extends({\n\t\t\tisAppend: true,\n\t\t\tremovedCount: 0,\n\t\t\tisTrusted: false\n\t\t}, _options);\n\n\t\t// for exception\n\t\tif (!_addItems && !options.isAppend) {\n\t\t\toptions.isAppend = true;\n\t\t}\n\t\tthis._waitResource(isRelayout, options.isAppend ? _addItems : _addItems.reverse(), options);\n\t\treturn this;\n\t};\n\n\tInfiniteGrid.prototype._onLayoutComplete = function _onLayoutComplete(isRelayout, addItems, options) {\n\t\tthis.layoutManager.layoutItems(isRelayout, addItems, options);\n\t\tthis._postLayout(isRelayout, addItems, options);\n\t};\n\n\t/**\n  * Adds a card element at the bottom of a grid layout. This method is available only if the isProcessing() method returns false.\n  * @ko 카드 엘리먼트를 그리드 레이아웃의 아래에 추가한다. isProcessing() 메서드의 반환값이 'false'일 때만 이 메서드를 사용할 수 있다\n  * 이 메소드는 isProcessing()의 반환값이 false일 경우에만 사용 가능하다.\n  * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트의 배열</ko>\n  * @param {Number|String} [groupKey] The group key to be configured in a card element. It is set to \"undefined\" by default.<ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 'undefined'로 설정된다</ko>\n  * @return {Number} The number of added card elements <ko>추가된 카드 엘리먼트의 개수</ko>\n  */\n\n\n\tInfiniteGrid.prototype.append = function append(paramElements, groupKey) {\n\t\treturn this._insert(paramElements, groupKey, true);\n\t};\n\n\t/**\n  * Adds a card element at the top of a grid layout. This method is available only if the isProcessing() method returns false and the isRecycling() method returns true.\n  * @ko 카드 엘리먼트를 그리드 레이아웃의 위에 추가한다. isProcessing() 메서드의 반환값이 'false'이고, isRecycling() 메서드의 반환값이 'true'일 때만 이 메서드를 사용할 수 있다\n  * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트 배열</ko>\n  * @param {Number|String} [groupKey] The group key to be configured in a card element. It is set to \"undefined\" by default.<ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 'undefined'로 설정된다</ko>\n  * @return {Number} The number of added card elements <ko>추가된 카드 엘리먼트의 개수</ko>\n  */\n\n\n\tInfiniteGrid.prototype.prepend = function prepend(paramElements, groupKey) {\n\t\treturn this._insert(paramElements, groupKey, false);\n\t};\n\n\t/**\n  * Clears added card elements and data.\n  * @ko 추가된 카드 엘리먼트와 데이터를 모두 지운다.\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.clear = function clear() {\n\t\tthis.el.innerHTML = \"\";\n\t\tthis.el.style.height = \"\";\n\t\tthis._reset();\n\t\treturn this;\n\t};\n\n\t/**\n  * Returns a card element at the top of a layout.\n  * @ko 레이아웃의 맨 위에 있는 카드 엘리먼트를 반환한다.\n  *\n  * @return {HTMLElement} Card element at the top of a layout. (if the position of card elements are same, it returns the first left element) <ko>레이아웃의 맨 위에 있는 카드 엘리먼트 (카드의 위치가 같은 경우, 왼쪽 엘리먼트가 반환된다)</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getTopElement = function getTopElement() {\n\t\tvar item = this.layoutManager.getTopItem();\n\n\t\treturn item && item.el;\n\t};\n\n\t/**\n  * Returns a card element at the bottom of a layout.\n  * @ko 레이아웃의 맨 아래에 있는 카드 엘리먼트를 반환한다.\n  *\n  * @return {HTMLElement} Card element at the bottom of a layout (if the position of card elements are same, it returns the first right element)<ko>레이아웃의 맨 아래에 있는 카드 엘리먼트 (카드의 위치가 같은 경우, 오른쪽 엘리먼트가 반환된다)</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getBottomElement = function getBottomElement() {\n\t\tvar item = this.layoutManager.getBottomItem();\n\n\t\treturn item && item.el;\n\t};\n\n\tInfiniteGrid.prototype._resizeContainerHeight = function _resizeContainerHeight() {\n\t\tthis.el.style.height = this.layoutManager.getLogicalHeight() + \"px\";\n\t};\n\n\tInfiniteGrid.prototype._postLayout = function _postLayout(isRelayout) {\n\t\tvar addItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar options = arguments[2];\n\n\t\tif (!this.isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tthis._resizeContainerHeight();\n\t\tthis._timer.doubleCheckCount = _consts.RETRY;\n\n\t\t// refresh element\n\t\tthis._status.topElement = this.getTopElement();\n\t\tthis._status.bottomElement = this.getBottomElement();\n\n\t\tvar distance = 0;\n\n\t\tif (!options.isAppend) {\n\t\t\tdistance = addItems.length >= this.layoutManager.items.length ? 0 : this.layoutManager.items[addItems.length].position.y;\n\t\t\tif (distance > 0) {\n\t\t\t\tthis._status.prevScrollTop = _utils.utils.scrollTop(this.view) + distance;\n\t\t\t\t_utils.utils.scrollTo(this.view, 0, this._status.prevScrollTop);\n\t\t\t}\n\t\t}\n\n\t\t// reset flags\n\t\tthis._status.isProcessing = false;\n\n\t\t/**\n   * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n   * @ko 레이아웃 배치가 완료됐을 때 발생하는 이벤트. append() 메서드나 prepend() 메서드, layout() 메서드 호출 후 카드의 배치가 완료됐을 때 발생한다\n   * @event eg.InfiniteGrid#layoutComplete\n   *\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {Array} param.target Rearranged card elements<ko>재배치된 카드 엘리먼트들</ko>\n   * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>카드 엘리먼트가 append() 메서드로 추가됐는지 확인한다. layout() 메서드가 호출된 후 layoutComplete 이벤트가 발생해도 'true'를 반환한다.</ko>\n   * @param {Number} param.distance Distance the card element at the top of a grid layout has moved after the layoutComplete event is fired. In other words, it is the same as an increased height with a new card element added using the prepend() method <ko>그리드 레이아웃의 맨 위에 있던 카드 엘리먼트가 layoutComplete 이벤트 발생 후 이동한 거리. 즉, prepend() 메서드로 카드 엘리먼트가 추가돼 늘어난 높이다.</ko>\n   * @param {Number} param.croppedCount The number of deleted card elements to maintain the number of DOMs<ko>일정한 DOM 개수를 유지하기 위해, 삭제한 카드 엘리먼트들의 개수</ko>\n   * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   */\n\t\tthis.trigger(\"layoutComplete\", {\n\t\t\ttarget: addItems.concat(),\n\t\t\tisAppend: options.isAppend,\n\t\t\tdistance: distance,\n\t\t\tcroppedCount: options.removedCount,\n\t\t\tisTrusted: options.isTrusted\n\t\t});\n\n\t\t!options.isAppend && this._doubleCheckForPrepend();\n\t};\n\n\tInfiniteGrid.prototype._doubleCheckForPrepend = function _doubleCheckForPrepend() {\n\t\tvar _this2 = this;\n\n\t\t// doublecheck!!! (workaround)\n\t\tif (_utils.utils.scrollTop(this.view) === 0) {\n\t\t\tclearInterval(this._timer.doubleCheck);\n\t\t\tthis._timer.doubleCheck = setInterval(function () {\n\t\t\t\tif (_utils.utils.scrollTop(_this2.view) === 0) {\n\t\t\t\t\t_this2.trigger(\"prepend\", {\n\t\t\t\t\t\tscrollTop: 0\n\t\t\t\t\t});\n\t\t\t\t\t--_this2._timer.doubleCheckCount <= 0 && clearInterval(_this2._timer.doubleCheck);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._selectItems = function _selectItems(elements) {\n\t\tvar _this3 = this;\n\n\t\treturn elements.filter(function (v) {\n\t\t\tif (_this3.options.itemSelector === \"*\") {\n\t\t\t\treturn (/DIV|SPAN|LI/.test(v.tagName)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn v.className.split(\" \").some(function (c) {\n\t\t\t\t\treturn c === _this3.options.itemSelector;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\tInfiniteGrid.prototype._prepareElement = function _prepareElement(paramElements) {\n\t\tvar elements = _utils.utils.$(paramElements, true);\n\n\t\telements = this._selectItems(elements);\n\t\tthis._status.isProcessing = true;\n\t\tif (!this.isRecycling()) {\n\t\t\tthis._status.isRecycling = this.layoutManager.items.length + elements.length >= this.options.count;\n\t\t}\n\t\treturn elements;\n\t};\n\n\t// elements => [HTMLElement, HTMLElement, ...]\n\n\n\tInfiniteGrid.prototype._insert = function _insert(paramElements, groupKey, isAppend) {\n\t\tif (this.isProcessing() || paramElements.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar elements = this._prepareElement(paramElements);\n\t\tvar cloneElements = elements.concat();\n\t\tvar dummy = -this._status.clientHeight + \"px\";\n\n\t\telements.forEach(function (v) {\n\t\t\tv.style.position = \"absolute\";\n\t\t\tv.style.top = dummy;\n\t\t});\n\t\tvar removedCount = this._adjustRange(isAppend, cloneElements);\n\n\t\t// prepare HTML\n\t\tvar docFragment = _browser.document.createDocumentFragment();\n\n\t\tcloneElements.forEach(function (v) {\n\t\t\treturn docFragment.appendChild(v);\n\t\t});\n\t\tisAppend ? this.el.appendChild(docFragment) : this.el.insertBefore(docFragment, this.el.firstChild);\n\t\tthis.layout(false, _LayoutManager2[\"default\"].itemize(cloneElements, groupKey), {\n\t\t\tisAppend: isAppend,\n\t\t\tremovedCount: removedCount\n\t\t});\n\t\t// console.info(\"remove count\", removedCount, this.el.children.length, \"+\", elements.length, \"||\", cloneElements.length);\n\n\t\treturn cloneElements.length;\n\t};\n\n\tInfiniteGrid.prototype._waitResource = function _waitResource(isRelayout, addItems, options) {\n\t\tvar needCheck = _ImageLoaded2[\"default\"].checkImageLoaded(this.el);\n\t\tvar callback = function () {\n\t\t\tthis._onLayoutComplete(isRelayout, addItems, options);\n\t\t}.bind(this);\n\n\t\tif (needCheck.length > 0) {\n\t\t\t_ImageLoaded2[\"default\"].waitImageLoaded(needCheck, callback);\n\t\t} else {\n\t\t\t// convert to async\n\t\t\tsetTimeout(function () {\n\t\t\t\tcallback && callback();\n\t\t\t}, 0);\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._adjustRange = function _adjustRange(isTop, elements) {\n\t\tvar removedCount = 0;\n\n\t\tif (!this.isRecycling()) {\n\t\t\treturn removedCount;\n\t\t}\n\n\t\t// trim $elements\n\t\tif (this.options.count <= elements.length) {\n\t\t\tremovedCount += isTop ? elements.splice(0, elements.length - this.options.count).length : elements.splice(this.options.count).length;\n\t\t}\n\n\t\tvar diff = this.layoutManager.items.length + elements.length - this.options.count;\n\t\tvar idx = void 0;\n\n\t\tif (diff <= 0 || (idx = this.layoutManager.getDelimiterIndex(isTop, diff)) < 0) {\n\t\t\treturn removedCount;\n\t\t}\n\n\t\tvar targets = this.layoutManager.adjustItems(isTop, idx);\n\n\t\t// @todo improve performance\n\t\ttargets.forEach(function (v) {\n\t\t\tidx = elements.indexOf(v.el);\n\t\t\tif (idx !== -1) {\n\t\t\t\telements.splice(idx, 1);\n\t\t\t} else {\n\t\t\t\tv.el.parentNode.removeChild(v.el);\n\t\t\t}\n\t\t});\n\t\tremovedCount += targets.length;\n\t\treturn removedCount;\n\t};\n\n\t/**\n * Removes extra space caused by adding card elements.\n * @private\n */\n\n\n\tInfiniteGrid.prototype._fitItems = function _fitItems() {\n\t\tvar y = this.layoutManager.fit();\n\n\t\ty !== 0 && this._resizeContainerHeight();\n\t\treturn y;\n\t};\n\n\tInfiniteGrid.prototype._reset = function _reset() {\n\t\tthis._status = {\n\t\t\tisProcessing: false,\n\t\t\tisRecycling: false,\n\t\t\tprevScrollTop: 0,\n\t\t\ttopElement: null,\n\t\t\tbottomElement: null,\n\t\t\tclientHeight: this._status && this._status.clientHeight\n\t\t};\n\t\tthis._timer = {\n\t\t\tresize: null,\n\t\t\tdoubleCheck: null,\n\t\t\tdoubleCheckCount: _consts.RETRY\n\t\t};\n\t\tthis.layoutManager.resetCols();\n\t\tthis.layoutManager.clear();\n\t};\n\n\t/**\n  * Removes a item element on a grid layout.\n  * @ko 그리드 레이아웃의 카드 엘리먼트를 삭제한다.\n  * @param {HTMLElement} item element to be removed <ko>삭제될 아이템 엘리먼트</ko>\n  * @return {Object}  Removed item element <ko>삭제된 아이템 엘리먼트 정보</ko>\n  */\n\n\n\tInfiniteGrid.prototype.remove = function remove(element) {\n\t\treturn this.layoutManager.removeItem(element);\n\t};\n\n\t/**\n  * Destroys elements, properties, and events used on a grid layout.\n  * @ko 그리드 레이아웃에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n  */\n\n\n\tInfiniteGrid.prototype.destroy = function destroy() {\n\t\tthis.off();\n\t\tthis._detachEvent();\n\t\tthis._reset();\n\t};\n\n\treturn InfiniteGrid;\n}((0, _utils.Mixin)(_component2[\"default\"])[\"with\"](_eventHandler2[\"default\"]));\n\nInfiniteGrid.VERSION = \"2.1.1\";\nexports[\"default\"] = InfiniteGrid;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/InfiniteGrid.js\n// module id = 4\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}\n// module id = 5\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nexports[\"default\"] = function (superclass) {\n\treturn function (_superclass) {\n\t\t_inherits(_class, _superclass);\n\n\t\tfunction _class(el, options) {\n\t\t\t_classCallCheck(this, _class);\n\n\t\t\tvar _this = _possibleConstructorReturn(this, _superclass.call(this));\n\n\t\t\t_this._onScroll = _this._onScroll.bind(_this);\n\t\t\t_this._onResize = _this._onResize.bind(_this);\n\t\t\treturn _this;\n\t\t}\n\n\t\t_class.prototype._attachEvent = function _attachEvent() {\n\t\t\t_utils.utils.addEvent(this.view, \"scroll\", this._onScroll);\n\t\t\t_utils.utils.addEvent(window, \"resize\", this._onResize);\n\t\t};\n\n\t\t_class.prototype._onScroll = function _onScroll() {\n\t\t\tif (this.isProcessing()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar scrollTop = _utils.utils.scrollTop(this.view);\n\t\t\tvar prevScrollTop = this._status.prevScrollTop;\n\n\t\t\tif (_consts.IS_IOS && scrollTop === 0 || prevScrollTop === scrollTop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar ele = void 0;\n\t\t\tvar rect = void 0;\n\n\t\t\tif (prevScrollTop < scrollTop) {\n\t\t\t\tif (_utils.utils.isEmptyObject(this._status.bottomElement)) {\n\t\t\t\t\tthis._status.bottomElement = this.getBottomElement();\n\t\t\t\t\tif (this._status.bottomElement == null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tele = this._status.bottomElement;\n\t\t\t\trect = ele.getBoundingClientRect();\n\t\t\t\tif (rect.top <= this._status.clientHeight + this.options.threshold) {\n\t\t\t\t\t/**\n      * This event is fired when a card element must be added at the bottom of a grid layout because there is no card to be displayed on screen when a user scrolls near bottom.\n      * @ko 카드 엘리먼트가 그리드 레이아웃의 아래에 추가돼야 할 때 발생하는 이벤트. 사용자가 아래로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다\n      * @event eg.InfiniteGrid#append\n      *\n      * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n      * @param {Number} param.scrollTop Current vertical position of the scroll bar<ko>현재 스크롤의 y 좌표 값</ko>\n      * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n      */\n\t\t\t\t\tthis.trigger(\"append\", {\n\t\t\t\t\t\tscrollTop: scrollTop,\n\t\t\t\t\t\tisTrusted: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (_utils.utils.isEmptyObject(this._status.topElement)) {\n\t\t\t\t\tthis._status.topElement = this.getTopElement();\n\t\t\t\t\tif (this._status.topElement == null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tele = this._status.topElement;\n\t\t\t\trect = ele.getBoundingClientRect();\n\t\t\t\tif (rect.bottom >= -this.options.threshold) {\n\t\t\t\t\t/**\n      * This event is fired when a card element must be added at the top of a grid layout because there is no card to be displayed on screen when a user scrolls near top. This event is available only if the isRecycling() method returns true.\n      * @ko 카드가 그리드 레이아웃의 위에 추가돼야 할 때 발생하는 이벤트. 사용자가 위로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다. 이 이벤트는 isRecycling() 메서드의 반환값이 'true'일 때만 발생한다\n      * @event eg.InfiniteGrid#prepend\n      *\n      * @param {Object} param The object of data to be sent to an event<ko>이벤트에 전달되는 데이터 객체</ko>\n      * @param {Number} param.scrollTop Current vertical position of the scroll bar<ko>현재 스크롤의 y 좌표 값</ko>\n      * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n      */\n\t\t\t\t\tvar croppedDistance = this._fitItems();\n\n\t\t\t\t\tif (croppedDistance > 0) {\n\t\t\t\t\t\tscrollTop -= croppedDistance;\n\t\t\t\t\t\t_utils.utils.scrollTo(this.view, 0, scrollTop);\n\t\t\t\t\t}\n\t\t\t\t\tthis.trigger(\"prepend\", {\n\t\t\t\t\t\tscrollTop: scrollTop,\n\t\t\t\t\t\tisTrusted: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._status.prevScrollTop = scrollTop;\n\t\t};\n\n\t\t_class.prototype._onResize = function _onResize() {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (this._timer.resize) {\n\t\t\t\tclearTimeout(this._timer.resize);\n\t\t\t}\n\t\t\tthis._timer.resize = setTimeout(function () {\n\t\t\t\tif (_this2.layoutManager.isNeededResize()) {\n\t\t\t\t\t_this2._resizeViewport();\n\t\t\t\t\t_this2.layout(true, undefined, {\n\t\t\t\t\t\tisAppend: true,\n\t\t\t\t\t\tisTrusted: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_this2._timer.resize = null;\n\t\t\t\t_this2._status.prevScrollTop = -1;\n\t\t\t}, 100);\n\t\t};\n\n\t\t_class.prototype._detachEvent = function _detachEvent() {\n\t\t\t_utils.utils.removeEvent(this.view, \"scroll\", this._onScroll);\n\t\t\t_utils.utils.removeEvent(window, \"resize\", this._onResize);\n\t\t};\n\n\t\treturn _class;\n\t}(superclass);\n};\n\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/eventHandler.js\n// module id = 6\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nvar ImageLoaded = {\n\tcheckImageLoaded: function checkImageLoaded(el) {\n\t\treturn _utils.utils.toArray(el.querySelectorAll(\"img\")).filter(function (v) {\n\t\t\tif (v.nodeType && [1, 9, 11].indexOf(v.nodeType) !== -1) {\n\t\t\t\treturn !v.complete;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t},\n\twaitImageLoaded: function waitImageLoaded(needCheck, callback) {\n\t\tvar checkCount = needCheck.length;\n\t\tvar checkImage = function checkImage() {\n\t\t\tcheckCount--;\n\t\t\tcheckCount <= 0 && callback && callback();\n\t\t};\n\t\tvar onCheck = function onCheck(e) {\n\t\t\t_utils.utils.removeEvent(e.target || e.srcElement, \"load\", onCheck);\n\t\t\t_utils.utils.removeEvent(e.target || e.srcElement, \"error\", onCheck);\n\t\t\tcheckImage();\n\t\t};\n\n\t\t// workaround for IE\n\t\t_consts.IS_IE && needCheck.forEach(function (v) {\n\t\t\treturn v.setAttribute(\"src\", v.getAttribute(\"src\"));\n\t\t});\n\t\tneedCheck.forEach(function (v) {\n\t\t\tif (v.complete) {\n\t\t\t\tcheckImage();\n\t\t\t} else {\n\t\t\t\t_utils.utils.addEvent(v, \"load\", onCheck);\n\t\t\t\t_utils.utils.addEvent(v, \"error\", onCheck);\n\t\t\t}\n\t\t});\n\t}\n};\n\nexports[\"default\"] = ImageLoaded;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ImageLoaded.js\n// module id = 7\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _utils = require(\"./utils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LayoutManager = function () {\n\tLayoutManager.itemize = function itemize(elements, groupKey, isAppend) {\n\t\treturn _utils.utils.toArray(elements).map(function (v) {\n\t\t\treturn {\n\t\t\t\tel: v,\n\t\t\t\tposition: {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t},\n\t\t\t\tgroupKey: typeof groupKey === \"undefined\" ? null : groupKey\n\t\t\t};\n\t\t});\n\t};\n\n\tfunction LayoutManager(el, options) {\n\t\t_classCallCheck(this, LayoutManager);\n\n\t\tthis.options = options;\n\t\tthis.size = {\n\t\t\tcolumnWidth: null,\n\t\t\tcontainerWidth: null,\n\t\t\tequalItemSize: null\n\t\t};\n\t\tthis.el = el;\n\t\tthis.el.style.position = \"relative\";\n\t\tthis.clear();\n\t\tthis.prependCols = [];\n\t\tthis.appendCols = [];\n\t}\n\n\tLayoutManager.prototype.appendItems = function appendItems(items) {\n\t\tthis.items = this.items.concat(items);\n\t};\n\n\tLayoutManager.prototype.prependItems = function prependItems(items) {\n\t\t// insert items (when prepending)\n\t\tthis.items = items.concat(this.items);\n\t\tvar y = this.getTopPositonY();\n\n\t\tif (y !== 0) {\n\t\t\tthis.items.forEach(function (v) {\n\t\t\t\tv.position.y -= y;\n\t\t\t});\n\t\t\tthis.syncCols(false); // for prepending\n\t\t\tthis.syncCols(true); // for appending\n\t\t\treturn this.items;\n\t\t}\n\t\treturn items;\n\t};\n\n\tLayoutManager.prototype.removeItem = function removeItem(element) {\n\t\tvar item = null;\n\t\tvar idx = -1;\n\n\t\tfor (var i = 0, len = this.items.length; i < len; i++) {\n\t\t\tif (this.items[i].el === element) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~idx) {\n\t\t\t// remove item information\n\t\t\titem = _extends({}, this.items[idx]);\n\t\t\tthis.items.splice(idx, 1);\n\n\t\t\t// remove item element\n\t\t\titem.el.parentNode.removeChild(item.el);\n\t\t}\n\t\treturn item;\n\t};\n\n\tLayoutManager.prototype.prepareLayout = function prepareLayout(isRelayout, addItems, isAppend) {\n\t\tvar isInit = !this.items.length;\n\n\t\t// insert items (when appending)\n\t\tif (addItems && isAppend) {\n\t\t\tthis.appendItems(addItems);\n\t\t}\n\t\tif (isInit && addItems) {\n\t\t\taddItems.forEach(function (v) {\n\t\t\t\tv.el.style.position = \"absolute\";\n\t\t\t});\n\t\t}\n\t\tif (isInit || isRelayout) {\n\t\t\tthis.resetCols(this.measureColumns());\n\t\t} else if (!addItems) {\n\t\t\tthis.appendCols = [].concat(this.prependCols);\n\t\t}\n\t};\n\n\tLayoutManager.prototype.layoutItems = function layoutItems(isRelayout, addItems, options) {\n\t\tvar _this = this;\n\n\t\tthis.prepareLayout(isRelayout, addItems, options.isAppend);\n\t\tvar items = addItems || this.items;\n\n\t\titems.forEach(function (v) {\n\t\t\tv.position = _this.getItemPosition(isRelayout, v, options.isAppend);\n\t\t});\n\t\tif (addItems && !options.isAppend) {\n\t\t\t// insert items (when prepending)\n\t\t\titems = this.prependItems(addItems.sort(function (p, c) {\n\t\t\t\treturn p.position.y - c.position.y;\n\t\t\t}));\n\t\t}\n\n\t\t// for performance\n\t\tvar style = void 0;\n\n\t\titems.forEach(function (v) {\n\t\t\tif (v.el) {\n\t\t\t\tstyle = v.el.style;\n\t\t\t\tstyle.left = v.position.x + \"px\";\n\t\t\t\tstyle.top = v.position.y + \"px\";\n\t\t\t}\n\t\t});\n\t};\n\n\tLayoutManager.prototype.resetCols = function resetCols(count) {\n\t\tvar arr = [];\n\t\tvar tmpCount = count || this.appendCols.length || 0;\n\n\t\twhile (tmpCount--) {\n\t\t\tarr.push(0);\n\t\t}\n\t\tthis.appendCols = arr.concat();\n\t\tthis.prependCols = arr.concat();\n\t};\n\n\tLayoutManager.prototype.clear = function clear() {\n\t\tthis.items = [];\n\t};\n\n\tLayoutManager.prototype.getItemPosition = function getItemPosition(isRelayout, item, isAppend) {\n\t\tif (!item || !item.el) {\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t};\n\t\t}\n\n\t\tif (isRelayout || !item.size) {\n\t\t\titem.size = this.getItemSize(item.el);\n\t\t}\n\t\tvar cols = isAppend ? this.appendCols : this.prependCols;\n\t\tvar y = Math[isAppend ? \"min\" : \"max\"].apply(Math, cols);\n\t\tvar shortColIndex = void 0;\n\n\t\tif (isAppend) {\n\t\t\tshortColIndex = cols.indexOf(y);\n\t\t} else {\n\t\t\tvar i = cols.length;\n\n\t\t\twhile (i-- >= 0) {\n\t\t\t\tif (cols[i] === y) {\n\t\t\t\t\tshortColIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcols[shortColIndex] = y + (isAppend ? item.size.height : -item.size.height);\n\n\t\treturn {\n\t\t\tx: this.size.columnWidth * shortColIndex,\n\t\t\ty: isAppend ? y : y - item.size.height\n\t\t};\n\t};\n\n\tLayoutManager.prototype.getGroupKeys = function getGroupKeys() {\n\t\treturn this.items.map(function (v) {\n\t\t\treturn v.groupKey;\n\t\t});\n\t};\n\n\tLayoutManager.prototype.syncCols = function syncCols(isBottom) {\n\t\tif (!this.items.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar items = this.getColItems(isBottom);\n\t\tvar col = isBottom ? this.appendCols : this.prependCols;\n\t\tvar len = col.length;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tcol[i] = items[i].position.y + (isBottom ? items[i].size.height : 0);\n\t\t}\n\t};\n\n\tLayoutManager.prototype.getTopPositonY = function getTopPositonY() {\n\t\tvar item = this.getTopItem();\n\n\t\treturn item ? item.position.y : 0;\n\t};\n\n\tLayoutManager.prototype.getTopItem = function getTopItem() {\n\t\tvar item = null;\n\t\tvar min = Infinity;\n\n\t\tthis.getColItems(false).forEach(function (v) {\n\t\t\tif (v && v.position.y < min) {\n\t\t\t\tmin = v.position.y;\n\t\t\t\titem = v;\n\t\t\t}\n\t\t});\n\t\treturn item;\n\t};\n\n\tLayoutManager.prototype.getBottomItem = function getBottomItem() {\n\t\tvar max = -Infinity;\n\t\tvar item = null;\n\t\tvar pos = void 0;\n\n\t\tthis.getColItems(true).forEach(function (v) {\n\t\t\tpos = v ? v.position.y + v.size.height : 0;\n\t\t\tif (pos >= max) {\n\t\t\t\tmax = pos;\n\t\t\t\titem = v;\n\t\t\t}\n\t\t});\n\t\treturn item;\n\t};\n\n\tLayoutManager.prototype.getColIdx = function getColIdx(item) {\n\t\treturn parseInt(item.position.x / parseInt(this.size.columnWidth, 10), 10);\n\t};\n\n\tLayoutManager.prototype.getColItems = function getColItems(isBottom) {\n\t\tvar len = this.appendCols.length;\n\t\tvar colItems = new Array(len);\n\t\tvar item = void 0;\n\t\tvar idx = void 0;\n\t\tvar count = 0;\n\t\tvar i = isBottom ? this.items.length - 1 : 0;\n\n\t\twhile (item = this.items[i]) {\n\t\t\tidx = this.getColIdx(item);\n\t\t\tif (!colItems[idx]) {\n\t\t\t\tcolItems[idx] = item;\n\t\t\t\tif (++count === len) {\n\t\t\t\t\treturn colItems;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += isBottom ? -1 : 1;\n\t\t}\n\t\treturn colItems;\n\t};\n\t// fit size\n\n\n\tLayoutManager.prototype.fit = function fit() {\n\t\t// for caching\n\t\tif (this.options.count <= 0) {\n\t\t\tthis.fit = function () {\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t\treturn false;\n\t\t}\n\n\t\tvar y = this.getTopPositonY();\n\n\t\tif (y !== 0) {\n\t\t\t// need to fit\n\t\t\tthis.items.forEach(function (v) {\n\t\t\t\tv.position.y -= y;\n\t\t\t\tv.el.style.top = v.position.y + \"px\";\n\t\t\t});\n\t\t\tthis.syncCols(false); // for prepending\n\t\t\tthis.syncCols(true); // for appending\n\t\t}\n\t\treturn y;\n\t};\n\n\tLayoutManager.prototype.getLogicalHeight = function getLogicalHeight() {\n\t\treturn Math.max.apply(Math, this.appendCols);\n\t};\n\n\tLayoutManager.prototype.getDelimiterIndex = function getDelimiterIndex(isTop, removeCount) {\n\t\tvar len = this.items.length;\n\n\t\tif (len === removeCount) {\n\t\t\treturn len;\n\t\t}\n\t\tvar i = void 0;\n\t\tvar idx = 0;\n\t\tvar baseIdx = isTop ? removeCount - 1 : len - removeCount;\n\t\tvar targetIdx = baseIdx + (isTop ? 1 : -1);\n\t\tvar groupKey = this.items[baseIdx].groupKey;\n\n\t\tif (groupKey != null && groupKey === this.items[targetIdx].groupKey) {\n\t\t\tif (isTop) {\n\t\t\t\tfor (i = baseIdx; i > 0; i--) {\n\t\t\t\t\tif (groupKey !== this.items[i].groupKey) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx = i === 0 ? -1 : i + 1;\n\t\t\t} else {\n\t\t\t\tfor (i = baseIdx; i < len; i++) {\n\t\t\t\t\tif (groupKey !== this.items[i].groupKey) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx = i === len ? -1 : i;\n\t\t\t}\n\t\t} else {\n\t\t\tidx = isTop ? targetIdx : baseIdx;\n\t\t}\n\t\treturn idx;\n\t};\n\n\tLayoutManager.prototype.adjustItems = function adjustItems(isTop, idx) {\n\t\tvar targets = void 0;\n\n\t\tif (isTop) {\n\t\t\ttargets = this.items.splice(0, idx);\n\t\t\tthis.syncCols(false); // for prepending\n\t\t} else {\n\t\t\ttargets = idx === this.items.length ? this.items.splice(0) : this.items.splice(idx, this.items.length - idx);\n\t\t\tthis.syncCols(true); // for appending;\n\t\t}\n\t\treturn targets;\n\t};\n\n\tLayoutManager.prototype.measureColumns = function measureColumns() {\n\t\tthis.el.style.width = null;\n\t\tthis.size.containerWidth = _utils.utils.innerWidth(this.el);\n\t\tthis.size.columnWidth = this.getColumnWidth() || this.size.containerWidth;\n\t\tvar cols = this.size.containerWidth / this.size.columnWidth;\n\t\tvar excess = this.size.columnWidth - this.size.containerWidth % this.size.columnWidth;\n\n\t\t// if overshoot is less than a pixel, round up, otherwise floor it\n\t\tcols = Math.max(Math[excess && excess <= 1 ? \"round\" : \"floor\"](cols), 1);\n\t\treturn cols || 0;\n\t};\n\n\tLayoutManager.prototype.getItemSize = function getItemSize(el) {\n\t\treturn this.size.equalItemSize || {\n\t\t\twidth: _utils.utils.innerWidth(el),\n\t\t\theight: _utils.utils.innerHeight(el)\n\t\t};\n\t};\n\n\tLayoutManager.prototype.getColumnWidth = function getColumnWidth() {\n\t\tvar width = 0;\n\t\tvar el = this.items[0] && this.items[0].el;\n\n\t\tif (el) {\n\t\t\twidth = _utils.utils.innerWidth(el);\n\t\t\tif (this.options.isEqualSize) {\n\t\t\t\tthis.size.equalItemSize = {\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: _utils.utils.innerHeight(el)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn width;\n\t};\n\n\tLayoutManager.prototype.isNeededResize = function isNeededResize() {\n\t\treturn _utils.utils.innerWidth(this.el) !== this.size.containerWidth;\n\t};\n\n\tLayoutManager.prototype.getStatus = function getStatus() {\n\t\tvar data = {};\n\n\t\tfor (var p in this) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(this, p) && typeof this[p] !== \"function\" && !(this[p] instanceof Element)) {\n\t\t\t\tdata[p] = this[p];\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tprop: data,\n\t\t\titems: this.items.map(function (v) {\n\t\t\t\tvar clone = _extends({}, v);\n\n\t\t\t\tdelete clone.el;\n\t\t\t\treturn clone;\n\t\t\t})\n\t\t};\n\t};\n\n\tLayoutManager.prototype.setStatus = function setStatus(status) {\n\t\tif (!status || !status.prop || !status.items) {\n\t\t\treturn this;\n\t\t}\n\t\t_extends(this, status.prop);\n\t\tthis.items = _utils.utils.toArray(this.el.children).map(function (v, i) {\n\t\t\tstatus.items[i].el = v;\n\t\t\treturn status.items[i];\n\t\t});\n\t\treturn this;\n\t};\n\n\treturn LayoutManager;\n}();\n\nexports[\"default\"] = LayoutManager;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/LayoutManager.js\n// module id = 8\n// module chunks = 0 1"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACvmBA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}