{"version":3,"sources":["bokeh-gl.min.js","tree/models/glyphs/webgl/base.js","tree/models/glyphs/webgl/gloo2.js","tree/models/glyphs/webgl/index.js","tree/models/glyphs/webgl/line.js","tree/models/glyphs/webgl/main.js","tree/models/glyphs/webgl/markers.js"],"names":["root","factory","this","Bokeh","modules","aliases","entry","register_plugin","Error","423","require","module","exports","Object","defineProperty","value","color_1","BaseGLGlyph","gl","glyph","nvertices","size_changed","data_changed","visuals_changed","init","prototype","set_data_changed","n","set_visuals_changed","render","ctx","indices","mainglyph","dx","dy","sx","sy","trans","wx","wy","_a","renderer","map_to_screen","Math","min","max","abs","_b","_c","pixel_ratio","width","glcanvas","height","draw","GLYPH","VERT","FRAG","line_width","sqrt","fill_array_with_float","val","a","i","k","ref","Float32Array","fill_array_with_vec","m","j","l","ref1","visual_prop_is_singular","visual","propname","spec","attach_float","prog","vbo","att_name","name","doit","used","set_attribute","cache","set_size","set_data","attach_color","prefix","alphaname","alphas","colorname","colors","rgba","color2rgba","results","push","424","Buffer","GlooObject","IndexBuffer","Program","Texture2D","Texture3DLike","VertexBuffer","__version__","check_error","console","_pyfunc_add","b","Array","isArray","concat","_pyfunc_all","x","length","_pyfunc_truthy","_pyfunc_contains","_pyfunc_equals","constructor","String","indexOf","e","equals","iseq","akeys","keys","bkeys","sort","_pyfunc_instantiate","ob","args","window","global","undefined","nobind","bind","__init__","apply","_pyfunc_mult","_pymeth_repeat","call","t","res","v","byteLength","getOwnPropertyNames","_pymeth_append","append","arguments","_pymeth_get","key","d","get","_pymeth_keys","_pymeth_lstrip","chars","lstrip","slice","_pymeth_remove","remove","splice","count","repeat","result","pattern","valueOf","_pymeth_startswith","startswith","when","err","err_3","errors","msg","stub1_seq","stub2_itr","getError","NO_ERROR","_base_class","_class_name","_gl","handle","_create","err_2","create","UTYPEMAP","float","vec2","vec3","vec4","int","ivec2","ivec3","ivec4","bool","bvec2","bvec3","bvec4","mat2","mat3","mat4","sampler1D","sampler2D","sampler3D","ATYPEMAP","ATYPEINFO","createProgram","locations","_unset_variables","_validated","_samplers","_attributes","_known_invalid","deleteProgram","activate","useProgram","deactivate","set_shaders","vert","frag","code","err_4","frag_handle","status","stub3_","tmp","type_","vert_handle","_linked","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","_get_active_attributes_and_uniforms","detachShader","deleteShader","attributes","ca","container","cu","getActive","getLocation","info","regex","stub4_","stub5_seq","stub6_itr","uniforms","RegExp","ACTIVE_UNIFORMS","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","getActiveUniform","getUniformLocation","match","size","type","iter0","i0","set_texture","unit","log","_target","uniform1i","set_uniform","a_type","funcname","name_","floor","stride","offset","gtype","is_vbo","stub7_","FALSE","_pre_draw","attr_handle","stub10_","stub11_seq","stub8_","stub9_seq","tex_handle","tex_target","vbo_handle","hasOwnProperty","activeTexture","TEXTURE0","bindTexture","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","disableVertexAttribArray","_validate","validateProgram","VALIDATE_STATUS","mode","selection","first","stub12_","_buffer_size","UNSIGNED_SHORT","drawElements","drawArrays","_usage","createBuffer","deleteBuffer","nbytes","bufferData","data","bufferSubData","_types","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","createTexture","_shape_format","deleteTexture","_get_alignment","alignment","alignments","stub13_seq","stub14_itr","set_wrapping","wrap_s","wrap_t","texParameterf","TEXTURE_WRAP_S","TEXTURE_WRAP_T","set_interpolation","mag","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","shape","format","stub15_","texImage2D","UNSIGNED_BYTE","u_shape","_","stub16_","stub17_","y","pixelStorei","UNPACK_ALIGNMENT","texSubImage2D","GLSL_SAMPLE_NEAREST","GLSL_SAMPLE_LINEAR","_get_tile_info","max_size","ncols","nrows","getParameter","MAX_TEXTURE_SIZE","ceil","sim_shape","stub18_","u_tiles","Type","col","elements_per_tile","row","stub19_","stub20_","tile","z","zeros","425","tslib_1","__exportStar","426","DashAtlas","gloo2_1","base_1","_atlas","_index","_width","_height","tex","REPEAT","NEAREST","RGBA","get_atlas_data","findex_period","period","join","make_pattern","len","C","Z","c","dash_end","dash_start","dash_type","index","p","q","r","ref2","val_at_index","LineGLGlyph","_super","__extends","_scale_aspect","index_buffer","vbo_position","vbo_tangents","vbo_segment","vbo_angles","vbo_texcoord","dash_atlas","mainGlyph","baked_offset","chunk","chunks","chunksize","mainGlGlyph","scale_length","these_indices","uint16_index","glglyph","isFinite","_baked_offset","_set_data","_set_visuals","_update_scale","cumsum","I_triangles","TRIANGLES","_bake","V_position","V_tangents","V_angles","V_texcoord","cap","color","dash_index","dash_pattern","dash_period","visuals","line","line_color","line_alpha","CAPS","line_cap","JOINS","line_join","line_dash","line_dash_offset","A","I","T","V_angles2","V_position2","V_tangents2","V_texcoord2","Vp","Vt","_x","_y","i1","ni","o","ref3","ref4","ref5","ref6","ref7","s","u","w","Float64Array","tangents","atan2","N","V_segment","V_segment2","pow","miter","round","bevel","","none",".",")","(","triangle in","<","triangle out",">","square","[","]","=","butt","|","FRAG_","427","428","MarkerGLGlyph","logging_1","replace","MARKERCODE","last_trans","vbo_x","vbo_y","vbo_s","vbo_a","vbo_linewidth","vbo_fg_color","vbo_bg_color","ua","_radius","sradius","POINTS","navigator","userAgent","logger","warn","xx","yy","_angle","_size","fill","CircleGLGlyph","SquareGLGlyph","AnnulusGLGlyph","DiamondGLGlyph","TriangleGLGlyph","InvertedTriangleGLGlyph","CrossGLGlyph","CircleCrossGLGlyph","SquareCrossGLGlyph","DiamondCrossGLGlyph","XGLGlyph","CircleXGLGlyph","SquareXGLGlyph","AsteriskGLGlyph","models/glyphs/webgl/base","models/glyphs/webgl/gloo2","models/glyphs/webgl/index","models/glyphs/webgl/line","models/glyphs/webgl/main","models/glyphs/webgl/markers"],"mappings":"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","file":"bokeh-gl.min.js","sourcesContent":["(function(root, factory) {\n//  if(typeof exports === 'object' && typeof module === 'object')\n//    factory(require(\"Bokeh\"));\n//  else if(typeof define === 'function' && define.amd)\n//    define([\"Bokeh\"], factory);\n//  else if(typeof exports === 'object')\n//    factory(require(\"Bokeh\"));\n//  else\n    factory(root[\"Bokeh\"]);\n})(this, function(Bokeh) {\n  var define;\n  return (function(modules, aliases, entry) {\n    if (Bokeh != null) {\n      return Bokeh.register_plugin(modules, aliases, entry);\n    } else {\n      throw new Error(\"Cannot find Bokeh. You have to load it prior to loading plugins.\");\n    }\n  })\n({\n423: /* models/glyphs/webgl/base */ function(require, module, exports) {\n'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// This module implements the Base GL Glyph and some utilities\nvar color_1 = require(26    /* core/util/color */);\nvar BaseGLGlyph = function () {\n    function BaseGLGlyph(gl, glyph) {\n        this.gl = gl;\n        this.glyph = glyph;\n        this.nvertices = 0;\n        this.size_changed = false;\n        this.data_changed = false;\n        this.visuals_changed = false;\n        this.init();\n    }\n    BaseGLGlyph.prototype.set_data_changed = function (n) {\n        if (n !== this.nvertices) {\n            this.nvertices = n;\n            this.size_changed = true;\n        }\n        return this.data_changed = true;\n    };\n    BaseGLGlyph.prototype.set_visuals_changed = function () {\n        return this.visuals_changed = true;\n    };\n    BaseGLGlyph.prototype.render = function (ctx, indices, mainglyph) {\n        var dx, dy, sx, sy, trans, wx, wy;\n        // Get transform\n        wx = wy = 1;\n        // Weights to scale our vectors\n        _a = this.glyph.renderer.map_to_screen([\n            0 * wx,\n            1 * wx,\n            2 * wx\n        ], [\n            0 * wy,\n            1 * wy,\n            2 * wy\n        ]), dx = _a[0], dy = _a[1];\n        // Try again, but with weighs so we're looking at ~100 in screen coordinates\n        wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1000000000000);\n        wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1000000000000);\n        _b = this.glyph.renderer.map_to_screen([\n            0 * wx,\n            1 * wx,\n            2 * wx\n        ], [\n            0 * wy,\n            1 * wy,\n            2 * wy\n        ]), dx = _b[0], dy = _b[1];\n        // Test how linear it is\n        if (Math.abs(dx[1] - dx[0] - (dx[2] - dx[1])) > 0.000001 || Math.abs(dy[1] - dy[0] - (dy[2] - dy[1])) > 0.000001) {\n            return false;\n        }\n        _c = [\n            (dx[1] - dx[0]) / wx,\n            (dy[1] - dy[0]) / wy\n        ], sx = _c[0], sy = _c[1];\n        trans = {\n            pixel_ratio: ctx.pixel_ratio,\n            width: ctx.glcanvas.width,\n            height: ctx.glcanvas.height,\n            dx: dx[0] / sx,\n            dy: dy[0] / sy,\n            sx: sx,\n            sy: sy\n        };\n        this.draw(indices, mainglyph, trans);\n        return true;\n        // success\n        var _a, _b, _c;\n    };\n    return BaseGLGlyph;\n}();\nexports.BaseGLGlyph = BaseGLGlyph;\n;\nBaseGLGlyph.prototype.GLYPH = '';\n// name of the glyph that this gl-glyph applies to\nBaseGLGlyph.prototype.VERT = '';\nBaseGLGlyph.prototype.FRAG = '';\nexports.line_width = function (width) {\n    // Increase small values to make it more similar to canvas\n    if (width < 2) {\n        width = Math.sqrt(width * 2);\n    }\n    return width;\n};\nexports.fill_array_with_float = function (n, val) {\n    var a, i, k, ref;\n    a = new Float32Array(n);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        a[i] = val;\n    }\n    return a;\n};\nexports.fill_array_with_vec = function (n, m, val) {\n    var a, i, j, k, l, ref, ref1;\n    a = new Float32Array(n * m);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n            a[i * m + j] = val[j];\n        }\n    }\n    return a;\n};\nexports.visual_prop_is_singular = function (visual, propname) {\n    // This touches the internals of the visual, so we limit use in this function\n    // See renderer.coffee:cache_select() for similar code\n    return visual[propname].spec.value !== void 0;\n};\nexports.attach_float = function (prog, vbo, att_name, n, visual, name) {\n    var a;\n    // Attach a float attribute to the program. Use singleton value if we can,\n    // otherwise use VBO to apply array.\n    if (!visual.doit) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', [0]);\n    } else if (exports.visual_prop_is_singular(visual, name)) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', visual[name].value());\n    } else {\n        vbo.used = true;\n        a = new Float32Array(visual.cache[name + '_array']);\n        vbo.set_size(n * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'float', vbo);\n    }\n};\nexports.attach_color = function (prog, vbo, att_name, n, visual, prefix) {\n    var a, alphaname, alphas, colorname, colors, i, j, k, l, m, ref, ref1, rgba;\n    // Attach the color attribute to the program. If there's just one color,\n    // then use this single color for all vertices (no VBO). Otherwise we\n    // create an array and upload that to the VBO, which we attahce to the prog.\n    m = 4;\n    colorname = prefix + '_color';\n    alphaname = prefix + '_alpha';\n    if (!visual.doit) {\n        // Don't draw (draw transparent)\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'vec4', [\n            0,\n            0,\n            0,\n            0\n        ]);\n    } else if (exports.visual_prop_is_singular(visual, colorname) && exports.visual_prop_is_singular(visual, alphaname)) {\n        // Nice and simple; both color and alpha are singular\n        vbo.used = false;\n        rgba = color_1.color2rgba(visual[colorname].value(), visual[alphaname].value());\n        return prog.set_attribute(att_name, 'vec4', rgba);\n    } else {\n        // Use vbo; we need an array for both the color and the alpha\n        vbo.used = true;\n        // Get array of colors\n        if (exports.visual_prop_is_singular(visual, colorname)) {\n            colors = function () {\n                var k, ref, results;\n                results = [];\n                for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                    results.push(visual[colorname].value());\n                }\n                return results;\n            }();\n        } else {\n            colors = visual.cache[colorname + '_array'];\n        }\n        // Get array of alphas\n        if (exports.visual_prop_is_singular(visual, alphaname)) {\n            alphas = exports.fill_array_with_float(n, visual[alphaname].value());\n        } else {\n            alphas = visual.cache[alphaname + '_array'];\n        }\n        // Create array of rgbs\n        a = new Float32Array(n * m);\n        for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            rgba = color_1.color2rgba(colors[i], alphas[i]);\n            for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                a[i * m + j] = rgba[j];\n            }\n        }\n        // Attach vbo\n        vbo.set_size(n * m * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'vec4', vbo);\n    }\n};    \n},\n424: /* models/glyphs/webgl/gloo2 */ function(require, module, exports) {\n'use strict';\n/* Do not edit, autogenerated by flexx.pyscript */\nvar _pyfunc_add = function (a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.concat(b);\n    }\n    return a + b;\n};\nvar _pyfunc_all = function (x) {\n    for (var i = 0; i < x.length; i++) {\n        if (!_pyfunc_truthy(x[i])) {\n            return false;\n        }\n    }\n    return true;\n};\nvar _pyfunc_contains = function contains(a, b) {\n    if (b == null) {\n    } else if (Array.isArray(b)) {\n        for (var i = 0; i < b.length; i++) {\n            if (_pyfunc_equals(a, b[i]))\n                return true;\n        }\n        return false;\n    } else if (b.constructor === Object) {\n        for (var k in b) {\n            if (a == k)\n                return true;\n        }\n        return false;\n    } else if (b.constructor == String) {\n        return b.indexOf(a) >= 0;\n    }\n    var e = Error('Not a container: ' + b);\n    e.name = 'TypeError';\n    throw e;\n};\nvar _pyfunc_equals = function equals(a, b) {\n    if (a == null || b == null) {\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        var i = 0, iseq = a.length == b.length;\n        while (iseq && i < a.length) {\n            iseq = equals(a[i], b[i]);\n            i += 1;\n        }\n        return iseq;\n    } else if (a.constructor === Object && b.constructor === Object) {\n        var akeys = Object.keys(a), bkeys = Object.keys(b);\n        akeys.sort();\n        bkeys.sort();\n        var i = 0, k, iseq = equals(akeys, bkeys);\n        while (iseq && i < akeys.length) {\n            k = akeys[i];\n            iseq = equals(a[k], b[k]);\n            i += 1;\n        }\n        return iseq;\n    }\n    return a == b;\n};\nvar _pyfunc_instantiate = function (ob, args) {\n    if (typeof ob === 'undefined' || typeof window !== 'undefined' && window === ob || typeof global !== 'undefined' && global === ob) {\n        throw 'Class constructor is called as a function.';\n    }\n    for (var name in ob) {\n        if (Object[name] === undefined && typeof ob[name] === 'function' && !ob[name].nobind) {\n            ob[name] = ob[name].bind(ob);\n        }\n    }\n    if (ob.__init__) {\n        ob.__init__.apply(ob, args);\n    }\n};\nvar _pyfunc_mult = function (a, b) {\n    if ((typeof a === 'number') + (typeof b === 'number') === 1) {\n        if (a.constructor === String)\n            return _pymeth_repeat.call(a, b);\n        if (b.constructor === String)\n            return _pymeth_repeat.call(b, a);\n        if (Array.isArray(b)) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n        if (Array.isArray(a)) {\n            var res = [];\n            for (var i = 0; i < b; i++)\n                res = res.concat(a);\n            return res;\n        }\n    }\n    return a * b;\n};\nvar _pyfunc_range = function (start, end, step) {\n    var i, res = [];\n    var val = start;\n    var n = (end - start) / step;\n    for (i = 0; i < n; i++) {\n        res.push(val);\n        val += step;\n    }\n    return res;\n};\nvar _pyfunc_truthy = function (v) {\n    if (v === null || typeof v !== 'object') {\n        return v;\n    } else if (v.length !== undefined) {\n        return v.length ? v : false;\n    } else if (v.byteLength !== undefined) {\n        return v.byteLength ? v : false;\n    } else if (v.constructor !== Object) {\n        return true;\n    } else {\n        return Object.getOwnPropertyNames(v).length ? v : false;\n    }\n};\nvar _pymeth_append = function (x) {\n    if (!Array.isArray(this))\n        return this.append.apply(this, arguments);\n    this.push(x);\n};\nvar _pymeth_get = function (key, d) {\n    if (this.constructor !== Object)\n        return this.get.apply(this, arguments);\n    if (this[key] !== undefined) {\n        return this[key];\n    } else if (d !== undefined) {\n        return d;\n    } else {\n        return null;\n    }\n};\nvar _pymeth_keys = function () {\n    if (typeof this['keys'] === 'function')\n        return this.keys.apply(this, arguments);\n    return Object.keys(this);\n};\nvar _pymeth_lstrip = function (chars) {\n    if (this.constructor !== String)\n        return this.lstrip.apply(this, arguments);\n    chars = chars === undefined ? ' \\t\\r\\n' : chars;\n    for (var i = 0; i < this.length; i++) {\n        if (chars.indexOf(this[i]) < 0)\n            return this.slice(i);\n    }\n    return '';\n};\nvar _pymeth_remove = function (x) {\n    if (!Array.isArray(this))\n        return this.remove.apply(this, arguments);\n    for (var i = 0; i < this.length; i++) {\n        if (_pyfunc_equals(this[i], x)) {\n            this.splice(i, 1);\n            return;\n        }\n    }\n    var e = Error(x);\n    e.name = 'ValueError';\n    throw e;\n};\nvar _pymeth_repeat = function (count) {\n    if (this.repeat)\n        return this.repeat(count);\n    if (count < 1)\n        return '';\n    var result = '', pattern = this.valueOf();\n    while (count > 1) {\n        if (count & 1)\n            result += pattern;\n        count >>= 1, pattern += pattern;\n    }\n    return result + pattern;\n};\nvar _pymeth_startswith = function (x) {\n    if (this.constructor !== String)\n        return this.startswith.apply(this, arguments);\n    return this.indexOf(x) == 0;\n};\nvar Buffer, GlooObject, IndexBuffer, Program, Texture2D, Texture3DLike, VertexBuffer, __version__, check_error, console;\n// PyScript module for gloo2.js - lightweight object oriented GL.\n{\n    console = window.console;\n}\n__version__ = '0.3';\ncheck_error = function (gl, when) {\n    var e, err, err_3, errors, msg, stub1_seq, stub2_itr;\n    when = when === undefined ? 'periodic check' : when;\n    // Check this from time to time to detect GL errors.\n    //\n    //     Parameters\n    //     ----------\n    //     when : str\n    //         Shown in the exception to help the developer determine when\n    //         this check was done.\n    errors = [];\n    while (true) {\n        err = gl.getError();\n        if (_pyfunc_equals(err, gl.NO_ERROR) || _pyfunc_truthy(errors) && _pyfunc_equals(err, errors[errors.length - 1])) {\n            break;\n        }\n        _pymeth_append.call(errors, err);\n    }\n    if (errors.length) {\n        msg = '';\n        stub1_seq = errors;\n        if (typeof stub1_seq === 'object' && !Array.isArray(stub1_seq)) {\n            stub1_seq = Object.keys(stub1_seq);\n        }\n        for (stub2_itr = 0; stub2_itr < stub1_seq.length; stub2_itr += 1) {\n            e = stub1_seq[stub2_itr];\n            msg = _pyfunc_add(msg, e);\n        }\n        err_3 = new Error('RuntimeError:' + ('OpenGL got errors (' + when + '): ' + msg + ''));\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    return null;\n};\nGlooObject = function () {\n    // Abstract base class for all Gloo classes.\n    _pyfunc_instantiate(this, arguments);\n};\nGlooObject.prototype._base_class = Object;\nGlooObject.prototype._class_name = 'GlooObject';\nGlooObject.prototype.__init__ = function (gl) {\n    // Init by passing the webgl context object.\n    this._gl = gl;\n    this.handle = null;\n    this._create();\n    if (!(this.handle !== null)) {\n        throw 'AssertionError: ' + 'this.handle !== null';\n    }\n    return null;\n};\nGlooObject.prototype._create = function () {\n    var err_2;\n    err_2 = new Error('NotImplementedError:' + '');\n    err_2.name = 'NotImplementedError';\n    throw err_2;\n    return null;\n};\nProgram = function () {\n    // The program is the central component to connect gloo objects and shaders.\n    _pyfunc_instantiate(this, arguments);\n};\nProgram.prototype = Object.create(GlooObject.prototype);\nProgram.prototype._base_class = GlooObject.prototype;\nProgram.prototype._class_name = 'Program';\nProgram.prototype.UTYPEMAP = {\n    'float': 'uniform1fv',\n    'vec2': 'uniform2fv',\n    'vec3': 'uniform3fv',\n    'vec4': 'uniform4fv',\n    'int': 'uniform1iv',\n    'ivec2': 'uniform2iv',\n    'ivec3': 'uniform3iv',\n    'ivec4': 'uniform4iv',\n    'bool': 'uniform1iv',\n    'bvec2': 'uniform2iv',\n    'bvec3': 'uniform3iv',\n    'bvec4': 'uniform4iv',\n    'mat2': 'uniformMatrix2fv',\n    'mat3': 'uniformMatrix3fv',\n    'mat4': 'uniformMatrix4fv',\n    'sampler1D': 'uniform1i',\n    'sampler2D': 'uniform1i',\n    'sampler3D': 'uniform1i'\n};\nProgram.prototype.ATYPEMAP = {\n    'float': 'vertexAttrib1f',\n    'vec2': 'vertexAttrib2f',\n    'vec3': 'vertexAttrib3f',\n    'vec4': 'vertexAttrib4f'\n};\nProgram.prototype.ATYPEINFO = {\n    'float': [\n        1,\n        5126\n    ],\n    'vec2': [\n        2,\n        5126\n    ],\n    'vec3': [\n        3,\n        5126\n    ],\n    'vec4': [\n        4,\n        5126\n    ]\n};\nProgram.prototype._create = function () {\n    this.handle = this._gl.createProgram();\n    this.locations = {};\n    this._unset_variables = [];\n    this._validated = false;\n    this._samplers = {};\n    this._attributes = {};\n    this._known_invalid = [];\n    return null;\n};\nProgram.prototype.delete = function () {\n    // Delete the program.\n    this._gl.deleteProgram(this.handle);\n    return null;\n};\nProgram.prototype.activate = function () {\n    // Activate the program.\n    this._gl.useProgram(this.handle);\n    return null;\n};\nProgram.prototype.deactivate = function () {\n    // Disable the program.\n    this._gl.useProgram(0);\n    return null;\n};\nProgram.prototype.set_shaders = function (vert, frag) {\n    var code, err_3, err_4, errors, frag_handle, gl, handle, i, status, stub3_, tmp, type_, vert_handle;\n    // Set GLSL code for the vertex and fragment shader.\n    //\n    // This function takes care of setting the shading code and\n    // compiling+linking it into a working program object that is ready\n    // to use.\n    //\n    // Parameters\n    // ----------\n    // vert : str\n    //     GLSL code for the vertex shader.\n    // frag : str\n    //     GLSL code for the fragment shader.\n    gl = this._gl;\n    this._linked = false;\n    vert_handle = gl.createShader(gl.VERTEX_SHADER);\n    frag_handle = gl.createShader(gl.FRAGMENT_SHADER);\n    tmp = [\n        [\n            vert,\n            vert_handle,\n            'vertex'\n        ],\n        [\n            frag,\n            frag_handle,\n            'fragment'\n        ]\n    ];\n    for (i = 0; i < 2; i += 1) {\n        stub3_ = tmp[i];\n        code = stub3_[0];\n        handle = stub3_[1];\n        type_ = stub3_[2];\n        gl.shaderSource(handle, code);\n        gl.compileShader(handle);\n        status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);\n        if (!_pyfunc_truthy(status)) {\n            errors = gl.getShaderInfoLog(handle);\n            err_4 = new Error('RuntimeError:' + _pyfunc_add('errors in ' + type_ + ' shader:\\n', errors));\n            err_4.name = 'RuntimeError';\n            throw err_4;\n        }\n    }\n    gl.attachShader(this.handle, vert_handle);\n    gl.attachShader(this.handle, frag_handle);\n    gl.linkProgram(this.handle);\n    if (!_pyfunc_truthy(gl.getProgramParameter(this.handle, gl.LINK_STATUS))) {\n        err_3 = new Error('RuntimeError:' + ('Program link error:\\n' + gl.getProgramInfoLog(this.handle)));\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    this._unset_variables = this._get_active_attributes_and_uniforms();\n    gl.detachShader(this.handle, vert_handle);\n    gl.detachShader(this.handle, frag_handle);\n    gl.deleteShader(vert_handle);\n    gl.deleteShader(frag_handle);\n    this._known_invalid = [];\n    this._linked = true;\n    return null;\n};\nProgram.prototype._get_active_attributes_and_uniforms = function () {\n    var attributes, ca, container, count, cu, getActive, getLocation, gl, i, info, j, m, name, regex, stub4_, stub5_seq, stub6_itr, uniforms, x;\n    // Retrieve active attributes and uniforms to be able to check that\n    // all uniforms/attributes are set by the user.\n    gl = this._gl;\n    this.locations = {};\n    regex = new window.RegExp('(\\\\w+)\\\\s*(\\\\[(\\\\d+)\\\\])\\\\s*');\n    cu = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\n    ca = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\n    attributes = [];\n    uniforms = [];\n    stub5_seq = [\n        [\n            attributes,\n            ca,\n            gl.getActiveAttrib,\n            gl.getAttribLocation\n        ],\n        [\n            uniforms,\n            cu,\n            gl.getActiveUniform,\n            gl.getUniformLocation\n        ]\n    ];\n    if (typeof stub5_seq === 'object' && !Array.isArray(stub5_seq)) {\n        stub5_seq = Object.keys(stub5_seq);\n    }\n    for (stub6_itr = 0; stub6_itr < stub5_seq.length; stub6_itr += 1) {\n        x = stub5_seq[stub6_itr];\n        stub4_ = x;\n        container = stub4_[0];\n        count = stub4_[1];\n        getActive = stub4_[2];\n        getLocation = stub4_[3];\n        for (i = 0; i < count; i += 1) {\n            info = getActive.call(gl, this.handle, i);\n            name = info.name;\n            m = name.match(regex);\n            if (_pyfunc_truthy(m)) {\n                name = m[1];\n                for (j = 0; j < info.size; j += 1) {\n                    _pymeth_append.call(container, [\n                        '' + name + '[' + j + ']',\n                        info.type\n                    ]);\n                }\n            } else {\n                _pymeth_append.call(container, [\n                    name,\n                    info.type\n                ]);\n            }\n            this.locations[name] = getLocation.call(gl, this.handle, name);\n        }\n    }\n    return _pyfunc_add(function list_comprehenson() {\n        var res = [];\n        var v, iter0, i0;\n        iter0 = attributes;\n        if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n            iter0 = Object.keys(iter0);\n        }\n        for (i0 = 0; i0 < iter0.length; i0++) {\n            v = iter0[i0];\n            {\n                res.push(v[0]);\n            }\n        }\n        return res;\n    }.apply(this), function list_comprehenson() {\n        var res = [];\n        var v, iter0, i0;\n        iter0 = uniforms;\n        if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n            iter0 = Object.keys(iter0);\n        }\n        for (i0 = 0; i0 < iter0.length; i0++) {\n            v = iter0[i0];\n            {\n                res.push(v[0]);\n            }\n        }\n        return res;\n    }.apply(this));\n};\nProgram.prototype.set_texture = function (name, value) {\n    var err_3, handle, unit;\n    // Set a texture sampler.\n    //\n    // A texture is a 2 dimensional grid of colors/intensities that\n    // can be applied to a face (or used for other means by providing\n    // a regular grid of data).\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the texture is known in the GLSL code.\n    // value : Texture2D\n    //     The gloo Texture2D object to bind.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    handle = _pymeth_get.call(this.locations, name, -1);\n    if (_pyfunc_truthy(handle < 0)) {\n        if (!_pyfunc_contains(name, this._known_invalid)) {\n            _pymeth_append.call(this._known_invalid, name);\n            console.log('Variable ' + name + ' is not an active texture');\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    this.activate();\n    if (true) {\n        unit = _pymeth_keys.call(this._samplers).length;\n        if (_pyfunc_contains(name, this._samplers)) {\n            unit = this._samplers[name][this._samplers[name].length - 1];\n        }\n        this._samplers[name] = [\n            value._target,\n            value.handle,\n            unit\n        ];\n        this._gl.uniform1i(handle, unit);\n    }\n    return null;\n};\nProgram.prototype.set_uniform = function (name, type_, value) {\n    var a_type, count, err_3, funcname, handle, j, name_;\n    // Set a uniform value.\n    //\n    // A uniform is a value that is global to both the vertex and\n    // fragment shader.\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the uniform is known in the GLSL code.\n    // type_ : str\n    //     The type of the uniform, e.g. 'float', 'vec2', etc.\n    // value : list of scalars\n    //     The value for the uniform. Should be a list even for type float.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    handle = _pymeth_get.call(this.locations, name, -1);\n    if (_pyfunc_truthy(handle < 0)) {\n        if (!_pyfunc_contains(name, this._known_invalid)) {\n            _pymeth_append.call(this._known_invalid, name);\n            console.log('Variable ' + name + ' is not an active uniform');\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    count = 1;\n    if (!_pymeth_startswith.call(type_, 'mat')) {\n        a_type = _pymeth_get.call({\n            'int': 'float',\n            'bool': 'float'\n        }, type_, _pymeth_lstrip.call(type_, 'ib'));\n        count = Math.floor(value.length / this.ATYPEINFO[a_type][0]);\n    }\n    if (_pyfunc_truthy(count > 1)) {\n        for (j = 0; j < count; j += 1) {\n            if (_pyfunc_contains('' + name + '[' + j + ']', this._unset_variables)) {\n                name_ = '' + name + '[' + j + ']';\n                if (_pyfunc_contains(name_, this._unset_variables)) {\n                    _pymeth_remove.call(this._unset_variables, name_);\n                }\n            }\n        }\n    }\n    funcname = this.UTYPEMAP[type_];\n    this.activate();\n    if (_pymeth_startswith.call(type_, 'mat')) {\n        this._gl[funcname](handle, false, value);\n    } else {\n        this._gl[funcname](handle, value);\n    }\n    return null;\n};\nProgram.prototype.set_attribute = function (name, type_, value, stride, offset) {\n    var args, err_3, funcname, gtype, handle, is_vbo, size, stub7_;\n    stride = stride === undefined ? 0 : stride;\n    offset = offset === undefined ? 0 : offset;\n    // Set an attribute value.\n    //\n    // An attribute represents per-vertex data and can only be used\n    // in the vertex shader.\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the attribute is known in the GLSL code.\n    // type_ : str\n    //     The type of the attribute, e.g. 'float', 'vec2', etc.\n    // value : VertexBuffer, array\n    //     If value is a VertexBuffer, it is used (with stride and offset)\n    //     for the vertex data. If value is an array, its used to set\n    //     the value of all vertices (similar to a uniform).\n    // stide : int, default 0\n    //     The stride to \"sample\" the vertex data inside the buffer. Unless\n    //     multiple vertex data are packed into a single buffer, this should\n    //     be zero.\n    // offset : int, default 0\n    //     The offset to \"sample\" the vertex data inside the buffer. Unless\n    //     multiple vertex data are packed into a single buffer, or only\n    //     a part of the data must be used, this should probably be zero.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot set attribute when program has no code');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    is_vbo = value instanceof VertexBuffer;\n    handle = _pymeth_get.call(this.locations, name, -1);\n    if (_pyfunc_truthy(handle < 0)) {\n        if (!_pyfunc_contains(name, this._known_invalid)) {\n            _pymeth_append.call(this._known_invalid, name);\n            if (_pyfunc_truthy(is_vbo) && _pyfunc_truthy(offset > 0)) {\n            } else {\n                console.log('Variable ' + name + ' is not an active attribute');\n            }\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    this.activate();\n    if (!_pyfunc_truthy(is_vbo)) {\n        funcname = this.ATYPEMAP[type_];\n        this._attributes[name] = [\n            0,\n            handle,\n            funcname,\n            value\n        ];\n    } else {\n        stub7_ = this.ATYPEINFO[type_];\n        size = stub7_[0];\n        gtype = stub7_[1];\n        funcname = 'vertexAttribPointer';\n        args = [\n            size,\n            gtype,\n            this._gl.FALSE,\n            stride,\n            offset\n        ];\n        this._attributes[name] = [\n            value.handle,\n            handle,\n            funcname,\n            args\n        ];\n    }\n    return null;\n};\nProgram.prototype._pre_draw = function () {\n    var args, attr_handle, funcname, stub10_, stub11_seq, stub8_, stub9_seq, tex_handle, tex_target, unit, vbo_handle, x;\n    // Prepare for drawing.\n    this.activate();\n    stub9_seq = this._samplers;\n    for (x in stub9_seq) {\n        if (!stub9_seq.hasOwnProperty(x)) {\n            continue;\n        }\n        x = stub9_seq[x];\n        stub8_ = x;\n        tex_target = stub8_[0];\n        tex_handle = stub8_[1];\n        unit = stub8_[2];\n        this._gl.activeTexture(_pyfunc_add(this._gl.TEXTURE0, unit));\n        this._gl.bindTexture(tex_target, tex_handle);\n    }\n    stub11_seq = this._attributes;\n    for (x in stub11_seq) {\n        if (!stub11_seq.hasOwnProperty(x)) {\n            continue;\n        }\n        x = stub11_seq[x];\n        stub10_ = x;\n        vbo_handle = stub10_[0];\n        attr_handle = stub10_[1];\n        funcname = stub10_[2];\n        args = stub10_[3];\n        if (_pyfunc_truthy(vbo_handle)) {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, vbo_handle);\n            this._gl.enableVertexAttribArray(attr_handle);\n            this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n        } else {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);\n            this._gl.disableVertexAttribArray(attr_handle);\n            this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n        }\n    }\n    if (!_pyfunc_truthy(this._validated)) {\n        this._validated = true;\n        this._validate();\n    }\n    return null;\n};\nProgram.prototype._validate = function () {\n    var err_3;\n    if (this._unset_variables.length) {\n        console.log('Program has unset variables: ' + this._unset_variables + '');\n    }\n    this._gl.validateProgram(this.handle);\n    if (!_pyfunc_truthy(this._gl.getProgramParameter(this.handle, this._gl.VALIDATE_STATUS))) {\n        console.log(this._gl.getProgramInfoLog(this.handle));\n        err_3 = new Error('RuntimeError:' + 'Program validation error');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    return null;\n};\nProgram.prototype.draw = function (mode, selection) {\n    var count, err_3, first, gtype, stub12_;\n    // Draw the current visualization defined by the program.\n    //\n    // Parameters\n    // ----------\n    // mode : GL enum\n    //     Can be POINTS, LINES, LINE_LOOP, LINE_STRIP, LINE_FAN, TRIANGLES\n    // selection : 2-element tuple or IndexBuffer\n    //     The selection to draw, specified either as (first, count) or an\n    //     IndexBuffer object.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot draw program if code has not been set');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    check_error(this._gl, 'before draw');\n    if (_pyfunc_truthy(selection instanceof IndexBuffer)) {\n        this._pre_draw();\n        selection.activate();\n        count = selection._buffer_size / 2;\n        gtype = this._gl.UNSIGNED_SHORT;\n        this._gl.drawElements(mode, count, gtype, 0);\n        selection.deactivate();\n    } else {\n        stub12_ = selection;\n        first = stub12_[0];\n        count = stub12_[1];\n        if (_pyfunc_truthy(count)) {\n            this._pre_draw();\n            this._gl.drawArrays(mode, first, count);\n        }\n    }\n    check_error(this._gl, 'after draw');\n    return null;\n};\nBuffer = function () {\n    // Base buffer class for vertex data or index data.\n    _pyfunc_instantiate(this, arguments);\n};\nBuffer.prototype = Object.create(GlooObject.prototype);\nBuffer.prototype._base_class = GlooObject.prototype;\nBuffer.prototype._class_name = 'Buffer';\nBuffer.prototype._target = null;\nBuffer.prototype._usage = 35048;\nBuffer.prototype._create = function () {\n    this.handle = this._gl.createBuffer();\n    this._buffer_size = 0;\n    return null;\n};\nBuffer.prototype.delete = function () {\n    // Delete the buffer.\n    this._gl.deleteBuffer(this.handle);\n    return null;\n};\nBuffer.prototype.activate = function () {\n    // Activete the buffer.\n    this._gl.bindBuffer(this._target, this.handle);\n    return null;\n};\nBuffer.prototype.deactivate = function () {\n    // Disable the buffer.\n    this._gl.bindBuffer(this._target, null);\n    return null;\n};\nBuffer.prototype.set_size = function (nbytes) {\n    // Set the size of the buffer in bytes.\n    //\n    // Parameters\n    // ----------\n    // nbytes : int\n    //     The number of bytes that the buffer needs to hold.\n    if (!_pyfunc_equals(nbytes, this._buffer_size)) {\n        this.activate();\n        this._gl.bufferData(this._target, nbytes, this._usage);\n        this._buffer_size = nbytes;\n    }\n    return null;\n};\nBuffer.prototype.set_data = function (offset, data) {\n    // Set the buffer data.\n    //\n    // Parameters\n    // ----------\n    // offset : int\n    //     The offset in bytes for the new data.\n    // data : typed array\n    //     The data to upload.\n    this.activate();\n    this._gl.bufferSubData(this._target, offset, data);\n    return null;\n};\nVertexBuffer = function () {\n    // A buffer for vertex data.\n    _pyfunc_instantiate(this, arguments);\n};\nVertexBuffer.prototype = Object.create(Buffer.prototype);\nVertexBuffer.prototype._base_class = Buffer.prototype;\nVertexBuffer.prototype._class_name = 'VertexBuffer';\nVertexBuffer.prototype._target = 34962;\nIndexBuffer = function () {\n    // A buffer for index data.\n    _pyfunc_instantiate(this, arguments);\n};\nIndexBuffer.prototype = Object.create(Buffer.prototype);\nIndexBuffer.prototype._base_class = Buffer.prototype;\nIndexBuffer.prototype._class_name = 'IndexBuffer';\nIndexBuffer.prototype._target = 34963;\nTexture2D = function () {\n    // A 2 dimensional regular grid.\n    _pyfunc_instantiate(this, arguments);\n};\nTexture2D.prototype = Object.create(GlooObject.prototype);\nTexture2D.prototype._base_class = GlooObject.prototype;\nTexture2D.prototype._class_name = 'Texture2D';\nTexture2D.prototype._target = 3553;\nTexture2D.prototype._types = {\n    'Int8Array': 5120,\n    'Uint8Array': 5121,\n    'Int16Array': 5122,\n    'Uint16Array': 5123,\n    'Int32Array': 5124,\n    'Uint32Array': 5125,\n    'Float32Array': 5126\n};\nTexture2D.prototype._create = function () {\n    this.handle = this._gl.createTexture();\n    this._shape_format = null;\n    return null;\n};\nTexture2D.prototype.delete = function () {\n    // Delete the texture.\n    this._gl.deleteTexture(this.handle);\n    return null;\n};\nTexture2D.prototype.activate = function () {\n    // Activate the texture.\n    this._gl.bindTexture(this._target, this.handle);\n    return null;\n};\nTexture2D.prototype.deactivate = function () {\n    // Disable the texture.\n    this._gl.bindTexture(this._target, 0);\n    return null;\n};\nTexture2D.prototype._get_alignment = function (width) {\n    var alignment, alignments, stub13_seq, stub14_itr;\n    // Determines a textures byte alignment. If the width isn't a\n    //         power of 2 we need to adjust the byte alignment of the image.\n    //         The image height is unimportant.\n    //\n    //         www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n    alignments = [\n        4,\n        8,\n        2,\n        1\n    ];\n    stub13_seq = alignments;\n    if (typeof stub13_seq === 'object' && !Array.isArray(stub13_seq)) {\n        stub13_seq = Object.keys(stub13_seq);\n    }\n    for (stub14_itr = 0; stub14_itr < stub13_seq.length; stub14_itr += 1) {\n        alignment = stub13_seq[stub14_itr];\n        if (_pyfunc_equals(width % alignment, 0)) {\n            return alignment;\n        }\n    }\n    return null;\n};\nTexture2D.prototype.set_wrapping = function (wrap_s, wrap_t) {\n    // Set the texture wrapping mode.\n    //\n    // Parameters\n    // ----------\n    // wrap_s : GL enum\n    //     The mode to wrap the x dimension. Valid values are REPEAT\n    //     CLAMP_TO_EDGE MIRRORED_REPEAT\n    // wrap_t : GL enum\n    //     The mode to wrap the y dimension. Same options as for wrap_s.\n    this.activate();\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_S, wrap_s);\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_T, wrap_t);\n    return null;\n};\nTexture2D.prototype.set_interpolation = function (min, mag) {\n    // Set the texture interpolation mode\n    //\n    // Parameters\n    // ----------\n    // min : GL enum\n    //     The interpolation mode when minifying (i.e. zoomed out). Valid\n    //     values are LINEAR and NEAREST.\n    // max : GL enum\n    //     The interpolation mode when magnifying (i.e. zoomed in). Valid\n    //     values are LINEAR, NEAREST, NEAREST_MIPMAP_NEAREST,\n    //     LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR.\n    this.activate();\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_MIN_FILTER, min);\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_MAG_FILTER, mag);\n    return null;\n};\nTexture2D.prototype.set_size = function (shape, format) {\n    var height, stub15_, width;\n    // Set the size of the 2D texture.\n    //\n    // Parameters\n    // ----------\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // format : GL enum\n    //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n    //     RGB, and RGBA.\n    stub15_ = shape;\n    height = stub15_[0];\n    width = stub15_[1];\n    if (!_pyfunc_equals([\n            height,\n            width,\n            format\n        ], this._shape_format)) {\n        this._shape_format = [\n            height,\n            width,\n            format\n        ];\n        this.activate();\n        this._gl.texImage2D(this._target, 0, format, width, height, 0, format, this._gl.UNSIGNED_BYTE, null);\n    }\n    this.u_shape = [\n        height,\n        width\n    ];\n    return null;\n};\nTexture2D.prototype.set_data = function (offset, shape, data) {\n    var _, alignment, err_3, format, gtype, height, stub16_, stub17_, width, x, y;\n    // Set the 2D texture data.\n    //\n    // Parameters\n    // ----------\n    // offset : tuple of ints\n    //     Offset in pixels for each dimension.\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // data : typed array\n    //     The actual pixel data. Can be of any type, but on the GPU the\n    //     dat is stored in 8 bit precision.\n    if (_pyfunc_equals(shape.length, 2)) {\n        shape = [\n            shape[0],\n            shape[1],\n            1\n        ];\n    }\n    this.activate();\n    format = this._shape_format[2];\n    stub16_ = shape;\n    height = stub16_[0];\n    width = stub16_[1];\n    _ = stub16_[2];\n    stub17_ = offset;\n    y = stub17_[0];\n    x = stub17_[1];\n    gtype = _pymeth_get.call(this._types, data.constructor.name, null);\n    if (gtype === null) {\n        err_3 = new Error('ValueError:' + ('Type ' + data.constructor.name + ' not allowed for texture'));\n        err_3.name = 'ValueError';\n        throw err_3;\n    }\n    alignment = this._get_alignment(_pyfunc_mult(shape[shape.length - 2], shape[shape.length - 1]));\n    if (!_pyfunc_equals(alignment, 4)) {\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, alignment);\n    }\n    this._gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);\n    if (!_pyfunc_equals(alignment, 4)) {\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 4);\n    }\n    return null;\n};\nTexture3DLike = function () {\n    // A 2D texture with support to simulate a 3D texture.\n    //\n    // To use this class, use set_size() and set_data() as if it was a 3D\n    // texture. Add the GLSL_SAMPLE_NEAREST or GLSL_SAMPLE_LINEAR to the\n    // shader to add the sample3D() function that can be used instead of\n    // texture2D(). This function needs ``shape`` and ``tiles`` arguments\n    // which can be set via uniforms, using the ``u_shape`` and ``u_tiles``\n    // attributes of this object.\n    _pyfunc_instantiate(this, arguments);\n};\nTexture3DLike.prototype = Object.create(Texture2D.prototype);\nTexture3DLike.prototype._base_class = Texture2D.prototype;\nTexture3DLike.prototype._class_name = 'Texture3DLike';\nTexture3DLike.prototype.GLSL_SAMPLE_NEAREST = '\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don\\'t let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float zindex = floor(texcoord.z * shape.z);\\n\\n            // Do a lookup in the 2D texture\\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\\n\\n            return texture2D(tex, vec2(u,v));\\n        }\\n    ';\nTexture3DLike.prototype.GLSL_SAMPLE_LINEAR = '\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don\\'t let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float z = texcoord.z * shape.z;\\n            float zindex1 = floor(z);\\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\\n\\n            float zindex2 = zindex1 + 1.0;\\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\\n\\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\\n\\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\\n        }\\n    ';\nTexture3DLike.prototype._get_tile_info = function (shape) {\n    var err_3, max_size, ncols, nrows;\n    max_size = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);\n    nrows = Math.floor(max_size / shape[1]);\n    nrows = Math.min(nrows, shape[0]);\n    ncols = window.Math.ceil(shape[0] / nrows);\n    if (_pyfunc_truthy(_pyfunc_mult(ncols, shape[2]) > max_size)) {\n        err_3 = new Error('RuntimeError:' + ('Cannot fit 3D data with shape ' + shape + ' onto simulated 2D texture.'));\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    return [\n        nrows,\n        ncols\n    ];\n};\nTexture3DLike.prototype.set_size = function (shape, format) {\n    var ncols, nrows, sim_shape, stub18_;\n    // Set the size of the 3D texture.\n    //\n    // Parameters\n    // ----------\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // format : GL enum\n    //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n    //     RGB, and RGBA.\n    stub18_ = this._get_tile_info(shape);\n    nrows = stub18_[0];\n    ncols = stub18_[1];\n    sim_shape = [\n        _pyfunc_mult(shape[1], nrows),\n        _pyfunc_mult(shape[2], ncols)\n    ];\n    Texture3DLike.prototype._base_class.set_size.call(this, sim_shape, format);\n    this.u_shape = [\n        shape[0],\n        shape[1],\n        shape[2]\n    ];\n    this.u_tiles = [\n        ncols,\n        nrows\n    ];\n    return null;\n};\nTexture3DLike.prototype.set_data = function (offset, shape, data) {\n    var Type, col, elements_per_tile, err_3, ncols, nrows, row, sim_shape, stub19_, stub20_, tile, z, zeros;\n    // Set the 3D texture data.\n    //\n    // Parameters\n    // ----------\n    // offset : tuple of ints\n    //     Offset in pixels for each dimension.\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // data : typed array\n    //     The actual pixel data. Can be of any type, but on the GPU the\n    //     dat is stored in 8 bit precision.\n    if (_pyfunc_equals(shape.length, 3)) {\n        shape = [\n            shape[0],\n            shape[1],\n            shape[2],\n            1\n        ];\n    }\n    if (!_pyfunc_all(function list_comprehenson() {\n            var res = [];\n            var i, iter0, i0;\n            iter0 = offset;\n            if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n                iter0 = Object.keys(iter0);\n            }\n            for (i0 = 0; i0 < iter0.length; i0++) {\n                i = iter0[i0];\n                {\n                    res.push(_pyfunc_equals(i, 0));\n                }\n            }\n            return res;\n        }.apply(this))) {\n        err_3 = new Error('ValueError:' + 'Texture3DLike does not support nonzero offset (for now)');\n        err_3.name = 'ValueError';\n        throw err_3;\n    }\n    stub19_ = this._get_tile_info(shape);\n    nrows = stub19_[0];\n    ncols = stub19_[1];\n    sim_shape = [\n        _pyfunc_mult(shape[1], nrows),\n        _pyfunc_mult(shape[2], ncols),\n        shape[3]\n    ];\n    if (_pyfunc_equals(ncols, 1)) {\n        Texture3DLike.prototype._base_class.set_data.call(this, [\n            0,\n            0\n        ], sim_shape, data);\n    } else {\n        Type = data.constructor;\n        zeros = new Type(_pyfunc_mult(_pyfunc_mult(sim_shape[0], sim_shape[1]), sim_shape[2]));\n        Texture3DLike.prototype._base_class.set_data.call(this, [\n            0,\n            0\n        ], sim_shape, zeros);\n        for (z = 0; z < shape[0]; z += 1) {\n            stub20_ = [\n                Math.floor(z / ncols),\n                z % ncols\n            ];\n            row = stub20_[0];\n            col = stub20_[1];\n            elements_per_tile = Math.floor(data.length / shape[0]);\n            tile = data.slice(_pyfunc_mult(z, elements_per_tile), _pyfunc_mult(z + 1, elements_per_tile));\n            Texture3DLike.prototype._base_class.set_data.call(this, [\n                _pyfunc_mult(row, shape[1]),\n                _pyfunc_mult(col, shape[2])\n            ], shape.slice(1), tile);\n        }\n    }\n    return null;\n};\nmodule.exports = {\n    'Buffer': Buffer,\n    'GlooObject': GlooObject,\n    'IndexBuffer': IndexBuffer,\n    'Program': Program,\n    'Texture2D': Texture2D,\n    'Texture3DLike': Texture3DLike,\n    'VertexBuffer': VertexBuffer,\n    'check_error': check_error,\n    'console': console\n};    \n},\n425: /* models/glyphs/webgl/index */ function(require, module, exports) {\n'use strict';\n/*\nCopyright notice: many of the awesome techniques and  GLSL code contained in\nthis module are based on work by Nicolas Rougier as part of the Glumpy and\nVispy projects. The algorithms are published in\nhttp://jcgt.org/published/0003/04/01/ and http://jcgt.org/published/0002/02/08/\n\nThis module contains all gl-specific code to add gl support for the glyphs.\nBy implementing it separetely, the GL functionality can be spun off in a\nseparate library.\nOther locations where we work with GL, or prepare for GL-rendering:\n- canvas.coffee\n- plot.coffee\n- glyph.coffee\n- glyph_renderer.coffee\n*/\nObject.defineProperty(exports, '__esModule', { value: true });\nvar tslib_1 = require(364    /* tslib */);\ntslib_1.__exportStar(require(426    /* ./line */), exports);\ntslib_1.__exportStar(require(428    /* ./markers */), exports);    \n},\n426: /* models/glyphs/webgl/line */ function(require, module, exports) {\n'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar tslib_1 = require(364    /* tslib */);\nvar DashAtlas;\nvar gloo2_1 = require(424    /* ./gloo2 */);\nvar base_1 = require(423    /* ./base */);\nvar color_1 = require(26    /* core/util/color */);\nDashAtlas = function () {\n    function DashAtlas(gl) {\n        this._atlas = {};\n        this._index = 0;\n        this._width = 256;\n        this._height = 256;\n        // Init texture\n        this.tex = new gloo2_1.Texture2D(gl);\n        this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n        this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n        this.tex.set_size([\n            this._height,\n            this._width\n        ], gl.RGBA);\n        this.tex.set_data([\n            0,\n            0\n        ], [\n            this._height,\n            this._width\n        ], new Uint8Array(this._height * this._width * 4));\n        // Init with solid line (index 0 is reserved for this)\n        this.get_atlas_data([1]);\n    }\n    DashAtlas.prototype.get_atlas_data = function (pattern) {\n        var data, findex_period, key, period, x;\n        key = pattern.join('-');\n        findex_period = this._atlas[key];\n        if (findex_period === void 0) {\n            _a = this.make_pattern(pattern), data = _a[0], period = _a[1];\n            this.tex.set_data([\n                this._index,\n                0\n            ], [\n                1,\n                this._width\n            ], new Uint8Array(function () {\n                var l, len, results;\n                results = [];\n                for (l = 0, len = data.length; l < len; l++) {\n                    x = data[l];\n                    results.push(x + 10);\n                }\n                return results;\n            }()));\n            this._atlas[key] = [\n                this._index / this._height,\n                period\n            ];\n            this._index += 1;\n        }\n        return this._atlas[key];\n        var _a;\n    };\n    DashAtlas.prototype.make_pattern = function (pattern) {\n        var C, Z, a, b, c, dash_end, dash_start, dash_type, i, index, j, l, len, n, p, period, q, r, ref, ref1, ref2, v, val, val_at_index, x;\n        // A pattern is defined as on/off sequence of segments\n        // It must be a multiple of 2\n        if (pattern.length > 1 && pattern.length % 2) {\n            pattern = pattern.concat(pattern);\n        }\n        // Period is sum of elements\n        period = 0;\n        for (l = 0, len = pattern.length; l < len; l++) {\n            v = pattern[l];\n            period += v;\n        }\n        // Find all start and end of on-segment only\n        C = [];\n        c = 0;\n        for (i = p = 0, ref = pattern.length + 2; p < ref; i = p += 2) {\n            a = Math.max(0.0001, pattern[i % pattern.length]);\n            b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n            C.push.apply(C, [\n                c,\n                c + a    // == extend\n            ]);\n            c += a + b;\n        }\n        // Build pattern\n        n = this._width;\n        Z = new Float32Array(n * 4);\n        for (i = q = 0, ref1 = n; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n            x = period * i / (n - 1);\n            // get index at min - index = np.argmin(abs(C-(x)))\n            index = 0;\n            val_at_index = 10000000000000000;\n            for (j = r = 0, ref2 = C.length; 0 <= ref2 ? r < ref2 : r > ref2; j = 0 <= ref2 ? ++r : --r) {\n                val = Math.abs(C[j] - x);\n                if (val < val_at_index) {\n                    index = j;\n                    val_at_index = val;\n                }\n            }\n            if (index % 2 === 0) {\n                dash_type = x <= C[index] ? +1 : 0;\n                dash_start = C[index];\n                dash_end = C[index + 1];\n            } else {\n                dash_type = x > C[index] ? -1 : 0;\n                dash_start = C[index - 1];\n                dash_end = C[index];\n            }\n            Z[i * 4 + 0] = C[index];\n            Z[i * 4 + 1] = dash_type;\n            Z[i * 4 + 2] = dash_start;\n            Z[i * 4 + 3] = dash_end;\n        }\n        return [\n            Z,\n            period\n        ];\n    };\n    return DashAtlas;\n}();\nvar LineGLGlyph = function (_super) {\n    tslib_1.__extends(LineGLGlyph, _super);\n    function LineGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LineGLGlyph.prototype.init = function () {\n        var gl;\n        gl = this.gl;\n        this._scale_aspect = 0;\n        // keep track, so we know when we need to update segment data\n        // The program\n        this.prog = new gloo2_1.Program(gl);\n        this.prog.set_shaders(this.VERT, this.FRAG);\n        this.index_buffer = new gloo2_1.IndexBuffer(gl);\n        // Buffers\n        this.vbo_position = new gloo2_1.VertexBuffer(gl);\n        this.vbo_tangents = new gloo2_1.VertexBuffer(gl);\n        this.vbo_segment = new gloo2_1.VertexBuffer(gl);\n        this.vbo_angles = new gloo2_1.VertexBuffer(gl);\n        this.vbo_texcoord = new gloo2_1.VertexBuffer(gl);\n        // Dash atlas\n        return this.dash_atlas = new DashAtlas(gl);\n    };\n    LineGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n        var baked_offset, chunk, chunks, chunksize, i, l, mainGlGlyph, nvertices, offset, p, q, ref, ref1, ref2, results, scale_length, sx, sy, these_indices, uint16_index;\n        mainGlGlyph = mainGlyph.glglyph;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return;\n            }\n            mainGlGlyph._baked_offset = [\n                trans.dx,\n                trans.dy\n            ];\n            mainGlGlyph._set_data();\n            mainGlGlyph.data_changed = false;\n        }\n        if (this.visuals_changed) {\n            this._set_visuals();\n            this.visuals_changed = false;\n        }\n        // Decompose x-y scale into scalar scale and aspect-vector.\n        sx = trans.sx;\n        sy = trans.sy;\n        scale_length = Math.sqrt(sx * sx + sy * sy);\n        sx /= scale_length;\n        sy /= scale_length;\n        // Do we need to re-calculate segment data and cumsum?\n        if (Math.abs(this._scale_aspect - sy / sx) > Math.abs(0.001 * this._scale_aspect)) {\n            mainGlGlyph._update_scale(sx, sy);\n            this._scale_aspect = sy / sx;\n        }\n        // Select buffers from main glyph\n        // (which may be this glyph but maybe not if this is a (non)selection glyph)\n        this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n        this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n        this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n        this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n        this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\n        this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n        this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\n        // Handle transformation to device coordinates\n        baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [\n            trans.width,\n            trans.height\n        ]);\n        this.prog.set_uniform('u_offset', 'vec2', [\n            trans.dx - baked_offset[0],\n            trans.dy - baked_offset[1]\n        ]);\n        this.prog.set_uniform('u_scale_aspect', 'vec2', [\n            sx,\n            sy\n        ]);\n        this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n        this.I_triangles = mainGlGlyph.I_triangles;\n        if (this.I_triangles.length < 65535) {\n            // Data is small enough to draw in one pass\n            this.index_buffer.set_size(this.I_triangles.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n            return this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n        } else {\n            // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n            // First collect indices in chunks\n            // @prog.draw(@gl.LINE_STRIP, @index_buffer)  # Use this to draw the line skeleton\n            indices = this.I_triangles;\n            nvertices = this.I_triangles.length;\n            chunksize = 64008;\n            // 65536 max. 64008 is divisible by 12\n            chunks = [];\n            for (i = l = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n                chunks.push([]);\n            }\n            for (i = p = 0, ref1 = indices.length; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n                uint16_index = indices[i] % chunksize;\n                chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            results = [];\n            // Then draw each chunk\n            for (chunk = q = 0, ref2 = chunks.length; 0 <= ref2 ? q < ref2 : q > ref2; chunk = 0 <= ref2 ? ++q : --q) {\n                these_indices = new Uint16Array(chunks[chunk]);\n                offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n                this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n                this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n                this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n                this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\n                // The actual drawing\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                results.push(this.prog.draw(this.gl.TRIANGLES, this.index_buffer));\n            }\n            return results;\n        }\n    };\n    LineGLGlyph.prototype._set_data = function () {\n        this._bake();\n        this.vbo_position.set_size(this.V_position.length * 4);\n        this.vbo_position.set_data(0, this.V_position);\n        this.vbo_tangents.set_size(this.V_tangents.length * 4);\n        this.vbo_tangents.set_data(0, this.V_tangents);\n        this.vbo_angles.set_size(this.V_angles.length * 4);\n        this.vbo_angles.set_data(0, this.V_angles);\n        this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n        return this.vbo_texcoord.set_data(0, this.V_texcoord);\n    };\n    LineGLGlyph.prototype._set_visuals = function () {\n        var cap, color, dash_index, dash_pattern, dash_period, join;\n        color = color_1.color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n        cap = this.CAPS[this.glyph.visuals.line.line_cap.value()];\n        join = this.JOINS[this.glyph.visuals.line.line_join.value()];\n        this.prog.set_uniform('u_color', 'vec4', color);\n        this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n        this.prog.set_uniform('u_antialias', 'float', [0.9]);\n        // Smaller aa-region to obtain crisper images\n        this.prog.set_uniform('u_linecaps', 'vec2', [\n            cap,\n            cap\n        ]);\n        this.prog.set_uniform('u_linejoin', 'float', [join]);\n        this.prog.set_uniform('u_miter_limit', 'float', [10]);\n        // 10 should be a good value\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n        dash_pattern = this.glyph.visuals.line.line_dash.value();\n        dash_index = 0;\n        dash_period = 1;\n        if (dash_pattern.length) {\n            _a = this.dash_atlas.get_atlas_data(dash_pattern), dash_index = _a[0], dash_period = _a[1];\n        }\n        this.prog.set_uniform('u_dash_index', 'float', [dash_index]);\n        // 0 means solid line\n        this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n        this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n        this.prog.set_uniform('u_dash_caps', 'vec2', [\n            cap,\n            cap\n        ]);\n        return this.prog.set_uniform('u_closed', 'float', [0]);\n        // We dont do closed lines\n        var _a;\n    };\n    LineGLGlyph.prototype._bake = function () {\n        var A, I, T, V_angles, V_angles2, V_position, V_position2, V_tangents, V_tangents2, V_texcoord, V_texcoord2, Vp, Vt, _x, _y, i, i1, j, k, l, m, n, ni, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, results, s, t, u, w, y, z;\n        // This is what you get if you port 50 lines of numpy code to JS.\n        // V_segment is handled in another method, because it depends on the aspect\n        // ratio of the scale (The original paper/code assumed isotropic scaling).\n        // Buffer dtype from the Python implementation:\n        // self.vtype = np.dtype( [('a_position', 'f4', 2),\n        //                         ('a_segment',  'f4', 2),\n        //                         ('a_angles',   'f4', 2),\n        //                         ('a_tangents', 'f4', 4),\n        //                         ('a_texcoord', 'f4', 2) ])\n        // Init array of implicit shape nx2\n        n = this.nvertices;\n        _x = new Float64Array(this.glyph._x);\n        _y = new Float64Array(this.glyph._y);\n        // Init vertex data\n        V_position = Vp = new Float32Array(n * 2);\n        //V_segment = new Float32Array(n*2)  # Done later\n        V_angles = new Float32Array(n * 2);\n        V_tangents = Vt = new Float32Array(n * 4);\n        // mind the 4!\n        V_texcoord = new Float32Array(n * 2);\n        // Position\n        for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            V_position[i * 2 + 0] = _x[i] + this._baked_offset[0];\n            V_position[i * 2 + 1] = _y[i] + this._baked_offset[1];\n        }\n        // Tangents & norms (need tangents to calculate segments based on scale)\n        this.tangents = T = new Float32Array(n * 2 - 2);\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            T[i * 2 + 0] = Vp[(i + 1) * 2 + 0] - Vp[i * 2 + 0];\n            T[i * 2 + 1] = Vp[(i + 1) * 2 + 1] - Vp[i * 2 + 1];\n        }\n        for (i = q = 0, ref2 = n - 1; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            // V['a_tangents'][+1:, :2] = T\n            V_tangents[(i + 1) * 4 + 0] = T[i * 2 + 0];\n            V_tangents[(i + 1) * 4 + 1] = T[i * 2 + 1];\n            // V['a_tangents'][:-1, 2:] = T\n            V_tangents[i * 4 + 2] = T[i * 2 + 0];\n            V_tangents[i * 4 + 3] = T[i * 2 + 1];\n        }\n        // V['a_tangents'][0  , :2] = T[0]\n        V_tangents[0 * 4 + 0] = T[0];\n        V_tangents[0 * 4 + 1] = T[1];\n        // V['a_tangents'][ -1, 2:] = T[-1]\n        V_tangents[(n - 1) * 4 + 2] = T[(n - 2) * 2 + 0];\n        V_tangents[(n - 1) * 4 + 3] = T[(n - 2) * 2 + 1];\n        // Angles\n        A = new Float32Array(n);\n        for (i = r = 0, ref3 = n; 0 <= ref3 ? r < ref3 : r > ref3; i = 0 <= ref3 ? ++r : --r) {\n            A[i] = Math.atan2(Vt[i * 4 + 0] * Vt[i * 4 + 3] - Vt[i * 4 + 1] * Vt[i * 4 + 2], Vt[i * 4 + 0] * Vt[i * 4 + 2] + Vt[i * 4 + 1] * Vt[i * 4 + 3]);\n        }\n        for (i = s = 0, ref4 = n - 1; 0 <= ref4 ? s < ref4 : s > ref4; i = 0 <= ref4 ? ++s : --s) {\n            V_angles[i * 2 + 0] = A[i];\n            V_angles[i * 2 + 1] = A[i + 1];\n        }\n        // Step 1: A -- B -- C  =>  A -- B, B' -- C\n        // Repeat our array 4 times\n        m = 4 * n - 4;\n        this.V_position = V_position2 = new Float32Array(m * 2);\n        this.V_angles = V_angles2 = new Float32Array(m * 2);\n        this.V_tangents = V_tangents2 = new Float32Array(m * 4);\n        // mind the 4!\n        this.V_texcoord = V_texcoord2 = new Float32Array(m * 2);\n        o = 2;\n        // all nodes on the line\n        // Arg, we really need an ndarray thing in JS :/\n        for (i = t = 0, ref5 = n; 0 <= ref5 ? t < ref5 : t > ref5; i = 0 <= ref5 ? ++t : --t) {\n            // the four quad vertices\n            for (j = u = 0; u < 4; j = ++u) {\n                // xy\n                for (k = w = 0; w < 2; k = ++w) {\n                    V_position2[(i * 4 + j - o) * 2 + k] = V_position[i * 2 + k];\n                    V_angles2[(i * 4 + j) * 2 + k] = V_angles[i * 2 + k];\n                }\n                for (k = y = 0; y < 4; k = ++y) {\n                    V_tangents2[(i * 4 + j - o) * 4 + k] = V_tangents[i * 4 + k];\n                }\n            }\n        }\n        for (i = z = 0, ref6 = n; 0 <= ref6 ? z <= ref6 : z >= ref6; i = 0 <= ref6 ? ++z : --z) {\n            V_texcoord2[(i * 4 + 0) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 2) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 3) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 0) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 1] = +1;\n            V_texcoord2[(i * 4 + 2) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 3) * 2 + 1] = +1;\n        }\n        // Indices\n        //I = np.resize( np.array([0,1,2,1,2,3], dtype=np.uint32), (n-1)*(2*3))\n        //I += np.repeat( 4*np.arange(n-1), 6)\n        ni = (n - 1) * 6;\n        this.I_triangles = I = new Uint32Array(ni);\n        results = [];\n        // Order of indices is such that drawing as line_strip reveals the line skeleton\n        // Might have implications on culling, if we ever turn that on.\n        // Order in paper was: 0 1 2 1 2 3\n        for (i = i1 = 0, ref7 = n; 0 <= ref7 ? i1 < ref7 : i1 > ref7; i = 0 <= ref7 ? ++i1 : --i1) {\n            I[i * 6 + 0] = 0 + 4 * i;\n            I[i * 6 + 1] = 1 + 4 * i;\n            I[i * 6 + 2] = 3 + 4 * i;\n            I[i * 6 + 3] = 2 + 4 * i;\n            I[i * 6 + 4] = 0 + 4 * i;\n            results.push(I[i * 6 + 5] = 3 + 4 * i);\n        }\n        return results;\n    };\n    LineGLGlyph.prototype._update_scale = function (sx, sy) {\n        var N, T, V_segment, V_segment2, cumsum, i, j, k, l, m, n, p, q, r, ref, ref1, ref2, s;\n        // Update segment data and cumsum so the length along the line has the\n        // scale aspect ratio in it. In the vertex shader we multiply with the\n        // \"isotropic part\" of the scale.\n        n = this.nvertices;\n        m = 4 * n - 4;\n        // Prepare arrays\n        T = this.tangents;\n        N = new Float32Array(n - 1);\n        V_segment = new Float32Array(n * 2);\n        // Elements are initialized with 0\n        this.V_segment = V_segment2 = new Float32Array(m * 2);\n        // Calculate vector lengths - with scale aspect ratio taken into account\n        for (i = l = 0, ref = n - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            N[i] = Math.sqrt(Math.pow(T[i * 2 + 0] * sx, 2) + Math.pow(T[i * 2 + 1] * sy, 2));\n        }\n        // Calculate Segments\n        cumsum = 0;\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            cumsum += N[i];\n            V_segment[(i + 1) * 2 + 0] = cumsum;\n            V_segment[i * 2 + 1] = cumsum;\n        }\n        // Upscale (same loop as in _bake())\n        for (i = q = 0, ref2 = n; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            for (j = r = 0; r < 4; j = ++r) {\n                for (k = s = 0; s < 2; k = ++s) {\n                    V_segment2[(i * 4 + j) * 2 + k] = V_segment[i * 2 + k];\n                }\n            }\n        }\n        // Update\n        this.cumsum = cumsum;\n        // L[-1] in Nico's code\n        this.vbo_segment.set_size(this.V_segment.length * 4);\n        return this.vbo_segment.set_data(0, this.V_segment);\n    };\n    return LineGLGlyph;\n}(base_1.BaseGLGlyph);\nexports.LineGLGlyph = LineGLGlyph;\n;\nLineGLGlyph.prototype.GLYPH = 'line';\nLineGLGlyph.prototype.JOINS = {\n    'miter': 0,\n    'round': 1,\n    'bevel': 2\n};\nLineGLGlyph.prototype.CAPS = {\n    '': 0,\n    'none': 0,\n    '.': 0,\n    'round': 1,\n    ')': 1,\n    '(': 1,\n    'o': 1,\n    'triangle in': 2,\n    '<': 2,\n    'triangle out': 3,\n    '>': 3,\n    'square': 4,\n    '[': 4,\n    ']': 4,\n    '=': 4,\n    'butt': 5,\n    '|': 5\n};\nLineGLGlyph.prototype.VERT = 'precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size, u_offset;\\nuniform vec2 u_scale_aspect;\\nuniform float u_scale_length;\\n\\nuniform vec4 u_color;\\nuniform float u_antialias;\\nuniform float u_length;\\nuniform float u_linewidth;\\nuniform float u_dash_index;\\nuniform float u_closed;\\n\\nattribute vec2 a_position;\\nattribute vec4 a_tangents;\\nattribute vec2 a_segment;\\nattribute vec2 a_angles;\\nattribute vec2 a_texcoord;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\nfloat cross(in vec2 v1, in vec2 v2)\\n{\\n    return v1.x*v2.y - v1.y*v2.x;\\n}\\n\\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\\n{\\n    return cross(v2-v1,v1-v3) / length(v2-v1);\\n}\\n\\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\\n{\\n    float c = cos(alpha);\\n    float s = sin(alpha);\\n    result = vec2( c*v.x - s*v.y,\\n                   s*v.x + c*v.y );\\n}\\n\\nvoid main()\\n{\\n    bool closed = (u_closed > 0.0);\\n\\n    // Attributes and uniforms to varyings\\n    v_color = u_color;\\n    v_linewidth = u_linewidth;\\n    v_segment = a_segment * u_scale_length;\\n    v_length = u_length * u_scale_length;\\n\\n    // Scale to map to pixel coordinates. The original algorithm from the paper\\n    // assumed isotropic scale. We obviously do not have this.\\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\\n\\n    // Correct angles for aspect ratio\\n    vec2 av;\\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\\n    v_angles.x = atan(av.y, av.x);\\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\\n    v_angles.y = atan(av.y, av.x);\\n\\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\\n    // and a modified alpha\\n    v_color.a = min(v_linewidth, v_color.a);\\n    v_linewidth = max(v_linewidth, 1.0);\\n\\n    // If color is fully transparent we just will discard the fragment anyway\\n    if( v_color.a <= 0.0 ) {\\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\\n        return;\\n    }\\n\\n    // This is the actual half width of the line\\n    float w = ceil(u_antialias+v_linewidth)/2.0;\\n\\n    vec2 position = (a_position + u_offset) * abs_scale;\\n\\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\\n    float u = a_texcoord.x;\\n    float v = a_texcoord.y;\\n    vec2 o1 = vec2( +t1.y, -t1.x);\\n    vec2 o2 = vec2( +t2.y, -t2.x);\\n\\n    // This is a join\\n    // ----------------------------------------------------------------\\n    if( t1 != t2 ) {\\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\\n        vec2 t  = normalize(t1+t2);\\n        vec2 o  = vec2( + t.y, - t.x);\\n\\n        if ( u_dash_index > 0.0 )\\n        {\\n            // Broken angle\\n            // ----------------------------------------------------------------\\n            if( (abs(angle) > THETA) ) {\\n                position += v * w * o / cos(angle/2.0);\\n                float s = sign(angle);\\n                if( angle < 0.0 ) {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position -= 2.0 * w * t1 / sin(angle);\\n                            u -= 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position += 2.0 * w * t2 / sin(angle);\\n                            u += 2.0*w / sin(angle);\\n                        }\\n                    }\\n                } else {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position += 2.0 * w * t1 / sin(angle);\\n                            u += 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position -= 2.0 * w * t2 / sin(angle);\\n                            u -= 2.0*w / sin(angle);\\n                        }\\n                    }\\n                }\\n                // Continuous angle\\n                // ------------------------------------------------------------\\n            } else {\\n                position += v * w * o / cos(angle/2.0);\\n                if( u == +1.0 ) u = v_segment.y;\\n                else            u = v_segment.x;\\n            }\\n        }\\n\\n        // Solid line\\n        // --------------------------------------------------------------------\\n        else\\n        {\\n            position.xy += v * w * o / cos(angle/2.0);\\n            if( angle < 0.0 ) {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            } else {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            }\\n        }\\n\\n    // This is a line start or end (t1 == t2)\\n    // ------------------------------------------------------------------------\\n    } else {\\n        position += v * w * o1;\\n        if( u == -1.0 ) {\\n            u = v_segment.x - w;\\n            position -= w * t1;\\n        } else {\\n            u = v_segment.y + w;\\n            position += w * t2;\\n        }\\n    }\\n\\n    // Miter distance\\n    // ------------------------------------------------------------------------\\n    vec2 t;\\n    vec2 curr = a_position * abs_scale;\\n    if( a_texcoord.x < 0.0 ) {\\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, +v_angles.x/2.0, t);\\n        v_miter.x = signed_distance(curr, curr+t, position);\\n\\n        rotate( t2, +v_angles.y/2.0, t);\\n        v_miter.y = signed_distance(next, next+t, position);\\n    } else {\\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, -v_angles.x/2.0,t);\\n        v_miter.x = signed_distance(prev, prev+t, position);\\n\\n        rotate( t2, -v_angles.y/2.0,t);\\n        v_miter.y = signed_distance(curr, curr+t, position);\\n    }\\n\\n    if (!closed && v_segment.x <= 0.0) {\\n        v_miter.x = 1e10;\\n    }\\n    if (!closed && v_segment.y >= v_length)\\n    {\\n        v_miter.y = 1e10;\\n    }\\n\\n    v_texcoord = vec2( u, v*w );\\n\\n    // Calculate position in device coordinates. Note that we\\n    // already scaled with abs scale above.\\n    vec2 normpos = position * sign(u_scale_aspect);\\n    normpos += 0.5;  // make up for Bokeh\\'s offset\\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n}\\n';\nLineGLGlyph.prototype.FRAG_ = '// Fragment shader that can be convenient during debugging to show the line skeleton.\\nprecision mediump float;\\nuniform vec4  u_color;\\nvoid main () {\\n  gl_FragColor = u_color;\\n}';\nLineGLGlyph.prototype.FRAG = 'precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform sampler2D u_dash_atlas;\\n\\nuniform vec2 u_linecaps;\\nuniform float u_miter_limit;\\nuniform float u_linejoin;\\nuniform float u_antialias;\\nuniform float u_dash_phase;\\nuniform float u_dash_period;\\nuniform float u_dash_index;\\nuniform vec2 u_dash_caps;\\nuniform float u_closed;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\n// Compute distance to cap ----------------------------------------------------\\nfloat cap( int type, float dx, float dy, float t, float linewidth )\\n{\\n    float d = 0.0;\\n    dx = abs(dx);\\n    dy = abs(dy);\\n    if      (type == 0)  discard;  // None\\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\\n    else if (type == 4)  d = max(dx,dy);  // Square\\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\\n    return d;\\n}\\n\\n// Compute distance to join -------------------------------------------------\\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\\n           in float linewidth )\\n{\\n    // texcoord.x is distance from start\\n    // texcoord.y is distance from centerline\\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\\n\\n    float dx = texcoord.x;\\n\\n    // Round join\\n    if( type == 1 ) {\\n        if (dx < segment.x) {\\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\\n            //d = length( texcoord - vec2(segment.x,0.0));\\n        } else if (dx > segment.y) {\\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\\n            //d = length( texcoord - vec2(segment.y,0.0));\\n        }\\n    }\\n    // Bevel join\\n    else if ( type == 2 ) {\\n        if (dx < segment.x) {\\n            vec2 x = texcoord - vec2(segment.x,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n\\n        } else if (dx > segment.y) {\\n            vec2 x = texcoord - vec2(segment.y,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n        }\\n        /*  Original code for bevel which does not work for us\\n        if( (dx < segment.x) ||  (dx > segment.y) )\\n            d = max(d, min(abs(x.x),abs(x.y)));\\n        */\\n    }\\n\\n    return d;\\n}\\n\\nvoid main()\\n{\\n    // If color is fully transparent we just discard the fragment\\n    if( v_color.a <= 0.0 ) {\\n        discard;\\n    }\\n\\n    // Test if dash pattern is the solid one (0)\\n    bool solid =  (u_dash_index == 0.0);\\n\\n    // Test if path is closed\\n    bool closed = (u_closed > 0.0);\\n\\n    vec4 color = v_color;\\n    float dx = v_texcoord.x;\\n    float dy = v_texcoord.y;\\n    float t = v_linewidth/2.0-u_antialias;\\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\\n    float d = 0.0;\\n\\n    vec2 linecaps = u_linecaps;\\n    vec2 dash_caps = u_dash_caps;\\n    float line_start = 0.0;\\n    float line_stop = v_length;\\n\\n    // Apply miter limit; fragments too far into the miter are simply discarded\\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\\n          discard;\\n    }\\n\\n    // Solid line --------------------------------------------------------------\\n    if( solid ) {\\n        d = abs(dy);\\n        if( (!closed) && (dx < line_start) ) {\\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\\n        }\\n        else if( (!closed) &&  (dx > line_stop) ) {\\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\\n        }\\n        else {\\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\\n        }\\n\\n    // Dash line --------------------------------------------------------------\\n    } else {\\n        float segment_start = v_segment.x;\\n        float segment_stop  = v_segment.y;\\n        float segment_center= (segment_start+segment_stop)/2.0;\\n        float freq          = u_dash_period*width;\\n        float u = mod( dx + u_dash_phase*width, freq);\\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n        float dash_center= tex.x * width;\\n        float dash_type  = tex.y;\\n        float _start = tex.z * width;\\n        float _stop  = tex.a * width;\\n        float dash_start = dx - u + _start;\\n        float dash_stop  = dx - u + _stop;\\n\\n        // Compute extents of the first dash (the one relative to v_segment.x)\\n        // Note: this could be computed in the vertex shader\\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\\n            float u = mod(segment_start + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_start - u + _start;\\n            dash_stop = segment_start - u + _stop;\\n        }\\n\\n        // Compute extents of the last dash (the one relatives to v_segment.y)\\n        // Note: This could be computed in the vertex shader\\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\\n            float u = mod(segment_stop + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_stop - u + _start;\\n            dash_stop  = segment_stop - u + _stop;\\n        }\\n\\n        // This test if the we are dealing with a discontinuous angle\\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\\n        //if( dx < line_start) discontinuous = false;\\n        //if( dx > line_stop)  discontinuous = false;\\n\\n        float d_join = join( int(u_linejoin), abs(dy),\\n                            v_segment, v_texcoord, v_miter, v_linewidth );\\n\\n        // When path is closed, we do not have room for linecaps, so we make room\\n        // by shortening the total length\\n        if (closed) {\\n             line_start += v_linewidth/2.0;\\n             line_stop  -= v_linewidth/2.0;\\n        }\\n\\n        // We also need to take antialias area into account\\n        //line_start += u_antialias;\\n        //line_stop  -= u_antialias;\\n\\n        // Check is dash stop is before line start\\n        if( dash_stop <= line_start ) {\\n            discard;\\n        }\\n        // Check is dash start is beyond line stop\\n        if( dash_start >= line_stop ) {\\n            discard;\\n        }\\n\\n        // Check if current dash start is beyond segment stop\\n        if( discontinuous ) {\\n            // Dash start is beyond segment, we discard\\n            if( (dash_start > segment_stop) ) {\\n                discard;\\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\\n            }\\n\\n            // Dash stop is before segment, we discard\\n            if( (dash_stop < segment_start) ) {\\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\\n            }\\n\\n            // Special case for round caps (nicer with this)\\n            if( dash_caps.x == 1.0 ) {\\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for round caps  (nicer with this)\\n            if( dash_caps.y == 1.0 ) {\\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\\n                    float a = v_angles.x/2.0;\\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the cap into square to avoid holes\\n                    dash_caps.x = 4.0;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\\n                    float a = v_angles.y/2.0;\\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the caps into square to avoid holes\\n                    dash_caps.y = 4.0;\\n                }\\n            }\\n        }\\n\\n        // Line cap at start\\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\\n        }\\n        // Line cap at stop\\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\\n        }\\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\\n        else if( dash_type < -0.5 ) {\\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash cap right\\n        else if( dash_type > 0.5 ) {\\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash body (plain)\\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\\n            d = abs(dy);\\n        }\\n\\n        // Line join\\n        if( (dx > line_start) && (dx < line_stop)) {\\n            if( (dx <= segment_start) && (dash_start <= segment_start)\\n                && (dash_stop >= segment_start) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.x;\\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\\n                     && (dash_stop >= segment_stop) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.y;\\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( dx < (segment_start - v_linewidth/2.)) {\\n                discard;\\n            }\\n            else if( dx > (segment_stop + v_linewidth/2.)) {\\n                discard;\\n            }\\n        }\\n        else if( dx < (segment_start - v_linewidth/2.)) {\\n            discard;\\n        }\\n        else if( dx > (segment_stop + v_linewidth/2.)) {\\n            discard;\\n        }\\n    }\\n\\n    // Distance to border ------------------------------------------------------\\n    d = d - t;\\n    if( d < 0.0 ) {\\n        gl_FragColor = color;\\n    } else {\\n        d /= u_antialias;\\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\\n    }\\n}';    \n},\n427: /* models/glyphs/webgl/main */ function(require, module, exports) {\n'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nrequire(425    /* ./index */);    \n},\n428: /* models/glyphs/webgl/markers */ function(require, module, exports) {\n'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar tslib_1 = require(364    /* tslib */);\nvar MarkerGLGlyph;\nvar gloo2_1 = require(424    /* ./gloo2 */);\nvar base_1 = require(423    /* ./base */);\nvar logging_1 = require(14    /* core/logging */);\nMarkerGLGlyph = function () {\n    var MarkerGLGlyph = function (_super) {\n        tslib_1.__extends(MarkerGLGlyph, _super);\n        function MarkerGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        MarkerGLGlyph.prototype.init = function () {\n            var frag, gl;\n            gl = this.gl;\n            frag = this.FRAG.replace(/MARKERCODE/, this.MARKERCODE);\n            this.last_trans = {};\n            // Keep track of transform\n            // The program\n            this.prog = new gloo2_1.Program(gl);\n            this.prog.set_shaders(this.VERT, frag);\n            // Real attributes\n            this.vbo_x = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_x', 'float', this.vbo_x);\n            this.vbo_y = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_y', 'float', this.vbo_y);\n            this.vbo_s = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_size', 'float', this.vbo_s);\n            this.vbo_a = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_angle', 'float', this.vbo_a);\n            // VBO's for attributes (they may not be used if value is singleton)\n            this.vbo_linewidth = new gloo2_1.VertexBuffer(gl);\n            this.vbo_fg_color = new gloo2_1.VertexBuffer(gl);\n            this.vbo_bg_color = new gloo2_1.VertexBuffer(gl);\n            return this.index_buffer = new gloo2_1.IndexBuffer(gl);\n        };\n        MarkerGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n            var baked_offset, chunk, chunks, chunksize, i, j, k, l, mainGlGlyph, nvertices, offset, ref, ref1, ref2, results, s, these_indices, ua, uint16_index;\n            // The main glyph has the data, *this* glyph has the visuals.\n            mainGlGlyph = mainGlyph.glglyph;\n            nvertices = mainGlGlyph.nvertices;\n            // Upload data if we must. Only happens for main glyph.\n            if (mainGlGlyph.data_changed) {\n                if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                    return;\n                }\n                mainGlGlyph._baked_offset = [\n                    trans.dx,\n                    trans.dy\n                ];\n                mainGlGlyph._set_data(nvertices);\n                mainGlGlyph.data_changed = false;\n            } else if (this.glyph._radius != null && (trans.sx !== this.last_trans.sx || trans.sy !== this.last_trans.sy)) {\n                // Keep screen radius up-to-date for circle glyph. Only happens when a radius is given\n                this.last_trans = trans;\n                this.vbo_s.set_data(0, new Float32Array(function () {\n                    var j, len, ref, results;\n                    ref = this.glyph.sradius;\n                    results = [];\n                    for (j = 0, len = ref.length; j < len; j++) {\n                        s = ref[j];\n                        results.push(s * 2);\n                    }\n                    return results;\n                }.call(this)));\n            }\n            // Update visuals if we must. Can happen for all glyphs.\n            if (this.visuals_changed) {\n                this._set_visuals(nvertices);\n                this.visuals_changed = false;\n            }\n            // Handle transformation to device coordinates\n            // Note the baked-in offset to avoid float32 precision problems\n            baked_offset = mainGlGlyph._baked_offset;\n            this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n            this.prog.set_uniform('u_canvas_size', 'vec2', [\n                trans.width,\n                trans.height\n            ]);\n            this.prog.set_uniform('u_offset', 'vec2', [\n                trans.dx - baked_offset[0],\n                trans.dy - baked_offset[1]\n            ]);\n            this.prog.set_uniform('u_scale', 'vec2', [\n                trans.sx,\n                trans.sy\n            ]);\n            // Select buffers from main glyph\n            // (which may be this glyph but maybe not if this is a (non)selection glyph)\n            this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n            this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n            this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n            this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\n            // Draw directly or using indices. Do not handle indices if they do not\n            // fit in a uint16; WebGL 1.0 does not support uint32.\n            if (indices.length === 0) {\n            } else if (indices.length === nvertices) {\n                return this.prog.draw(this.gl.POINTS, [\n                    0,\n                    nvertices\n                ]);\n            } else if (nvertices < 65535) {\n                // On IE the marker size is reduced to 1 px when using an index buffer\n                // A MS Edge dev on Twitter said on 24-04-2014: \"gl_PointSize > 1.0 works\n                // in DrawArrays; gl_PointSize > 1.0 in DrawElements is coming soon in the\n                // next renderer update.\n                ua = window.navigator.userAgent;\n                if (ua.indexOf('MSIE ') + ua.indexOf('Trident/') + ua.indexOf('Edge/') > 0) {\n                    logging_1.logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n                }\n                this.index_buffer.set_size(indices.length * 2);\n                this.index_buffer.set_data(0, new Uint16Array(indices));\n                return this.prog.draw(this.gl.POINTS, this.index_buffer);\n            } else {\n                // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n                // First collect indices in chunks\n                chunksize = 64000;\n                // 65536\n                chunks = [];\n                for (i = j = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    chunks.push([]);\n                }\n                for (i = k = 0, ref1 = indices.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n                    uint16_index = indices[i] % chunksize;\n                    chunk = Math.floor(indices[i] / chunksize);\n                    chunks[chunk].push(uint16_index);\n                }\n                results = [];\n                // Then draw each chunk\n                for (chunk = l = 0, ref2 = chunks.length; 0 <= ref2 ? l < ref2 : l > ref2; chunk = 0 <= ref2 ? ++l : --l) {\n                    these_indices = new Uint16Array(chunks[chunk]);\n                    offset = chunk * chunksize * 4;\n                    if (these_indices.length === 0) {\n                        continue;\n                    }\n                    this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n                    this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n                    this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n                    this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n                    if (this.vbo_linewidth.used) {\n                        this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n                    }\n                    if (this.vbo_fg_color.used) {\n                        this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n                    }\n                    if (this.vbo_bg_color.used) {\n                        this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n                    }\n                    // The actual drawing\n                    this.index_buffer.set_size(these_indices.length * 2);\n                    this.index_buffer.set_data(0, these_indices);\n                    results.push(this.prog.draw(this.gl.POINTS, this.index_buffer));\n                }\n                return results;\n            }\n        };\n        MarkerGLGlyph.prototype._set_data = function (nvertices) {\n            var i, j, n, ref, s, xx, yy;\n            n = nvertices * 4;\n            // in bytes\n            // Set buffer size\n            this.vbo_x.set_size(n);\n            this.vbo_y.set_size(n);\n            this.vbo_a.set_size(n);\n            this.vbo_s.set_size(n);\n            // Upload data for x and y, apply a baked-in offset for float32 precision (issue #3795)\n            // The exact value for the baked_offset does not matter, as long as it brings the data to less extreme values\n            xx = new Float64Array(this.glyph._x);\n            yy = new Float64Array(this.glyph._y);\n            for (i = j = 0, ref = nvertices; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                xx[i] += this._baked_offset[0];\n                yy[i] += this._baked_offset[1];\n            }\n            this.vbo_x.set_data(0, new Float32Array(xx));\n            this.vbo_y.set_data(0, new Float32Array(yy));\n            // Angle if available; circle does not have angle. If we don't set data, angle is default 0 in glsl\n            if (this.glyph._angle != null) {\n                this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n            }\n            // Radius is special; some markes allow radius in data-coords instead of screen coords\n            // @radius tells us that radius is in units, sradius is the pre-calculated screen radius\n            if (this.glyph._radius != null) {\n                return this.vbo_s.set_data(0, new Float32Array(function () {\n                    var k, len, ref1, results;\n                    ref1 = this.glyph.sradius;\n                    results = [];\n                    for (k = 0, len = ref1.length; k < len; k++) {\n                        s = ref1[k];\n                        results.push(s * 2);\n                    }\n                    return results;\n                }.call(this)));\n            } else {\n                return this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n            }\n        };\n        MarkerGLGlyph.prototype._set_visuals = function (nvertices) {\n            base_1.attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n            base_1.attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n            base_1.attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\n            // Static value for antialias. Smaller aa-region to obtain crisper images\n            return this.prog.set_uniform('u_antialias', 'float', [0.8]);\n        };\n        return MarkerGLGlyph;\n    }(base_1.BaseGLGlyph);\n    ;\n    // Base class for markers. All markers share the same GLSL, except for one\n    // function that defines the marker geometry.\n    MarkerGLGlyph.prototype.VERT = 'precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\n//\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size;\\nuniform vec2 u_offset;\\nuniform vec2 u_scale;\\nuniform float u_antialias;\\n//\\nattribute float a_x;\\nattribute float a_y;\\nattribute float a_size;\\nattribute float a_angle;  // in radians\\nattribute float a_linewidth;\\nattribute vec4  a_fg_color;\\nattribute vec4  a_bg_color;\\n//\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying vec2  v_rotation;\\n\\nvoid main (void)\\n{\\n    v_size = a_size * u_pixel_ratio;\\n    v_linewidth = a_linewidth * u_pixel_ratio;\\n    v_fg_color = a_fg_color;\\n    v_bg_color = a_bg_color;\\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\\n    // Calculate position - the -0.5 is to correct for canvas origin\\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\\n    pos += 0.5;  // make up for Bokeh\\'s offset\\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\\n}';\n    MarkerGLGlyph.prototype.FRAG = 'precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\nconst float PI = 3.14159265358979323846264;\\n//\\nuniform float u_antialias;\\n//\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec2  v_rotation;\\n\\nMARKERCODE\\n\\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\\n{\\n    vec4 frag_color;\\n    float t = linewidth/2.0 - antialias;\\n    float signed_distance = distance;\\n    float border_distance = abs(signed_distance) - t;\\n    float alpha = border_distance/antialias;\\n    alpha = exp(-alpha*alpha);\\n\\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\\n    float select = float(bool(fg_color.a));\\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\\n    // Similarly, if we want a transparent bg\\n    select = float(bool(bg_color.a));\\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\\n\\n    if( border_distance < 0.0)\\n        frag_color = fg_color;\\n    else if( signed_distance < 0.0 ) {\\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\\n    } else {\\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\\n        } else {\\n            discard;\\n        }\\n    }\\n    return frag_color;\\n}\\n\\nvoid main()\\n{\\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\\n             v_rotation.y*P.x + v_rotation.x*P.y);\\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\\n    float distance = marker(P*point_size, v_size);\\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\\n}';\n    MarkerGLGlyph.prototype.MARKERCODE = '<defined in subclasses>';\n    return MarkerGLGlyph;\n}();\nvar CircleGLGlyph = function (_super) {\n    tslib_1.__extends(CircleGLGlyph, _super);\n    function CircleGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CircleGLGlyph;\n}(MarkerGLGlyph);\nexports.CircleGLGlyph = CircleGLGlyph;\n;\nCircleGLGlyph.prototype.GLYPH = 'circle';\nCircleGLGlyph.prototype.MARKERCODE = '// --- disc\\nfloat marker(vec2 P, float size)\\n{\\n    return length(P) - size/2.0;\\n}';\nvar SquareGLGlyph = function (_super) {\n    tslib_1.__extends(SquareGLGlyph, _super);\n    function SquareGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return SquareGLGlyph;\n}(MarkerGLGlyph);\nexports.SquareGLGlyph = SquareGLGlyph;\n;\nSquareGLGlyph.prototype.GLYPH = 'square';\nSquareGLGlyph.prototype.MARKERCODE = '// --- square\\nfloat marker(vec2 P, float size)\\n{\\n    return max(abs(P.x), abs(P.y)) - size/2.0;\\n}';\nvar AnnulusGLGlyph = function (_super) {\n    tslib_1.__extends(AnnulusGLGlyph, _super);\n    function AnnulusGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return AnnulusGLGlyph;\n}(MarkerGLGlyph);\nexports.AnnulusGLGlyph = AnnulusGLGlyph;\n;\nAnnulusGLGlyph.prototype.GLYPH = 'annulus';\nAnnulusGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float r1 = length(P) - size/2.0;\\n    float r2 = length(P) - size/4.0;  // half width\\n    return max(r1, -r2);\\n}';\nvar DiamondGLGlyph = function (_super) {\n    tslib_1.__extends(DiamondGLGlyph, _super);\n    function DiamondGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DiamondGLGlyph;\n}(MarkerGLGlyph);\nexports.DiamondGLGlyph = DiamondGLGlyph;\n;\nDiamondGLGlyph.prototype.GLYPH = 'diamond';\nDiamondGLGlyph.prototype.MARKERCODE = '// --- diamond\\nfloat marker(vec2 P, float size)\\n{\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    return r1 / SQRT_2;\\n}';\nvar TriangleGLGlyph = function (_super) {\n    tslib_1.__extends(TriangleGLGlyph, _super);\n    function TriangleGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return TriangleGLGlyph;\n}(MarkerGLGlyph);\nexports.TriangleGLGlyph = TriangleGLGlyph;\n;\nTriangleGLGlyph.prototype.GLYPH = 'triangle';\nTriangleGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    P.y -= size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}';\nvar InvertedTriangleGLGlyph = function (_super) {\n    tslib_1.__extends(InvertedTriangleGLGlyph, _super);\n    function InvertedTriangleGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return InvertedTriangleGLGlyph;\n}(MarkerGLGlyph);\nexports.InvertedTriangleGLGlyph = InvertedTriangleGLGlyph;\n;\nInvertedTriangleGLGlyph.prototype.GLYPH = 'invertedtriangle';\nInvertedTriangleGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    P.y += size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = - P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}';\nvar CrossGLGlyph = function (_super) {\n    tslib_1.__extends(CrossGLGlyph, _super);\n    function CrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CrossGLGlyph;\n}(MarkerGLGlyph);\nexports.CrossGLGlyph = CrossGLGlyph;\n;\nCrossGLGlyph.prototype.GLYPH = 'cross';\nCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;  // 2.5 is a tweak\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return max(square, cross);\\n}';\nvar CircleCrossGLGlyph = function (_super) {\n    tslib_1.__extends(CircleCrossGLGlyph, _super);\n    function CircleCrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CircleCrossGLGlyph;\n}(MarkerGLGlyph);\nexports.CircleCrossGLGlyph = CircleCrossGLGlyph;\n;\nCircleCrossGLGlyph.prototype.GLYPH = 'circlecross';\nCircleCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar SquareCrossGLGlyph = function (_super) {\n    tslib_1.__extends(SquareCrossGLGlyph, _super);\n    function SquareCrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return SquareCrossGLGlyph;\n}(MarkerGLGlyph);\nexports.SquareCrossGLGlyph = SquareCrossGLGlyph;\n;\nSquareCrossGLGlyph.prototype.GLYPH = 'squarecross';\nSquareCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar DiamondCrossGLGlyph = function (_super) {\n    tslib_1.__extends(DiamondCrossGLGlyph, _super);\n    function DiamondCrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DiamondCrossGLGlyph;\n}(MarkerGLGlyph);\nexports.DiamondCrossGLGlyph = DiamondCrossGLGlyph;\n;\nDiamondCrossGLGlyph.prototype.GLYPH = 'diamondcross';\nDiamondCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    diamond /= SQRT_2;\\n    float c1 = max(diamond, s1);\\n    float c2 = max(diamond, s2);\\n    float c3 = max(diamond, s3);\\n    float c4 = max(diamond, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar XGLGlyph = function (_super) {\n    tslib_1.__extends(XGLGlyph, _super);\n    function XGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return XGLGlyph;\n}(MarkerGLGlyph);\nexports.XGLGlyph = XGLGlyph;\n;\nXGLGlyph.prototype.GLYPH = 'x';\nXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float circle = length(P) - size / 1.6;\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return max(circle, X);\\n}';\nvar CircleXGLGlyph = function (_super) {\n    tslib_1.__extends(CircleXGLGlyph, _super);\n    function CircleXGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CircleXGLGlyph;\n}(MarkerGLGlyph);\nexports.CircleXGLGlyph = CircleXGLGlyph;\n;\nCircleXGLGlyph.prototype.GLYPH = 'circlex';\nCircleXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    float almost = min(min(min(c1, c2), c3), c4);\\n    // In this case, the X is also outside of the main shape\\n    float Xmask = length(P) - size / 1.6;  // a circle\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return min(max(X, Xmask), almost);\\n}';\nvar SquareXGLGlyph = function (_super) {\n    tslib_1.__extends(SquareXGLGlyph, _super);\n    function SquareXGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return SquareXGLGlyph;\n}(MarkerGLGlyph);\nexports.SquareXGLGlyph = SquareXGLGlyph;\n;\nSquareXGLGlyph.prototype.GLYPH = 'squarex';\nSquareXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar AsteriskGLGlyph = function (_super) {\n    tslib_1.__extends(AsteriskGLGlyph, _super);\n    function AsteriskGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return AsteriskGLGlyph;\n}(MarkerGLGlyph);\nexports.AsteriskGLGlyph = AsteriskGLGlyph;\n;\nAsteriskGLGlyph.prototype.GLYPH = 'asterisk';\nAsteriskGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Masks\\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\\n    // Shapes\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    // Result is union of masked shapes\\n    return min(max(X, diamond), max(cross, square));\\n}';    \n}\n}, {\"models/glyphs/webgl/base\":423,\"models/glyphs/webgl/gloo2\":424,\"models/glyphs/webgl/index\":425,\"models/glyphs/webgl/line\":426,\"models/glyphs/webgl/main\":427,\"models/glyphs/webgl/markers\":428}, 427);\n})\n\n\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// This module implements the Base GL Glyph and some utilities\nvar color_1 = require(26    /* core/util/color */);\nvar BaseGLGlyph = function () {\n    function BaseGLGlyph(gl, glyph) {\n        this.gl = gl;\n        this.glyph = glyph;\n        this.nvertices = 0;\n        this.size_changed = false;\n        this.data_changed = false;\n        this.visuals_changed = false;\n        this.init();\n    }\n    BaseGLGlyph.prototype.set_data_changed = function (n) {\n        if (n !== this.nvertices) {\n            this.nvertices = n;\n            this.size_changed = true;\n        }\n        return this.data_changed = true;\n    };\n    BaseGLGlyph.prototype.set_visuals_changed = function () {\n        return this.visuals_changed = true;\n    };\n    BaseGLGlyph.prototype.render = function (ctx, indices, mainglyph) {\n        var dx, dy, sx, sy, trans, wx, wy;\n        // Get transform\n        wx = wy = 1;\n        // Weights to scale our vectors\n        _a = this.glyph.renderer.map_to_screen([\n            0 * wx,\n            1 * wx,\n            2 * wx\n        ], [\n            0 * wy,\n            1 * wy,\n            2 * wy\n        ]), dx = _a[0], dy = _a[1];\n        // Try again, but with weighs so we're looking at ~100 in screen coordinates\n        wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1000000000000);\n        wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1000000000000);\n        _b = this.glyph.renderer.map_to_screen([\n            0 * wx,\n            1 * wx,\n            2 * wx\n        ], [\n            0 * wy,\n            1 * wy,\n            2 * wy\n        ]), dx = _b[0], dy = _b[1];\n        // Test how linear it is\n        if (Math.abs(dx[1] - dx[0] - (dx[2] - dx[1])) > 0.000001 || Math.abs(dy[1] - dy[0] - (dy[2] - dy[1])) > 0.000001) {\n            return false;\n        }\n        _c = [\n            (dx[1] - dx[0]) / wx,\n            (dy[1] - dy[0]) / wy\n        ], sx = _c[0], sy = _c[1];\n        trans = {\n            pixel_ratio: ctx.pixel_ratio,\n            width: ctx.glcanvas.width,\n            height: ctx.glcanvas.height,\n            dx: dx[0] / sx,\n            dy: dy[0] / sy,\n            sx: sx,\n            sy: sy\n        };\n        this.draw(indices, mainglyph, trans);\n        return true;\n        // success\n        var _a, _b, _c;\n    };\n    return BaseGLGlyph;\n}();\nexports.BaseGLGlyph = BaseGLGlyph;\n;\nBaseGLGlyph.prototype.GLYPH = '';\n// name of the glyph that this gl-glyph applies to\nBaseGLGlyph.prototype.VERT = '';\nBaseGLGlyph.prototype.FRAG = '';\nexports.line_width = function (width) {\n    // Increase small values to make it more similar to canvas\n    if (width < 2) {\n        width = Math.sqrt(width * 2);\n    }\n    return width;\n};\nexports.fill_array_with_float = function (n, val) {\n    var a, i, k, ref;\n    a = new Float32Array(n);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        a[i] = val;\n    }\n    return a;\n};\nexports.fill_array_with_vec = function (n, m, val) {\n    var a, i, j, k, l, ref, ref1;\n    a = new Float32Array(n * m);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n            a[i * m + j] = val[j];\n        }\n    }\n    return a;\n};\nexports.visual_prop_is_singular = function (visual, propname) {\n    // This touches the internals of the visual, so we limit use in this function\n    // See renderer.coffee:cache_select() for similar code\n    return visual[propname].spec.value !== void 0;\n};\nexports.attach_float = function (prog, vbo, att_name, n, visual, name) {\n    var a;\n    // Attach a float attribute to the program. Use singleton value if we can,\n    // otherwise use VBO to apply array.\n    if (!visual.doit) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', [0]);\n    } else if (exports.visual_prop_is_singular(visual, name)) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', visual[name].value());\n    } else {\n        vbo.used = true;\n        a = new Float32Array(visual.cache[name + '_array']);\n        vbo.set_size(n * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'float', vbo);\n    }\n};\nexports.attach_color = function (prog, vbo, att_name, n, visual, prefix) {\n    var a, alphaname, alphas, colorname, colors, i, j, k, l, m, ref, ref1, rgba;\n    // Attach the color attribute to the program. If there's just one color,\n    // then use this single color for all vertices (no VBO). Otherwise we\n    // create an array and upload that to the VBO, which we attahce to the prog.\n    m = 4;\n    colorname = prefix + '_color';\n    alphaname = prefix + '_alpha';\n    if (!visual.doit) {\n        // Don't draw (draw transparent)\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'vec4', [\n            0,\n            0,\n            0,\n            0\n        ]);\n    } else if (exports.visual_prop_is_singular(visual, colorname) && exports.visual_prop_is_singular(visual, alphaname)) {\n        // Nice and simple; both color and alpha are singular\n        vbo.used = false;\n        rgba = color_1.color2rgba(visual[colorname].value(), visual[alphaname].value());\n        return prog.set_attribute(att_name, 'vec4', rgba);\n    } else {\n        // Use vbo; we need an array for both the color and the alpha\n        vbo.used = true;\n        // Get array of colors\n        if (exports.visual_prop_is_singular(visual, colorname)) {\n            colors = function () {\n                var k, ref, results;\n                results = [];\n                for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                    results.push(visual[colorname].value());\n                }\n                return results;\n            }();\n        } else {\n            colors = visual.cache[colorname + '_array'];\n        }\n        // Get array of alphas\n        if (exports.visual_prop_is_singular(visual, alphaname)) {\n            alphas = exports.fill_array_with_float(n, visual[alphaname].value());\n        } else {\n            alphas = visual.cache[alphaname + '_array'];\n        }\n        // Create array of rgbs\n        a = new Float32Array(n * m);\n        for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            rgba = color_1.color2rgba(colors[i], alphas[i]);\n            for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                a[i * m + j] = rgba[j];\n            }\n        }\n        // Attach vbo\n        vbo.set_size(n * m * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'vec4', vbo);\n    }\n};    \n","'use strict';\n/* Do not edit, autogenerated by flexx.pyscript */\nvar _pyfunc_add = function (a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.concat(b);\n    }\n    return a + b;\n};\nvar _pyfunc_all = function (x) {\n    for (var i = 0; i < x.length; i++) {\n        if (!_pyfunc_truthy(x[i])) {\n            return false;\n        }\n    }\n    return true;\n};\nvar _pyfunc_contains = function contains(a, b) {\n    if (b == null) {\n    } else if (Array.isArray(b)) {\n        for (var i = 0; i < b.length; i++) {\n            if (_pyfunc_equals(a, b[i]))\n                return true;\n        }\n        return false;\n    } else if (b.constructor === Object) {\n        for (var k in b) {\n            if (a == k)\n                return true;\n        }\n        return false;\n    } else if (b.constructor == String) {\n        return b.indexOf(a) >= 0;\n    }\n    var e = Error('Not a container: ' + b);\n    e.name = 'TypeError';\n    throw e;\n};\nvar _pyfunc_equals = function equals(a, b) {\n    if (a == null || b == null) {\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        var i = 0, iseq = a.length == b.length;\n        while (iseq && i < a.length) {\n            iseq = equals(a[i], b[i]);\n            i += 1;\n        }\n        return iseq;\n    } else if (a.constructor === Object && b.constructor === Object) {\n        var akeys = Object.keys(a), bkeys = Object.keys(b);\n        akeys.sort();\n        bkeys.sort();\n        var i = 0, k, iseq = equals(akeys, bkeys);\n        while (iseq && i < akeys.length) {\n            k = akeys[i];\n            iseq = equals(a[k], b[k]);\n            i += 1;\n        }\n        return iseq;\n    }\n    return a == b;\n};\nvar _pyfunc_instantiate = function (ob, args) {\n    if (typeof ob === 'undefined' || typeof window !== 'undefined' && window === ob || typeof global !== 'undefined' && global === ob) {\n        throw 'Class constructor is called as a function.';\n    }\n    for (var name in ob) {\n        if (Object[name] === undefined && typeof ob[name] === 'function' && !ob[name].nobind) {\n            ob[name] = ob[name].bind(ob);\n        }\n    }\n    if (ob.__init__) {\n        ob.__init__.apply(ob, args);\n    }\n};\nvar _pyfunc_mult = function (a, b) {\n    if ((typeof a === 'number') + (typeof b === 'number') === 1) {\n        if (a.constructor === String)\n            return _pymeth_repeat.call(a, b);\n        if (b.constructor === String)\n            return _pymeth_repeat.call(b, a);\n        if (Array.isArray(b)) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n        if (Array.isArray(a)) {\n            var res = [];\n            for (var i = 0; i < b; i++)\n                res = res.concat(a);\n            return res;\n        }\n    }\n    return a * b;\n};\nvar _pyfunc_range = function (start, end, step) {\n    var i, res = [];\n    var val = start;\n    var n = (end - start) / step;\n    for (i = 0; i < n; i++) {\n        res.push(val);\n        val += step;\n    }\n    return res;\n};\nvar _pyfunc_truthy = function (v) {\n    if (v === null || typeof v !== 'object') {\n        return v;\n    } else if (v.length !== undefined) {\n        return v.length ? v : false;\n    } else if (v.byteLength !== undefined) {\n        return v.byteLength ? v : false;\n    } else if (v.constructor !== Object) {\n        return true;\n    } else {\n        return Object.getOwnPropertyNames(v).length ? v : false;\n    }\n};\nvar _pymeth_append = function (x) {\n    if (!Array.isArray(this))\n        return this.append.apply(this, arguments);\n    this.push(x);\n};\nvar _pymeth_get = function (key, d) {\n    if (this.constructor !== Object)\n        return this.get.apply(this, arguments);\n    if (this[key] !== undefined) {\n        return this[key];\n    } else if (d !== undefined) {\n        return d;\n    } else {\n        return null;\n    }\n};\nvar _pymeth_keys = function () {\n    if (typeof this['keys'] === 'function')\n        return this.keys.apply(this, arguments);\n    return Object.keys(this);\n};\nvar _pymeth_lstrip = function (chars) {\n    if (this.constructor !== String)\n        return this.lstrip.apply(this, arguments);\n    chars = chars === undefined ? ' \\t\\r\\n' : chars;\n    for (var i = 0; i < this.length; i++) {\n        if (chars.indexOf(this[i]) < 0)\n            return this.slice(i);\n    }\n    return '';\n};\nvar _pymeth_remove = function (x) {\n    if (!Array.isArray(this))\n        return this.remove.apply(this, arguments);\n    for (var i = 0; i < this.length; i++) {\n        if (_pyfunc_equals(this[i], x)) {\n            this.splice(i, 1);\n            return;\n        }\n    }\n    var e = Error(x);\n    e.name = 'ValueError';\n    throw e;\n};\nvar _pymeth_repeat = function (count) {\n    if (this.repeat)\n        return this.repeat(count);\n    if (count < 1)\n        return '';\n    var result = '', pattern = this.valueOf();\n    while (count > 1) {\n        if (count & 1)\n            result += pattern;\n        count >>= 1, pattern += pattern;\n    }\n    return result + pattern;\n};\nvar _pymeth_startswith = function (x) {\n    if (this.constructor !== String)\n        return this.startswith.apply(this, arguments);\n    return this.indexOf(x) == 0;\n};\nvar Buffer, GlooObject, IndexBuffer, Program, Texture2D, Texture3DLike, VertexBuffer, __version__, check_error, console;\n// PyScript module for gloo2.js - lightweight object oriented GL.\n{\n    console = window.console;\n}\n__version__ = '0.3';\ncheck_error = function (gl, when) {\n    var e, err, err_3, errors, msg, stub1_seq, stub2_itr;\n    when = when === undefined ? 'periodic check' : when;\n    // Check this from time to time to detect GL errors.\n    //\n    //     Parameters\n    //     ----------\n    //     when : str\n    //         Shown in the exception to help the developer determine when\n    //         this check was done.\n    errors = [];\n    while (true) {\n        err = gl.getError();\n        if (_pyfunc_equals(err, gl.NO_ERROR) || _pyfunc_truthy(errors) && _pyfunc_equals(err, errors[errors.length - 1])) {\n            break;\n        }\n        _pymeth_append.call(errors, err);\n    }\n    if (errors.length) {\n        msg = '';\n        stub1_seq = errors;\n        if (typeof stub1_seq === 'object' && !Array.isArray(stub1_seq)) {\n            stub1_seq = Object.keys(stub1_seq);\n        }\n        for (stub2_itr = 0; stub2_itr < stub1_seq.length; stub2_itr += 1) {\n            e = stub1_seq[stub2_itr];\n            msg = _pyfunc_add(msg, e);\n        }\n        err_3 = new Error('RuntimeError:' + ('OpenGL got errors (' + when + '): ' + msg + ''));\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    return null;\n};\nGlooObject = function () {\n    // Abstract base class for all Gloo classes.\n    _pyfunc_instantiate(this, arguments);\n};\nGlooObject.prototype._base_class = Object;\nGlooObject.prototype._class_name = 'GlooObject';\nGlooObject.prototype.__init__ = function (gl) {\n    // Init by passing the webgl context object.\n    this._gl = gl;\n    this.handle = null;\n    this._create();\n    if (!(this.handle !== null)) {\n        throw 'AssertionError: ' + 'this.handle !== null';\n    }\n    return null;\n};\nGlooObject.prototype._create = function () {\n    var err_2;\n    err_2 = new Error('NotImplementedError:' + '');\n    err_2.name = 'NotImplementedError';\n    throw err_2;\n    return null;\n};\nProgram = function () {\n    // The program is the central component to connect gloo objects and shaders.\n    _pyfunc_instantiate(this, arguments);\n};\nProgram.prototype = Object.create(GlooObject.prototype);\nProgram.prototype._base_class = GlooObject.prototype;\nProgram.prototype._class_name = 'Program';\nProgram.prototype.UTYPEMAP = {\n    'float': 'uniform1fv',\n    'vec2': 'uniform2fv',\n    'vec3': 'uniform3fv',\n    'vec4': 'uniform4fv',\n    'int': 'uniform1iv',\n    'ivec2': 'uniform2iv',\n    'ivec3': 'uniform3iv',\n    'ivec4': 'uniform4iv',\n    'bool': 'uniform1iv',\n    'bvec2': 'uniform2iv',\n    'bvec3': 'uniform3iv',\n    'bvec4': 'uniform4iv',\n    'mat2': 'uniformMatrix2fv',\n    'mat3': 'uniformMatrix3fv',\n    'mat4': 'uniformMatrix4fv',\n    'sampler1D': 'uniform1i',\n    'sampler2D': 'uniform1i',\n    'sampler3D': 'uniform1i'\n};\nProgram.prototype.ATYPEMAP = {\n    'float': 'vertexAttrib1f',\n    'vec2': 'vertexAttrib2f',\n    'vec3': 'vertexAttrib3f',\n    'vec4': 'vertexAttrib4f'\n};\nProgram.prototype.ATYPEINFO = {\n    'float': [\n        1,\n        5126\n    ],\n    'vec2': [\n        2,\n        5126\n    ],\n    'vec3': [\n        3,\n        5126\n    ],\n    'vec4': [\n        4,\n        5126\n    ]\n};\nProgram.prototype._create = function () {\n    this.handle = this._gl.createProgram();\n    this.locations = {};\n    this._unset_variables = [];\n    this._validated = false;\n    this._samplers = {};\n    this._attributes = {};\n    this._known_invalid = [];\n    return null;\n};\nProgram.prototype.delete = function () {\n    // Delete the program.\n    this._gl.deleteProgram(this.handle);\n    return null;\n};\nProgram.prototype.activate = function () {\n    // Activate the program.\n    this._gl.useProgram(this.handle);\n    return null;\n};\nProgram.prototype.deactivate = function () {\n    // Disable the program.\n    this._gl.useProgram(0);\n    return null;\n};\nProgram.prototype.set_shaders = function (vert, frag) {\n    var code, err_3, err_4, errors, frag_handle, gl, handle, i, status, stub3_, tmp, type_, vert_handle;\n    // Set GLSL code for the vertex and fragment shader.\n    //\n    // This function takes care of setting the shading code and\n    // compiling+linking it into a working program object that is ready\n    // to use.\n    //\n    // Parameters\n    // ----------\n    // vert : str\n    //     GLSL code for the vertex shader.\n    // frag : str\n    //     GLSL code for the fragment shader.\n    gl = this._gl;\n    this._linked = false;\n    vert_handle = gl.createShader(gl.VERTEX_SHADER);\n    frag_handle = gl.createShader(gl.FRAGMENT_SHADER);\n    tmp = [\n        [\n            vert,\n            vert_handle,\n            'vertex'\n        ],\n        [\n            frag,\n            frag_handle,\n            'fragment'\n        ]\n    ];\n    for (i = 0; i < 2; i += 1) {\n        stub3_ = tmp[i];\n        code = stub3_[0];\n        handle = stub3_[1];\n        type_ = stub3_[2];\n        gl.shaderSource(handle, code);\n        gl.compileShader(handle);\n        status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);\n        if (!_pyfunc_truthy(status)) {\n            errors = gl.getShaderInfoLog(handle);\n            err_4 = new Error('RuntimeError:' + _pyfunc_add('errors in ' + type_ + ' shader:\\n', errors));\n            err_4.name = 'RuntimeError';\n            throw err_4;\n        }\n    }\n    gl.attachShader(this.handle, vert_handle);\n    gl.attachShader(this.handle, frag_handle);\n    gl.linkProgram(this.handle);\n    if (!_pyfunc_truthy(gl.getProgramParameter(this.handle, gl.LINK_STATUS))) {\n        err_3 = new Error('RuntimeError:' + ('Program link error:\\n' + gl.getProgramInfoLog(this.handle)));\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    this._unset_variables = this._get_active_attributes_and_uniforms();\n    gl.detachShader(this.handle, vert_handle);\n    gl.detachShader(this.handle, frag_handle);\n    gl.deleteShader(vert_handle);\n    gl.deleteShader(frag_handle);\n    this._known_invalid = [];\n    this._linked = true;\n    return null;\n};\nProgram.prototype._get_active_attributes_and_uniforms = function () {\n    var attributes, ca, container, count, cu, getActive, getLocation, gl, i, info, j, m, name, regex, stub4_, stub5_seq, stub6_itr, uniforms, x;\n    // Retrieve active attributes and uniforms to be able to check that\n    // all uniforms/attributes are set by the user.\n    gl = this._gl;\n    this.locations = {};\n    regex = new window.RegExp('(\\\\w+)\\\\s*(\\\\[(\\\\d+)\\\\])\\\\s*');\n    cu = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\n    ca = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\n    attributes = [];\n    uniforms = [];\n    stub5_seq = [\n        [\n            attributes,\n            ca,\n            gl.getActiveAttrib,\n            gl.getAttribLocation\n        ],\n        [\n            uniforms,\n            cu,\n            gl.getActiveUniform,\n            gl.getUniformLocation\n        ]\n    ];\n    if (typeof stub5_seq === 'object' && !Array.isArray(stub5_seq)) {\n        stub5_seq = Object.keys(stub5_seq);\n    }\n    for (stub6_itr = 0; stub6_itr < stub5_seq.length; stub6_itr += 1) {\n        x = stub5_seq[stub6_itr];\n        stub4_ = x;\n        container = stub4_[0];\n        count = stub4_[1];\n        getActive = stub4_[2];\n        getLocation = stub4_[3];\n        for (i = 0; i < count; i += 1) {\n            info = getActive.call(gl, this.handle, i);\n            name = info.name;\n            m = name.match(regex);\n            if (_pyfunc_truthy(m)) {\n                name = m[1];\n                for (j = 0; j < info.size; j += 1) {\n                    _pymeth_append.call(container, [\n                        '' + name + '[' + j + ']',\n                        info.type\n                    ]);\n                }\n            } else {\n                _pymeth_append.call(container, [\n                    name,\n                    info.type\n                ]);\n            }\n            this.locations[name] = getLocation.call(gl, this.handle, name);\n        }\n    }\n    return _pyfunc_add(function list_comprehenson() {\n        var res = [];\n        var v, iter0, i0;\n        iter0 = attributes;\n        if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n            iter0 = Object.keys(iter0);\n        }\n        for (i0 = 0; i0 < iter0.length; i0++) {\n            v = iter0[i0];\n            {\n                res.push(v[0]);\n            }\n        }\n        return res;\n    }.apply(this), function list_comprehenson() {\n        var res = [];\n        var v, iter0, i0;\n        iter0 = uniforms;\n        if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n            iter0 = Object.keys(iter0);\n        }\n        for (i0 = 0; i0 < iter0.length; i0++) {\n            v = iter0[i0];\n            {\n                res.push(v[0]);\n            }\n        }\n        return res;\n    }.apply(this));\n};\nProgram.prototype.set_texture = function (name, value) {\n    var err_3, handle, unit;\n    // Set a texture sampler.\n    //\n    // A texture is a 2 dimensional grid of colors/intensities that\n    // can be applied to a face (or used for other means by providing\n    // a regular grid of data).\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the texture is known in the GLSL code.\n    // value : Texture2D\n    //     The gloo Texture2D object to bind.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    handle = _pymeth_get.call(this.locations, name, -1);\n    if (_pyfunc_truthy(handle < 0)) {\n        if (!_pyfunc_contains(name, this._known_invalid)) {\n            _pymeth_append.call(this._known_invalid, name);\n            console.log('Variable ' + name + ' is not an active texture');\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    this.activate();\n    if (true) {\n        unit = _pymeth_keys.call(this._samplers).length;\n        if (_pyfunc_contains(name, this._samplers)) {\n            unit = this._samplers[name][this._samplers[name].length - 1];\n        }\n        this._samplers[name] = [\n            value._target,\n            value.handle,\n            unit\n        ];\n        this._gl.uniform1i(handle, unit);\n    }\n    return null;\n};\nProgram.prototype.set_uniform = function (name, type_, value) {\n    var a_type, count, err_3, funcname, handle, j, name_;\n    // Set a uniform value.\n    //\n    // A uniform is a value that is global to both the vertex and\n    // fragment shader.\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the uniform is known in the GLSL code.\n    // type_ : str\n    //     The type of the uniform, e.g. 'float', 'vec2', etc.\n    // value : list of scalars\n    //     The value for the uniform. Should be a list even for type float.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    handle = _pymeth_get.call(this.locations, name, -1);\n    if (_pyfunc_truthy(handle < 0)) {\n        if (!_pyfunc_contains(name, this._known_invalid)) {\n            _pymeth_append.call(this._known_invalid, name);\n            console.log('Variable ' + name + ' is not an active uniform');\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    count = 1;\n    if (!_pymeth_startswith.call(type_, 'mat')) {\n        a_type = _pymeth_get.call({\n            'int': 'float',\n            'bool': 'float'\n        }, type_, _pymeth_lstrip.call(type_, 'ib'));\n        count = Math.floor(value.length / this.ATYPEINFO[a_type][0]);\n    }\n    if (_pyfunc_truthy(count > 1)) {\n        for (j = 0; j < count; j += 1) {\n            if (_pyfunc_contains('' + name + '[' + j + ']', this._unset_variables)) {\n                name_ = '' + name + '[' + j + ']';\n                if (_pyfunc_contains(name_, this._unset_variables)) {\n                    _pymeth_remove.call(this._unset_variables, name_);\n                }\n            }\n        }\n    }\n    funcname = this.UTYPEMAP[type_];\n    this.activate();\n    if (_pymeth_startswith.call(type_, 'mat')) {\n        this._gl[funcname](handle, false, value);\n    } else {\n        this._gl[funcname](handle, value);\n    }\n    return null;\n};\nProgram.prototype.set_attribute = function (name, type_, value, stride, offset) {\n    var args, err_3, funcname, gtype, handle, is_vbo, size, stub7_;\n    stride = stride === undefined ? 0 : stride;\n    offset = offset === undefined ? 0 : offset;\n    // Set an attribute value.\n    //\n    // An attribute represents per-vertex data and can only be used\n    // in the vertex shader.\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the attribute is known in the GLSL code.\n    // type_ : str\n    //     The type of the attribute, e.g. 'float', 'vec2', etc.\n    // value : VertexBuffer, array\n    //     If value is a VertexBuffer, it is used (with stride and offset)\n    //     for the vertex data. If value is an array, its used to set\n    //     the value of all vertices (similar to a uniform).\n    // stide : int, default 0\n    //     The stride to \"sample\" the vertex data inside the buffer. Unless\n    //     multiple vertex data are packed into a single buffer, this should\n    //     be zero.\n    // offset : int, default 0\n    //     The offset to \"sample\" the vertex data inside the buffer. Unless\n    //     multiple vertex data are packed into a single buffer, or only\n    //     a part of the data must be used, this should probably be zero.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot set attribute when program has no code');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    is_vbo = value instanceof VertexBuffer;\n    handle = _pymeth_get.call(this.locations, name, -1);\n    if (_pyfunc_truthy(handle < 0)) {\n        if (!_pyfunc_contains(name, this._known_invalid)) {\n            _pymeth_append.call(this._known_invalid, name);\n            if (_pyfunc_truthy(is_vbo) && _pyfunc_truthy(offset > 0)) {\n            } else {\n                console.log('Variable ' + name + ' is not an active attribute');\n            }\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    this.activate();\n    if (!_pyfunc_truthy(is_vbo)) {\n        funcname = this.ATYPEMAP[type_];\n        this._attributes[name] = [\n            0,\n            handle,\n            funcname,\n            value\n        ];\n    } else {\n        stub7_ = this.ATYPEINFO[type_];\n        size = stub7_[0];\n        gtype = stub7_[1];\n        funcname = 'vertexAttribPointer';\n        args = [\n            size,\n            gtype,\n            this._gl.FALSE,\n            stride,\n            offset\n        ];\n        this._attributes[name] = [\n            value.handle,\n            handle,\n            funcname,\n            args\n        ];\n    }\n    return null;\n};\nProgram.prototype._pre_draw = function () {\n    var args, attr_handle, funcname, stub10_, stub11_seq, stub8_, stub9_seq, tex_handle, tex_target, unit, vbo_handle, x;\n    // Prepare for drawing.\n    this.activate();\n    stub9_seq = this._samplers;\n    for (x in stub9_seq) {\n        if (!stub9_seq.hasOwnProperty(x)) {\n            continue;\n        }\n        x = stub9_seq[x];\n        stub8_ = x;\n        tex_target = stub8_[0];\n        tex_handle = stub8_[1];\n        unit = stub8_[2];\n        this._gl.activeTexture(_pyfunc_add(this._gl.TEXTURE0, unit));\n        this._gl.bindTexture(tex_target, tex_handle);\n    }\n    stub11_seq = this._attributes;\n    for (x in stub11_seq) {\n        if (!stub11_seq.hasOwnProperty(x)) {\n            continue;\n        }\n        x = stub11_seq[x];\n        stub10_ = x;\n        vbo_handle = stub10_[0];\n        attr_handle = stub10_[1];\n        funcname = stub10_[2];\n        args = stub10_[3];\n        if (_pyfunc_truthy(vbo_handle)) {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, vbo_handle);\n            this._gl.enableVertexAttribArray(attr_handle);\n            this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n        } else {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);\n            this._gl.disableVertexAttribArray(attr_handle);\n            this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n        }\n    }\n    if (!_pyfunc_truthy(this._validated)) {\n        this._validated = true;\n        this._validate();\n    }\n    return null;\n};\nProgram.prototype._validate = function () {\n    var err_3;\n    if (this._unset_variables.length) {\n        console.log('Program has unset variables: ' + this._unset_variables + '');\n    }\n    this._gl.validateProgram(this.handle);\n    if (!_pyfunc_truthy(this._gl.getProgramParameter(this.handle, this._gl.VALIDATE_STATUS))) {\n        console.log(this._gl.getProgramInfoLog(this.handle));\n        err_3 = new Error('RuntimeError:' + 'Program validation error');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    return null;\n};\nProgram.prototype.draw = function (mode, selection) {\n    var count, err_3, first, gtype, stub12_;\n    // Draw the current visualization defined by the program.\n    //\n    // Parameters\n    // ----------\n    // mode : GL enum\n    //     Can be POINTS, LINES, LINE_LOOP, LINE_STRIP, LINE_FAN, TRIANGLES\n    // selection : 2-element tuple or IndexBuffer\n    //     The selection to draw, specified either as (first, count) or an\n    //     IndexBuffer object.\n    if (!_pyfunc_truthy(this._linked)) {\n        err_3 = new Error('RuntimeError:' + 'Cannot draw program if code has not been set');\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    check_error(this._gl, 'before draw');\n    if (_pyfunc_truthy(selection instanceof IndexBuffer)) {\n        this._pre_draw();\n        selection.activate();\n        count = selection._buffer_size / 2;\n        gtype = this._gl.UNSIGNED_SHORT;\n        this._gl.drawElements(mode, count, gtype, 0);\n        selection.deactivate();\n    } else {\n        stub12_ = selection;\n        first = stub12_[0];\n        count = stub12_[1];\n        if (_pyfunc_truthy(count)) {\n            this._pre_draw();\n            this._gl.drawArrays(mode, first, count);\n        }\n    }\n    check_error(this._gl, 'after draw');\n    return null;\n};\nBuffer = function () {\n    // Base buffer class for vertex data or index data.\n    _pyfunc_instantiate(this, arguments);\n};\nBuffer.prototype = Object.create(GlooObject.prototype);\nBuffer.prototype._base_class = GlooObject.prototype;\nBuffer.prototype._class_name = 'Buffer';\nBuffer.prototype._target = null;\nBuffer.prototype._usage = 35048;\nBuffer.prototype._create = function () {\n    this.handle = this._gl.createBuffer();\n    this._buffer_size = 0;\n    return null;\n};\nBuffer.prototype.delete = function () {\n    // Delete the buffer.\n    this._gl.deleteBuffer(this.handle);\n    return null;\n};\nBuffer.prototype.activate = function () {\n    // Activete the buffer.\n    this._gl.bindBuffer(this._target, this.handle);\n    return null;\n};\nBuffer.prototype.deactivate = function () {\n    // Disable the buffer.\n    this._gl.bindBuffer(this._target, null);\n    return null;\n};\nBuffer.prototype.set_size = function (nbytes) {\n    // Set the size of the buffer in bytes.\n    //\n    // Parameters\n    // ----------\n    // nbytes : int\n    //     The number of bytes that the buffer needs to hold.\n    if (!_pyfunc_equals(nbytes, this._buffer_size)) {\n        this.activate();\n        this._gl.bufferData(this._target, nbytes, this._usage);\n        this._buffer_size = nbytes;\n    }\n    return null;\n};\nBuffer.prototype.set_data = function (offset, data) {\n    // Set the buffer data.\n    //\n    // Parameters\n    // ----------\n    // offset : int\n    //     The offset in bytes for the new data.\n    // data : typed array\n    //     The data to upload.\n    this.activate();\n    this._gl.bufferSubData(this._target, offset, data);\n    return null;\n};\nVertexBuffer = function () {\n    // A buffer for vertex data.\n    _pyfunc_instantiate(this, arguments);\n};\nVertexBuffer.prototype = Object.create(Buffer.prototype);\nVertexBuffer.prototype._base_class = Buffer.prototype;\nVertexBuffer.prototype._class_name = 'VertexBuffer';\nVertexBuffer.prototype._target = 34962;\nIndexBuffer = function () {\n    // A buffer for index data.\n    _pyfunc_instantiate(this, arguments);\n};\nIndexBuffer.prototype = Object.create(Buffer.prototype);\nIndexBuffer.prototype._base_class = Buffer.prototype;\nIndexBuffer.prototype._class_name = 'IndexBuffer';\nIndexBuffer.prototype._target = 34963;\nTexture2D = function () {\n    // A 2 dimensional regular grid.\n    _pyfunc_instantiate(this, arguments);\n};\nTexture2D.prototype = Object.create(GlooObject.prototype);\nTexture2D.prototype._base_class = GlooObject.prototype;\nTexture2D.prototype._class_name = 'Texture2D';\nTexture2D.prototype._target = 3553;\nTexture2D.prototype._types = {\n    'Int8Array': 5120,\n    'Uint8Array': 5121,\n    'Int16Array': 5122,\n    'Uint16Array': 5123,\n    'Int32Array': 5124,\n    'Uint32Array': 5125,\n    'Float32Array': 5126\n};\nTexture2D.prototype._create = function () {\n    this.handle = this._gl.createTexture();\n    this._shape_format = null;\n    return null;\n};\nTexture2D.prototype.delete = function () {\n    // Delete the texture.\n    this._gl.deleteTexture(this.handle);\n    return null;\n};\nTexture2D.prototype.activate = function () {\n    // Activate the texture.\n    this._gl.bindTexture(this._target, this.handle);\n    return null;\n};\nTexture2D.prototype.deactivate = function () {\n    // Disable the texture.\n    this._gl.bindTexture(this._target, 0);\n    return null;\n};\nTexture2D.prototype._get_alignment = function (width) {\n    var alignment, alignments, stub13_seq, stub14_itr;\n    // Determines a textures byte alignment. If the width isn't a\n    //         power of 2 we need to adjust the byte alignment of the image.\n    //         The image height is unimportant.\n    //\n    //         www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n    alignments = [\n        4,\n        8,\n        2,\n        1\n    ];\n    stub13_seq = alignments;\n    if (typeof stub13_seq === 'object' && !Array.isArray(stub13_seq)) {\n        stub13_seq = Object.keys(stub13_seq);\n    }\n    for (stub14_itr = 0; stub14_itr < stub13_seq.length; stub14_itr += 1) {\n        alignment = stub13_seq[stub14_itr];\n        if (_pyfunc_equals(width % alignment, 0)) {\n            return alignment;\n        }\n    }\n    return null;\n};\nTexture2D.prototype.set_wrapping = function (wrap_s, wrap_t) {\n    // Set the texture wrapping mode.\n    //\n    // Parameters\n    // ----------\n    // wrap_s : GL enum\n    //     The mode to wrap the x dimension. Valid values are REPEAT\n    //     CLAMP_TO_EDGE MIRRORED_REPEAT\n    // wrap_t : GL enum\n    //     The mode to wrap the y dimension. Same options as for wrap_s.\n    this.activate();\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_S, wrap_s);\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_T, wrap_t);\n    return null;\n};\nTexture2D.prototype.set_interpolation = function (min, mag) {\n    // Set the texture interpolation mode\n    //\n    // Parameters\n    // ----------\n    // min : GL enum\n    //     The interpolation mode when minifying (i.e. zoomed out). Valid\n    //     values are LINEAR and NEAREST.\n    // max : GL enum\n    //     The interpolation mode when magnifying (i.e. zoomed in). Valid\n    //     values are LINEAR, NEAREST, NEAREST_MIPMAP_NEAREST,\n    //     LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR.\n    this.activate();\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_MIN_FILTER, min);\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_MAG_FILTER, mag);\n    return null;\n};\nTexture2D.prototype.set_size = function (shape, format) {\n    var height, stub15_, width;\n    // Set the size of the 2D texture.\n    //\n    // Parameters\n    // ----------\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // format : GL enum\n    //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n    //     RGB, and RGBA.\n    stub15_ = shape;\n    height = stub15_[0];\n    width = stub15_[1];\n    if (!_pyfunc_equals([\n            height,\n            width,\n            format\n        ], this._shape_format)) {\n        this._shape_format = [\n            height,\n            width,\n            format\n        ];\n        this.activate();\n        this._gl.texImage2D(this._target, 0, format, width, height, 0, format, this._gl.UNSIGNED_BYTE, null);\n    }\n    this.u_shape = [\n        height,\n        width\n    ];\n    return null;\n};\nTexture2D.prototype.set_data = function (offset, shape, data) {\n    var _, alignment, err_3, format, gtype, height, stub16_, stub17_, width, x, y;\n    // Set the 2D texture data.\n    //\n    // Parameters\n    // ----------\n    // offset : tuple of ints\n    //     Offset in pixels for each dimension.\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // data : typed array\n    //     The actual pixel data. Can be of any type, but on the GPU the\n    //     dat is stored in 8 bit precision.\n    if (_pyfunc_equals(shape.length, 2)) {\n        shape = [\n            shape[0],\n            shape[1],\n            1\n        ];\n    }\n    this.activate();\n    format = this._shape_format[2];\n    stub16_ = shape;\n    height = stub16_[0];\n    width = stub16_[1];\n    _ = stub16_[2];\n    stub17_ = offset;\n    y = stub17_[0];\n    x = stub17_[1];\n    gtype = _pymeth_get.call(this._types, data.constructor.name, null);\n    if (gtype === null) {\n        err_3 = new Error('ValueError:' + ('Type ' + data.constructor.name + ' not allowed for texture'));\n        err_3.name = 'ValueError';\n        throw err_3;\n    }\n    alignment = this._get_alignment(_pyfunc_mult(shape[shape.length - 2], shape[shape.length - 1]));\n    if (!_pyfunc_equals(alignment, 4)) {\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, alignment);\n    }\n    this._gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);\n    if (!_pyfunc_equals(alignment, 4)) {\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 4);\n    }\n    return null;\n};\nTexture3DLike = function () {\n    // A 2D texture with support to simulate a 3D texture.\n    //\n    // To use this class, use set_size() and set_data() as if it was a 3D\n    // texture. Add the GLSL_SAMPLE_NEAREST or GLSL_SAMPLE_LINEAR to the\n    // shader to add the sample3D() function that can be used instead of\n    // texture2D(). This function needs ``shape`` and ``tiles`` arguments\n    // which can be set via uniforms, using the ``u_shape`` and ``u_tiles``\n    // attributes of this object.\n    _pyfunc_instantiate(this, arguments);\n};\nTexture3DLike.prototype = Object.create(Texture2D.prototype);\nTexture3DLike.prototype._base_class = Texture2D.prototype;\nTexture3DLike.prototype._class_name = 'Texture3DLike';\nTexture3DLike.prototype.GLSL_SAMPLE_NEAREST = '\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don\\'t let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float zindex = floor(texcoord.z * shape.z);\\n\\n            // Do a lookup in the 2D texture\\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\\n\\n            return texture2D(tex, vec2(u,v));\\n        }\\n    ';\nTexture3DLike.prototype.GLSL_SAMPLE_LINEAR = '\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don\\'t let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float z = texcoord.z * shape.z;\\n            float zindex1 = floor(z);\\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\\n\\n            float zindex2 = zindex1 + 1.0;\\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\\n\\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\\n\\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\\n        }\\n    ';\nTexture3DLike.prototype._get_tile_info = function (shape) {\n    var err_3, max_size, ncols, nrows;\n    max_size = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);\n    nrows = Math.floor(max_size / shape[1]);\n    nrows = Math.min(nrows, shape[0]);\n    ncols = window.Math.ceil(shape[0] / nrows);\n    if (_pyfunc_truthy(_pyfunc_mult(ncols, shape[2]) > max_size)) {\n        err_3 = new Error('RuntimeError:' + ('Cannot fit 3D data with shape ' + shape + ' onto simulated 2D texture.'));\n        err_3.name = 'RuntimeError';\n        throw err_3;\n    }\n    return [\n        nrows,\n        ncols\n    ];\n};\nTexture3DLike.prototype.set_size = function (shape, format) {\n    var ncols, nrows, sim_shape, stub18_;\n    // Set the size of the 3D texture.\n    //\n    // Parameters\n    // ----------\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // format : GL enum\n    //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n    //     RGB, and RGBA.\n    stub18_ = this._get_tile_info(shape);\n    nrows = stub18_[0];\n    ncols = stub18_[1];\n    sim_shape = [\n        _pyfunc_mult(shape[1], nrows),\n        _pyfunc_mult(shape[2], ncols)\n    ];\n    Texture3DLike.prototype._base_class.set_size.call(this, sim_shape, format);\n    this.u_shape = [\n        shape[0],\n        shape[1],\n        shape[2]\n    ];\n    this.u_tiles = [\n        ncols,\n        nrows\n    ];\n    return null;\n};\nTexture3DLike.prototype.set_data = function (offset, shape, data) {\n    var Type, col, elements_per_tile, err_3, ncols, nrows, row, sim_shape, stub19_, stub20_, tile, z, zeros;\n    // Set the 3D texture data.\n    //\n    // Parameters\n    // ----------\n    // offset : tuple of ints\n    //     Offset in pixels for each dimension.\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // data : typed array\n    //     The actual pixel data. Can be of any type, but on the GPU the\n    //     dat is stored in 8 bit precision.\n    if (_pyfunc_equals(shape.length, 3)) {\n        shape = [\n            shape[0],\n            shape[1],\n            shape[2],\n            1\n        ];\n    }\n    if (!_pyfunc_all(function list_comprehenson() {\n            var res = [];\n            var i, iter0, i0;\n            iter0 = offset;\n            if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n                iter0 = Object.keys(iter0);\n            }\n            for (i0 = 0; i0 < iter0.length; i0++) {\n                i = iter0[i0];\n                {\n                    res.push(_pyfunc_equals(i, 0));\n                }\n            }\n            return res;\n        }.apply(this))) {\n        err_3 = new Error('ValueError:' + 'Texture3DLike does not support nonzero offset (for now)');\n        err_3.name = 'ValueError';\n        throw err_3;\n    }\n    stub19_ = this._get_tile_info(shape);\n    nrows = stub19_[0];\n    ncols = stub19_[1];\n    sim_shape = [\n        _pyfunc_mult(shape[1], nrows),\n        _pyfunc_mult(shape[2], ncols),\n        shape[3]\n    ];\n    if (_pyfunc_equals(ncols, 1)) {\n        Texture3DLike.prototype._base_class.set_data.call(this, [\n            0,\n            0\n        ], sim_shape, data);\n    } else {\n        Type = data.constructor;\n        zeros = new Type(_pyfunc_mult(_pyfunc_mult(sim_shape[0], sim_shape[1]), sim_shape[2]));\n        Texture3DLike.prototype._base_class.set_data.call(this, [\n            0,\n            0\n        ], sim_shape, zeros);\n        for (z = 0; z < shape[0]; z += 1) {\n            stub20_ = [\n                Math.floor(z / ncols),\n                z % ncols\n            ];\n            row = stub20_[0];\n            col = stub20_[1];\n            elements_per_tile = Math.floor(data.length / shape[0]);\n            tile = data.slice(_pyfunc_mult(z, elements_per_tile), _pyfunc_mult(z + 1, elements_per_tile));\n            Texture3DLike.prototype._base_class.set_data.call(this, [\n                _pyfunc_mult(row, shape[1]),\n                _pyfunc_mult(col, shape[2])\n            ], shape.slice(1), tile);\n        }\n    }\n    return null;\n};\nmodule.exports = {\n    'Buffer': Buffer,\n    'GlooObject': GlooObject,\n    'IndexBuffer': IndexBuffer,\n    'Program': Program,\n    'Texture2D': Texture2D,\n    'Texture3DLike': Texture3DLike,\n    'VertexBuffer': VertexBuffer,\n    'check_error': check_error,\n    'console': console\n};    \n","'use strict';\n/*\nCopyright notice: many of the awesome techniques and  GLSL code contained in\nthis module are based on work by Nicolas Rougier as part of the Glumpy and\nVispy projects. The algorithms are published in\nhttp://jcgt.org/published/0003/04/01/ and http://jcgt.org/published/0002/02/08/\n\nThis module contains all gl-specific code to add gl support for the glyphs.\nBy implementing it separetely, the GL functionality can be spun off in a\nseparate library.\nOther locations where we work with GL, or prepare for GL-rendering:\n- canvas.coffee\n- plot.coffee\n- glyph.coffee\n- glyph_renderer.coffee\n*/\nObject.defineProperty(exports, '__esModule', { value: true });\nvar tslib_1 = require(364    /* tslib */);\ntslib_1.__exportStar(require(426    /* ./line */), exports);\ntslib_1.__exportStar(require(428    /* ./markers */), exports);    \n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar tslib_1 = require(364    /* tslib */);\nvar DashAtlas;\nvar gloo2_1 = require(424    /* ./gloo2 */);\nvar base_1 = require(423    /* ./base */);\nvar color_1 = require(26    /* core/util/color */);\nDashAtlas = function () {\n    function DashAtlas(gl) {\n        this._atlas = {};\n        this._index = 0;\n        this._width = 256;\n        this._height = 256;\n        // Init texture\n        this.tex = new gloo2_1.Texture2D(gl);\n        this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n        this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n        this.tex.set_size([\n            this._height,\n            this._width\n        ], gl.RGBA);\n        this.tex.set_data([\n            0,\n            0\n        ], [\n            this._height,\n            this._width\n        ], new Uint8Array(this._height * this._width * 4));\n        // Init with solid line (index 0 is reserved for this)\n        this.get_atlas_data([1]);\n    }\n    DashAtlas.prototype.get_atlas_data = function (pattern) {\n        var data, findex_period, key, period, x;\n        key = pattern.join('-');\n        findex_period = this._atlas[key];\n        if (findex_period === void 0) {\n            _a = this.make_pattern(pattern), data = _a[0], period = _a[1];\n            this.tex.set_data([\n                this._index,\n                0\n            ], [\n                1,\n                this._width\n            ], new Uint8Array(function () {\n                var l, len, results;\n                results = [];\n                for (l = 0, len = data.length; l < len; l++) {\n                    x = data[l];\n                    results.push(x + 10);\n                }\n                return results;\n            }()));\n            this._atlas[key] = [\n                this._index / this._height,\n                period\n            ];\n            this._index += 1;\n        }\n        return this._atlas[key];\n        var _a;\n    };\n    DashAtlas.prototype.make_pattern = function (pattern) {\n        var C, Z, a, b, c, dash_end, dash_start, dash_type, i, index, j, l, len, n, p, period, q, r, ref, ref1, ref2, v, val, val_at_index, x;\n        // A pattern is defined as on/off sequence of segments\n        // It must be a multiple of 2\n        if (pattern.length > 1 && pattern.length % 2) {\n            pattern = pattern.concat(pattern);\n        }\n        // Period is sum of elements\n        period = 0;\n        for (l = 0, len = pattern.length; l < len; l++) {\n            v = pattern[l];\n            period += v;\n        }\n        // Find all start and end of on-segment only\n        C = [];\n        c = 0;\n        for (i = p = 0, ref = pattern.length + 2; p < ref; i = p += 2) {\n            a = Math.max(0.0001, pattern[i % pattern.length]);\n            b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n            C.push.apply(C, [\n                c,\n                c + a    // == extend\n            ]);\n            c += a + b;\n        }\n        // Build pattern\n        n = this._width;\n        Z = new Float32Array(n * 4);\n        for (i = q = 0, ref1 = n; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n            x = period * i / (n - 1);\n            // get index at min - index = np.argmin(abs(C-(x)))\n            index = 0;\n            val_at_index = 10000000000000000;\n            for (j = r = 0, ref2 = C.length; 0 <= ref2 ? r < ref2 : r > ref2; j = 0 <= ref2 ? ++r : --r) {\n                val = Math.abs(C[j] - x);\n                if (val < val_at_index) {\n                    index = j;\n                    val_at_index = val;\n                }\n            }\n            if (index % 2 === 0) {\n                dash_type = x <= C[index] ? +1 : 0;\n                dash_start = C[index];\n                dash_end = C[index + 1];\n            } else {\n                dash_type = x > C[index] ? -1 : 0;\n                dash_start = C[index - 1];\n                dash_end = C[index];\n            }\n            Z[i * 4 + 0] = C[index];\n            Z[i * 4 + 1] = dash_type;\n            Z[i * 4 + 2] = dash_start;\n            Z[i * 4 + 3] = dash_end;\n        }\n        return [\n            Z,\n            period\n        ];\n    };\n    return DashAtlas;\n}();\nvar LineGLGlyph = function (_super) {\n    tslib_1.__extends(LineGLGlyph, _super);\n    function LineGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LineGLGlyph.prototype.init = function () {\n        var gl;\n        gl = this.gl;\n        this._scale_aspect = 0;\n        // keep track, so we know when we need to update segment data\n        // The program\n        this.prog = new gloo2_1.Program(gl);\n        this.prog.set_shaders(this.VERT, this.FRAG);\n        this.index_buffer = new gloo2_1.IndexBuffer(gl);\n        // Buffers\n        this.vbo_position = new gloo2_1.VertexBuffer(gl);\n        this.vbo_tangents = new gloo2_1.VertexBuffer(gl);\n        this.vbo_segment = new gloo2_1.VertexBuffer(gl);\n        this.vbo_angles = new gloo2_1.VertexBuffer(gl);\n        this.vbo_texcoord = new gloo2_1.VertexBuffer(gl);\n        // Dash atlas\n        return this.dash_atlas = new DashAtlas(gl);\n    };\n    LineGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n        var baked_offset, chunk, chunks, chunksize, i, l, mainGlGlyph, nvertices, offset, p, q, ref, ref1, ref2, results, scale_length, sx, sy, these_indices, uint16_index;\n        mainGlGlyph = mainGlyph.glglyph;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return;\n            }\n            mainGlGlyph._baked_offset = [\n                trans.dx,\n                trans.dy\n            ];\n            mainGlGlyph._set_data();\n            mainGlGlyph.data_changed = false;\n        }\n        if (this.visuals_changed) {\n            this._set_visuals();\n            this.visuals_changed = false;\n        }\n        // Decompose x-y scale into scalar scale and aspect-vector.\n        sx = trans.sx;\n        sy = trans.sy;\n        scale_length = Math.sqrt(sx * sx + sy * sy);\n        sx /= scale_length;\n        sy /= scale_length;\n        // Do we need to re-calculate segment data and cumsum?\n        if (Math.abs(this._scale_aspect - sy / sx) > Math.abs(0.001 * this._scale_aspect)) {\n            mainGlGlyph._update_scale(sx, sy);\n            this._scale_aspect = sy / sx;\n        }\n        // Select buffers from main glyph\n        // (which may be this glyph but maybe not if this is a (non)selection glyph)\n        this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n        this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n        this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n        this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n        this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\n        this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n        this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\n        // Handle transformation to device coordinates\n        baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [\n            trans.width,\n            trans.height\n        ]);\n        this.prog.set_uniform('u_offset', 'vec2', [\n            trans.dx - baked_offset[0],\n            trans.dy - baked_offset[1]\n        ]);\n        this.prog.set_uniform('u_scale_aspect', 'vec2', [\n            sx,\n            sy\n        ]);\n        this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n        this.I_triangles = mainGlGlyph.I_triangles;\n        if (this.I_triangles.length < 65535) {\n            // Data is small enough to draw in one pass\n            this.index_buffer.set_size(this.I_triangles.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n            return this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n        } else {\n            // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n            // First collect indices in chunks\n            // @prog.draw(@gl.LINE_STRIP, @index_buffer)  # Use this to draw the line skeleton\n            indices = this.I_triangles;\n            nvertices = this.I_triangles.length;\n            chunksize = 64008;\n            // 65536 max. 64008 is divisible by 12\n            chunks = [];\n            for (i = l = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n                chunks.push([]);\n            }\n            for (i = p = 0, ref1 = indices.length; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n                uint16_index = indices[i] % chunksize;\n                chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            results = [];\n            // Then draw each chunk\n            for (chunk = q = 0, ref2 = chunks.length; 0 <= ref2 ? q < ref2 : q > ref2; chunk = 0 <= ref2 ? ++q : --q) {\n                these_indices = new Uint16Array(chunks[chunk]);\n                offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n                this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n                this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n                this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n                this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\n                // The actual drawing\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                results.push(this.prog.draw(this.gl.TRIANGLES, this.index_buffer));\n            }\n            return results;\n        }\n    };\n    LineGLGlyph.prototype._set_data = function () {\n        this._bake();\n        this.vbo_position.set_size(this.V_position.length * 4);\n        this.vbo_position.set_data(0, this.V_position);\n        this.vbo_tangents.set_size(this.V_tangents.length * 4);\n        this.vbo_tangents.set_data(0, this.V_tangents);\n        this.vbo_angles.set_size(this.V_angles.length * 4);\n        this.vbo_angles.set_data(0, this.V_angles);\n        this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n        return this.vbo_texcoord.set_data(0, this.V_texcoord);\n    };\n    LineGLGlyph.prototype._set_visuals = function () {\n        var cap, color, dash_index, dash_pattern, dash_period, join;\n        color = color_1.color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n        cap = this.CAPS[this.glyph.visuals.line.line_cap.value()];\n        join = this.JOINS[this.glyph.visuals.line.line_join.value()];\n        this.prog.set_uniform('u_color', 'vec4', color);\n        this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n        this.prog.set_uniform('u_antialias', 'float', [0.9]);\n        // Smaller aa-region to obtain crisper images\n        this.prog.set_uniform('u_linecaps', 'vec2', [\n            cap,\n            cap\n        ]);\n        this.prog.set_uniform('u_linejoin', 'float', [join]);\n        this.prog.set_uniform('u_miter_limit', 'float', [10]);\n        // 10 should be a good value\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n        dash_pattern = this.glyph.visuals.line.line_dash.value();\n        dash_index = 0;\n        dash_period = 1;\n        if (dash_pattern.length) {\n            _a = this.dash_atlas.get_atlas_data(dash_pattern), dash_index = _a[0], dash_period = _a[1];\n        }\n        this.prog.set_uniform('u_dash_index', 'float', [dash_index]);\n        // 0 means solid line\n        this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n        this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n        this.prog.set_uniform('u_dash_caps', 'vec2', [\n            cap,\n            cap\n        ]);\n        return this.prog.set_uniform('u_closed', 'float', [0]);\n        // We dont do closed lines\n        var _a;\n    };\n    LineGLGlyph.prototype._bake = function () {\n        var A, I, T, V_angles, V_angles2, V_position, V_position2, V_tangents, V_tangents2, V_texcoord, V_texcoord2, Vp, Vt, _x, _y, i, i1, j, k, l, m, n, ni, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, results, s, t, u, w, y, z;\n        // This is what you get if you port 50 lines of numpy code to JS.\n        // V_segment is handled in another method, because it depends on the aspect\n        // ratio of the scale (The original paper/code assumed isotropic scaling).\n        // Buffer dtype from the Python implementation:\n        // self.vtype = np.dtype( [('a_position', 'f4', 2),\n        //                         ('a_segment',  'f4', 2),\n        //                         ('a_angles',   'f4', 2),\n        //                         ('a_tangents', 'f4', 4),\n        //                         ('a_texcoord', 'f4', 2) ])\n        // Init array of implicit shape nx2\n        n = this.nvertices;\n        _x = new Float64Array(this.glyph._x);\n        _y = new Float64Array(this.glyph._y);\n        // Init vertex data\n        V_position = Vp = new Float32Array(n * 2);\n        //V_segment = new Float32Array(n*2)  # Done later\n        V_angles = new Float32Array(n * 2);\n        V_tangents = Vt = new Float32Array(n * 4);\n        // mind the 4!\n        V_texcoord = new Float32Array(n * 2);\n        // Position\n        for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            V_position[i * 2 + 0] = _x[i] + this._baked_offset[0];\n            V_position[i * 2 + 1] = _y[i] + this._baked_offset[1];\n        }\n        // Tangents & norms (need tangents to calculate segments based on scale)\n        this.tangents = T = new Float32Array(n * 2 - 2);\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            T[i * 2 + 0] = Vp[(i + 1) * 2 + 0] - Vp[i * 2 + 0];\n            T[i * 2 + 1] = Vp[(i + 1) * 2 + 1] - Vp[i * 2 + 1];\n        }\n        for (i = q = 0, ref2 = n - 1; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            // V['a_tangents'][+1:, :2] = T\n            V_tangents[(i + 1) * 4 + 0] = T[i * 2 + 0];\n            V_tangents[(i + 1) * 4 + 1] = T[i * 2 + 1];\n            // V['a_tangents'][:-1, 2:] = T\n            V_tangents[i * 4 + 2] = T[i * 2 + 0];\n            V_tangents[i * 4 + 3] = T[i * 2 + 1];\n        }\n        // V['a_tangents'][0  , :2] = T[0]\n        V_tangents[0 * 4 + 0] = T[0];\n        V_tangents[0 * 4 + 1] = T[1];\n        // V['a_tangents'][ -1, 2:] = T[-1]\n        V_tangents[(n - 1) * 4 + 2] = T[(n - 2) * 2 + 0];\n        V_tangents[(n - 1) * 4 + 3] = T[(n - 2) * 2 + 1];\n        // Angles\n        A = new Float32Array(n);\n        for (i = r = 0, ref3 = n; 0 <= ref3 ? r < ref3 : r > ref3; i = 0 <= ref3 ? ++r : --r) {\n            A[i] = Math.atan2(Vt[i * 4 + 0] * Vt[i * 4 + 3] - Vt[i * 4 + 1] * Vt[i * 4 + 2], Vt[i * 4 + 0] * Vt[i * 4 + 2] + Vt[i * 4 + 1] * Vt[i * 4 + 3]);\n        }\n        for (i = s = 0, ref4 = n - 1; 0 <= ref4 ? s < ref4 : s > ref4; i = 0 <= ref4 ? ++s : --s) {\n            V_angles[i * 2 + 0] = A[i];\n            V_angles[i * 2 + 1] = A[i + 1];\n        }\n        // Step 1: A -- B -- C  =>  A -- B, B' -- C\n        // Repeat our array 4 times\n        m = 4 * n - 4;\n        this.V_position = V_position2 = new Float32Array(m * 2);\n        this.V_angles = V_angles2 = new Float32Array(m * 2);\n        this.V_tangents = V_tangents2 = new Float32Array(m * 4);\n        // mind the 4!\n        this.V_texcoord = V_texcoord2 = new Float32Array(m * 2);\n        o = 2;\n        // all nodes on the line\n        // Arg, we really need an ndarray thing in JS :/\n        for (i = t = 0, ref5 = n; 0 <= ref5 ? t < ref5 : t > ref5; i = 0 <= ref5 ? ++t : --t) {\n            // the four quad vertices\n            for (j = u = 0; u < 4; j = ++u) {\n                // xy\n                for (k = w = 0; w < 2; k = ++w) {\n                    V_position2[(i * 4 + j - o) * 2 + k] = V_position[i * 2 + k];\n                    V_angles2[(i * 4 + j) * 2 + k] = V_angles[i * 2 + k];\n                }\n                for (k = y = 0; y < 4; k = ++y) {\n                    V_tangents2[(i * 4 + j - o) * 4 + k] = V_tangents[i * 4 + k];\n                }\n            }\n        }\n        for (i = z = 0, ref6 = n; 0 <= ref6 ? z <= ref6 : z >= ref6; i = 0 <= ref6 ? ++z : --z) {\n            V_texcoord2[(i * 4 + 0) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 2) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 3) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 0) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 1] = +1;\n            V_texcoord2[(i * 4 + 2) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 3) * 2 + 1] = +1;\n        }\n        // Indices\n        //I = np.resize( np.array([0,1,2,1,2,3], dtype=np.uint32), (n-1)*(2*3))\n        //I += np.repeat( 4*np.arange(n-1), 6)\n        ni = (n - 1) * 6;\n        this.I_triangles = I = new Uint32Array(ni);\n        results = [];\n        // Order of indices is such that drawing as line_strip reveals the line skeleton\n        // Might have implications on culling, if we ever turn that on.\n        // Order in paper was: 0 1 2 1 2 3\n        for (i = i1 = 0, ref7 = n; 0 <= ref7 ? i1 < ref7 : i1 > ref7; i = 0 <= ref7 ? ++i1 : --i1) {\n            I[i * 6 + 0] = 0 + 4 * i;\n            I[i * 6 + 1] = 1 + 4 * i;\n            I[i * 6 + 2] = 3 + 4 * i;\n            I[i * 6 + 3] = 2 + 4 * i;\n            I[i * 6 + 4] = 0 + 4 * i;\n            results.push(I[i * 6 + 5] = 3 + 4 * i);\n        }\n        return results;\n    };\n    LineGLGlyph.prototype._update_scale = function (sx, sy) {\n        var N, T, V_segment, V_segment2, cumsum, i, j, k, l, m, n, p, q, r, ref, ref1, ref2, s;\n        // Update segment data and cumsum so the length along the line has the\n        // scale aspect ratio in it. In the vertex shader we multiply with the\n        // \"isotropic part\" of the scale.\n        n = this.nvertices;\n        m = 4 * n - 4;\n        // Prepare arrays\n        T = this.tangents;\n        N = new Float32Array(n - 1);\n        V_segment = new Float32Array(n * 2);\n        // Elements are initialized with 0\n        this.V_segment = V_segment2 = new Float32Array(m * 2);\n        // Calculate vector lengths - with scale aspect ratio taken into account\n        for (i = l = 0, ref = n - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            N[i] = Math.sqrt(Math.pow(T[i * 2 + 0] * sx, 2) + Math.pow(T[i * 2 + 1] * sy, 2));\n        }\n        // Calculate Segments\n        cumsum = 0;\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            cumsum += N[i];\n            V_segment[(i + 1) * 2 + 0] = cumsum;\n            V_segment[i * 2 + 1] = cumsum;\n        }\n        // Upscale (same loop as in _bake())\n        for (i = q = 0, ref2 = n; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            for (j = r = 0; r < 4; j = ++r) {\n                for (k = s = 0; s < 2; k = ++s) {\n                    V_segment2[(i * 4 + j) * 2 + k] = V_segment[i * 2 + k];\n                }\n            }\n        }\n        // Update\n        this.cumsum = cumsum;\n        // L[-1] in Nico's code\n        this.vbo_segment.set_size(this.V_segment.length * 4);\n        return this.vbo_segment.set_data(0, this.V_segment);\n    };\n    return LineGLGlyph;\n}(base_1.BaseGLGlyph);\nexports.LineGLGlyph = LineGLGlyph;\n;\nLineGLGlyph.prototype.GLYPH = 'line';\nLineGLGlyph.prototype.JOINS = {\n    'miter': 0,\n    'round': 1,\n    'bevel': 2\n};\nLineGLGlyph.prototype.CAPS = {\n    '': 0,\n    'none': 0,\n    '.': 0,\n    'round': 1,\n    ')': 1,\n    '(': 1,\n    'o': 1,\n    'triangle in': 2,\n    '<': 2,\n    'triangle out': 3,\n    '>': 3,\n    'square': 4,\n    '[': 4,\n    ']': 4,\n    '=': 4,\n    'butt': 5,\n    '|': 5\n};\nLineGLGlyph.prototype.VERT = 'precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size, u_offset;\\nuniform vec2 u_scale_aspect;\\nuniform float u_scale_length;\\n\\nuniform vec4 u_color;\\nuniform float u_antialias;\\nuniform float u_length;\\nuniform float u_linewidth;\\nuniform float u_dash_index;\\nuniform float u_closed;\\n\\nattribute vec2 a_position;\\nattribute vec4 a_tangents;\\nattribute vec2 a_segment;\\nattribute vec2 a_angles;\\nattribute vec2 a_texcoord;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\nfloat cross(in vec2 v1, in vec2 v2)\\n{\\n    return v1.x*v2.y - v1.y*v2.x;\\n}\\n\\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\\n{\\n    return cross(v2-v1,v1-v3) / length(v2-v1);\\n}\\n\\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\\n{\\n    float c = cos(alpha);\\n    float s = sin(alpha);\\n    result = vec2( c*v.x - s*v.y,\\n                   s*v.x + c*v.y );\\n}\\n\\nvoid main()\\n{\\n    bool closed = (u_closed > 0.0);\\n\\n    // Attributes and uniforms to varyings\\n    v_color = u_color;\\n    v_linewidth = u_linewidth;\\n    v_segment = a_segment * u_scale_length;\\n    v_length = u_length * u_scale_length;\\n\\n    // Scale to map to pixel coordinates. The original algorithm from the paper\\n    // assumed isotropic scale. We obviously do not have this.\\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\\n\\n    // Correct angles for aspect ratio\\n    vec2 av;\\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\\n    v_angles.x = atan(av.y, av.x);\\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\\n    v_angles.y = atan(av.y, av.x);\\n\\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\\n    // and a modified alpha\\n    v_color.a = min(v_linewidth, v_color.a);\\n    v_linewidth = max(v_linewidth, 1.0);\\n\\n    // If color is fully transparent we just will discard the fragment anyway\\n    if( v_color.a <= 0.0 ) {\\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\\n        return;\\n    }\\n\\n    // This is the actual half width of the line\\n    float w = ceil(u_antialias+v_linewidth)/2.0;\\n\\n    vec2 position = (a_position + u_offset) * abs_scale;\\n\\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\\n    float u = a_texcoord.x;\\n    float v = a_texcoord.y;\\n    vec2 o1 = vec2( +t1.y, -t1.x);\\n    vec2 o2 = vec2( +t2.y, -t2.x);\\n\\n    // This is a join\\n    // ----------------------------------------------------------------\\n    if( t1 != t2 ) {\\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\\n        vec2 t  = normalize(t1+t2);\\n        vec2 o  = vec2( + t.y, - t.x);\\n\\n        if ( u_dash_index > 0.0 )\\n        {\\n            // Broken angle\\n            // ----------------------------------------------------------------\\n            if( (abs(angle) > THETA) ) {\\n                position += v * w * o / cos(angle/2.0);\\n                float s = sign(angle);\\n                if( angle < 0.0 ) {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position -= 2.0 * w * t1 / sin(angle);\\n                            u -= 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position += 2.0 * w * t2 / sin(angle);\\n                            u += 2.0*w / sin(angle);\\n                        }\\n                    }\\n                } else {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position += 2.0 * w * t1 / sin(angle);\\n                            u += 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position -= 2.0 * w * t2 / sin(angle);\\n                            u -= 2.0*w / sin(angle);\\n                        }\\n                    }\\n                }\\n                // Continuous angle\\n                // ------------------------------------------------------------\\n            } else {\\n                position += v * w * o / cos(angle/2.0);\\n                if( u == +1.0 ) u = v_segment.y;\\n                else            u = v_segment.x;\\n            }\\n        }\\n\\n        // Solid line\\n        // --------------------------------------------------------------------\\n        else\\n        {\\n            position.xy += v * w * o / cos(angle/2.0);\\n            if( angle < 0.0 ) {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            } else {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            }\\n        }\\n\\n    // This is a line start or end (t1 == t2)\\n    // ------------------------------------------------------------------------\\n    } else {\\n        position += v * w * o1;\\n        if( u == -1.0 ) {\\n            u = v_segment.x - w;\\n            position -= w * t1;\\n        } else {\\n            u = v_segment.y + w;\\n            position += w * t2;\\n        }\\n    }\\n\\n    // Miter distance\\n    // ------------------------------------------------------------------------\\n    vec2 t;\\n    vec2 curr = a_position * abs_scale;\\n    if( a_texcoord.x < 0.0 ) {\\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, +v_angles.x/2.0, t);\\n        v_miter.x = signed_distance(curr, curr+t, position);\\n\\n        rotate( t2, +v_angles.y/2.0, t);\\n        v_miter.y = signed_distance(next, next+t, position);\\n    } else {\\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, -v_angles.x/2.0,t);\\n        v_miter.x = signed_distance(prev, prev+t, position);\\n\\n        rotate( t2, -v_angles.y/2.0,t);\\n        v_miter.y = signed_distance(curr, curr+t, position);\\n    }\\n\\n    if (!closed && v_segment.x <= 0.0) {\\n        v_miter.x = 1e10;\\n    }\\n    if (!closed && v_segment.y >= v_length)\\n    {\\n        v_miter.y = 1e10;\\n    }\\n\\n    v_texcoord = vec2( u, v*w );\\n\\n    // Calculate position in device coordinates. Note that we\\n    // already scaled with abs scale above.\\n    vec2 normpos = position * sign(u_scale_aspect);\\n    normpos += 0.5;  // make up for Bokeh\\'s offset\\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n}\\n';\nLineGLGlyph.prototype.FRAG_ = '// Fragment shader that can be convenient during debugging to show the line skeleton.\\nprecision mediump float;\\nuniform vec4  u_color;\\nvoid main () {\\n  gl_FragColor = u_color;\\n}';\nLineGLGlyph.prototype.FRAG = 'precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform sampler2D u_dash_atlas;\\n\\nuniform vec2 u_linecaps;\\nuniform float u_miter_limit;\\nuniform float u_linejoin;\\nuniform float u_antialias;\\nuniform float u_dash_phase;\\nuniform float u_dash_period;\\nuniform float u_dash_index;\\nuniform vec2 u_dash_caps;\\nuniform float u_closed;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\n// Compute distance to cap ----------------------------------------------------\\nfloat cap( int type, float dx, float dy, float t, float linewidth )\\n{\\n    float d = 0.0;\\n    dx = abs(dx);\\n    dy = abs(dy);\\n    if      (type == 0)  discard;  // None\\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\\n    else if (type == 4)  d = max(dx,dy);  // Square\\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\\n    return d;\\n}\\n\\n// Compute distance to join -------------------------------------------------\\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\\n           in float linewidth )\\n{\\n    // texcoord.x is distance from start\\n    // texcoord.y is distance from centerline\\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\\n\\n    float dx = texcoord.x;\\n\\n    // Round join\\n    if( type == 1 ) {\\n        if (dx < segment.x) {\\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\\n            //d = length( texcoord - vec2(segment.x,0.0));\\n        } else if (dx > segment.y) {\\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\\n            //d = length( texcoord - vec2(segment.y,0.0));\\n        }\\n    }\\n    // Bevel join\\n    else if ( type == 2 ) {\\n        if (dx < segment.x) {\\n            vec2 x = texcoord - vec2(segment.x,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n\\n        } else if (dx > segment.y) {\\n            vec2 x = texcoord - vec2(segment.y,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n        }\\n        /*  Original code for bevel which does not work for us\\n        if( (dx < segment.x) ||  (dx > segment.y) )\\n            d = max(d, min(abs(x.x),abs(x.y)));\\n        */\\n    }\\n\\n    return d;\\n}\\n\\nvoid main()\\n{\\n    // If color is fully transparent we just discard the fragment\\n    if( v_color.a <= 0.0 ) {\\n        discard;\\n    }\\n\\n    // Test if dash pattern is the solid one (0)\\n    bool solid =  (u_dash_index == 0.0);\\n\\n    // Test if path is closed\\n    bool closed = (u_closed > 0.0);\\n\\n    vec4 color = v_color;\\n    float dx = v_texcoord.x;\\n    float dy = v_texcoord.y;\\n    float t = v_linewidth/2.0-u_antialias;\\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\\n    float d = 0.0;\\n\\n    vec2 linecaps = u_linecaps;\\n    vec2 dash_caps = u_dash_caps;\\n    float line_start = 0.0;\\n    float line_stop = v_length;\\n\\n    // Apply miter limit; fragments too far into the miter are simply discarded\\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\\n          discard;\\n    }\\n\\n    // Solid line --------------------------------------------------------------\\n    if( solid ) {\\n        d = abs(dy);\\n        if( (!closed) && (dx < line_start) ) {\\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\\n        }\\n        else if( (!closed) &&  (dx > line_stop) ) {\\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\\n        }\\n        else {\\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\\n        }\\n\\n    // Dash line --------------------------------------------------------------\\n    } else {\\n        float segment_start = v_segment.x;\\n        float segment_stop  = v_segment.y;\\n        float segment_center= (segment_start+segment_stop)/2.0;\\n        float freq          = u_dash_period*width;\\n        float u = mod( dx + u_dash_phase*width, freq);\\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n        float dash_center= tex.x * width;\\n        float dash_type  = tex.y;\\n        float _start = tex.z * width;\\n        float _stop  = tex.a * width;\\n        float dash_start = dx - u + _start;\\n        float dash_stop  = dx - u + _stop;\\n\\n        // Compute extents of the first dash (the one relative to v_segment.x)\\n        // Note: this could be computed in the vertex shader\\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\\n            float u = mod(segment_start + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_start - u + _start;\\n            dash_stop = segment_start - u + _stop;\\n        }\\n\\n        // Compute extents of the last dash (the one relatives to v_segment.y)\\n        // Note: This could be computed in the vertex shader\\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\\n            float u = mod(segment_stop + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_stop - u + _start;\\n            dash_stop  = segment_stop - u + _stop;\\n        }\\n\\n        // This test if the we are dealing with a discontinuous angle\\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\\n        //if( dx < line_start) discontinuous = false;\\n        //if( dx > line_stop)  discontinuous = false;\\n\\n        float d_join = join( int(u_linejoin), abs(dy),\\n                            v_segment, v_texcoord, v_miter, v_linewidth );\\n\\n        // When path is closed, we do not have room for linecaps, so we make room\\n        // by shortening the total length\\n        if (closed) {\\n             line_start += v_linewidth/2.0;\\n             line_stop  -= v_linewidth/2.0;\\n        }\\n\\n        // We also need to take antialias area into account\\n        //line_start += u_antialias;\\n        //line_stop  -= u_antialias;\\n\\n        // Check is dash stop is before line start\\n        if( dash_stop <= line_start ) {\\n            discard;\\n        }\\n        // Check is dash start is beyond line stop\\n        if( dash_start >= line_stop ) {\\n            discard;\\n        }\\n\\n        // Check if current dash start is beyond segment stop\\n        if( discontinuous ) {\\n            // Dash start is beyond segment, we discard\\n            if( (dash_start > segment_stop) ) {\\n                discard;\\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\\n            }\\n\\n            // Dash stop is before segment, we discard\\n            if( (dash_stop < segment_start) ) {\\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\\n            }\\n\\n            // Special case for round caps (nicer with this)\\n            if( dash_caps.x == 1.0 ) {\\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for round caps  (nicer with this)\\n            if( dash_caps.y == 1.0 ) {\\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\\n                    float a = v_angles.x/2.0;\\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the cap into square to avoid holes\\n                    dash_caps.x = 4.0;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\\n                    float a = v_angles.y/2.0;\\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the caps into square to avoid holes\\n                    dash_caps.y = 4.0;\\n                }\\n            }\\n        }\\n\\n        // Line cap at start\\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\\n        }\\n        // Line cap at stop\\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\\n        }\\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\\n        else if( dash_type < -0.5 ) {\\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash cap right\\n        else if( dash_type > 0.5 ) {\\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash body (plain)\\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\\n            d = abs(dy);\\n        }\\n\\n        // Line join\\n        if( (dx > line_start) && (dx < line_stop)) {\\n            if( (dx <= segment_start) && (dash_start <= segment_start)\\n                && (dash_stop >= segment_start) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.x;\\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\\n                     && (dash_stop >= segment_stop) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.y;\\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( dx < (segment_start - v_linewidth/2.)) {\\n                discard;\\n            }\\n            else if( dx > (segment_stop + v_linewidth/2.)) {\\n                discard;\\n            }\\n        }\\n        else if( dx < (segment_start - v_linewidth/2.)) {\\n            discard;\\n        }\\n        else if( dx > (segment_stop + v_linewidth/2.)) {\\n            discard;\\n        }\\n    }\\n\\n    // Distance to border ------------------------------------------------------\\n    d = d - t;\\n    if( d < 0.0 ) {\\n        gl_FragColor = color;\\n    } else {\\n        d /= u_antialias;\\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\\n    }\\n}';    \n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nrequire(425    /* ./index */);    \n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar tslib_1 = require(364    /* tslib */);\nvar MarkerGLGlyph;\nvar gloo2_1 = require(424    /* ./gloo2 */);\nvar base_1 = require(423    /* ./base */);\nvar logging_1 = require(14    /* core/logging */);\nMarkerGLGlyph = function () {\n    var MarkerGLGlyph = function (_super) {\n        tslib_1.__extends(MarkerGLGlyph, _super);\n        function MarkerGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        MarkerGLGlyph.prototype.init = function () {\n            var frag, gl;\n            gl = this.gl;\n            frag = this.FRAG.replace(/MARKERCODE/, this.MARKERCODE);\n            this.last_trans = {};\n            // Keep track of transform\n            // The program\n            this.prog = new gloo2_1.Program(gl);\n            this.prog.set_shaders(this.VERT, frag);\n            // Real attributes\n            this.vbo_x = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_x', 'float', this.vbo_x);\n            this.vbo_y = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_y', 'float', this.vbo_y);\n            this.vbo_s = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_size', 'float', this.vbo_s);\n            this.vbo_a = new gloo2_1.VertexBuffer(gl);\n            this.prog.set_attribute('a_angle', 'float', this.vbo_a);\n            // VBO's for attributes (they may not be used if value is singleton)\n            this.vbo_linewidth = new gloo2_1.VertexBuffer(gl);\n            this.vbo_fg_color = new gloo2_1.VertexBuffer(gl);\n            this.vbo_bg_color = new gloo2_1.VertexBuffer(gl);\n            return this.index_buffer = new gloo2_1.IndexBuffer(gl);\n        };\n        MarkerGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n            var baked_offset, chunk, chunks, chunksize, i, j, k, l, mainGlGlyph, nvertices, offset, ref, ref1, ref2, results, s, these_indices, ua, uint16_index;\n            // The main glyph has the data, *this* glyph has the visuals.\n            mainGlGlyph = mainGlyph.glglyph;\n            nvertices = mainGlGlyph.nvertices;\n            // Upload data if we must. Only happens for main glyph.\n            if (mainGlGlyph.data_changed) {\n                if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                    return;\n                }\n                mainGlGlyph._baked_offset = [\n                    trans.dx,\n                    trans.dy\n                ];\n                mainGlGlyph._set_data(nvertices);\n                mainGlGlyph.data_changed = false;\n            } else if (this.glyph._radius != null && (trans.sx !== this.last_trans.sx || trans.sy !== this.last_trans.sy)) {\n                // Keep screen radius up-to-date for circle glyph. Only happens when a radius is given\n                this.last_trans = trans;\n                this.vbo_s.set_data(0, new Float32Array(function () {\n                    var j, len, ref, results;\n                    ref = this.glyph.sradius;\n                    results = [];\n                    for (j = 0, len = ref.length; j < len; j++) {\n                        s = ref[j];\n                        results.push(s * 2);\n                    }\n                    return results;\n                }.call(this)));\n            }\n            // Update visuals if we must. Can happen for all glyphs.\n            if (this.visuals_changed) {\n                this._set_visuals(nvertices);\n                this.visuals_changed = false;\n            }\n            // Handle transformation to device coordinates\n            // Note the baked-in offset to avoid float32 precision problems\n            baked_offset = mainGlGlyph._baked_offset;\n            this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n            this.prog.set_uniform('u_canvas_size', 'vec2', [\n                trans.width,\n                trans.height\n            ]);\n            this.prog.set_uniform('u_offset', 'vec2', [\n                trans.dx - baked_offset[0],\n                trans.dy - baked_offset[1]\n            ]);\n            this.prog.set_uniform('u_scale', 'vec2', [\n                trans.sx,\n                trans.sy\n            ]);\n            // Select buffers from main glyph\n            // (which may be this glyph but maybe not if this is a (non)selection glyph)\n            this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n            this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n            this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n            this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\n            // Draw directly or using indices. Do not handle indices if they do not\n            // fit in a uint16; WebGL 1.0 does not support uint32.\n            if (indices.length === 0) {\n            } else if (indices.length === nvertices) {\n                return this.prog.draw(this.gl.POINTS, [\n                    0,\n                    nvertices\n                ]);\n            } else if (nvertices < 65535) {\n                // On IE the marker size is reduced to 1 px when using an index buffer\n                // A MS Edge dev on Twitter said on 24-04-2014: \"gl_PointSize > 1.0 works\n                // in DrawArrays; gl_PointSize > 1.0 in DrawElements is coming soon in the\n                // next renderer update.\n                ua = window.navigator.userAgent;\n                if (ua.indexOf('MSIE ') + ua.indexOf('Trident/') + ua.indexOf('Edge/') > 0) {\n                    logging_1.logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n                }\n                this.index_buffer.set_size(indices.length * 2);\n                this.index_buffer.set_data(0, new Uint16Array(indices));\n                return this.prog.draw(this.gl.POINTS, this.index_buffer);\n            } else {\n                // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n                // First collect indices in chunks\n                chunksize = 64000;\n                // 65536\n                chunks = [];\n                for (i = j = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    chunks.push([]);\n                }\n                for (i = k = 0, ref1 = indices.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n                    uint16_index = indices[i] % chunksize;\n                    chunk = Math.floor(indices[i] / chunksize);\n                    chunks[chunk].push(uint16_index);\n                }\n                results = [];\n                // Then draw each chunk\n                for (chunk = l = 0, ref2 = chunks.length; 0 <= ref2 ? l < ref2 : l > ref2; chunk = 0 <= ref2 ? ++l : --l) {\n                    these_indices = new Uint16Array(chunks[chunk]);\n                    offset = chunk * chunksize * 4;\n                    if (these_indices.length === 0) {\n                        continue;\n                    }\n                    this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n                    this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n                    this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n                    this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n                    if (this.vbo_linewidth.used) {\n                        this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n                    }\n                    if (this.vbo_fg_color.used) {\n                        this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n                    }\n                    if (this.vbo_bg_color.used) {\n                        this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n                    }\n                    // The actual drawing\n                    this.index_buffer.set_size(these_indices.length * 2);\n                    this.index_buffer.set_data(0, these_indices);\n                    results.push(this.prog.draw(this.gl.POINTS, this.index_buffer));\n                }\n                return results;\n            }\n        };\n        MarkerGLGlyph.prototype._set_data = function (nvertices) {\n            var i, j, n, ref, s, xx, yy;\n            n = nvertices * 4;\n            // in bytes\n            // Set buffer size\n            this.vbo_x.set_size(n);\n            this.vbo_y.set_size(n);\n            this.vbo_a.set_size(n);\n            this.vbo_s.set_size(n);\n            // Upload data for x and y, apply a baked-in offset for float32 precision (issue #3795)\n            // The exact value for the baked_offset does not matter, as long as it brings the data to less extreme values\n            xx = new Float64Array(this.glyph._x);\n            yy = new Float64Array(this.glyph._y);\n            for (i = j = 0, ref = nvertices; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                xx[i] += this._baked_offset[0];\n                yy[i] += this._baked_offset[1];\n            }\n            this.vbo_x.set_data(0, new Float32Array(xx));\n            this.vbo_y.set_data(0, new Float32Array(yy));\n            // Angle if available; circle does not have angle. If we don't set data, angle is default 0 in glsl\n            if (this.glyph._angle != null) {\n                this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n            }\n            // Radius is special; some markes allow radius in data-coords instead of screen coords\n            // @radius tells us that radius is in units, sradius is the pre-calculated screen radius\n            if (this.glyph._radius != null) {\n                return this.vbo_s.set_data(0, new Float32Array(function () {\n                    var k, len, ref1, results;\n                    ref1 = this.glyph.sradius;\n                    results = [];\n                    for (k = 0, len = ref1.length; k < len; k++) {\n                        s = ref1[k];\n                        results.push(s * 2);\n                    }\n                    return results;\n                }.call(this)));\n            } else {\n                return this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n            }\n        };\n        MarkerGLGlyph.prototype._set_visuals = function (nvertices) {\n            base_1.attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n            base_1.attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n            base_1.attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\n            // Static value for antialias. Smaller aa-region to obtain crisper images\n            return this.prog.set_uniform('u_antialias', 'float', [0.8]);\n        };\n        return MarkerGLGlyph;\n    }(base_1.BaseGLGlyph);\n    ;\n    // Base class for markers. All markers share the same GLSL, except for one\n    // function that defines the marker geometry.\n    MarkerGLGlyph.prototype.VERT = 'precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\n//\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size;\\nuniform vec2 u_offset;\\nuniform vec2 u_scale;\\nuniform float u_antialias;\\n//\\nattribute float a_x;\\nattribute float a_y;\\nattribute float a_size;\\nattribute float a_angle;  // in radians\\nattribute float a_linewidth;\\nattribute vec4  a_fg_color;\\nattribute vec4  a_bg_color;\\n//\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying vec2  v_rotation;\\n\\nvoid main (void)\\n{\\n    v_size = a_size * u_pixel_ratio;\\n    v_linewidth = a_linewidth * u_pixel_ratio;\\n    v_fg_color = a_fg_color;\\n    v_bg_color = a_bg_color;\\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\\n    // Calculate position - the -0.5 is to correct for canvas origin\\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\\n    pos += 0.5;  // make up for Bokeh\\'s offset\\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\\n}';\n    MarkerGLGlyph.prototype.FRAG = 'precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\nconst float PI = 3.14159265358979323846264;\\n//\\nuniform float u_antialias;\\n//\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec2  v_rotation;\\n\\nMARKERCODE\\n\\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\\n{\\n    vec4 frag_color;\\n    float t = linewidth/2.0 - antialias;\\n    float signed_distance = distance;\\n    float border_distance = abs(signed_distance) - t;\\n    float alpha = border_distance/antialias;\\n    alpha = exp(-alpha*alpha);\\n\\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\\n    float select = float(bool(fg_color.a));\\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\\n    // Similarly, if we want a transparent bg\\n    select = float(bool(bg_color.a));\\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\\n\\n    if( border_distance < 0.0)\\n        frag_color = fg_color;\\n    else if( signed_distance < 0.0 ) {\\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\\n    } else {\\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\\n        } else {\\n            discard;\\n        }\\n    }\\n    return frag_color;\\n}\\n\\nvoid main()\\n{\\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\\n             v_rotation.y*P.x + v_rotation.x*P.y);\\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\\n    float distance = marker(P*point_size, v_size);\\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\\n}';\n    MarkerGLGlyph.prototype.MARKERCODE = '<defined in subclasses>';\n    return MarkerGLGlyph;\n}();\nvar CircleGLGlyph = function (_super) {\n    tslib_1.__extends(CircleGLGlyph, _super);\n    function CircleGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CircleGLGlyph;\n}(MarkerGLGlyph);\nexports.CircleGLGlyph = CircleGLGlyph;\n;\nCircleGLGlyph.prototype.GLYPH = 'circle';\nCircleGLGlyph.prototype.MARKERCODE = '// --- disc\\nfloat marker(vec2 P, float size)\\n{\\n    return length(P) - size/2.0;\\n}';\nvar SquareGLGlyph = function (_super) {\n    tslib_1.__extends(SquareGLGlyph, _super);\n    function SquareGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return SquareGLGlyph;\n}(MarkerGLGlyph);\nexports.SquareGLGlyph = SquareGLGlyph;\n;\nSquareGLGlyph.prototype.GLYPH = 'square';\nSquareGLGlyph.prototype.MARKERCODE = '// --- square\\nfloat marker(vec2 P, float size)\\n{\\n    return max(abs(P.x), abs(P.y)) - size/2.0;\\n}';\nvar AnnulusGLGlyph = function (_super) {\n    tslib_1.__extends(AnnulusGLGlyph, _super);\n    function AnnulusGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return AnnulusGLGlyph;\n}(MarkerGLGlyph);\nexports.AnnulusGLGlyph = AnnulusGLGlyph;\n;\nAnnulusGLGlyph.prototype.GLYPH = 'annulus';\nAnnulusGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float r1 = length(P) - size/2.0;\\n    float r2 = length(P) - size/4.0;  // half width\\n    return max(r1, -r2);\\n}';\nvar DiamondGLGlyph = function (_super) {\n    tslib_1.__extends(DiamondGLGlyph, _super);\n    function DiamondGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DiamondGLGlyph;\n}(MarkerGLGlyph);\nexports.DiamondGLGlyph = DiamondGLGlyph;\n;\nDiamondGLGlyph.prototype.GLYPH = 'diamond';\nDiamondGLGlyph.prototype.MARKERCODE = '// --- diamond\\nfloat marker(vec2 P, float size)\\n{\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    return r1 / SQRT_2;\\n}';\nvar TriangleGLGlyph = function (_super) {\n    tslib_1.__extends(TriangleGLGlyph, _super);\n    function TriangleGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return TriangleGLGlyph;\n}(MarkerGLGlyph);\nexports.TriangleGLGlyph = TriangleGLGlyph;\n;\nTriangleGLGlyph.prototype.GLYPH = 'triangle';\nTriangleGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    P.y -= size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}';\nvar InvertedTriangleGLGlyph = function (_super) {\n    tslib_1.__extends(InvertedTriangleGLGlyph, _super);\n    function InvertedTriangleGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return InvertedTriangleGLGlyph;\n}(MarkerGLGlyph);\nexports.InvertedTriangleGLGlyph = InvertedTriangleGLGlyph;\n;\nInvertedTriangleGLGlyph.prototype.GLYPH = 'invertedtriangle';\nInvertedTriangleGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    P.y += size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = - P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}';\nvar CrossGLGlyph = function (_super) {\n    tslib_1.__extends(CrossGLGlyph, _super);\n    function CrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CrossGLGlyph;\n}(MarkerGLGlyph);\nexports.CrossGLGlyph = CrossGLGlyph;\n;\nCrossGLGlyph.prototype.GLYPH = 'cross';\nCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;  // 2.5 is a tweak\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return max(square, cross);\\n}';\nvar CircleCrossGLGlyph = function (_super) {\n    tslib_1.__extends(CircleCrossGLGlyph, _super);\n    function CircleCrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CircleCrossGLGlyph;\n}(MarkerGLGlyph);\nexports.CircleCrossGLGlyph = CircleCrossGLGlyph;\n;\nCircleCrossGLGlyph.prototype.GLYPH = 'circlecross';\nCircleCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar SquareCrossGLGlyph = function (_super) {\n    tslib_1.__extends(SquareCrossGLGlyph, _super);\n    function SquareCrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return SquareCrossGLGlyph;\n}(MarkerGLGlyph);\nexports.SquareCrossGLGlyph = SquareCrossGLGlyph;\n;\nSquareCrossGLGlyph.prototype.GLYPH = 'squarecross';\nSquareCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar DiamondCrossGLGlyph = function (_super) {\n    tslib_1.__extends(DiamondCrossGLGlyph, _super);\n    function DiamondCrossGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DiamondCrossGLGlyph;\n}(MarkerGLGlyph);\nexports.DiamondCrossGLGlyph = DiamondCrossGLGlyph;\n;\nDiamondCrossGLGlyph.prototype.GLYPH = 'diamondcross';\nDiamondCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    diamond /= SQRT_2;\\n    float c1 = max(diamond, s1);\\n    float c2 = max(diamond, s2);\\n    float c3 = max(diamond, s3);\\n    float c4 = max(diamond, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar XGLGlyph = function (_super) {\n    tslib_1.__extends(XGLGlyph, _super);\n    function XGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return XGLGlyph;\n}(MarkerGLGlyph);\nexports.XGLGlyph = XGLGlyph;\n;\nXGLGlyph.prototype.GLYPH = 'x';\nXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float circle = length(P) - size / 1.6;\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return max(circle, X);\\n}';\nvar CircleXGLGlyph = function (_super) {\n    tslib_1.__extends(CircleXGLGlyph, _super);\n    function CircleXGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CircleXGLGlyph;\n}(MarkerGLGlyph);\nexports.CircleXGLGlyph = CircleXGLGlyph;\n;\nCircleXGLGlyph.prototype.GLYPH = 'circlex';\nCircleXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    float almost = min(min(min(c1, c2), c3), c4);\\n    // In this case, the X is also outside of the main shape\\n    float Xmask = length(P) - size / 1.6;  // a circle\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return min(max(X, Xmask), almost);\\n}';\nvar SquareXGLGlyph = function (_super) {\n    tslib_1.__extends(SquareXGLGlyph, _super);\n    function SquareXGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return SquareXGLGlyph;\n}(MarkerGLGlyph);\nexports.SquareXGLGlyph = SquareXGLGlyph;\n;\nSquareXGLGlyph.prototype.GLYPH = 'squarex';\nSquareXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\nvar AsteriskGLGlyph = function (_super) {\n    tslib_1.__extends(AsteriskGLGlyph, _super);\n    function AsteriskGLGlyph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return AsteriskGLGlyph;\n}(MarkerGLGlyph);\nexports.AsteriskGLGlyph = AsteriskGLGlyph;\n;\nAsteriskGLGlyph.prototype.GLYPH = 'asterisk';\nAsteriskGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Masks\\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\\n    // Shapes\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    // Result is union of masked shapes\\n    return min(max(X, diamond), max(cross, square));\\n}';    \n"]}