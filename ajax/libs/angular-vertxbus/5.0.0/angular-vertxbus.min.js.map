{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-vertxbus.min.js","webpack:///webpack/bootstrap 926bb58af44ffe5bff48","webpack:///./src/index.js","webpack:///./src/module.js","webpack:///./src/config.js","webpack:///./src/lib/VertxEventBusWrapperProvider.js","webpack:///./src/lib/adapter/EventBusAdapter.js","webpack:///./src/lib/adapter/BaseAdapter.js","webpack:///./src/lib/support/ConnectionConfigHolder.js","webpack:///./src/lib/adapter/NoopAdapter.js","webpack:///./src/lib/VertxEventBusServiceProvider.js","webpack:///./src/lib/service/delegate/EventBusDelegate.js","webpack:///./src/lib/support/Queue.js","webpack:///./src/lib/support/SimpleMap.js","webpack:///./src/lib/service/delegate/BaseDelegate.js","webpack:///./src/lib/service/delegate/NoopDelegate.js","webpack:///./src/lib/service/Delegator.js"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_module","_module2","_config","_VertxEventBusWrapperProvider","_VertxEventBusWrapperProvider2","_VertxEventBusServiceProvider","_VertxEventBusServiceProvider2","angular","moduleName","provider","name","_EventBusAdapter","_EventBusAdapter2","_NoopAdapter","_NoopAdapter2","_ConnectionConfigHolder","_ConnectionConfigHolder2","_vertxEventbus","_vertxEventbus2","DEFAULTS","enabled","debugEnabled","initialConnectEnabled","urlServer","location","protocol","hostname","port","urlPath","reconnectEnabled","sockjsReconnectInterval","sockjsOptions","VertxEventBusWrapperProvider","_this","options","extend","enable","arguments","length","undefined","disableAutoConnect","useDebug","useUrlServer","useUrlPath","useReconnect","useSockJsReconnectInterval","useSockJsOptions","$get","$timeout","$log","$q","instanceOptions","debug","connectionConfig","$inject","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_BaseAdapter2","_BaseAdapter3","EventBusAdapter","_BaseAdapter","EventBus","_ref","getPrototypeOf","disconnectTimeoutEnabled","connect","_this2","deferred","defer","url","onopen","isFunction","resolve","onclose","onerror","message","promise","immediately","state","OPEN","close","address","headers","replyHandler","failureHandler","send","publish","handler","_this3","registerHandler","deconstructor","unregisterHandler","displayName","CLOSED","get","readyState","BaseAdapter","reject","ConnectionConfigHolder","_urlServer","_urlPath","NoopAdapter","_EventBusDelegate","_EventBusDelegate2","_NoopDelegate","_NoopDelegate2","_Delegator","_Delegator2","prefix","sockjsStateInterval","messageBuffer","VertxEventBusServiceProvider","usePrefix","useSockJsStateInterval","useMessageBuffer","$rootScope","$interval","vertxEventBus","getOptions","_Queue","_Queue2","_SimpleMap","_SimpleMap2","_BaseDelegate2","_BaseDelegate3","EventBusDelegate","_BaseDelegate","eventBus","loginRequired","loginInterceptor","connectionState","states","connected","validSession","observers","messageQueue","callbackMap","initialize","onEventbusOpen","onEventbusClose","connectionIntervalCheck","getConnectionState","connectionStateFlipped","afterEventbusConnected","$broadcast","$digest","size","fn","first","observer","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","err","callback","callbackWrapper","_ref2","replyTo","body","put","remove","_this4","timeout","expectReply","isNumber","timer","reply","cancel","ensureOpenAuthConnection","_this5","isConnectionOpen","_this6","fnWrapper","ensureOpenConnection","immediate","Queue","maxSize","items","item","recalibrateBufferSize","pop","shift","SimpleMap","clear","idx","_indexForKey","values","keys","_indexForValue","BaseDelegate","NoopDelegate","apply","Delegator","delegate","handlers","observe","callbacks","_step$value","unregisterFn","index","indexOf","splice","isObject","error","isEnabled","isConnected","username","password","login"],"mappings":"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","file":"dist/angular-vertxbus.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! angular-vertxbus - v5.0.0 - 2016-03-25\n * http://github.com/knalli/angular-vertxbus\n * Copyright (c) 2016 Jan Philipp\n * @license MIT */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _module = __webpack_require__(1);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _module2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _VertxEventBusWrapperProvider = __webpack_require__(3);\n\n\tvar _VertxEventBusWrapperProvider2 = _interopRequireDefault(_VertxEventBusWrapperProvider);\n\n\tvar _VertxEventBusServiceProvider = __webpack_require__(9);\n\n\tvar _VertxEventBusServiceProvider2 = _interopRequireDefault(_VertxEventBusServiceProvider);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc overview\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus\n\t * @description\n\t *\n\t * Client side library using VertX Event Bus as an Angular Service module\n\t *\n\t * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n\t *\n\t * <pre>\n\t *   angular.module('app', ['knalli.angular-vertxbus'])\n\t *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n\t *\n\t *       // using the EventBus directly\n\t *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n\t *         // your reply comes here\n\t *       });\n\t *\n\t *       // using the service\n\t *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n\t *         .then(function (reply) {\n\t *           // your reply comes here\n\t *         })\n\t *         .catch(function (err) {\n\t *           // something went wrong, no connection, no login, timed out, or so\n\t *         });\n\t *     });\n\t * </pre>\n\t *\n\t * The module itself provides following components:\n\t * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n\t * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n\t *\n\t * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n\t * reconnect management, authorization and a clean promise based api.\n\t *\n\t * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n\t * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n\t * underlying instance of the current `vertx.EventBus`.\n\t *\n\t * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n\t */\n\texports.default = angular.module(_config.moduleName, ['ng']).provider('vertxEventBus', _VertxEventBusWrapperProvider2.default).provider('vertxEventBusService', _VertxEventBusServiceProvider2.default).name;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar moduleName = 'knalli.angular-vertxbus';\n\n\texports.moduleName = moduleName;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _EventBusAdapter = __webpack_require__(4);\n\n\tvar _EventBusAdapter2 = _interopRequireDefault(_EventBusAdapter);\n\n\tvar _NoopAdapter = __webpack_require__(7);\n\n\tvar _NoopAdapter2 = _interopRequireDefault(_NoopAdapter);\n\n\tvar _ConnectionConfigHolder = __webpack_require__(6);\n\n\tvar _ConnectionConfigHolder2 = _interopRequireDefault(_ConnectionConfigHolder);\n\n\tvar _vertxEventbus = __webpack_require__(8);\n\n\tvar _vertxEventbus2 = _interopRequireDefault(_vertxEventbus);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc service\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus.vertxEventBusProvider\n\t * @description\n\t * An AngularJS wrapper for projects using the VertX Event Bus\n\t */\n\n\tvar DEFAULTS = {\n\t  enabled: true,\n\t  debugEnabled: false,\n\t  initialConnectEnabled: true,\n\t  urlServer: location.protocol + '//' + location.hostname + (function () {\n\t    if (location.port) {\n\t      return ':' + location.port;\n\t    }\n\t  }() || ''),\n\t  urlPath: '/eventbus',\n\t  reconnectEnabled: true,\n\t  sockjsReconnectInterval: 10000,\n\t  sockjsOptions: {}\n\t};\n\n\tvar VertxEventBusWrapperProvider = function VertxEventBusWrapperProvider() {\n\t  var _this = this;\n\n\t  // options (globally, application-wide)\n\t  var options = angular.extend({}, DEFAULTS);\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#enable\n\t   *\n\t   * @description\n\t   * Enables or disables the service. This setup is immutable.\n\t   *\n\t   * @param {boolean} [value=true] service is enabled on startup\n\t   * @returns {object} this\n\t   */\n\t  this.enable = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.enabled : arguments[0];\n\n\t    options.enabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#disableAutoConnect\n\t   *\n\t   * @description\n\t   * Disables the auto connection feature.\n\t   *\n\t   * This feature will be only available if `enable == true`.\n\t   *\n\t   * @param {boolean} [value=true] auto connect on startup\n\t   * @returns {object} this\n\t   */\n\t  this.disableAutoConnect = function () {\n\t    options.initialConnectEnabled = false;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useDebug\n\t   *\n\t   * @description\n\t   * Enables a verbose mode in which certain events will be logged to `$log`.\n\t   *\n\t   * @param {boolean} [value=false] verbose mode (using `$log`)\n\t   * @returns {object} this\n\t   */\n\t  this.useDebug = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.debugEnabled : arguments[0];\n\n\t    options.debugEnabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useUrlServer\n\t   *\n\t   * @description\n\t   * Overrides the url part \"server\" for connecting. The default is based on\n\t   * - `location.protocol`\n\t   * - `location.hostname`\n\t   * - `location.port`\n\t   *\n\t   * i.e. `http://domain.tld` or `http://domain.tld:port`\n\t   *\n\t   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n\t   * @returns {object} this\n\t   */\n\t  this.useUrlServer = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.urlServer : arguments[0];\n\n\t    options.urlServer = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useUrlPath\n\t   *\n\t   * @description\n\t   * Overrides the url part \"path\" for connection.\n\t   *\n\t   * @param {boolean} [value='/eventbus'] path to connect\n\t   * @returns {object} this\n\t   */\n\t  this.useUrlPath = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.urlPath : arguments[0];\n\n\t    options.urlPath = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useReconnect\n\t   *\n\t   * @description\n\t   * Enables or disables the automatic reconnect handling.\n\t   *\n\t   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n\t   * @returns {object} this\n\t   */\n\t  this.useReconnect = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.reconnectEnabled : arguments[0];\n\n\t    options.reconnectEnabled = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useSockJsReconnectInterval\n\t   *\n\t   * @description\n\t   * Overrides the timeout for reconnecting after a disconnect was found.\n\t   *\n\t   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsReconnectInterval = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsReconnectInterval : arguments[0];\n\n\t    options.sockjsReconnectInterval = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useSockJsOptions\n\t   *\n\t   * @description\n\t   * Sets additional params for the `SockJS` instance.\n\t   *\n\t   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n\t   *\n\t   * @param {boolean} [value={}]  optional params for raw SockJS options\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsOptions = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsOptions : arguments[0];\n\n\t    options.sockjsOptions = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc service\n\t   * @module knalli.angular-vertxbus\n\t   * @name knalli.angular-vertxbus.vertxEventBus\n\t   * @description\n\t   * A stub representing the Vert.x EventBus (core functionality)\n\t   *\n\t   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n\t   * new instance of the bus have to be created.\n\t   * This stub ensures only one object holding the current active instance of the bus.\n\t   *\n\t   * The stub supports theses Vert.x Event Bus APIs:\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n\t   *\n\t   * Furthermore, the stub supports theses extra APIs:\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n\t   *\n\t   * @requires $timeout\n\t   * @requires $log\n\t   */\n\t  /* @ngInject */\n\t  this.$get = function ($timeout, $log, $q) {\n\t    // Current options (merged defaults with application-wide settings)\n\t    var instanceOptions = angular.extend({}, DEFAULTS, options);\n\t    if (instanceOptions.enabled && _vertxEventbus2.default) {\n\t      if (instanceOptions.debugEnabled) {\n\t        $log.debug('[Vert.x EB Stub] Enabled');\n\t      }\n\n\t      // aggregate server connection params\n\t      instanceOptions.connectionConfig = new _ConnectionConfigHolder2.default({\n\t        urlServer: instanceOptions.urlServer,\n\t        urlPath: instanceOptions.urlPath\n\t      });\n\t      delete instanceOptions.urlServer;\n\t      delete instanceOptions.urlPath;\n\n\t      return new _EventBusAdapter2.default(_vertxEventbus2.default, $timeout, $log, $q, instanceOptions);\n\t    } else {\n\t      if (instanceOptions.debugEnabled) {\n\t        $log.debug('[Vert.x EB Stub] Disabled');\n\t      }\n\t      return new _NoopAdapter2.default(_vertxEventbus2.default, $q);\n\t    }\n\t  };\n\t  this.$get.$inject = [\"$timeout\", \"$log\", \"$q\"];\n\t};\n\n\texports.default = VertxEventBusWrapperProvider;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _BaseAdapter2 = __webpack_require__(5);\n\n\tvar _BaseAdapter3 = _interopRequireDefault(_BaseAdapter2);\n\n\tvar _ConnectionConfigHolder = __webpack_require__(6);\n\n\tvar _ConnectionConfigHolder2 = _interopRequireDefault(_ConnectionConfigHolder);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\t/**\n\t * @ngdoc service\n\t * @module global\n\t * @name global.EventBus\n\t *\n\t * @description\n\t * This is the interface of `EventBus`. It is not included.\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#close\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#send\n\t *\n\t * @param {string} address target address\n\t * @param {object} message payload message\n\t * @param {function=} replyHandler optional callback\n\t * @param {function=} failureHandler optional callback\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#publish\n\t *\n\t * @param {string} address target address\n\t * @param {object} message payload message\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#registerHandler\n\t *\n\t * @param {string} address target address\n\t * @param {function} handler callback handler\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#unregisterHandler\n\t *\n\t * @param {string} address target address\n\t * @param {function} handler callback handler to be removed\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onopen\n\t * @description\n\t * Defines the callback called on opening the connection.\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onclose\n\t * @description\n\t * Defines the callback called on closing the connection.\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onerror\n\t * @description\n\t * Defines the callback called on any error.\n\t */\n\n\tvar EventBusAdapter = function (_BaseAdapter) {\n\t  _inherits(EventBusAdapter, _BaseAdapter);\n\n\t  function EventBusAdapter(EventBus, $timeout, $log, $q, _ref) {\n\t    var enabled = _ref.enabled;\n\t    var debugEnabled = _ref.debugEnabled;\n\t    var initialConnectEnabled = _ref.initialConnectEnabled;\n\t    var connectionConfig = _ref.connectionConfig;\n\t    var reconnectEnabled = _ref.reconnectEnabled;\n\t    var sockjsReconnectInterval = _ref.sockjsReconnectInterval;\n\t    var sockjsOptions = _ref.sockjsOptions;\n\n\t    _classCallCheck(this, EventBusAdapter);\n\n\t    // actual EventBus type\n\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventBusAdapter).call(this, $q));\n\n\t    _this.EventBus = EventBus;\n\t    _this.$timeout = $timeout;\n\t    _this.$log = $log;\n\t    _this.$q = $q;\n\t    _this.options = {\n\t      enabled: enabled,\n\t      debugEnabled: debugEnabled,\n\t      initialConnectEnabled: initialConnectEnabled,\n\t      connectionConfig: connectionConfig,\n\t      reconnectEnabled: reconnectEnabled,\n\t      sockjsReconnectInterval: sockjsReconnectInterval,\n\t      sockjsOptions: sockjsOptions\n\t    };\n\t    _this.disconnectTimeoutEnabled = true;\n\t    if (initialConnectEnabled) {\n\t      // asap create connection\n\t      _this.connect();\n\t    }\n\t    return _this;\n\t  }\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t   * @name .#configureConnect\n\t   *\n\t   * @description\n\t   * Reconfigure the connection details.\n\t   *\n\t   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n\t   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n\t   */\n\n\n\t  _createClass(EventBusAdapter, [{\n\t    key: 'configureConnection',\n\t    value: function configureConnection(urlServer) {\n\t      var urlPath = arguments.length <= 1 || arguments[1] === undefined ? '/eventbus' : arguments[1];\n\n\t      this.options.connectionConfig = new _ConnectionConfigHolder2.default({ urlServer: urlServer, urlPath: urlPath });\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\n\t      // connect promise\n\t      var deferred = this.$q.defer();\n\t      // currently valid url\n\t      var url = '' + this.options.connectionConfig.urlServer + this.options.connectionConfig.urlPath;\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Stub] Enabled: connecting \\'' + url + '\\'');\n\t      }\n\t      // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n\t      // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n\t      this.instance = new this.EventBus(url, this.options.sockjsOptions);\n\t      this.instance.onopen = function () {\n\t        if (_this2.options.debugEnabled) {\n\t          _this2.$log.debug('[Vert.x EB Stub] Connected');\n\t        }\n\t        if (angular.isFunction(_this2.onopen)) {\n\t          _this2.onopen();\n\t        }\n\t        deferred.resolve();\n\t      };\n\t      // instance onClose handler\n\t      this.instance.onclose = function () {\n\t        if (_this2.options.debugEnabled) {\n\t          _this2.$log.debug('[Vert.x EB Stub] Reconnect in ' + _this2.options.sockjsReconnectInterval + 'ms');\n\t        }\n\t        if (angular.isFunction(_this2.onclose)) {\n\t          _this2.onclose();\n\t        }\n\t        _this2.instance = undefined;\n\n\t        if (!_this2.disconnectTimeoutEnabled) {\n\t          // reconnect required asap\n\t          if (_this2.options.debugEnabled) {\n\t            _this2.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n\t          }\n\t          _this2.disconnectTimeoutEnabled = true;\n\t          _this2.connect();\n\t        } else if (_this2.options.reconnectEnabled) {\n\t          // automatic reconnect after timeout\n\t          if (_this2.options.debugEnabled) {\n\t            _this2.$log.debug('[Vert.x EB Stub] Reconnect in ' + _this2.options.sockjsReconnectInterval + 'ms');\n\t          }\n\t          _this2.$timeout(function () {\n\t            return _this2.connect();\n\t          }, _this2.options.sockjsReconnectInterval);\n\t        }\n\t      };\n\t      // instance onError handler\n\t      this.instance.onerror = function (message) {\n\t        if (angular.isFunction(_this2.onerror)) {\n\t          _this2.onerror(message);\n\t        }\n\t      };\n\t      return deferred.promise;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#reconnect\n\t     *\n\t     * @description\n\t     * Reconnects the underlying connection.\n\t     *\n\t     * Unless a connection is open, it will connect using a new one.\n\t     *\n\t     * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n\t     * default timeout for reconnect will be skipped.\n\t     *\n\t     * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n\t     */\n\n\t  }, {\n\t    key: 'reconnect',\n\t    value: function reconnect() {\n\t      var immediately = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n\t      if (this.instance && this.instance.state === this.EventBus.OPEN) {\n\t        if (immediately) {\n\t          this.disconnectTimeoutEnabled = false;\n\t        }\n\t        this.instance.close();\n\t      } else {\n\t        this.connect();\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#close\n\t     *\n\t     * @description\n\t     * Closes the underlying connection.\n\t     *\n\t     * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n\t     *\n\t     * See also:\n\t     * - {@link EventBus#methods_close EventBus.close()}\n\t     */\n\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      if (this.instance) {\n\t        this.instance.close();\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#send\n\t     *\n\t     * @description\n\t     * Sends a message\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_send EventBus.send()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers\n\t     * @param {function=} replyHandler optional callback\n\t     * @param {function=} failureHandler optional callback (since Vert.x 3.0.0)\n\t     */\n\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message, headers, replyHandler, failureHandler) {\n\t      if (this.instance) {\n\t        if (angular.isFunction(headers)) {\n\t          failureHandler = replyHandler;\n\t          replyHandler = headers;\n\t          headers = undefined;\n\t        }\n\t        this.instance.send(address, message, headers, replyHandler, failureHandler);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#publish\n\t     *\n\t     * @description\n\t     * Publishes a message\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_publish EventBus.publish()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers optional headers\n\t     */\n\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message, headers) {\n\t      if (this.instance) {\n\t        this.instance.publish(address, message, headers);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#registerHandler\n\t     *\n\t     * @description\n\t     * Registers a listener\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} handler callback handler\n\t     */\n\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, handler) {\n\t      var _this3 = this;\n\n\t      if (this.instance) {\n\t        if (angular.isFunction(headers) && !handler) {\n\t          handler = headers;\n\t          headers = undefined;\n\t        }\n\t        this.instance.registerHandler(address, headers, handler);\n\t        // and return the deregister callback\n\t        var deconstructor = function deconstructor() {\n\t          _this3.unregisterHandler(address, headers, handler);\n\t        };\n\t        deconstructor.displayName = _config.moduleName + '.wrapper.eventbus.registerHandler.deconstructor';\n\t        return deconstructor;\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#unregisterHandler\n\t     *\n\t     * @description\n\t     * Removes a registered a listener\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} handler callback handler to be removed\n\t     */\n\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, handler) {\n\t      if (this.instance && this.instance.state === this.EventBus.OPEN) {\n\t        if (angular.isFunction(headers) && !handler) {\n\t          handler = headers;\n\t          headers = undefined;\n\t        }\n\t        this.instance.unregisterHandler(address, headers, handler);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#readyState\n\t     *\n\t     * @description\n\t     * Returns the current connection state\n\t     *\n\t     * @returns {number} value of vertx-eventbus connection states\n\t     */\n\n\t  }, {\n\t    key: 'readyState',\n\t    value: function readyState() {\n\t      if (this.instance) {\n\t        return this.instance.state;\n\t      } else {\n\t        return this.EventBus.CLOSED;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getOptions',\n\n\n\t    // private\n\t    value: function getOptions() {\n\t      // clone options\n\t      return angular.extend({}, this.options);\n\t    }\n\t  }, {\n\t    key: 'state',\n\t    get: function get() {\n\t      return this.readyState();\n\t    }\n\t  }]);\n\n\t  return EventBusAdapter;\n\t}(_BaseAdapter3.default);\n\n\texports.default = EventBusAdapter;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar BaseAdapter = function () {\n\t  function BaseAdapter($q) {\n\t    _classCallCheck(this, BaseAdapter);\n\n\t    this.$q = $q;\n\t  }\n\n\t  _createClass(BaseAdapter, [{\n\t    key: \"configureConnection\",\n\t    value: function configureConnection() {}\n\t  }, {\n\t    key: \"connect\",\n\t    value: function connect() {\n\t      return this.$q.reject();\n\t    }\n\t  }, {\n\t    key: \"reconnect\",\n\t    value: function reconnect() {}\n\t  }, {\n\t    key: \"close\",\n\t    value: function close() {}\n\t  }, {\n\t    key: \"send\",\n\t    value: function send() {}\n\t  }, {\n\t    key: \"publish\",\n\t    value: function publish() {}\n\t  }, {\n\t    key: \"registerHandler\",\n\t    value: function registerHandler() {}\n\t  }, {\n\t    key: \"unregisterHandler\",\n\t    value: function unregisterHandler() {}\n\t  }, {\n\t    key: \"readyState\",\n\t    value: function readyState() {}\n\t  }, {\n\t    key: \"getOptions\",\n\t    value: function getOptions() {\n\t      return {};\n\t    }\n\n\t    // empty: can be overriden by externals\n\n\t  }, {\n\t    key: \"onopen\",\n\t    value: function onopen() {}\n\n\t    // empty: can be overriden by externals\n\n\t  }, {\n\t    key: \"onclose\",\n\t    value: function onclose() {}\n\t  }]);\n\n\t  return BaseAdapter;\n\t}();\n\n\texports.default = BaseAdapter;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar ConnectionConfigHolder = function () {\n\t  function ConnectionConfigHolder(_ref) {\n\t    var urlServer = _ref.urlServer;\n\t    var urlPath = _ref.urlPath;\n\n\t    _classCallCheck(this, ConnectionConfigHolder);\n\n\t    this._urlServer = urlServer;\n\t    this._urlPath = urlPath;\n\t  }\n\n\t  _createClass(ConnectionConfigHolder, [{\n\t    key: \"urlServer\",\n\t    get: function get() {\n\t      return this._urlServer;\n\t    }\n\t  }, {\n\t    key: \"urlPath\",\n\t    get: function get() {\n\t      return this._urlPath;\n\t    }\n\t  }]);\n\n\t  return ConnectionConfigHolder;\n\t}();\n\n\texports.default = ConnectionConfigHolder;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _BaseAdapter2 = __webpack_require__(5);\n\n\tvar _BaseAdapter3 = _interopRequireDefault(_BaseAdapter2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tvar NoopAdapter = function (_BaseAdapter) {\n\t  _inherits(NoopAdapter, _BaseAdapter);\n\n\t  function NoopAdapter(EventBus, $q) {\n\t    _classCallCheck(this, NoopAdapter);\n\n\t    // actual EventBus type\n\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NoopAdapter).call(this, $q));\n\n\t    _this.EventBus = EventBus;\n\t    return _this;\n\t  }\n\n\t  return NoopAdapter;\n\t}(_BaseAdapter3.default);\n\n\texports.default = NoopAdapter;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _EventBusDelegate = __webpack_require__(10);\n\n\tvar _EventBusDelegate2 = _interopRequireDefault(_EventBusDelegate);\n\n\tvar _NoopDelegate = __webpack_require__(14);\n\n\tvar _NoopDelegate2 = _interopRequireDefault(_NoopDelegate);\n\n\tvar _Delegator = __webpack_require__(15);\n\n\tvar _Delegator2 = _interopRequireDefault(_Delegator);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc service\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t * @description\n\t * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n\t */\n\n\tvar DEFAULTS = {\n\t  enabled: true,\n\t  debugEnabled: false,\n\t  prefix: 'vertx-eventbus.',\n\t  sockjsStateInterval: 10000,\n\t  messageBuffer: 10000\n\t};\n\n\tvar VertxEventBusServiceProvider = function VertxEventBusServiceProvider() {\n\t  var _this = this;\n\n\t  // options (globally, application-wide)\n\t  var options = angular.extend({}, DEFAULTS);\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#enable\n\t   *\n\t   * @description\n\t   * Enables or disables the service. This setup is immutable.\n\t   *\n\t   * @param {boolean} [value=true] service is enabled on startup\n\t   * @returns {object} this\n\t   */\n\t  this.enable = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.enabled : arguments[0];\n\n\t    options.enabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useDebug\n\t   *\n\t   * @description\n\t   * Enables a verbose mode in which certain events will be logged to `$log`.\n\t   *\n\t   * @param {boolean} [value=false] verbose mode (using `$log`)\n\t   * @returns {object} this\n\t   */\n\t  this.useDebug = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.debugEnabled : arguments[0];\n\n\t    options.debugEnabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#usePrefix\n\t   *\n\t   * @description\n\t   * Overrides the default prefix which will be used for emitted events.\n\t   *\n\t   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n\t   * @returns {object} this\n\t   */\n\t  this.usePrefix = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.prefix : arguments[0];\n\n\t    options.prefix = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useSockJsStateInterval\n\t   *\n\t   *\n\t   * @description\n\t   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n\t   *\n\t   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsStateInterval = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsStateInterval : arguments[0];\n\n\t    options.sockjsStateInterval = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useMessageBuffer\n\t   *\n\t   * @description\n\t   * Enables buffering of (sending) messages.\n\t   *\n\t   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n\t   * connection is still in progress, the connection is stale or a login is required/pending.\n\t   *\n\t   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n\t   * @returns {object} this\n\t   */\n\t  this.useMessageBuffer = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.messageBuffer : arguments[0];\n\n\t    options.messageBuffer = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc service\n\t   * @module knalli.angular-vertxbus\n\t   * @name knalli.angular-vertxbus.vertxEventBusService\n\t   * @description\n\t   * A service utilizing an underlying Vert.x Event Bus\n\t   *\n\t   * The advanced features of this service are:\n\t   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n\t   *  - registering all handlers again when a reconnect had been required\n\t   *  - supporting a promise when using send()\n\t   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n\t   *\n\t   * Basic usage:\n\t   * <pre>\n\t   * module.controller('MyController', function('vertxEventService') {\n\t  *   vertxEventService.on('my.address', function(message) {\n\t  *     console.log(\"JSON Message received: \", message)\n\t  *   });\n\t  *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n\t  * });\n\t   * </pre>\n\t   *\n\t   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n\t   *\n\t   * @requires knalli.angular-vertxbus.vertxEventBus\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires $interval\n\t   * @requires $log\n\t   */\n\t  /* @ngInject */\n\t  this.$get = function ($rootScope, $q, $interval, vertxEventBus, $log) {\n\t    // Current options (merged defaults with application-wide settings)\n\t    var instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n\t    if (instanceOptions.enabled) {\n\t      return new _Delegator2.default(new _EventBusDelegate2.default($rootScope, $interval, $log, $q, vertxEventBus, instanceOptions), $log);\n\t    } else {\n\t      return new _Delegator2.default(new _NoopDelegate2.default());\n\t    }\n\t  };\n\t  this.$get.$inject = [\"$rootScope\", \"$q\", \"$interval\", \"vertxEventBus\", \"$log\"];\n\t};\n\n\texports.default = VertxEventBusServiceProvider;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _Queue = __webpack_require__(11);\n\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\n\tvar _SimpleMap = __webpack_require__(12);\n\n\tvar _SimpleMap2 = _interopRequireDefault(_SimpleMap);\n\n\tvar _BaseDelegate2 = __webpack_require__(13);\n\n\tvar _BaseDelegate3 = _interopRequireDefault(_BaseDelegate2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name disconnected\n\t *\n\t * @description\n\t * After a connection was being terminated.\n\t *\n\t * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name connected\n\t *\n\t * @description\n\t * After a connection was being established\n\t *\n\t * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name login-succeeded\n\t *\n\t * @description\n\t * After a login has been validated successfully\n\t *\n\t * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t *\n\t * @param {object} data data\n\t * @param {boolean} data.status must be `'ok'`\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name login-failed\n\t *\n\t * @description\n\t * After a login has been destroyed or was invalidated\n\t *\n\t * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t *\n\t * @param {object} data data\n\t * @param {boolean} data.status must be not`'ok'`\n\t */\n\n\tvar EventBusDelegate = function (_BaseDelegate) {\n\t  _inherits(EventBusDelegate, _BaseDelegate);\n\n\t  function EventBusDelegate($rootScope, $interval, $log, $q, eventBus, _ref) {\n\t    var enabled = _ref.enabled;\n\t    var debugEnabled = _ref.debugEnabled;\n\t    var prefix = _ref.prefix;\n\t    var sockjsStateInterval = _ref.sockjsStateInterval;\n\t    var messageBuffer = _ref.messageBuffer;\n\t    var loginRequired = _ref.loginRequired;\n\t    var loginInterceptor = _ref.loginInterceptor;\n\n\t    _classCallCheck(this, EventBusDelegate);\n\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventBusDelegate).call(this));\n\n\t    _this.$rootScope = $rootScope;\n\t    _this.$interval = $interval;\n\t    _this.$log = $log;\n\t    _this.$q = $q;\n\t    _this.eventBus = eventBus;\n\t    _this.options = {\n\t      enabled: enabled,\n\t      debugEnabled: debugEnabled,\n\t      prefix: prefix,\n\t      sockjsStateInterval: sockjsStateInterval,\n\t      messageBuffer: messageBuffer,\n\t      loginRequired: loginRequired\n\t    };\n\t    _this.loginInterceptor = loginInterceptor;\n\t    _this.connectionState = _this.eventBus.EventBus.CLOSED;\n\t    _this.states = {\n\t      connected: false,\n\t      validSession: false\n\t    };\n\t    _this.observers = [];\n\t    // internal store of buffered messages\n\t    _this.messageQueue = new _Queue2.default(_this.options.messageBuffer);\n\t    // internal map of callbacks\n\t    _this.callbackMap = new _SimpleMap2.default();\n\t    // asap\n\t    _this.initialize();\n\t    return _this;\n\t  }\n\n\t  // internal\n\n\n\t  _createClass(EventBusDelegate, [{\n\t    key: 'initialize',\n\t    value: function initialize() {\n\t      var _this2 = this;\n\n\t      this.eventBus.onopen = function () {\n\t        return _this2.onEventbusOpen();\n\t      };\n\t      this.eventBus.onclose = function () {\n\t        return _this2.onEventbusClose();\n\t      };\n\n\t      // Update the current connection state periodically.\n\t      var connectionIntervalCheck = function connectionIntervalCheck() {\n\t        return _this2.getConnectionState(true);\n\t      };\n\t      connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n\t      this.$interval(function () {\n\t        return connectionIntervalCheck();\n\t      }, this.options.sockjsStateInterval);\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'onEventbusOpen',\n\t    value: function onEventbusOpen() {\n\t      var connectionStateFlipped = false;\n\t      this.getConnectionState(true);\n\t      if (!this.states.connected) {\n\t        this.states.connected = true;\n\t        connectionStateFlipped = true;\n\t      }\n\t      // Ensure all events will be re-attached\n\t      this.afterEventbusConnected();\n\t      // Everything is online and registered again, let's notify everybody\n\t      if (connectionStateFlipped) {\n\t        this.$rootScope.$broadcast(this.options.prefix + 'system.connected');\n\t      }\n\t      this.$rootScope.$digest(); // explicitly\n\t      // consume message queue?\n\t      if (this.options.messageBuffer && this.messageQueue.size()) {\n\t        while (this.messageQueue.size()) {\n\t          var fn = this.messageQueue.first();\n\t          if (angular.isFunction(fn)) {\n\t            fn();\n\t          }\n\t        }\n\t        this.$rootScope.$digest();\n\t      }\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'onEventbusClose',\n\t    value: function onEventbusClose() {\n\t      this.getConnectionState(true);\n\t      if (this.states.connected) {\n\t        this.states.connected = false;\n\t        this.$rootScope.$broadcast(this.options.prefix + 'system.disconnected');\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#observe\n\t     *\n\t     * @description\n\t     * Adds an observer\n\t     *\n\t     * @param {object} observer observer\n\t     * @param {function=} observer.afterEventbusConnected will be called after establishing a new connection\n\t     */\n\n\t  }, {\n\t    key: 'observe',\n\t    value: function observe(observer) {\n\t      this.observers.push(observer);\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'afterEventbusConnected',\n\t    value: function afterEventbusConnected() {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\n\t      try {\n\t        for (var _iterator = this.observers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var observer = _step.value;\n\n\t          if (angular.isFunction(observer.afterEventbusConnected)) {\n\t            observer.afterEventbusConnected();\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#registerHandler\n\t     *\n\t     * @description\n\t     * Registers a callback handler for the specified address match.\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} callback handler with params `(message, replyTo)`\n\t     * @returns {function=} deconstructor\n\t     */\n\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, callback) {\n\t      var _this3 = this;\n\n\t      if (angular.isFunction(headers) && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      if (!angular.isFunction(callback)) {\n\t        return;\n\t      }\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Service] Register handler for ' + address);\n\t      }\n\t      var callbackWrapper = function callbackWrapper(err, _ref2, replyTo) {\n\t        var body = _ref2.body;\n\n\t        callback(body, replyTo);\n\t        _this3.$rootScope.$digest();\n\t      };\n\t      callbackWrapper.displayName = _config.moduleName + '.service.delegate.live.registerHandler.callbackWrapper';\n\t      this.callbackMap.put(callback, callbackWrapper);\n\t      return this.eventBus.registerHandler(address, headers, callbackWrapper);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#unregisterHandler\n\t     *\n\t     * @description\n\t     * Removes a callback handler for the specified address match.\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} callback handler with params `(message, replyTo)`\n\t     */\n\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, callback) {\n\t      if (angular.isFunction(headers) && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      if (!angular.isFunction(callback)) {\n\t        return;\n\t      }\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Service] Unregister handler for ' + address);\n\t      }\n\t      this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n\t      this.callbackMap.remove(callback);\n\t    }\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#send\n\t     *\n\t     * @description\n\t     * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers\n\t     * @param {number=} [timeout=10000] timeout (in ms) after which the promise will be rejected\n\t     * @param {boolean=} [expectReply=true] if false, the promise will be resolved directly and\n\t     *                                       no replyHandler will be created\n\t     * @returns {object} promise\n\t     */\n\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message, headers) {\n\t      var _this4 = this;\n\n\t      var timeout = arguments.length <= 3 || arguments[3] === undefined ? 10000 : arguments[3];\n\t      var expectReply = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];\n\n\t      if (angular.isNumber(headers)) {\n\t        if (typeof timeout === 'boolean') {\n\t          expectReply = timeout;\n\t        }\n\t        timeout = headers;\n\t        headers = undefined;\n\t      }\n\t      var deferred = this.$q.defer();\n\t      var next = function next() {\n\t        if (expectReply) {\n\t          (function () {\n\t            // Register timeout for promise rejecting\n\t            var timer = _this4.$interval(function () {\n\t              if (_this4.options.debugEnabled) {\n\t                _this4.$log.debug('[Vert.x EB Service] send(\\'' + address + '\\') timed out');\n\t              }\n\t              deferred.reject();\n\t            }, timeout, 1);\n\t            // Send message\n\t            _this4.eventBus.send(address, message, headers, function (err, reply) {\n\t              _this4.$interval.cancel(timer); // because it's resolved\n\t              if (err) {\n\t                deferred.reject(err);\n\t              } else {\n\t                deferred.resolve(reply);\n\t              }\n\t            }, function (err) {\n\t              _this4.$interval.cancel(timer); // because it's resolved\n\t              deferred.reject(err);\n\t            });\n\t          })();\n\t        } else {\n\t          _this4.eventBus.send(address, message, headers);\n\t          deferred.resolve(); // we don't care\n\t        }\n\t      };\n\t      next.displayName = _config.moduleName + '.service.delegate.live.send.next';\n\t      if (!this.ensureOpenAuthConnection(next)) {\n\t        deferred.reject();\n\t      }\n\t      return deferred.promise;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#publish\n\t     *\n\t     * @description\n\t     * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers optional headers\n\t     * @returns {boolean} false if cannot be send or queued\n\t     */\n\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message, headers) {\n\t      var _this5 = this;\n\n\t      return this.ensureOpenAuthConnection(function () {\n\t        return _this5.eventBus.publish(address, message, headers);\n\t      });\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#ensureOpenConnection\n\t     *\n\t     * @description\n\t     * Ensures the callback will be performed with an open connection.\n\t     *\n\t     * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n\t     *\n\t     * @param {function} fn callback\n\t     * @returns {boolean} false if the callback cannot be performed or queued\n\t     */\n\n\t  }, {\n\t    key: 'ensureOpenConnection',\n\t    value: function ensureOpenConnection(fn) {\n\t      if (this.isConnectionOpen()) {\n\t        fn();\n\t        return true;\n\t      } else if (this.options.messageBuffer) {\n\t        this.messageQueue.push(fn);\n\t        return true;\n\t      }\n\t      return false;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#ensureOpenAuthConnection\n\t     *\n\t     * @description\n\t     * Ensures the callback will be performed with a valid session.\n\t     *\n\t     * Unless `loginRequired` is enabled, this will be simple forward.\n\t     *\n\t     * Unless a valid session exist (but required), the callback will be not invoked.\n\t     *\n\t     * @param {function} fn callback\n\t     * @returns {boolean} false if the callback cannot be performed or queued\n\t     */\n\n\t  }, {\n\t    key: 'ensureOpenAuthConnection',\n\t    value: function ensureOpenAuthConnection(fn) {\n\t      var _this6 = this;\n\n\t      if (!this.options.loginRequired) {\n\t        // easy: no login required\n\t        return this.ensureOpenConnection(fn);\n\t      } else {\n\t        var fnWrapper = function fnWrapper() {\n\t          if (_this6.states.validSession) {\n\t            fn();\n\t            return true;\n\t          } else {\n\t            // ignore this message\n\t            if (_this6.options.debugEnabled) {\n\t              _this6.$log.debug('[Vert.x EB Service] Message was not sent because login is required');\n\t            }\n\t            return false;\n\t          }\n\t        };\n\t        fnWrapper.displayName = _config.moduleName + '.service.delegate.live.ensureOpenAuthConnection.fnWrapper';\n\t        return this.ensureOpenConnection(fnWrapper);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#getConnectionState\n\t     *\n\t     * @description\n\t     * Returns the current connection state. The state is being cached internally.\n\t     *\n\t     * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n\t     * @returns {number} state type of vertx.EventBus\n\t     */\n\n\t  }, {\n\t    key: 'getConnectionState',\n\t    value: function getConnectionState(immediate) {\n\t      if (this.options.enabled) {\n\t        if (immediate) {\n\t          this.connectionState = this.eventBus.state;\n\t        }\n\t      } else {\n\t        this.connectionState = this.eventBus.EventBus.CLOSED;\n\t      }\n\t      return this.connectionState;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isConnectionOpen\n\t     *\n\t     * @description\n\t     * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n\t     *\n\t     * @returns {boolean} connection open state\n\t     */\n\n\t  }, {\n\t    key: 'isConnectionOpen',\n\t    value: function isConnectionOpen() {\n\t      return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isValidSession\n\t     *\n\t     * @description\n\t     * Returns true if the session is valid\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isValidSession',\n\t    value: function isValidSession() {\n\t      return this.states.validSession;\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return this.states.connected;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isEnabled\n\t     *\n\t     * @description\n\t     * Returns true if service is being enabled.\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isEnabled',\n\t    value: function isEnabled() {\n\t      return this.options.enabled;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isConnectionOpen\n\t     *\n\t     * @description\n\t     * Returns the current amount of messages in the internal buffer.\n\t     *\n\t     * @returns {number} amount\n\t     */\n\n\t  }, {\n\t    key: 'getMessageQueueLength',\n\t    value: function getMessageQueueLength() {\n\t      return this.messageQueue.size();\n\t    }\n\t  }]);\n\n\t  return EventBusDelegate;\n\t}(_BaseDelegate3.default);\n\n\texports.default = EventBusDelegate;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/*\n\t Simple queue implementation\n\n\t FIFO: #push() + #first()\n\t LIFO: #push() + #last()\n\t */\n\n\tvar Queue = function () {\n\t  function Queue() {\n\t    var maxSize = arguments.length <= 0 || arguments[0] === undefined ? 10 : arguments[0];\n\n\t    _classCallCheck(this, Queue);\n\n\t    this.maxSize = maxSize;\n\t    this.items = [];\n\t  }\n\n\t  _createClass(Queue, [{\n\t    key: \"push\",\n\t    value: function push(item) {\n\t      this.items.push(item);\n\t      return this.recalibrateBufferSize();\n\t    }\n\t  }, {\n\t    key: \"recalibrateBufferSize\",\n\t    value: function recalibrateBufferSize() {\n\t      while (this.items.length > this.maxSize) {\n\t        this.first();\n\t      }\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"last\",\n\t    value: function last() {\n\t      return this.items.pop();\n\t    }\n\t  }, {\n\t    key: \"first\",\n\t    value: function first() {\n\t      return this.items.shift(0);\n\t    }\n\t  }, {\n\t    key: \"size\",\n\t    value: function size() {\n\t      return this.items.length;\n\t    }\n\t  }]);\n\n\t  return Queue;\n\t}();\n\n\texports.default = Queue;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/*\n\t Simple Map implementation\n\n\t This implementation allows usage of non serializable keys for values.\n\t */\n\n\tvar SimpleMap = function () {\n\t  function SimpleMap() {\n\t    _classCallCheck(this, SimpleMap);\n\n\t    this.clear();\n\t  }\n\n\t  // Stores the value under the key.\n\t  // Chainable\n\n\n\t  _createClass(SimpleMap, [{\n\t    key: \"put\",\n\t    value: function put(key, value) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        this.values[idx] = value;\n\t      } else {\n\t        this.keys.push(key);\n\t        this.values.push(value);\n\t      }\n\t      return this;\n\t    }\n\n\t    // Returns value for key, otherwise undefined.\n\n\t  }, {\n\t    key: \"get\",\n\t    value: function get(key) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        return this.values[idx];\n\t      }\n\t    }\n\n\t    // Returns true if the key exists.\n\n\t  }, {\n\t    key: \"containsKey\",\n\t    value: function containsKey(key) {\n\t      var idx = this._indexForKey(key);\n\t      return idx > -1;\n\t    }\n\n\t    // Returns true if the value exists.\n\n\t  }, {\n\t    key: \"containsValue\",\n\t    value: function containsValue(value) {\n\t      var idx = this._indexForValue(value);\n\t      return idx > -1;\n\t    }\n\n\t    // Removes the key and its value.\n\n\t  }, {\n\t    key: \"remove\",\n\t    value: function remove(key) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        this.keys[idx] = undefined;\n\t        this.values[idx] = undefined;\n\t      }\n\t    }\n\n\t    // Clears all keys and values.\n\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      this.keys = [];\n\t      this.values = [];\n\t      return this;\n\t    }\n\n\t    // Returns index of key, otherwise -1.\n\n\t  }, {\n\t    key: \"_indexForKey\",\n\t    value: function _indexForKey(key) {\n\t      for (var i in this.keys) {\n\t        if (key === this.keys[i]) {\n\t          return i;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }, {\n\t    key: \"_indexForValue\",\n\t    value: function _indexForValue(value) {\n\t      for (var i in this.values) {\n\t        if (value === this.values[i]) {\n\t          return i;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }]);\n\n\t  return SimpleMap;\n\t}();\n\n\texports.default = SimpleMap;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar BaseDelegate = function () {\n\t  function BaseDelegate() {\n\t    _classCallCheck(this, BaseDelegate);\n\t  }\n\n\t  _createClass(BaseDelegate, [{\n\t    key: \"getConnectionState\",\n\t    value: function getConnectionState() {\n\t      return 3; // CLOSED\n\t    }\n\t  }, {\n\t    key: \"isConnectionOpen\",\n\t    value: function isConnectionOpen() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isValidSession\",\n\t    value: function isValidSession() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isEnabled\",\n\t    value: function isEnabled() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isConnected\",\n\t    value: function isConnected() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"send\",\n\t    value: function send() {}\n\t  }, {\n\t    key: \"publish\",\n\t    value: function publish() {}\n\t  }]);\n\n\t  return BaseDelegate;\n\t}();\n\n\texports.default = BaseDelegate;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _BaseDelegate2 = __webpack_require__(13);\n\n\tvar _BaseDelegate3 = _interopRequireDefault(_BaseDelegate2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tvar NoopDelegate = function (_BaseDelegate) {\n\t  _inherits(NoopDelegate, _BaseDelegate);\n\n\t  function NoopDelegate() {\n\t    _classCallCheck(this, NoopDelegate);\n\n\t    return _possibleConstructorReturn(this, Object.getPrototypeOf(NoopDelegate).apply(this, arguments));\n\t  }\n\n\t  return NoopDelegate;\n\t}(_BaseDelegate3.default);\n\n\texports.default = NoopDelegate;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar Delegator = function () {\n\t  function Delegator(delegate, $log) {\n\t    var _this = this;\n\n\t    _classCallCheck(this, Delegator);\n\n\t    this.delegate = delegate;\n\t    this.$log = $log;\n\t    this.handlers = [];\n\t    this.delegate.observe({\n\t      afterEventbusConnected: function afterEventbusConnected() {\n\t        return _this.afterEventbusConnected();\n\t      }\n\t    });\n\t  }\n\n\t  _createClass(Delegator, [{\n\t    key: 'afterEventbusConnected',\n\t    value: function afterEventbusConnected() {\n\t      for (var address in this.handlers) {\n\t        var callbacks = this.handlers[address];\n\t        if (callbacks && callbacks.length) {\n\t          var _iteratorNormalCompletion = true;\n\t          var _didIteratorError = false;\n\t          var _iteratorError = undefined;\n\n\t          try {\n\t            for (var _iterator = callbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t              var _step$value = _step.value;\n\t              var headers = _step$value.headers;\n\t              var callback = _step$value.callback;\n\n\t              this.delegate.registerHandler(address, headers, callback);\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError) {\n\t                throw _iteratorError;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, callback) {\n\t      var _this2 = this;\n\n\t      if (angular.isFunction(headers) && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      if (!this.handlers[address]) {\n\t        this.handlers[address] = [];\n\t      }\n\t      var handler = { headers: headers, callback: callback };\n\t      this.handlers[address].push(handler);\n\t      var unregisterFn = null;\n\t      if (this.delegate.isConnectionOpen()) {\n\t        this.delegate.registerHandler(address, headers, callback);\n\t        unregisterFn = function unregisterFn() {\n\t          return _this2.delegate.unregisterHandler(address, headers, callback);\n\t        };\n\t      }\n\t      // and return the deregister callback\n\t      var deconstructor = function deconstructor() {\n\t        if (unregisterFn) {\n\t          unregisterFn();\n\t          unregisterFn = undefined;\n\t        }\n\t        // Remove from internal map\n\t        if (_this2.handlers[address]) {\n\t          var index = _this2.handlers[address].indexOf(handler);\n\t          if (index > -1) {\n\t            _this2.handlers[address].splice(index, 1);\n\t          }\n\t          if (_this2.handlers[address].length < 1) {\n\t            _this2.handlers[address] = undefined;\n\t          }\n\t        }\n\t      };\n\t      deconstructor.displayName = _config.moduleName + '.service.registerHandler.deconstructor';\n\t      return deconstructor;\n\t    }\n\t  }, {\n\t    key: 'on',\n\t    value: function on(address, headers, callback) {\n\t      if (typeof headers === 'function' && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      return this.registerHandler(address, headers, callback);\n\t    }\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(address, headers, callback) {\n\t      if (typeof headers === 'function' && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      return this.registerHandler(address, headers, callback);\n\t    }\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, callback) {\n\t      if (typeof headers === 'function' && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      // Remove from internal map\n\t      if (this.handlers[address]) {\n\t        var index = this.handlers[address].indexOf({ headers: headers, callback: callback });\n\t        if (index > -1) {\n\t          this.handlers[address].splice(index, 1);\n\t        }\n\t        if (this.handlers[address].length < 1) {\n\t          this.handlers[address] = undefined;\n\t        }\n\t      }\n\t      // Remove from real instance\n\t      if (this.delegate.isConnectionOpen()) {\n\t        this.delegate.unregisterHandler(address, headers, callback);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'un',\n\t    value: function un(address, headers, callback) {\n\t      if (typeof headers === 'function' && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      return this.unregisterHandler(address, headers, callback);\n\t    }\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(address, headers, callback) {\n\t      if (typeof headers === 'function' && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      return this.unregisterHandler(address, headers, callback);\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message) {\n\t      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\n\t      // FALLBACK: signature change since 2.0\n\t      if (!angular.isObject(options)) {\n\t        this.$log.error(_config.moduleName + ': Signature of vertxEventBusService.send() has been changed!');\n\t        return this.send(address, message, {\n\t          timeout: arguments[2] !== undefined ? arguments[2] : 10000,\n\t          expectReply: arguments[3] !== undefined ? arguments[3] : true\n\t        });\n\t      }\n\n\t      return this.delegate.send(address, message, options.timeout, options.expectReply);\n\t    }\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message) {\n\t      return this.delegate.publish(address, message);\n\t    }\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(address, message) {\n\t      return this.publish(address, message);\n\t    }\n\t  }, {\n\t    key: 'getConnectionState',\n\t    value: function getConnectionState() {\n\t      return this.delegate.getConnectionState();\n\t    }\n\t  }, {\n\t    key: 'readyState',\n\t    value: function readyState() {\n\t      return this.getConnectionState();\n\t    }\n\t  }, {\n\t    key: 'isEnabled',\n\t    value: function isEnabled() {\n\t      return this.delegate.isEnabled();\n\t    }\n\t  }, {\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return this.delegate.isConnected();\n\t    }\n\t  }, {\n\t    key: 'login',\n\t    value: function login(username, password, timeout) {\n\t      return this.delegate.login(username, password, timeout);\n\t    }\n\t  }]);\n\n\t  return Delegator;\n\t}();\n\n\texports.default = Delegator;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-vertxbus.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 926bb58af44ffe5bff48\n **/","import moduleName from './module';\n\nexport default moduleName;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import {moduleName} from './config';\n\nimport VertxEventBusWrapperProvider from './lib/VertxEventBusWrapperProvider';\nimport VertxEventBusServiceProvider from './lib/VertxEventBusServiceProvider';\n\n/**\n * @ngdoc overview\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus\n * @description\n *\n * Client side library using VertX Event Bus as an Angular Service module\n *\n * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n *\n * <pre>\n *   angular.module('app', ['knalli.angular-vertxbus'])\n *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n *\n *       // using the EventBus directly\n *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n *         // your reply comes here\n *       });\n *\n *       // using the service\n *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n *         .then(function (reply) {\n *           // your reply comes here\n *         })\n *         .catch(function (err) {\n *           // something went wrong, no connection, no login, timed out, or so\n *         });\n *     });\n * </pre>\n *\n * The module itself provides following components:\n * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n *\n * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n * reconnect management, authorization and a clean promise based api.\n *\n * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n * underlying instance of the current `vertx.EventBus`.\n *\n * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n */\nexport default angular\n\n  .module(moduleName, ['ng'])\n\n  .provider('vertxEventBus', VertxEventBusWrapperProvider)\n  .provider('vertxEventBusService', VertxEventBusServiceProvider)\n\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/module.js\n **/","const moduleName = 'knalli.angular-vertxbus';\n\nexport {moduleName};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/config.js\n **/","import EventBusAdapter from './adapter/EventBusAdapter';\nimport NoopAdapter from './adapter/NoopAdapter';\nimport ConnectionConfigHolder from './support/ConnectionConfigHolder';\n\nimport EventBus from 'vertx-eventbus';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusProvider\n * @description\n * An AngularJS wrapper for projects using the VertX Event Bus\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  initialConnectEnabled : true,\n  urlServer : `${location.protocol}//${location.hostname}` + ((() => {\n    if (location.port) {\n      return `:${location.port}`;\n    }\n  })() || ''),\n  urlPath : '/eventbus',\n  reconnectEnabled : true,\n  sockjsReconnectInterval : 10000,\n  sockjsOptions : {}\n};\n\nlet VertxEventBusWrapperProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#disableAutoConnect\n   *\n   * @description\n   * Disables the auto connection feature.\n   *\n   * This feature will be only available if `enable == true`.\n   *\n   * @param {boolean} [value=true] auto connect on startup\n   * @returns {object} this\n   */\n  this.disableAutoConnect = () => {\n    options.initialConnectEnabled = false;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlServer\n   *\n   * @description\n   * Overrides the url part \"server\" for connecting. The default is based on\n   * - `location.protocol`\n   * - `location.hostname`\n   * - `location.port`\n   *\n   * i.e. `http://domain.tld` or `http://domain.tld:port`\n   *\n   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n   * @returns {object} this\n   */\n  this.useUrlServer = (value = DEFAULTS.urlServer) => {\n    options.urlServer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlPath\n   *\n   * @description\n   * Overrides the url part \"path\" for connection.\n   *\n   * @param {boolean} [value='/eventbus'] path to connect\n   * @returns {object} this\n   */\n  this.useUrlPath = (value = DEFAULTS.urlPath) => {\n    options.urlPath = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useReconnect\n   *\n   * @description\n   * Enables or disables the automatic reconnect handling.\n   *\n   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n   * @returns {object} this\n   */\n  this.useReconnect = (value = DEFAULTS.reconnectEnabled) => {\n    options.reconnectEnabled = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsReconnectInterval\n   *\n   * @description\n   * Overrides the timeout for reconnecting after a disconnect was found.\n   *\n   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsReconnectInterval = (value = DEFAULTS.sockjsReconnectInterval) => {\n    options.sockjsReconnectInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsOptions\n   *\n   * @description\n   * Sets additional params for the `SockJS` instance.\n   *\n   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n   *\n   * @param {boolean} [value={}]  optional params for raw SockJS options\n   * @returns {object} this\n   */\n  this.useSockJsOptions = (value = DEFAULTS.sockjsOptions) => {\n    options.sockjsOptions = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBus\n   * @description\n   * A stub representing the Vert.x EventBus (core functionality)\n   *\n   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n   * new instance of the bus have to be created.\n   * This stub ensures only one object holding the current active instance of the bus.\n   *\n   * The stub supports theses Vert.x Event Bus APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n   *\n   * Furthermore, the stub supports theses extra APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n   *\n   * @requires $timeout\n   * @requires $log\n   */\n  /* @ngInject */\n  this.$get = ($timeout, $log, $q) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, DEFAULTS, options);\n    if (instanceOptions.enabled && EventBus) {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Enabled');\n      }\n\n      // aggregate server connection params\n      instanceOptions.connectionConfig = new ConnectionConfigHolder({\n        urlServer : instanceOptions.urlServer,\n        urlPath : instanceOptions.urlPath\n      });\n      delete instanceOptions.urlServer;\n      delete instanceOptions.urlPath;\n\n      return new EventBusAdapter(EventBus, $timeout, $log, $q, instanceOptions);\n    } else {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Disabled');\n      }\n      return new NoopAdapter(EventBus, $q);\n    }\n  };\n\n};\n\nexport default VertxEventBusWrapperProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusWrapperProvider.js\n **/","import {moduleName} from '../../config.js';\n\nimport BaseAdapter from './BaseAdapter';\nimport ConnectionConfigHolder from './../support/ConnectionConfigHolder';\n\n/**\n * @ngdoc service\n * @module global\n * @name global.EventBus\n *\n * @description\n * This is the interface of `EventBus`. It is not included.\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#close\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#send\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {function=} replyHandler optional callback\n * @param {function=} failureHandler optional callback\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#publish\n *\n * @param {string} address target address\n * @param {object} message payload message\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#registerHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#unregisterHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler to be removed\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onopen\n * @description\n * Defines the callback called on opening the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onclose\n * @description\n * Defines the callback called on closing the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onerror\n * @description\n * Defines the callback called on any error.\n */\n\nexport default class EventBusAdapter extends BaseAdapter {\n\n  constructor(EventBus, $timeout, $log, $q, {\n    enabled,\n    debugEnabled,\n    initialConnectEnabled,\n    connectionConfig,\n    reconnectEnabled,\n    sockjsReconnectInterval,\n    sockjsOptions\n    }) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n    this.$timeout = $timeout;\n    this.$log = $log;\n    this.$q = $q;\n    this.options = {\n      enabled,\n      debugEnabled,\n      initialConnectEnabled,\n      connectionConfig,\n      reconnectEnabled,\n      sockjsReconnectInterval,\n      sockjsOptions\n    };\n    this.disconnectTimeoutEnabled = true;\n    if (initialConnectEnabled) {\n      // asap create connection\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#configureConnect\n   *\n   * @description\n   * Reconfigure the connection details.\n   *\n   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n   */\n  configureConnection(urlServer, urlPath = '/eventbus') {\n    this.options.connectionConfig = new ConnectionConfigHolder({urlServer, urlPath});\n    return this;\n  }\n\n  connect() {\n    // connect promise\n    let deferred = this.$q.defer();\n    // currently valid url\n    let url = `${this.options.connectionConfig.urlServer}${this.options.connectionConfig.urlPath}`;\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Stub] Enabled: connecting '${url}'`);\n    }\n    // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n    // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n    this.instance = new this.EventBus(url, this.options.sockjsOptions);\n    this.instance.onopen = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug('[Vert.x EB Stub] Connected');\n      }\n      if (angular.isFunction(this.onopen)) {\n        this.onopen();\n      }\n      deferred.resolve();\n    };\n    // instance onClose handler\n    this.instance.onclose = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n      }\n      if (angular.isFunction(this.onclose)) {\n        this.onclose();\n      }\n      this.instance = undefined;\n\n      if (!this.disconnectTimeoutEnabled) {\n        // reconnect required asap\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n        }\n        this.disconnectTimeoutEnabled = true;\n        this.connect();\n      } else if (this.options.reconnectEnabled) {\n        // automatic reconnect after timeout\n        if (this.options.debugEnabled) {\n          this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n        }\n        this.$timeout((() => this.connect()), this.options.sockjsReconnectInterval);\n      }\n    };\n    // instance onError handler\n    this.instance.onerror = (message) => {\n      if (angular.isFunction(this.onerror)) {\n        this.onerror(message);\n      }\n    };\n    return deferred.promise;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#reconnect\n   *\n   * @description\n   * Reconnects the underlying connection.\n   *\n   * Unless a connection is open, it will connect using a new one.\n   *\n   * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n   * default timeout for reconnect will be skipped.\n   *\n   * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n   */\n  reconnect(immediately = false) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (immediately) {\n        this.disconnectTimeoutEnabled = false;\n      }\n      this.instance.close();\n    } else {\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#close\n   *\n   * @description\n   * Closes the underlying connection.\n   *\n   * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n   *\n   * See also:\n   * - {@link EventBus#methods_close EventBus.close()}\n   */\n  close() {\n    if (this.instance) {\n      this.instance.close();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#send\n   *\n   * @description\n   * Sends a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_send EventBus.send()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers\n   * @param {function=} replyHandler optional callback\n   * @param {function=} failureHandler optional callback (since Vert.x 3.0.0)\n   */\n  send(address, message, headers, replyHandler, failureHandler) {\n    if (this.instance) {\n      if (angular.isFunction(headers)) {\n        failureHandler = replyHandler;\n        replyHandler = headers;\n        headers = undefined;\n      }\n      this.instance.send(address, message, headers, replyHandler, failureHandler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_publish EventBus.publish()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers optional headers\n   */\n  publish(address, message, headers) {\n    if (this.instance) {\n      this.instance.publish(address, message, headers);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} handler callback handler\n   */\n  registerHandler(address, headers, handler) {\n    if (this.instance) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      this.instance.registerHandler(address, headers, handler);\n      // and return the deregister callback\n      let deconstructor = () => {\n        this.unregisterHandler(address, headers, handler);\n      };\n      deconstructor.displayName = `${moduleName}.wrapper.eventbus.registerHandler.deconstructor`;\n      return deconstructor;\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a registered a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} handler callback handler to be removed\n   */\n  unregisterHandler(address, headers, handler) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      this.instance.unregisterHandler(address, headers, handler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#readyState\n   *\n   * @description\n   * Returns the current connection state\n   *\n   * @returns {number} value of vertx-eventbus connection states\n   */\n  readyState() {\n    if (this.instance) {\n      return this.instance.state;\n    } else {\n      return this.EventBus.CLOSED;\n    }\n  }\n\n  get state() {\n    return this.readyState();\n  }\n\n  // private\n  getOptions() {\n    // clone options\n    return angular.extend({}, this.options);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/EventBusAdapter.js\n **/","export default class BaseAdapter {\n\n  constructor($q) {\n    this.$q = $q;\n  }\n\n  configureConnection() {\n  }\n\n  connect() {\n    return this.$q.reject();\n  }\n\n  reconnect() {\n  }\n\n  close() {\n  }\n\n  send() {\n  }\n\n  publish() {\n  }\n\n  registerHandler() {\n  }\n\n  unregisterHandler() {\n  }\n\n  readyState() {\n  }\n\n  getOptions() {\n    return {};\n  }\n\n  // empty: can be overriden by externals\n  onopen() {\n  }\n\n  // empty: can be overriden by externals\n  onclose() {\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/BaseAdapter.js\n **/","export default class ConnectionConfigHolder {\n\n  constructor({urlServer, urlPath}) {\n    this._urlServer = urlServer;\n    this._urlPath = urlPath;\n  }\n\n  get urlServer() {\n    return this._urlServer;\n  }\n\n  get urlPath() {\n    return this._urlPath;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/ConnectionConfigHolder.js\n **/","import BaseAdapter from './BaseAdapter';\n\nexport default class NoopAdapter extends BaseAdapter {\n\n  constructor(EventBus, $q) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/NoopAdapter.js\n **/","import EventBusDelegate from './service/delegate/EventBusDelegate';\nimport NoopDelegate from './service/delegate/NoopDelegate';\nimport Delegator from './service/Delegator';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n * @description\n * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  prefix : 'vertx-eventbus.',\n  sockjsStateInterval : 10000,\n  messageBuffer : 10000\n};\n\nlet VertxEventBusServiceProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#usePrefix\n   *\n   * @description\n   * Overrides the default prefix which will be used for emitted events.\n   *\n   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n   * @returns {object} this\n   */\n  this.usePrefix = (value = DEFAULTS.prefix) => {\n    options.prefix = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useSockJsStateInterval\n   *\n   *\n   * @description\n   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n   *\n   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsStateInterval = (value = DEFAULTS.sockjsStateInterval) => {\n    options.sockjsStateInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useMessageBuffer\n   *\n   * @description\n   * Enables buffering of (sending) messages.\n   *\n   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n   * connection is still in progress, the connection is stale or a login is required/pending.\n   *\n   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n   * @returns {object} this\n   */\n  this.useMessageBuffer = (value = DEFAULTS.messageBuffer) => {\n    options.messageBuffer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBusService\n   * @description\n   * A service utilizing an underlying Vert.x Event Bus\n   *\n   * The advanced features of this service are:\n   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n   *  - registering all handlers again when a reconnect had been required\n   *  - supporting a promise when using send()\n   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n   *\n   * Basic usage:\n   * <pre>\n   * module.controller('MyController', function('vertxEventService') {\n *   vertxEventService.on('my.address', function(message) {\n *     console.log(\"JSON Message received: \", message)\n *   });\n *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n * });\n   * </pre>\n   *\n   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n   *\n   * @requires knalli.angular-vertxbus.vertxEventBus\n   * @requires $rootScope\n   * @requires $q\n   * @requires $interval\n   * @requires $log\n   */\n  /* @ngInject */\n  this.$get = ($rootScope, $q, $interval, vertxEventBus, $log) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n    if (instanceOptions.enabled) {\n      return new Delegator(\n        new EventBusDelegate($rootScope, $interval, $log, $q, vertxEventBus, instanceOptions),\n        $log\n      );\n    } else {\n      return new Delegator(new NoopDelegate());\n    }\n  };\n\n};\n\nexport default VertxEventBusServiceProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusServiceProvider.js\n **/","import {moduleName} from '../../../config';\n\nimport Queue from './../../support/Queue';\nimport SimpleMap from './../../support/SimpleMap';\nimport BaseDelegate from './BaseDelegate';\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name disconnected\n *\n * @description\n * After a connection was being terminated.\n *\n * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name connected\n *\n * @description\n * After a connection was being established\n *\n * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-succeeded\n *\n * @description\n * After a login has been validated successfully\n *\n * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be `'ok'`\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-failed\n *\n * @description\n * After a login has been destroyed or was invalidated\n *\n * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be not`'ok'`\n */\n\nexport default class EventBusDelegate extends BaseDelegate {\n\n  constructor($rootScope, $interval, $log, $q, eventBus, {\n    enabled,\n    debugEnabled,\n    prefix,\n    sockjsStateInterval,\n    messageBuffer,\n    loginRequired,\n    loginInterceptor\n    }) {\n    super();\n    this.$rootScope = $rootScope;\n    this.$interval = $interval;\n    this.$log = $log;\n    this.$q = $q;\n    this.eventBus = eventBus;\n    this.options = {\n      enabled,\n      debugEnabled,\n      prefix,\n      sockjsStateInterval,\n      messageBuffer,\n      loginRequired\n    };\n    this.loginInterceptor = loginInterceptor;\n    this.connectionState = this.eventBus.EventBus.CLOSED;\n    this.states = {\n      connected: false,\n      validSession: false\n    };\n    this.observers = [];\n    // internal store of buffered messages\n    this.messageQueue = new Queue(this.options.messageBuffer);\n    // internal map of callbacks\n    this.callbackMap = new SimpleMap();\n    // asap\n    this.initialize();\n  }\n\n  // internal\n  initialize() {\n    this.eventBus.onopen = () => this.onEventbusOpen();\n    this.eventBus.onclose = () => this.onEventbusClose();\n\n    // Update the current connection state periodically.\n    let connectionIntervalCheck = () => this.getConnectionState(true);\n    connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n    this.$interval((() => connectionIntervalCheck()), this.options.sockjsStateInterval);\n  }\n\n  // internal\n  onEventbusOpen() {\n    let connectionStateFlipped = false;\n    this.getConnectionState(true);\n    if (!this.states.connected) {\n      this.states.connected = true;\n      connectionStateFlipped = true;\n    }\n    // Ensure all events will be re-attached\n    this.afterEventbusConnected();\n    // Everything is online and registered again, let's notify everybody\n    if (connectionStateFlipped) {\n      this.$rootScope.$broadcast(`${this.options.prefix}system.connected`);\n    }\n    this.$rootScope.$digest(); // explicitly\n    // consume message queue?\n    if (this.options.messageBuffer && this.messageQueue.size()) {\n      while (this.messageQueue.size()) {\n        let fn = this.messageQueue.first();\n        if (angular.isFunction(fn)) {\n          fn();\n        }\n      }\n      this.$rootScope.$digest();\n    }\n  }\n\n  // internal\n  onEventbusClose() {\n    this.getConnectionState(true);\n    if (this.states.connected) {\n      this.states.connected = false;\n      this.$rootScope.$broadcast(`${this.options.prefix}system.disconnected`);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#observe\n   *\n   * @description\n   * Adds an observer\n   *\n   * @param {object} observer observer\n   * @param {function=} observer.afterEventbusConnected will be called after establishing a new connection\n   */\n  observe(observer) {\n    this.observers.push(observer);\n  }\n\n  // internal\n  afterEventbusConnected() {\n    for (let observer of this.observers) {\n      if (angular.isFunction(observer.afterEventbusConnected)) {\n        observer.afterEventbusConnected();\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   * @returns {function=} deconstructor\n   */\n  registerHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Register handler for ${address}`);\n    }\n    var callbackWrapper = (err, {body}, replyTo) => {\n      callback(body, replyTo);\n      this.$rootScope.$digest();\n    };\n    callbackWrapper.displayName = `${moduleName}.service.delegate.live.registerHandler.callbackWrapper`;\n    this.callbackMap.put(callback, callbackWrapper);\n    return this.eventBus.registerHandler(address, headers, callbackWrapper);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   */\n  unregisterHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Unregister handler for ${address}`);\n    }\n    this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n    this.callbackMap.remove(callback);\n  }\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#send\n   *\n   * @description\n   * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers\n   * @param {number=} [timeout=10000] timeout (in ms) after which the promise will be rejected\n   * @param {boolean=} [expectReply=true] if false, the promise will be resolved directly and\n   *                                       no replyHandler will be created\n   * @returns {object} promise\n   */\n  send(address, message, headers, timeout = 10000, expectReply = true) {\n    if (angular.isNumber(headers)) {\n      if (typeof timeout === 'boolean') {\n        expectReply = timeout;\n      }\n      timeout = headers;\n      headers = undefined;\n    }\n    let deferred = this.$q.defer();\n    let next = () => {\n      if (expectReply) {\n        // Register timeout for promise rejecting\n        let timer = this.$interval((() => {\n          if (this.options.debugEnabled) {\n            this.$log.debug(`[Vert.x EB Service] send('${address}') timed out`);\n          }\n          deferred.reject();\n        }), timeout, 1);\n        // Send message\n        this.eventBus.send(address, message, headers, (err, reply) => {\n          this.$interval.cancel(timer); // because it's resolved\n          if (err) {\n            deferred.reject(err);\n          } else {\n            deferred.resolve(reply);\n          }\n        }, (err) => {\n          this.$interval.cancel(timer); // because it's resolved\n          deferred.reject(err);\n        });\n      } else {\n        this.eventBus.send(address, message, headers);\n        deferred.resolve(); // we don't care\n      }\n    };\n    next.displayName = `${moduleName}.service.delegate.live.send.next`;\n    if (!this.ensureOpenAuthConnection(next)) {\n      deferred.reject();\n    }\n    return deferred.promise;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers optional headers\n   * @returns {boolean} false if cannot be send or queued\n   */\n  publish(address, message, headers) {\n    return this.ensureOpenAuthConnection(() => this.eventBus.publish(address, message, headers));\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#ensureOpenConnection\n   *\n   * @description\n   * Ensures the callback will be performed with an open connection.\n   *\n   * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n   *\n   * @param {function} fn callback\n   * @returns {boolean} false if the callback cannot be performed or queued\n   */\n  ensureOpenConnection(fn) {\n    if (this.isConnectionOpen()) {\n      fn();\n      return true;\n    } else if (this.options.messageBuffer) {\n      this.messageQueue.push(fn);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#ensureOpenAuthConnection\n   *\n   * @description\n   * Ensures the callback will be performed with a valid session.\n   *\n   * Unless `loginRequired` is enabled, this will be simple forward.\n   *\n   * Unless a valid session exist (but required), the callback will be not invoked.\n   *\n   * @param {function} fn callback\n   * @returns {boolean} false if the callback cannot be performed or queued\n   */\n  ensureOpenAuthConnection(fn) {\n    if (!this.options.loginRequired) {\n      // easy: no login required\n      return this.ensureOpenConnection(fn);\n    } else {\n      let fnWrapper = () => {\n        if (this.states.validSession) {\n          fn();\n          return true;\n        } else {\n          // ignore this message\n          if (this.options.debugEnabled) {\n            this.$log.debug('[Vert.x EB Service] Message was not sent because login is required');\n          }\n          return false;\n        }\n      };\n      fnWrapper.displayName = `${moduleName}.service.delegate.live.ensureOpenAuthConnection.fnWrapper`;\n      return this.ensureOpenConnection(fnWrapper);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getConnectionState\n   *\n   * @description\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState(immediate) {\n    if (this.options.enabled) {\n      if (immediate) {\n        this.connectionState = this.eventBus.state;\n      }\n    } else {\n      this.connectionState = this.eventBus.EventBus.CLOSED;\n    }\n    return this.connectionState;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnectionOpen\n   *\n   * @description\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isValidSession\n   *\n   * @description\n   * Returns true if the session is valid\n   *\n   * @returns {boolean} state\n   */\n  isValidSession() {\n    return this.states.validSession;\n  }\n\n  // internal\n  isConnected() {\n    return this.states.connected;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isEnabled\n   *\n   * @description\n   * Returns true if service is being enabled.\n   *\n   * @returns {boolean} state\n   */\n  isEnabled() {\n    return this.options.enabled;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnectionOpen\n   *\n   * @description\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.messageQueue.size();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/EventBusDelegate.js\n **/","/*\n Simple queue implementation\n\n FIFO: #push() + #first()\n LIFO: #push() + #last()\n */\nexport default class Queue {\n\n  constructor(maxSize = 10) {\n    this.maxSize = maxSize;\n    this.items = [];\n  }\n\n  push(item) {\n    this.items.push(item);\n    return this.recalibrateBufferSize();\n  }\n\n  recalibrateBufferSize() {\n    while (this.items.length > this.maxSize) {\n      this.first();\n    }\n    return this;\n  }\n\n  last() {\n    return this.items.pop();\n  }\n\n  first() {\n    return this.items.shift(0);\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/Queue.js\n **/","/*\n Simple Map implementation\n\n This implementation allows usage of non serializable keys for values.\n */\nexport default class SimpleMap {\n\n  constructor() {\n    this.clear();\n  }\n\n  // Stores the value under the key.\n  // Chainable\n  put(key, value) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.values[idx] = value;\n    } else {\n      this.keys.push(key);\n      this.values.push(value);\n    }\n    return this;\n  }\n\n  // Returns value for key, otherwise undefined.\n  get(key) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      return this.values[idx];\n    }\n  }\n\n  // Returns true if the key exists.\n  containsKey(key) {\n    let idx = this._indexForKey(key);\n    return idx > -1;\n  }\n\n  // Returns true if the value exists.\n  containsValue(value) {\n    let idx = this._indexForValue(value);\n    return idx > -1;\n  }\n\n  // Removes the key and its value.\n  remove(key) {\n    let idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.keys[idx] = undefined;\n      this.values[idx] = undefined;\n    }\n\n  }\n\n  // Clears all keys and values.\n  clear() {\n    this.keys = [];\n    this.values = [];\n    return this;\n  }\n\n  // Returns index of key, otherwise -1.\n  _indexForKey(key) {\n    for (let i in this.keys) {\n      if (key === this.keys[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  _indexForValue(value) {\n    for (let i in this.values) {\n      if (value === this.values[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/SimpleMap.js\n **/","export default class BaseDelegate {\n\n  getConnectionState() {\n    return 3; // CLOSED\n  }\n\n  isConnectionOpen() {\n    return false;\n  }\n\n  isValidSession() {\n    return false;\n  }\n\n  isEnabled() {\n    return false;\n  }\n\n  isConnected() {\n    return false;\n  }\n\n  send() {}\n\n  publish() {}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/BaseDelegate.js\n **/","import BaseDelegate from './BaseDelegate';\n\nexport default class NoopDelegate extends BaseDelegate {}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/NoopDelegate.js\n **/","import {moduleName} from '../../config';\n\nexport default class Delegator {\n\n  constructor(delegate, $log) {\n    this.delegate = delegate;\n    this.$log = $log;\n    this.handlers = [];\n    this.delegate.observe({\n      afterEventbusConnected: () => this.afterEventbusConnected()\n    });\n  }\n\n  afterEventbusConnected() {\n    for (let address in this.handlers) {\n      let callbacks = this.handlers[address];\n      if (callbacks && callbacks.length) {\n        for (let {headers, callback} of callbacks) {\n          this.delegate.registerHandler(address, headers, callback);\n        }\n      }\n    }\n  }\n\n  registerHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!this.handlers[address]) {\n      this.handlers[address] = [];\n    }\n    var handler = {headers, callback};\n    this.handlers[address].push(handler);\n    var unregisterFn = null;\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.registerHandler(address, headers, callback);\n      unregisterFn = () => this.delegate.unregisterHandler(address, headers, callback);\n    }\n    // and return the deregister callback\n    var deconstructor = () => {\n      if (unregisterFn) {\n        unregisterFn();\n        unregisterFn = undefined;\n      }\n      // Remove from internal map\n      if (this.handlers[address]) {\n        var index = this.handlers[address].indexOf(handler);\n        if (index > -1) {\n          this.handlers[address].splice(index, 1);\n        }\n        if (this.handlers[address].length < 1) {\n          this.handlers[address] = undefined;\n        }\n      }\n    };\n    deconstructor.displayName = `${moduleName}.service.registerHandler.deconstructor`;\n    return deconstructor;\n  }\n  on(address, headers, callback) {\n    if (typeof headers === 'function' && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    return this.registerHandler(address, headers, callback);\n  }\n  addListener(address, headers, callback) {\n    if (typeof headers === 'function' && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    return this.registerHandler(address, headers, callback);\n  }\n\n  unregisterHandler(address, headers, callback) {\n    if (typeof headers === 'function' && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    // Remove from internal map\n    if (this.handlers[address]) {\n      var index = this.handlers[address].indexOf({headers, callback});\n      if (index > -1) {\n        this.handlers[address].splice(index, 1);\n      }\n      if (this.handlers[address].length < 1) {\n        this.handlers[address] = undefined;\n      }\n    }\n    // Remove from real instance\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.unregisterHandler(address, headers, callback);\n    }\n  }\n  un(address, headers, callback) {\n    if (typeof headers === 'function' && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    return this.unregisterHandler(address, headers, callback);\n  }\n  removeListener(address, headers, callback) {\n    if (typeof headers === 'function' && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  send(address, message, options = {}) {\n\n    // FALLBACK: signature change since 2.0\n    if (!angular.isObject(options)) {\n      this.$log.error(`${moduleName}: Signature of vertxEventBusService.send() has been changed!`);\n      return this.send(address, message, {\n        timeout: arguments[2] !== undefined ? arguments[2] : 10000,\n        expectReply: arguments[3] !== undefined ? arguments[3] : true\n      });\n    }\n\n    return this.delegate.send(address, message, options.timeout, options.expectReply);\n  }\n\n  publish(address, message) {\n    return this.delegate.publish(address, message);\n  }\n  emit(address, message) {\n    return this.publish(address, message);\n  }\n\n  getConnectionState() {\n    return this.delegate.getConnectionState();\n  }\n\n  readyState() {\n    return this.getConnectionState();\n  }\n\n  isEnabled() {\n    return this.delegate.isEnabled();\n  }\n\n  isConnected() {\n    return this.delegate.isConnected();\n  }\n\n  login(username, password, timeout) {\n    return this.delegate.login(username, password, timeout);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/Delegator.js\n **/"],"sourceRoot":""}