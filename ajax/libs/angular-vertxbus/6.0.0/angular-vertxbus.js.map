{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9129d8acc85947c990d8","webpack:///./src/index.js","webpack:///./src/module.js","webpack:///./src/config.js","webpack:///./src/lib/VertxEventBusWrapperProvider.js","webpack:///./src/lib/adapter/EventBusAdapter.js","webpack:///./src/lib/adapter/BaseAdapter.js","webpack:///./src/lib/support/ConnectionConfigHolder.js","webpack:///./src/lib/adapter/NoopAdapter.js","webpack:///./src/lib/VertxEventBusServiceProvider.js","webpack:///./src/lib/service/delegate/EventBusDelegate.js","webpack:///./src/lib/support/Queue.js","webpack:///./src/lib/support/SimpleMap.js","webpack:///./src/lib/service/delegate/BaseDelegate.js","webpack:///./src/lib/service/delegate/NoopDelegate.js","webpack:///./src/lib/service/Delegator.js"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtCA;;;;;;;;;;;;;;;;;;ACAA;;AAEA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA6Ce,QAEZ,MAFY,qBAEO,CAAC,IAAD,CAFP,EAIZ,QAJY,CAIH,eAJG,0CAKZ,QALY,CAKH,sBALG,0CAOZ,IAPY,C;;;;;;;;;;;AChDf,KAAM,aAAa,yBAAb;;SAEE,wB;;;;;;;;;;;;ACFR;;;;AACA;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AAUA,KAAM,WAAW;AACf,YAAU,IAAV;AACA,iBAAe,KAAf;AACA,0BAAwB,IAAxB;AACA,cAAY,QAAG,CAAS,QAAT,UAAsB,SAAS,QAAT,IAAuB,YAAO;AACjE,SAAI,SAAS,IAAT,EAAe;AACjB,oBAAW,SAAS,IAAT,CADM;MAAnB;IAD2D,EAAD,IAIpD,EAJoD,CAAhD;AAKZ,YAAU,WAAV;AACA,qBAAmB,IAAnB;AACA,4BAA0B,KAA1B;AACA,kBAAgB,EAAhB;EAZI;;AAeN,KAAI,+BAA+B,SAA/B,4BAA+B,GAAY;;;;AAG7C,OAAI,UAAU,QAAQ,MAAR,CAAe,EAAf,EAAmB,QAAnB,CAAV;;;;;;;;;;;;;;AAHyC,OAiB7C,CAAK,MAAL,GAAc,YAA8B;SAA7B,8DAAQ,SAAS,OAAT,gBAAqB;;AAC1C,aAAQ,OAAR,GAAmB,UAAU,IAAV,CADuB;AAE1C,kBAF0C;IAA9B;;;;;;;;;;;;;;;;AAjB+B,OAoC7C,CAAK,kBAAL,GAA0B,YAAM;AAC9B,aAAQ,qBAAR,GAAgC,KAAhC,CAD8B;AAE9B,kBAF8B;IAAN;;;;;;;;;;;;;;AApCmB,OAqD7C,CAAK,QAAL,GAAgB,YAAmC;SAAlC,8DAAQ,SAAS,YAAT,gBAA0B;;AACjD,aAAQ,YAAR,GAAwB,UAAU,IAAV,CADyB;AAEjD,kBAFiD;IAAnC;;;;;;;;;;;;;;;;;;;AArD6B,OA2E7C,CAAK,YAAL,GAAoB,YAAgC;SAA/B,8DAAQ,SAAS,SAAT,gBAAuB;;AAClD,aAAQ,SAAR,GAAoB,KAApB,CADkD;AAElD,kBAFkD;IAAhC;;;;;;;;;;;;;;AA3EyB,OA4F7C,CAAK,UAAL,GAAkB,YAA8B;SAA7B,8DAAQ,SAAS,OAAT,gBAAqB;;AAC9C,aAAQ,OAAR,GAAkB,KAAlB,CAD8C;AAE9C,kBAF8C;IAA9B;;;;;;;;;;;;;;AA5F2B,OA6G7C,CAAK,YAAL,GAAoB,YAAuC;SAAtC,8DAAQ,SAAS,gBAAT,gBAA8B;;AACzD,aAAQ,gBAAR,GAA2B,KAA3B,CADyD;AAEzD,kBAFyD;IAAvC;;;;;;;;;;;;;;AA7GyB,OA8H7C,CAAK,0BAAL,GAAkC,YAA8C;SAA7C,8DAAQ,SAAS,uBAAT,gBAAqC;;AAC9E,aAAQ,uBAAR,GAAkC,KAAlC,CAD8E;AAE9E,kBAF8E;IAA9C;;;;;;;;;;;;;;;;AA9HW,OAiJ7C,CAAK,gBAAL,GAAwB,YAAoC;SAAnC,8DAAQ,SAAS,aAAT,gBAA2B;;AAC1D,aAAQ,aAAR,GAAwB,KAAxB,CAD0D;AAE1D,kBAF0D;IAApC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjJqB,OAgL7C,CAAK,IAAL,GAAY,UAAC,QAAD,EAAW,IAAX,EAAiB,EAAjB,EAAwB;;AAElC,SAAI,kBAAkB,QAAQ,MAAR,CAAe,EAAf,EAAmB,QAAnB,EAA6B,OAA7B,CAAlB,CAF8B;AAGlC,SAAI,gBAAgB,OAAhB,2BAAJ,EAAyC;AACvC,WAAI,gBAAgB,YAAhB,EAA8B;AAChC,cAAK,KAAL,CAAW,0BAAX,EADgC;QAAlC;;;AADuC,sBAMvC,CAAgB,gBAAhB,GAAmC,qCAA2B;AAC5D,oBAAY,gBAAgB,SAAhB;AACZ,kBAAU,gBAAgB,OAAhB;QAFuB,CAAnC,CANuC;AAUvC,cAAO,gBAAgB,SAAhB,CAVgC;AAWvC,cAAO,gBAAgB,OAAhB,CAXgC;;AAavC,cAAO,uDAA8B,QAA9B,EAAwC,IAAxC,EAA8C,EAA9C,EAAkD,eAAlD,CAAP,CAbuC;MAAzC,MAcO;AACL,WAAI,gBAAgB,YAAhB,EAA8B;AAChC,cAAK,KAAL,CAAW,2BAAX,EADgC;QAAlC;AAGA,cAAO,mDAA0B,EAA1B,CAAP,CAJK;MAdP;IAHU,CAhLiC;EAAZ;;;;;;;;;;;;;;;;;;AC7BnC;;AAEA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FqB;;;AAUd;SAPH,uBAOG;SANH,uBAMG;SALH,iCAKG;SAJH,yCAIG;SAHH,yCAGG;SAFH,yCAEG;SADH,mCACG;;AAAA;;;;AAAA;;AAAA;AAIH,WAAK,QAAL,GAAgB,QAAhB,CAJG;AAKH,WAAK,IAAL,GAAY,IAAZ,CALG;AAMH,WAAK,EAAL,GAAU,EAAV,CANG;AAOH,WAAK,OAAL,CAAe;AACb,sBADa;AAEb,wBAFa;AAGb,kCAHa;AAIb,yCAJa;AAKb,yCALa;AAMb,0CANa;AAOb,mCAPa;MAAf,CAPG;AAgBH,OAhBG;AAiBH,WAAK,mBAAL,GAjBG;AAkBH,SAAI,qBAAJ,EAA2B;;AAEzB,aAAK,OAAL,GAFyB;MAA3B;MAlBG;IARL;;;;;;;;;;;;;;;;AAFmB;;gCA8CmC;WAAvB,0CAAuB;;AAAA;AAEpD,cAAO,IAAP,CAFoD;;;;oBAK5C;;;;AAER,WAAI,WAAW,GAAX;;AAFI,WAIJ,WAAS,KAAK,EAJV;AAKR,WAAI,KAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,cAAK,IAAL,CAAU,KAAV,eAD6B;QAA/B;;;AALQ,WAUR,CAAK,QAAL,GAAgB,IAAI,KAAK,QAAL,CAAc,GAAlB,EAAuB,KAAK,OAAL,CAAa,aAAb,CAAvC,CAVQ;AAWR,YAAK,QAAL,CAAc,MAAd,GAAuB,YAAM;AAC3B,aAAI,OAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,kBAAK,IAAL,CAAU,KAAV,CAAgB,cADa;UAA/B;AAGA,UAAqC;AACnC,kBAAK,MAAL,GADmC;UAArC;AAGA,UAP2B;QAAN;;AAXf,WAqBR,CAAK,QAAL,CAAc,OAAd,GAAwB,GAAM;AAC5B,aAAI,OAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,kBAAK,IAAL,CAAU,KAAV,eAD6B;UAA/B;AAGA,UAAsC;AACpC,kBAAK,OAAL,GADoC;UAAtC;AAGA,UAP4B;;AASQ;;AAElC,eAAI,OAAK,OAAL,CAAa,OAAc;AAC7B,oBAAK,IAAL,CAAU,KAAV,CAAgB,cADa;YAA/B;AAGA,YALkC;AAMlC,kBAAK,OAAL,GANkC;UAApC,MAOO,IAAI,OAAK,CAA0B;;AAExC,eAAI,OAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,oBAAK,IAAL,CAAU,KAAV,eAD6B;YAA/B;AAGA,YAAe;oBAAM,OAAK,OAAL;YAAN,EAAuB,OAAK,OAAL,CAAa,QALX;UAAnC;QAhBe;;AArBhB,WA8CR,CAAK,QAAL,CAAc,OAAd,GAAwB,GAAa;AACnC,aAAI,QAAQ,UAAR,CAAmB,OAAK,OAAL,CAAvB,EAAsC;AACpC,kBAAK,OAAL,CAAa,OAAb,EADoC;UAAtC;QADsB,CA9ChB;AAmDR,SAnDQ;;;;;;;;;;;;;;;;;;;;;;sBAsEqB;WAArB,uBAAqB;;AACoC;AAC/D,aAAI,WAAJ,EAAiB;AACf,gBAAK,WADU;UAAjB;AAGA,UAJ+D;QAAjE,MAKO;AACL,cAAK,CADA;QALP;;;;;;;;;;;;;;;;;;;;kBAwBM;AACN,WAAI,KAAK,QAAL,EAAe;AACjB,cAAK,QAAL,CAAc,IADG;QAAnB;;;;;;;;;;;;;;;;;;;;;;;iBAsB4C;AAC5C,WAAI,KAAK,QAAL,EAAe;AACjB,aAAM,cADW;AAEjB,cAAK,QAAL,CAAc,IAAd,CAAmB,OAAnB,EAA4B,OAA5B,EAAqC,aAArC,CAFiB;QAAnB;;;;;;;;;;;;;;;;;;;;;;oBAsBiC;AACjC,WAAI,KAAK,QAAL,EAAe;AACjB,aAAM,cADW;AAEjB,cAAK,QAAL,CAAc,OAAd,CAAsB,OAAtB,EAA+B,OAA/B,EAAwC,WAFvB;QAAnB;;;;;;;;;;;;;;;;;;;;;;4BAsByC;;;AACtB;;AACjB,eAAI,QAAQ,UAAiC;AAC3C,uBAAU,OAAV,CAD2C;AAE3C,uBAAU,QAFiC;YAA7C;AAIA,YAAM;AACN,kBAAK,QAAL,CAAc,eAAd,CAA8B,OAA9B,EAAuC,YAAvC;;AAEA,eAAI,gBAAgB,SAAhB,QAAsB;AACxB,oBAAK,iBAAL,CAAuB,OAAvB,EAAgC,UADR;YAAN;AAGpB;AACA;gBAAO;YAAP;aAZiB;;;QAAnB;;;;;;;;;;;;;;;;;;;;;;8BAgC2C;AAC3C,WAAI,KAAK,QAAL,IAAiB,KAAK,QAAL,CAAc,KAAd,KAAwB,KAAK,QAAL,CAAc,CAAM;AAC/D,aAAI,QAAQ,UAAR,CAAmB,OAAnB,KAA+B,CAAC,OAAD,EAAU;AAC3C,qBAAU,OAAV,CAD2C;AAE3C,qBAAU,QAFiC;UAA7C;AAIA,UAL+D;AAM/D,cAAK,QAAL,CAAc,iBAAd,CAAgC,OAAhC,EAAyC,UANsB;QAAjE;;;;;;;;;;;;;;;;;uBAqBW;AACX,WAAI,KAAK,QAAL,EAAe;AACjB,gBAAO,KAAK,MADK;QAAnB,MAEO;AACL,eADK;QAFP;;;;;;;eAYW;;AAEX,cAAO,QAAQ,CAFJ;;;;kBALD;AACV,cAAO,KAAK,OADF;;;;AAtRO;;;;;;;;;;;;;;;;;;;AC9FA;AAEnB,YAFmB,WAEnB,CAAY,EAAZ,EAAgB;2BAFG,EAEH;;AAAA;IAAhB;;AAFmB;;gCAMG;;;oBAGZ;AACR,cAAO,KAAK,EAAL,CAAQ,MAAR,EAAP,CADQ;;;;sBAIE;;;kBAGJ;;;iBAGD;;;oBAGG;;;4BAGQ;;;8BAGE;;;uBAGP;;;uBAGA;AACX,cAAO,EAAP,CADW;;;;;;;mBAKJ;;;;;;oBAIC;;;;;;8BAIU;AAClB,cAAO,KAAK,cAAL,CADW;;;;;;;;;;;;;;;;;gCAec;WAAd,iCAAc;;AAAA;;;;;;;6BAKH;WAAd,8BAAc;;AAAA;;;;AAnEZ;;;;;;;;;;;;;;;;;;;ACAA;AAEnB,YAFmB,sBAEnB,OAAkC;SAArB,2BAAqB;SAAV,uBAAU;;AAAA;;AAAA;AAEhC,UAAK,QAAL,GAAgB,OAAhB,CAFgC;IAAlC;;AAFmB;;sBAOH;AACd,cAAO,KAAK,OADE;;;;oBAIF;AACZ,cAAO,KAAK,OADA;;;;AAXK;;;;;;;;;;;;;;;ACArB;;;;;;;;;;;;AAEqB;;;AAEO;2BAFP,YAEO;;;;AAAA;;AAAA;;IAA1B;;AAFmB;;;;;;;;;;;;;;;;;;;;;ACFrB;;;;AACA;;;;AACA;;;;;;;;;;;;;;AAUiB;AACf,YAAU,IAAV;AACA;AACA,iBAAe,KAAf;AACA,WAAS,YAAT;AACA,wBAAsB,KAAtB;AACA,kBAAgB,KAAhB;EANI;;AASyC;;;;AAG7C,OAAI,UAAU,QAAQ,MAAR,CAAe,EAAf,EAAmB,MAA7B;;;;;;;;;;;;;;AAHyC,MAiBD;SAA7B,qBAA6B;;AAAA;AAE1C,kBAF0C;IAA9B;;;;;;;;;;;;;;AAjB+B,MAkCM;SAAlC,uBAAkC;;AAAA;AAEjD,kBAFiD;IAAnC;;;;;;;;;;;;;;AAlC6B,MAmDC;SAA5B,wBAA4B;;AAAA;AAE5C,kBAF4C;IAA7B;;;;;;;;;;;;;;AAnD4B,MAoE2B;SAAzC,qCAAyC;;AAAA;AAEtE,kBAFsE;IAA1C;;;;;;;;;;;;;;;;AApEe,MAuFe;SAAnC,+BAAmC;;AAAA;AAE1D,kBAF0D;IAApC;;;;;;;;;;;;;;;;;;AAvFqB,MA4Gf;AAC5B,aAAQ,WAAR,GAAsB,KAAtB,CAD4B;AAE5B,aAAQ,YAAR,GAAuB,CAAC,CAAC,GAFG;AAG5B,kBAH4B;IAAX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5G0B,OAmJ7C,CAAK,IAAL,GAAY,GAA+D;;AAEzE,SAAI,kBAAkB,QAAQ,MAAR,CAAe,EAAf,EAAmB,cAAc,UAAd,EAFgC;AAGzE,SAAI,gBAAgB,OAAhB,EAAyB;AAC3B,cAAO,qBADoB;MAA7B,MAKO;AACL,aADK;MALP;IAHU,CAnJiC;EAAZ;;;;;;;;;;;;;;;;ACrBnC;;AAEA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4DqB;;;AAEnB,YAFmB,gBAEnB,CAAY,UAAZ,EAAwB,KAQnB;AAAA;SANH,iCAMG;SALH,qBAKG;SAJH,iCAIG;SAHH,qBAGG;SAFH,iCAEG;SADH,+BACG;;2BAVc,aAUd;;6CAAA;;AAEH,WAAK,UAAL,GAAkB,UAAlB,CAFG;AAAA;AAIH,WAAK,IAAL,GAAY,IAAZ,CAJG;AAKH,WAAK,EAAL,GAAU,EAAV,CALG;AAMH,WAAK,QAAL,GAAgB,CANb;AAOH,WAAK,OAAL,CAAe;AACb,uBADa;AAEb,sBAFa;AAGb,qBAHa;AAIb,kCAJa;AAKb,sBALa;AAMb,iCANa;MAAf,CAPG;AAeH,SAAI,QAAQ,UAAR,CAAmB,KAAc;AACnC,OADmC;MAArC,MAEO,IAAI,QAAQ,QAAR,CAAiB,UAAc;AACxC,WAAI;AACF,eAAK,WAAL,GAAmB,UAAU,GAAV,CAAc,KAD/B;QAAJ,CAEE,GAAU;AACV,aAAI,MAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,iBAAK,GADwB;UAA/B;QADA;MAHG;AASP,QA1BG;AA2BH,MAAc;AACZ,kBAAW,KAAX;AACA,mBAAY,EAAZ;MAFF,CA3BG;AA+BH,WAAK,SAAL,GAAiB,CAAjB;;AA/BG,UAiCH,CAAK,YAAL;;AAjCG,UAmCH,CAAK,WAAL,GAAmB,yBAAnB;;AAnCG,UAqCH,CAAK,UAAL,GArCG;;IARL;;;;;AAFmB;;kCAmDN;;;AACX,YAAK,QAAL,CAAc,IAAS;AAAM;QAAN,CADZ;AAEX,YAAK,QAAL,CAAc,OAAd,GAAwB;SAAM;QAAN;;;AAGM;gBAAM,OAAK,kBAAL,CAAwB,IAAxB;QAAN,CALnB;AAMX,+BAAwB,WAAxB,GAAsC,GAN3B;AAOX,SAAgB;gBAAM;QAAN,EAAkC,KAAK,OAAL,CAAa,YAPpD;;;;;;;OAWI;AACf,WAAI,gBADW;AAEf,YAAK,kBAAL,CAAwB,IAAxB,EAFe;AAGf,WAAI,CAAC,KAAK,MAAL,CAAY,SAAZ,EAAuB;AAC1B,cAAK,MAAL,CAAY,SAAZ,GAAwB,IADE;AAE1B,kCAAyB,EAFC;QAA5B;;AAHe,QAQf;;AARe,WAUX,sBAAJ,EAA4B;AAC1B,cAAK,UAAL,CAAgB,UAAhB,CAA8B,KAAK,OAAL,CAAa,MAAb,oBADJ;QAA5B;AAGA,YAAK,UAAL,CAAgB,OAAhB;;AAbe,WAeX,KAAK,OAAL,CAAa,aAAb,IAA8B,KAAK,CAAqB;AAC1D,gBAAO,KAAK,WAAqB;AAC/B,eAAI,KAAK,KAAK,YAAL,CAAkB,KAAlB,EAAL,CAD2B;AAE/B,eAAI,QAAQ,UAAR,CAAmB,EAAnB,CAAJ,EAA4B;AAC1B,kBAD0B;YAA5B;UAFF;AAMA,YAP0D;QAA5D;;;;;;;OAYgB;AAChB,YAAK,gBADW;AAEhB,WAAI,KAAK,MAAL,CAAY,SAAZ,EAAuB;AACzB,cAAK,MAAL,CAAY,SAAZ,GAAwB,IADC;AAEzB,cAAK,UAAL,CAAgB,UAFS;QAA3B;;;;;;;OAOgB;AAChB,YAAK,QADW;;;;;;;OAKO;;;;;;AACc;YAAA;;AACnC,eAAI,QAAQ,UAAR,CAAmB,IAAkC;AAAA;YAAzD;UADF;;;;;;;;;;;;;;QADuB;;;;OAQmB;;;AAC1C,WAAI,QAAQ,MAAkC;AAAA;AAE5C,mBAAU,SAAV,CAF4C;QAA9C;AAIA,WAAI,CAAC,QAAQ,SAAsB;AACjC,QADiC;QAAnC;AAGA,WAAI,KAA2B;AAC7B,QAD6B;QAA/B;AAGA,WAAI,kBAAkB,SAAlB,eAAkB,CAAC,GAAD,SAAc,OAAd,EAA0B;QAAA;;AAC9C,kBAAS,IAAT,EAAe,OAD+B;AAAA;QAA1B,CAXoB;AAe1C,uBAAgB,WAAhB,GAf0C;AAgB1C,SAhB0C;AAiB1C,cAAO,KAAK,QAAL,CAAc,eAAd,CAA8B,OAA9B,EAAuC,OAAvC,EAAgD,eAAhD,CAAP,CAjB0C;;;;OAoBE;AAC5C,WAAI,QAAQ,UAAR,CAA0C;AAC5C,oBAAW,OAAX,CAD4C;AAE5C,mBAAU,SAAV,CAF4C;QAA9C;AAIA,WAAI,CAAC,QAAQ,SAAsB;AACjC,QADiC;QAAnC;AAGA,WAAI,KAA2B;AAC7B,QAD6B;QAA/B;AAGA,YAAK,QAAL,CAAc,iBAAd,CAAgC,OAAhC,EAAyC,OAAzC,EAAkD,KAAK,WAAL,CAAiB,GAAjB,CAAqB,IAX3B;AAY5C,QAZ4C;;;;OAeuB;;;WAArC,cAAqC;AAAA;;AACnE,WAAI,WAAW,KAAK,EAAL,CAAQ,KAAR,EAAX,CAD+D;AAElD;AACf,aAAI,WAAJ,EAAiB;;;AAEf,iBAAI,QAA8B;AAChC,mBAAI,OAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,wBAAK,IAAL,CAAU,KAAV,qBAD6B;gBAA/B;AAGA,wBAAS,MAAT,GAJgC;cAAN,EAAxB;;AAOJ,oBAAK,QAAyD;AAC5D,sBAAK,MAAL;AAD4D,mBAExD,GAAJ,EAAS;AACP,0BAAS,MAAT,CAAgB,GAAhB,EADO;gBAAT,MAEO;AACL,0BAAS,OAAT,CAAiB,IADZ;gBAFP;cAF4C,CAA9C;gBATe;UAAjB,MAiBO;AACL,gBADK;AAEL;AAFK,UAjBP;QADS,CAFwD;AAyBnE,UAzBmE;AA0BnE,SA1BmE;AA2BnE,cAAO,SAAS,OAAT,CA3B4D;;;;OA8BlC;;;AACjC,cAAO,KAAK,MAAyB;AAAM;QAAN,CAArC,CADiC;;;;;;;;;;;;;;OAYV;AACvB,WAAM,WAAW,KAAK,EAAL,CAAQ,GADF;AAEvB,WAAI,KAAK,gBAAL,EAAJ,EAA6B;AAC3B,cAD2B;AAE3B,kBAAS,OAAT,CAAiB;AACf;UADF,EAF2B;QAA7B,MAKO,IAAI,KAAK,EAAuB;AACrC,YADqC;AAErC,kBAAS,OAAT,CAAiB;AACf,oBAAS,IAAT;UADF,EAFqC;QAAhC,MAKA;AACL,YADK;QALA;AAQP,cAAO,SAAS,IAfO;;;;;;;;;;;;;;;;OA4BI;;;AAC3B,WAAI,CAAC,KAAK,OAAL,CAA2B;;AAE9B,gBAAO,KAAK,mBAFkB;QAAhC,MAGO;AACL,aAAI,YAAY,SAAZ,SAAY,GAAM;AACpB,eAAsB;AACpB,iBAAM,cAAc,SAAd,OAAoB;AACxB,sBAAK,MAAL,CAAY,OADY;AAExB,oBAFwB;cAAN,CADA;AAKpB,iBAAM,GAAsB;AAC1B,eAD0B;AAE1B,mBAAI,OAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,wBAAK,IAAL,CAAU,KAAV,CAAgB,aADa;gBAA/B;cAFoB,CALF;AAWpB,gBAXoB;AAYpB,eAA0D;AACxD,mBAAI,OAAK,OAAL,CAAa,YAAb,EAA2B;AAC7B,wBAAK,IAAL,CAAU,KAAV,CAAgB,qCADa;gBAA/B;AAGA,sBAAO,KAAP,CAJwD;cAA1D;AAMA,wBAAW,IAlBS;AAmBpB,cAnBoB;YAAtB,MAoBO;;AAEL,iBAAI,EAA2B;AAC7B,sBAAK,IAAL,CAAU,KAAV,CAAgB,EADa;cAA/B;AAGA,oBAAO,KAAP,CALK;YApBP;UADc,CADX;AA8BL,YA9BK;AA+BL,WA/BK;QAHP;;;;;;;;;;;;OA4C4B;AAC5B,WAAI,KAAK,OAAL,CAAa,OAAS;AACxB,aAAI,SAAJ,EAAe;AACb,gBAAK,eAAL,GADa;UAAf;QADF,MAIO;AACL,UADK;QAJP;AAOA,cAAO,KAAK,eAAL,CARqB;;;;;;;;;;;OAgBX;AACjB,cAAO,KAAK,UADK;;;;;;;;;;;OASJ;AACb,cAAO,KAAK,MADC;;;;;;;OAKD;AACZ,cAAO,KAAK,KADA;;;;OAIF;AACV,cAAO,KAAK,GADF;;;;;;;;;;;OASY;AACtB,cAAO,KAAK,YAAL,CAAkB,EADH;;;;OAhTL;;;;;;;;;;;;;;;;;;;;;;;;;;IC1DA;AAEO;SAAd,iBAAc;;2BAFP,OAEO;;AACxB,UAAK,OAAL,GAAe,OAAf,CADwB;AAAA;IAA1B;;IAFmB;;yBAOR;AACT,YAAK,KADI;AAET,cAAO,KAAK,cAFH;;;;OAKa;AACtB,cAAO,KAAK,KAAL,CAAW,MAAX,GAAkC;AACvC,cAAK,KAAL,GADuC;QAAzC;AAGA,cAAO,IAAP,CAJsB;;;;OAOjB;AACL,cAAO,GADF;;;;OAIC;AACN,cAAO,IADD;;;;OAID;AACL,cAAO,GADF;;;;OA3BY;;;;;;;;;;;;;;;;;;;;;;;;;ICDA;AAEL;2BAFK,GAEL;;AACZ,UAAK,KAAL,GADY;AAAd;;;;;;AAFmB;;yBAQf,IAAY;AACd,WAAI,KADU;AAEd,WAAI,MAAM,CAAC,CAAD,EAAI;AACZ,cAAK,MAAL,CAAY,GAAZ,IAAmB,KAAnB,CADY;QAAd,MAEO;AACL,cAAK,IAAL,CAAU,IAAV,CAAe,GAAf,EADK;AAEL,cAAK,CAFA;QAFP;AAMA,cAAO,IAAP,CARc;;;;;;;OAYP;AACP,WAAI,KADG;AAEP,WAAI,MAAM,CAAC,CAAD,EAAI;AACZ,gBAAO,KAAK,MAAL,CAAY,GAAZ,CAAP,CADY;QAAd;;;;;;;OAMe;AACf,WAAI,MAAM,KAAK,EADA;AAEf,cAAO,MAAM,CAAC,CAAD,CAFE;;;;;;;OAMI;AACnB,WAAI,MAAM,KAAK,IADI;AAEnB,cAAO,MAAM,CAAC,CAAD,CAFM;;;;;;;OAMT;AACV,WAAI,MAAM,EADA;AAEV,WAAI,MAAM,CAAC,CAAD,EAAI;AACZ,cAAK,IAAL,CAAU,GAAV,IAAiB,SAAjB,CADY;AAEZ,cAAK,MAAL,CAAY,CAFA;QAAd;;;;;;;OAQM;AACN,YAAK,IAAL,EADM;AAEN,YAAK,MAAL,GAAc,EAAd,CAFM;AAGN,cAAO,IAAP,CAHM;;;;;;;OAOU;AAChB,YAAK,IAAI,CAAJ,IAAS,IAAW;AACvB,aAAI,QAAQ,KAAK,IAAL,CAAU,CAAV,CAAR,EAAsB;AACxB,kBAAO,CAAP,CADwB;UAA1B;QADF;AAKA,UANgB;;;;OASI;AACpB,YAAK,IAAI,CAAJ,IAAS,KAAK,CAAQ;AACzB,aAAI,UAAU,KAAK,MAAL,CAAY,CAAZ,CAAV,EAA0B;AAC5B,kBAAO,CAAP,CAD4B;UAA9B;QADF;AAKA,UANoB;;;;OAlEH;;;;;;;;;;;;;;;;;;;KCLA;;;;;;;+BAET;;;OAEW;AACnB,cAAO,CAAP;AADmB;;;OAIF;AACjB,cAAO,KAAP,CADiB;;;;OAIJ;AACb,cAAO,KAAP,CADa;;;;OAIH;AACV,cAAO,KAAP,CADU;;;;OAIE;AACZ,cAAO,KAAP,CADY;;;;OAIP;;;OAEG;;;OA1BS;;;;;;;;;;;;;;;ACArB;;;;;;;;;;;;KAEqB;;;;;;;;;;;;;;;;;;;;;;;;;;ACFrB;;;;KAEqB;AAES;;;sBAAA;;AAC1B,UAAK,QAAL,GAAgB,QAAhB,CAD0B;AAAA;AAG1B,UAAK,QAAL,GAAgB,EAAhB,CAH0B;AAI1B,UAAK,QAAL,CAAc,GAAQ;AACpB,wBAAwB;gBAAM,MAAK,MAAL;QAAN;MAD1B,EAJ0B;IAA5B;;IAFmB;;6BAWM;AACvB,YAAK,IAAI,OAAJ,IAAe,KAAK,GAAU;AACjC,aAAI,YAAY,KAAK,QAAL,CAAc,OAAd,CADiB;AAEjC,aAAI,aAAa,UAAU,MAAV,CAAkB;;;;;;AACU;;mBAAjC,8BAAiC;mBAAxB,0BAAwB;;AACzC,oBAAK,QAAL,CAAc,eAAd,CAA8B,MADW;AAA3C;;;;;;;;;;;;;;YADiC;UAAnC;QAFF;;;;;;;;;;;;;;;;;;;;OAwB0C;;;AAC1C,WAAI,CAAC,KAAK,QAAmB;AAAA;QAA7B;AAGA,WAAI,UAAU,EAAC,cAJ2B;AAK1C,QAL0C;AAM1C,WAAI,eAAe,IAAf,CANsC;AAO1C,WAAI,KAAK,QAAL,CAAc,gBAAd,EAAJ,CAAsC;AACpC,cAAK,QAAL,CAAc,QADsB;AAEpC,wBAAe;kBAAM,OAAK,QAAL,CAAc,iBAAd,CAAgC,OAAhC,EAAyC,MAAzC;UAAN,CAFqB;QAAtC;;AAP0C,QAYhB;AACxB,aAAI,YAAJ,EAAkB;AAChB,0BADgB;AAEhB,0BAAe,EAFC;UAAlB;;AADwB,UAMI;AAC1B,eAAI,QAAQ,OAAK,MADS;AAE1B,eAAI,QAAQ,CAAC,CAAD,EAAI;AACd,oBAAK,QAAL,CAAc,OAAd,EAAuB,MAAvB,CAA8B,KAA9B,EAAqC,CAArC,EADc;YAAhB;AAGA,eAAI,OAAK,QAAL,CAAc,OAAd,EAAuB,MAAvB,GAAgC,CAAhC,EAAmC;AACrC,YADqC;YAAvC;UALF;QANkB,CAZsB;AA4B1C,UA5B0C;AA6B1C,SA7B0C;;;;;;;;;;;;;;;OAyCb;AAC7B,cAAO,CADsB;;;;;;;;;;;;;;;OAaS;AACtC,cAAO,KAAK,KAD0B;;;;;;;;;;;;;;;;;;;OAiBM;;AAE5C,WAAI,KAAK,QAAL,CAAc,OAAd,CAAJ,EAA4B;AAC1B,aAAI,QAAQ,KAAK,QADS;AAE1B,aAAI,QAAQ,CAAC,CAAD,EAAI;AACd,gBAAK,QAAL,CAAc,OAAd,EAAuB,MAAvB,CAA8B,KAA9B,EAAqC,CAArC,EADc;UAAhB;AAGA,aAAI,KAAK,QAAL,CAAc,OAAd,EAAuB,MAAvB,GAAgC,CAAhC,EAAmC;AACrC,UADqC;UAAvC;QALF;;AAF4C,QAYN;AACpC,cAAK,QAAL,CAAc,YADsB;QAAtC;;;;;;;;;;;;;;;OAc6B;AAC7B,cAAO,CADsB;;;;;;;;;;;;;;;OAaY;AACzC,cAAO,KAAK,QAD6B;;;;;;;;;;;;;;;;;;;;;;;OAqByC;WAA7D,MAA6D;WAA/C,kCAA+C;;AAClF,cAAO,KAAK,QAAL,CAAc,IAAd,CAAmB,OAAnB,EAA4B,OAA5B,EAAqC,OAArC,EAA8C,QAAQ,OAAR,EAAiB,QAAQ,WAAR,CAAtE,CADkF;;;;;;;;;;;;;;;;;;;;OAkB5C;WAAd,SAAc;;AACtC,cAAO,KAAK,QAAL,CAAc,OAAd,CAAsB,OAAtB,EAA+B,OAA/B,EAAwC,OAAxC,CAAP,CADsC;;;;;;;;;;;;;;;OAaH;WAAd,MAAc;;AACnC,cAAO,KAAK,OAAL,CAAa,OAAb,EAAsB,OAAtB,EAA+B,OAA/B,CAAP,CADmC;;;;;;;;;;;;;;;;;OAehB;AACnB,cAAO,KAAK,QAAL,CAAc,GADF;;;;;;;;;;;;;;;OAaR;AACX,cAAO,KAAK,IADD;;;;;;;;;;;;;;;;;OAiBM;AACjB,cAAO,KAAK,UADK;;;;;;;;;;;;;;;;;OAeP;AACV,cAAO,KAAK,GADF;;;;;;;;;;;;;;;;;OAeE;AACZ,cAAO,KAAK,KADA;;;;;;;;;;;;;;;;;OAeC;AACb,cAAO,KAAK,MADC;;;;;;;;;;;;;;OAYE;AACf,cAAO,KAAK,QADG;;;;;;;;;;;;;;;;;OAeO;AACtB,cAAO,KAAK,QAAL,CAAc,MADC;;;;OA3TL","file":"dist/angular-vertxbus.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9129d8acc85947c990d8\n **/","import moduleName from './module';\n\nexport default moduleName;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import {moduleName} from './config';\n\nimport VertxEventBusWrapperProvider from './lib/VertxEventBusWrapperProvider';\nimport VertxEventBusServiceProvider from './lib/VertxEventBusServiceProvider';\n\n/**\n * @ngdoc overview\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus\n * @description\n *\n * Client side library using VertX Event Bus as an Angular Service module\n *\n * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n *\n * <pre>\n *   angular.module('app', ['knalli.angular-vertxbus'])\n *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n *\n *       // using the EventBus directly\n *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n *         // your reply comes here\n *       });\n *\n *       // using the service\n *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n *         .then(function (reply) {\n *           // your reply comes here\n *         })\n *         .catch(function (err) {\n *           // something went wrong, no connection, no login, timed out, or so\n *         });\n *     });\n * </pre>\n *\n * The module itself provides following components:\n * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n *\n * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n * reconnect management, authorization and a clean promise based api.\n *\n * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n * underlying instance of the current `vertx.EventBus`.\n *\n * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n */\nexport default angular\n\n  .module(moduleName, ['ng'])\n\n  .provider('vertxEventBus', VertxEventBusWrapperProvider)\n  .provider('vertxEventBusService', VertxEventBusServiceProvider)\n\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/module.js\n **/","const moduleName = 'knalli.angular-vertxbus';\n\nexport {moduleName};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/config.js\n **/","import EventBusAdapter from './adapter/EventBusAdapter';\nimport NoopAdapter from './adapter/NoopAdapter';\nimport ConnectionConfigHolder from './support/ConnectionConfigHolder';\n\nimport EventBus from 'vertx-eventbus';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusProvider\n * @description\n * An AngularJS wrapper for projects using the VertX Event Bus\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  initialConnectEnabled : true,\n  urlServer : `${location.protocol}//${location.hostname}` + ((() => {\n    if (location.port) {\n      return `:${location.port}`;\n    }\n  })() || ''),\n  urlPath : '/eventbus',\n  reconnectEnabled : true,\n  sockjsReconnectInterval : 10000,\n  sockjsOptions : {}\n};\n\nlet VertxEventBusWrapperProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#disableAutoConnect\n   *\n   * @description\n   * Disables the auto connection feature.\n   *\n   * This feature will be only available if `enable == true`.\n   *\n   * @param {boolean} [value=true] auto connect on startup\n   * @returns {object} this\n   */\n  this.disableAutoConnect = () => {\n    options.initialConnectEnabled = false;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlServer\n   *\n   * @description\n   * Overrides the url part \"server\" for connecting. The default is based on\n   * - `location.protocol`\n   * - `location.hostname`\n   * - `location.port`\n   *\n   * i.e. `http://domain.tld` or `http://domain.tld:port`\n   *\n   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n   * @returns {object} this\n   */\n  this.useUrlServer = (value = DEFAULTS.urlServer) => {\n    options.urlServer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlPath\n   *\n   * @description\n   * Overrides the url part \"path\" for connection.\n   *\n   * @param {boolean} [value='/eventbus'] path to connect\n   * @returns {object} this\n   */\n  this.useUrlPath = (value = DEFAULTS.urlPath) => {\n    options.urlPath = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useReconnect\n   *\n   * @description\n   * Enables or disables the automatic reconnect handling.\n   *\n   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n   * @returns {object} this\n   */\n  this.useReconnect = (value = DEFAULTS.reconnectEnabled) => {\n    options.reconnectEnabled = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsReconnectInterval\n   *\n   * @description\n   * Overrides the timeout for reconnecting after a disconnect was found.\n   *\n   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsReconnectInterval = (value = DEFAULTS.sockjsReconnectInterval) => {\n    options.sockjsReconnectInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsOptions\n   *\n   * @description\n   * Sets additional params for the `SockJS` instance.\n   *\n   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n   *\n   * @param {boolean} [value={}]  optional params for raw SockJS options\n   * @returns {object} this\n   */\n  this.useSockJsOptions = (value = DEFAULTS.sockjsOptions) => {\n    options.sockjsOptions = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBus\n   * @description\n   * A stub representing the Vert.x EventBus (core functionality)\n   *\n   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n   * new instance of the bus have to be created.\n   * This stub ensures only one object holding the current active instance of the bus.\n   *\n   * The stub supports theses Vert.x Event Bus APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n   *\n   * Furthermore, the stub supports theses extra APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n   *\n   * @requires $timeout\n   * @requires $log\n   */\n  /* @ngInject */\n  this.$get = ($timeout, $log, $q) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, DEFAULTS, options);\n    if (instanceOptions.enabled && EventBus) {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Enabled');\n      }\n\n      // aggregate server connection params\n      instanceOptions.connectionConfig = new ConnectionConfigHolder({\n        urlServer : instanceOptions.urlServer,\n        urlPath : instanceOptions.urlPath\n      });\n      delete instanceOptions.urlServer;\n      delete instanceOptions.urlPath;\n\n      return new EventBusAdapter(EventBus, $timeout, $log, $q, instanceOptions);\n    } else {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Disabled');\n      }\n      return new NoopAdapter(EventBus, $q);\n    }\n  };\n\n};\n\nexport default VertxEventBusWrapperProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusWrapperProvider.js\n **/","import {moduleName} from '../../config.js';\n\nimport BaseAdapter from './BaseAdapter';\nimport ConnectionConfigHolder from './../support/ConnectionConfigHolder';\n\n/**\n * @ngdoc service\n * @module global\n * @name global.EventBus\n *\n * @description\n * This is the interface of `EventBus`. It is not included.\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#close\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#send\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n * @param {function=} replyHandler optional callback\n * @param {function=} failureHandler optional callback\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#publish\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#registerHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#unregisterHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler to be removed\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onopen\n * @description\n * Defines the callback called on opening the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onclose\n * @description\n * Defines the callback called on closing the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onerror\n * @description\n * Defines the callback called on any error.\n */\n\nexport default class EventBusAdapter extends BaseAdapter {\n\n  constructor(EventBus, $timeout, $log, $q, {\n    enabled,\n    debugEnabled,\n    initialConnectEnabled,\n    connectionConfig,\n    reconnectEnabled,\n    sockjsReconnectInterval,\n    sockjsOptions\n    }) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n    this.$timeout = $timeout;\n    this.$log = $log;\n    this.$q = $q;\n    this.options = {\n      enabled,\n      debugEnabled,\n      initialConnectEnabled,\n      connectionConfig,\n      reconnectEnabled,\n      sockjsReconnectInterval,\n      sockjsOptions\n    };\n    this.disconnectTimeoutEnabled = true;\n    this.applyDefaultHeaders();\n    if (initialConnectEnabled) {\n      // asap create connection\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#configureConnect\n   *\n   * @description\n   * Reconfigure the connection details.\n   *\n   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n   */\n  configureConnection(urlServer, urlPath = '/eventbus') {\n    this.options.connectionConfig = new ConnectionConfigHolder({urlServer, urlPath});\n    return this;\n  }\n\n  connect() {\n    // connect promise\n    let deferred = this.$q.defer();\n    // currently valid url\n    let url = `${this.options.connectionConfig.urlServer}${this.options.connectionConfig.urlPath}`;\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Stub] Enabled: connecting '${url}'`);\n    }\n    // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n    // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n    this.instance = new this.EventBus(url, this.options.sockjsOptions);\n    this.instance.onopen = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug('[Vert.x EB Stub] Connected');\n      }\n      if (angular.isFunction(this.onopen)) {\n        this.onopen();\n      }\n      deferred.resolve();\n    };\n    // instance onClose handler\n    this.instance.onclose = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n      }\n      if (angular.isFunction(this.onclose)) {\n        this.onclose();\n      }\n      this.instance = undefined;\n\n      if (!this.disconnectTimeoutEnabled) {\n        // reconnect required asap\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n        }\n        this.disconnectTimeoutEnabled = true;\n        this.connect();\n      } else if (this.options.reconnectEnabled) {\n        // automatic reconnect after timeout\n        if (this.options.debugEnabled) {\n          this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n        }\n        this.$timeout((() => this.connect()), this.options.sockjsReconnectInterval);\n      }\n    };\n    // instance onError handler\n    this.instance.onerror = (message) => {\n      if (angular.isFunction(this.onerror)) {\n        this.onerror(message);\n      }\n    };\n    return deferred.promise;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#reconnect\n   *\n   * @description\n   * Reconnects the underlying connection.\n   *\n   * Unless a connection is open, it will connect using a new one.\n   *\n   * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n   * default timeout for reconnect will be skipped.\n   *\n   * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n   */\n  reconnect(immediately = false) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (immediately) {\n        this.disconnectTimeoutEnabled = false;\n      }\n      this.instance.close();\n    } else {\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#close\n   *\n   * @description\n   * Closes the underlying connection.\n   *\n   * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n   *\n   * See also:\n   * - {@link EventBus#methods_close EventBus.close()}\n   */\n  close() {\n    if (this.instance) {\n      this.instance.close();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#send\n   *\n   * @description\n   * Sends a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_send EventBus.send()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers optional headers\n   * @param {function=} replyHandler optional callback\n   */\n  send(address, message, headers, replyHandler) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.send(address, message, mergedHeaders, replyHandler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_publish EventBus.publish()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers optional headers\n   */\n  publish(address, message, headers) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.publish(address, message, mergedHeaders);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler\n   */\n  registerHandler(address, headers, handler) {\n    if (this.instance) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.registerHandler(address, mergedHeaders, handler);\n      // and return the deregister callback\n      let deconstructor = () => {\n        this.unregisterHandler(address, mergedHeaders, handler);\n      };\n      deconstructor.displayName = `${moduleName}.wrapper.eventbus.registerHandler.deconstructor`;\n      return deconstructor;\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a registered a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler to be removed\n   */\n  unregisterHandler(address, headers, handler) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.unregisterHandler(address, mergedHeaders, handler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#readyState\n   *\n   * @description\n   * Returns the current connection state\n   *\n   * @returns {number} value of vertx-eventbus connection states\n   */\n  readyState() {\n    if (this.instance) {\n      return this.instance.state;\n    } else {\n      return this.EventBus.CLOSED;\n    }\n  }\n\n  get state() {\n    return this.readyState();\n  }\n\n  // private\n  getOptions() {\n    // clone options\n    return angular.extend({}, this.options);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/EventBusAdapter.js\n **/","export default class BaseAdapter {\n\n  constructor($q) {\n    this.$q = $q;\n  }\n\n  configureConnection() {\n  }\n\n  connect() {\n    return this.$q.reject();\n  }\n\n  reconnect() {\n  }\n\n  close() {\n  }\n\n  send() {\n  }\n\n  publish() {\n  }\n\n  registerHandler() {\n  }\n\n  unregisterHandler() {\n  }\n\n  readyState() {\n  }\n\n  getOptions() {\n    return {};\n  }\n\n  // empty: can be overriden by externals\n  onopen() {\n  }\n\n  // empty: can be overriden by externals\n  onclose() {\n  }\n\n  // private\n  getDefaultHeaders() {\n    return this.defaultHeaders;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#applyDefaultHeaders\n   *\n   * @description\n   * Stores the given default headers\n   *\n   * @param {object} headers additional standard headers\n   */\n  applyDefaultHeaders(headers = {}) {\n    this.defaultHeaders = angular.extend({}, headers);\n  }\n\n  // private\n  getMergedHeaders(headers = {}) {\n    return angular.extend({}, this.defaultHeaders, headers);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/BaseAdapter.js\n **/","export default class ConnectionConfigHolder {\n\n  constructor({urlServer, urlPath}) {\n    this._urlServer = urlServer;\n    this._urlPath = urlPath;\n  }\n\n  get urlServer() {\n    return this._urlServer;\n  }\n\n  get urlPath() {\n    return this._urlPath;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/ConnectionConfigHolder.js\n **/","import BaseAdapter from './BaseAdapter';\n\nexport default class NoopAdapter extends BaseAdapter {\n\n  constructor(EventBus, $q) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/NoopAdapter.js\n **/","import EventBusDelegate from './service/delegate/EventBusDelegate';\nimport NoopDelegate from './service/delegate/NoopDelegate';\nimport Delegator from './service/Delegator';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n * @description\n * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  authRequired : false,\n  prefix : 'vertx-eventbus.',\n  sockjsStateInterval : 10000,\n  messageBuffer : 10000\n};\n\nlet VertxEventBusServiceProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#usePrefix\n   *\n   * @description\n   * Overrides the default prefix which will be used for emitted events.\n   *\n   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n   * @returns {object} this\n   */\n  this.usePrefix = (value = DEFAULTS.prefix) => {\n    options.prefix = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useSockJsStateInterval\n   *\n   *\n   * @description\n   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n   *\n   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsStateInterval = (value = DEFAULTS.sockjsStateInterval) => {\n    options.sockjsStateInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useMessageBuffer\n   *\n   * @description\n   * Enables buffering of (sending) messages.\n   *\n   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n   * connection is still in progress, the connection is stale or a login is required/pending.\n   *\n   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n   * @returns {object} this\n   */\n  this.useMessageBuffer = (value = DEFAULTS.messageBuffer) => {\n    options.messageBuffer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#authHandler\n   *\n   * @description\n   * Function or service reference name for function checking the authorization state.\n   *\n   * The result of the function must be a boolean or promise. The handler can (but is not required) to create authorization on demand.\n   * If it is resolved, the authorization is valid.\n   * If it is rejected, the authorization is invalid.\n   *\n   * @param {string|function} value authorization handler (either a function or a service name)\n   * @returns {object} promise\n   */\n  this.authHandler = (value) => {\n    options.authHandler = value;\n    options.authRequired = !!value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBusService\n   * @description\n   * A service utilizing an underlying Vert.x Event Bus\n   *\n   * The advanced features of this service are:\n   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n   *  - registering all handlers again when a reconnect had been required\n   *  - supporting a promise when using send()\n   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n   *\n   * Basic usage:\n   * <pre>\n   * module.controller('MyController', function('vertxEventService') {\n *   vertxEventService.on('my.address', function(message) {\n *     console.log(\"JSON Message received: \", message)\n *   });\n *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n * });\n   * </pre>\n   *\n   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n   *\n   * @requires knalli.angular-vertxbus.vertxEventBus\n   * @requires $rootScope\n   * @requires $q\n   * @requires $interval\n   * @requires $log\n   * @requires $injector\n   */\n  /* @ngInject */\n  this.$get = ($rootScope, $q, $interval, vertxEventBus, $log, $injector) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n    if (instanceOptions.enabled) {\n      return new Delegator(\n        new EventBusDelegate($rootScope, $interval, $log, $q, $injector, vertxEventBus, instanceOptions),\n        $log\n      );\n    } else {\n      return new Delegator(new NoopDelegate());\n    }\n  };\n\n};\n\nexport default VertxEventBusServiceProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusServiceProvider.js\n **/","import {moduleName} from '../../../config';\n\nimport Queue from './../../support/Queue';\nimport SimpleMap from './../../support/SimpleMap';\nimport BaseDelegate from './BaseDelegate';\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name disconnected\n *\n * @description\n * After a connection was being terminated.\n *\n * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name connected\n *\n * @description\n * After a connection was being established\n *\n * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-succeeded\n *\n * @description\n * After a login has been validated successfully\n *\n * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be `'ok'`\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-failed\n *\n * @description\n * After a login has been destroyed or was invalidated\n *\n * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be not`'ok'`\n */\n\nexport default class EventBusDelegate extends BaseDelegate {\n\n  constructor($rootScope, $interval, $log, $q, $injector, eventBus, {\n    enabled,\n    debugEnabled,\n    prefix,\n    sockjsStateInterval,\n    messageBuffer,\n    authRequired,\n    authHandler\n    }) {\n    super();\n    this.$rootScope = $rootScope;\n    this.$interval = $interval;\n    this.$log = $log;\n    this.$q = $q;\n    this.eventBus = eventBus;\n    this.options = {\n      enabled,\n      debugEnabled,\n      prefix,\n      sockjsStateInterval,\n      messageBuffer,\n      authRequired\n    };\n    if (angular.isFunction(authHandler)) {\n      this.authHandler = authHandler;\n    } else if (angular.isString(authHandler)) {\n      try {\n        this.authHandler = $injector.get(authHandler);\n      } catch (e) {\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Service] Failed to resolve authHandler: %s', e.message);\n        }\n      }\n    }\n    this.connectionState = this.eventBus.EventBus.CLOSED;\n    this.states = {\n      connected: false,\n      authorized: false\n    };\n    this.observers = [];\n    // internal store of buffered messages\n    this.messageQueue = new Queue(this.options.messageBuffer);\n    // internal map of callbacks\n    this.callbackMap = new SimpleMap();\n    // asap\n    this.initialize();\n  }\n\n  // internal\n  initialize() {\n    this.eventBus.onopen = () => this.onEventbusOpen();\n    this.eventBus.onclose = () => this.onEventbusClose();\n\n    // Update the current connection state periodically.\n    let connectionIntervalCheck = () => this.getConnectionState(true);\n    connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n    this.$interval((() => connectionIntervalCheck()), this.options.sockjsStateInterval);\n  }\n\n  // internal\n  onEventbusOpen() {\n    let connectionStateFlipped = false;\n    this.getConnectionState(true);\n    if (!this.states.connected) {\n      this.states.connected = true;\n      connectionStateFlipped = true;\n    }\n    // Ensure all events will be re-attached\n    this.afterEventbusConnected();\n    // Everything is online and registered again, let's notify everybody\n    if (connectionStateFlipped) {\n      this.$rootScope.$broadcast(`${this.options.prefix}system.connected`);\n    }\n    this.$rootScope.$digest(); // explicitly\n    // consume message queue?\n    if (this.options.messageBuffer && this.messageQueue.size()) {\n      while (this.messageQueue.size()) {\n        let fn = this.messageQueue.first();\n        if (angular.isFunction(fn)) {\n          fn();\n        }\n      }\n      this.$rootScope.$digest();\n    }\n  }\n\n  // internal\n  onEventbusClose() {\n    this.getConnectionState(true);\n    if (this.states.connected) {\n      this.states.connected = false;\n      this.$rootScope.$broadcast(`${this.options.prefix}system.disconnected`);\n    }\n  }\n\n  // internal\n  observe(observer) {\n    this.observers.push(observer);\n  }\n\n  // internal\n  afterEventbusConnected() {\n    for (let observer of this.observers) {\n      if (angular.isFunction(observer.afterEventbusConnected)) {\n        observer.afterEventbusConnected();\n      }\n    }\n  }\n\n  registerHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Register handler for ${address}`);\n    }\n    var callbackWrapper = (err, {body}, replyTo) => {\n      callback(body, replyTo);\n      this.$rootScope.$digest();\n    };\n    callbackWrapper.displayName = `${moduleName}.service.delegate.live.registerHandler.callbackWrapper`;\n    this.callbackMap.put(callback, callbackWrapper);\n    return this.eventBus.registerHandler(address, headers, callbackWrapper);\n  }\n\n  unregisterHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Unregister handler for ${address}`);\n    }\n    this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n    this.callbackMap.remove(callback);\n  }\n\n  send(address, message, headers, timeout = 10000, expectReply = true) {\n    let deferred = this.$q.defer();\n    let next = () => {\n      if (expectReply) {\n        // Register timeout for promise rejecting\n        let timer = this.$interval((() => {\n          if (this.options.debugEnabled) {\n            this.$log.debug(`[Vert.x EB Service] send('${address}') timed out`);\n          }\n          deferred.reject();\n        }), timeout, 1);\n        // Send message\n        this.eventBus.send(address, message, headers, (err, reply) => {\n          this.$interval.cancel(timer); // because it's resolved\n          if (err) {\n            deferred.reject(err);\n          } else {\n            deferred.resolve(reply);\n          }\n        });\n      } else {\n        this.eventBus.send(address, message, headers);\n        deferred.resolve(); // we don't care\n      }\n    };\n    next.displayName = `${moduleName}.service.delegate.live.send.next`;\n    this.ensureOpenAuthConnection(next).then(null, deferred.reject);\n    return deferred.promise;\n  }\n\n  publish(address, message, headers) {\n    return this.ensureOpenAuthConnection(() => this.eventBus.publish(address, message, headers));\n  }\n\n  /**\n   * Ensures the callback will be performed with an open connection.\n   *\n   * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenConnection(fn) {\n    const deferred = this.$q.defer();\n    if (this.isConnectionOpen()) {\n      fn();\n      deferred.resolve({\n        inQueue: false\n      });\n    } else if (this.options.messageBuffer) {\n      this.messageQueue.push(fn);\n      deferred.resolve({\n        inQueue: true\n      });\n    } else {\n      deferred.reject();\n    }\n    return deferred.promise;\n  }\n\n  /**\n   * Ensures the callback will be performed with a valid session.\n   *\n   * Unless `authRequired` is enabled, this will be simple forward.\n   *\n   * Unless a valid session exist (but required), the callback will be not invoked.\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenAuthConnection(fn) {\n    if (!this.options.authRequired) {\n      // easy: no login required\n      return this.ensureOpenConnection(fn);\n    } else {\n      let fnWrapper = () => {\n        if (this.authHandler) {\n          const onValidAuth = () => {\n            this.states.authorized = true;\n            fn();\n          };\n          const onInvalidAuth = () => {\n            this.states.authorized = false;\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent due authHandler rejected');\n            }\n          };\n          const authResult = this.authHandler(this.eventBus);\n          if (!(authResult && angular.isFunction(authResult.then))) {\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent because authHandler is returning not a promise');\n            }\n            return false;\n          }\n          authResult.then(onValidAuth, onInvalidAuth);\n          return true;\n        } else {\n          // ignore this message\n          if (this.options.debugEnabled) {\n            this.$log.debug('[Vert.x EB Service] Message was not sent because no authHandler is defined');\n          }\n          return false;\n        }\n      };\n      fnWrapper.displayName = `${moduleName}.service.delegate.live.ensureOpenAuthConnection.fnWrapper`;\n      return this.ensureOpenConnection(fnWrapper);\n    }\n  }\n\n  /**\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState(immediate) {\n    if (this.options.enabled) {\n      if (immediate) {\n        this.connectionState = this.eventBus.state;\n      }\n    } else {\n      this.connectionState = this.eventBus.EventBus.CLOSED;\n    }\n    return this.connectionState;\n  }\n\n  /**\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n  }\n\n  /**\n   * Returns true if the session is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.states.authorized;\n  }\n\n  // internal\n  isConnected() {\n    return this.states.connected;\n  }\n\n  isEnabled() {\n    return this.options.enabled;\n  }\n\n  /**\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.messageQueue.size();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/EventBusDelegate.js\n **/","/*\n Simple queue implementation\n\n FIFO: #push() + #first()\n LIFO: #push() + #last()\n */\nexport default class Queue {\n\n  constructor(maxSize = 10) {\n    this.maxSize = maxSize;\n    this.items = [];\n  }\n\n  push(item) {\n    this.items.push(item);\n    return this.recalibrateBufferSize();\n  }\n\n  recalibrateBufferSize() {\n    while (this.items.length > this.maxSize) {\n      this.first();\n    }\n    return this;\n  }\n\n  last() {\n    return this.items.pop();\n  }\n\n  first() {\n    return this.items.shift(0);\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/Queue.js\n **/","/*\n Simple Map implementation\n\n This implementation allows usage of non serializable keys for values.\n */\nexport default class SimpleMap {\n\n  constructor() {\n    this.clear();\n  }\n\n  // Stores the value under the key.\n  // Chainable\n  put(key, value) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.values[idx] = value;\n    } else {\n      this.keys.push(key);\n      this.values.push(value);\n    }\n    return this;\n  }\n\n  // Returns value for key, otherwise undefined.\n  get(key) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      return this.values[idx];\n    }\n  }\n\n  // Returns true if the key exists.\n  containsKey(key) {\n    let idx = this._indexForKey(key);\n    return idx > -1;\n  }\n\n  // Returns true if the value exists.\n  containsValue(value) {\n    let idx = this._indexForValue(value);\n    return idx > -1;\n  }\n\n  // Removes the key and its value.\n  remove(key) {\n    let idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.keys[idx] = undefined;\n      this.values[idx] = undefined;\n    }\n\n  }\n\n  // Clears all keys and values.\n  clear() {\n    this.keys = [];\n    this.values = [];\n    return this;\n  }\n\n  // Returns index of key, otherwise -1.\n  _indexForKey(key) {\n    for (let i in this.keys) {\n      if (key === this.keys[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  _indexForValue(value) {\n    for (let i in this.values) {\n      if (value === this.values[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/SimpleMap.js\n **/","export default class BaseDelegate {\n\n  observe() {}\n\n  getConnectionState() {\n    return 3; // CLOSED\n  }\n\n  isConnectionOpen() {\n    return false;\n  }\n\n  isAuthorized() {\n    return false;\n  }\n\n  isEnabled() {\n    return false;\n  }\n\n  isConnected() {\n    return false;\n  }\n\n  send() {}\n\n  publish() {}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/BaseDelegate.js\n **/","import BaseDelegate from './BaseDelegate';\n\nexport default class NoopDelegate extends BaseDelegate {}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/NoopDelegate.js\n **/","import {moduleName} from '../../config';\n\nexport default class Delegator {\n\n  constructor(delegate, $log) {\n    this.delegate = delegate;\n    this.$log = $log;\n    this.handlers = [];\n    this.delegate.observe({\n      afterEventbusConnected: () => this.afterEventbusConnected()\n    });\n  }\n\n  afterEventbusConnected() {\n    for (let address in this.handlers) {\n      let callbacks = this.handlers[address];\n      if (callbacks && callbacks.length) {\n        for (let {headers, callback} of callbacks) {\n          this.delegate.registerHandler(address, headers, callback);\n        }\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   * @returns {function} deconstructor\n   */\n  registerHandler(address, headers, callback) {\n    if (!this.handlers[address]) {\n      this.handlers[address] = [];\n    }\n    var handler = {headers, callback};\n    this.handlers[address].push(handler);\n    var unregisterFn = null;\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.registerHandler(address, headers, callback);\n      unregisterFn = () => this.delegate.unregisterHandler(address, headers, callback);\n    }\n    // and return the deregister callback\n    var deconstructor = () => {\n      if (unregisterFn) {\n        unregisterFn();\n        unregisterFn = undefined;\n      }\n      // Remove from internal map\n      if (this.handlers[address]) {\n        var index = this.handlers[address].indexOf(handler);\n        if (index > -1) {\n          this.handlers[address].splice(index, 1);\n        }\n        if (this.handlers[address].length < 1) {\n          this.handlers[address] = undefined;\n        }\n      }\n    };\n    deconstructor.displayName = `${moduleName}.service.registerHandler.deconstructor`;\n    return deconstructor;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#on\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  on(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#addListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  addListener(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   */\n  unregisterHandler(address, headers, callback) {\n    // Remove from internal map\n    if (this.handlers[address]) {\n      var index = this.handlers[address].indexOf({headers, callback});\n      if (index > -1) {\n        this.handlers[address].splice(index, 1);\n      }\n      if (this.handlers[address].length < 1) {\n        this.handlers[address] = undefined;\n      }\n    }\n    // Remove from real instance\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.unregisterHandler(address, headers, callback);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#un\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  un(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#removeListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  removeListener(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#send\n   *\n   * @description\n   * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers headers\n   * @param {number=} [options.timeout=10000] (in ms) after which the promise will be rejected\n   * @param {boolean=} [options.expectReply=true] if false, the promise will be resolved directly and\n   *                                       no replyHandler will be created\n   * @returns {object} promise\n   */\n  send(address, message, headers = {}, options = {timeout: 10000, expectReply: true}) {\n    return this.delegate.send(address, message, headers, options.timeout, options.expectReply);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers headers\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  publish(address, message, headers = {}) {\n    return this.delegate.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#emit\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_publish publish()})\n   */\n  emit(address, message, headers = {}) {\n    return this.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getConnectionState\n   *\n   * @description\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState() {\n    return this.delegate.getConnectionState();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#readyState\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()})\n   */\n  readyState() {\n    return this.getConnectionState();\n  }\n\n\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnectionOpen\n   *\n   * @description\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.isConnectionOpen();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isEnabled\n   *\n   * @description\n   * Returns true if service is being enabled.\n   *\n   * @returns {boolean} state\n   */\n  isEnabled() {\n    return this.delegate.isEnabled();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnected\n   *\n   * @description\n   * Returns true if service (and the eventbus) is being connected.\n   *\n   * @returns {boolean} state\n   */\n  isConnected() {\n    return this.delegate.isConnected();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isAuthorized\n   *\n   * @description\n   * Returns true if the authorization is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isValidSession\n   *\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_isAuthorized isAuthorized()})\n   */\n  isValidSession() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getMessageQueueLength\n   *\n   * @description\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.delegate.getMessageQueueLength();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/Delegator.js\n **/"],"sourceRoot":""}