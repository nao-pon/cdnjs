{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-vertxbus.min.js","webpack:///webpack/bootstrap 411fd831f717e46099b9","webpack:///./src/index.js","webpack:///./src/module.js","webpack:///./src/config.js","webpack:///./src/lib/VertxEventBusWrapperProvider.js","webpack:///./src/lib/adapter/EventBusAdapter.js","webpack:///./src/lib/adapter/BaseAdapter.js","webpack:///./src/lib/support/ConnectionConfigHolder.js","webpack:///./src/lib/adapter/NoopAdapter.js","webpack:///./src/lib/VertxEventBusServiceProvider.js","webpack:///./src/lib/service/delegate/EventBusDelegate.js","webpack:///./src/lib/support/Queue.js","webpack:///./src/lib/support/SimpleMap.js","webpack:///./src/lib/service/delegate/BaseDelegate.js","webpack:///./src/lib/service/delegate/NoopDelegate.js","webpack:///./src/lib/service/Delegator.js"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_module","_module2","_config","_VertxEventBusWrapperProvider","_VertxEventBusWrapperProvider2","_VertxEventBusServiceProvider","_VertxEventBusServiceProvider2","angular","moduleName","provider","name","_EventBusAdapter","_EventBusAdapter2","_NoopAdapter","_NoopAdapter2","_ConnectionConfigHolder","_ConnectionConfigHolder2","_vertxEventbus","_vertxEventbus2","DEFAULTS","enabled","debugEnabled","initialConnectEnabled","urlServer","location","protocol","hostname","port","urlPath","reconnectEnabled","sockjsReconnectInterval","sockjsOptions","VertxEventBusWrapperProvider","_this","options","extend","enable","arguments","length","undefined","disableAutoConnect","useDebug","useUrlServer","useUrlPath","useReconnect","useSockJsReconnectInterval","useSockJsOptions","$get","$timeout","$log","$q","instanceOptions","debug","connectionConfig","$inject","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_BaseAdapter2","_BaseAdapter3","EventBusAdapter","_BaseAdapter","EventBus","_ref","getPrototypeOf","disconnectTimeoutEnabled","applyDefaultHeaders","connect","_this2","deferred","defer","url","onopen","isFunction","resolve","onclose","onerror","message","promise","immediately","state","OPEN","close","address","headers","replyHandler","mergedHeaders","getMergedHeaders","send","publish","handler","_this3","_ret","registerHandler","deconstructor","unregisterHandler","displayName","v","CLOSED","get","readyState","BaseAdapter","reject","defaultHeaders","ConnectionConfigHolder","_urlServer","_urlPath","NoopAdapter","_EventBusDelegate","_EventBusDelegate2","_NoopDelegate","_NoopDelegate2","_Delegator","_Delegator2","authRequired","prefix","sockjsStateInterval","messageBuffer","VertxEventBusServiceProvider","usePrefix","useSockJsStateInterval","useMessageBuffer","authHandler","$rootScope","$interval","vertxEventBus","$injector","getOptions","_Queue","_Queue2","_SimpleMap","_SimpleMap2","_BaseDelegate2","_BaseDelegate3","EventBusDelegate","_BaseDelegate","eventBus","isString","e","connectionState","states","connected","authorized","observers","messageQueue","callbackMap","initialize","onEventbusOpen","onEventbusClose","connectionIntervalCheck","getConnectionState","connectionStateFlipped","afterEventbusConnected","$broadcast","$digest","size","fn","first","observer","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","next","done","err","callback","callbackWrapper","_ref2","replyTo","body","put","remove","_this4","timeout","expectReply","timer","reply","cancel","ensureOpenAuthConnection","then","_this5","isConnectionOpen","inQueue","_this6","fnWrapper","onValidAuth","onInvalidAuth","authResult","ensureOpenConnection","immediate","Queue","maxSize","items","item","recalibrateBufferSize","pop","shift","SimpleMap","clear","idx","_indexForKey","values","keys","_indexForValue","BaseDelegate","NoopDelegate","apply","Delegator","delegate","handlers","observe","callbacks","_step$value","unregisterFn","index","indexOf","splice","isEnabled","isConnected","isAuthorized","getMessageQueueLength"],"mappings":"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","file":"dist/angular-vertxbus.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! angular-vertxbus - v6.0.0 - 2016-04-01\n * http://github.com/knalli/angular-vertxbus\n * Copyright (c) 2016 Jan Philipp\n * @license MIT */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vertx-eventbus\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vertx-eventbus\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"vertx-eventbus\")) : factory(root[\"EventBus\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _module = __webpack_require__(1);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _module2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _VertxEventBusWrapperProvider = __webpack_require__(3);\n\n\tvar _VertxEventBusWrapperProvider2 = _interopRequireDefault(_VertxEventBusWrapperProvider);\n\n\tvar _VertxEventBusServiceProvider = __webpack_require__(9);\n\n\tvar _VertxEventBusServiceProvider2 = _interopRequireDefault(_VertxEventBusServiceProvider);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc overview\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus\n\t * @description\n\t *\n\t * Client side library using VertX Event Bus as an Angular Service module\n\t *\n\t * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n\t *\n\t * <pre>\n\t *   angular.module('app', ['knalli.angular-vertxbus'])\n\t *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n\t *\n\t *       // using the EventBus directly\n\t *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n\t *         // your reply comes here\n\t *       });\n\t *\n\t *       // using the service\n\t *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n\t *         .then(function (reply) {\n\t *           // your reply comes here\n\t *         })\n\t *         .catch(function (err) {\n\t *           // something went wrong, no connection, no login, timed out, or so\n\t *         });\n\t *     });\n\t * </pre>\n\t *\n\t * The module itself provides following components:\n\t * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n\t * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n\t *\n\t * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n\t * reconnect management, authorization and a clean promise based api.\n\t *\n\t * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n\t * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n\t * underlying instance of the current `vertx.EventBus`.\n\t *\n\t * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n\t */\n\texports.default = angular.module(_config.moduleName, ['ng']).provider('vertxEventBus', _VertxEventBusWrapperProvider2.default).provider('vertxEventBusService', _VertxEventBusServiceProvider2.default).name;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar moduleName = 'knalli.angular-vertxbus';\n\n\texports.moduleName = moduleName;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _EventBusAdapter = __webpack_require__(4);\n\n\tvar _EventBusAdapter2 = _interopRequireDefault(_EventBusAdapter);\n\n\tvar _NoopAdapter = __webpack_require__(7);\n\n\tvar _NoopAdapter2 = _interopRequireDefault(_NoopAdapter);\n\n\tvar _ConnectionConfigHolder = __webpack_require__(6);\n\n\tvar _ConnectionConfigHolder2 = _interopRequireDefault(_ConnectionConfigHolder);\n\n\tvar _vertxEventbus = __webpack_require__(8);\n\n\tvar _vertxEventbus2 = _interopRequireDefault(_vertxEventbus);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc service\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus.vertxEventBusProvider\n\t * @description\n\t * An AngularJS wrapper for projects using the VertX Event Bus\n\t */\n\n\tvar DEFAULTS = {\n\t  enabled: true,\n\t  debugEnabled: false,\n\t  initialConnectEnabled: true,\n\t  urlServer: location.protocol + '//' + location.hostname + (function () {\n\t    if (location.port) {\n\t      return ':' + location.port;\n\t    }\n\t  }() || ''),\n\t  urlPath: '/eventbus',\n\t  reconnectEnabled: true,\n\t  sockjsReconnectInterval: 10000,\n\t  sockjsOptions: {}\n\t};\n\n\tvar VertxEventBusWrapperProvider = function VertxEventBusWrapperProvider() {\n\t  var _this = this;\n\n\t  // options (globally, application-wide)\n\t  var options = angular.extend({}, DEFAULTS);\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#enable\n\t   *\n\t   * @description\n\t   * Enables or disables the service. This setup is immutable.\n\t   *\n\t   * @param {boolean} [value=true] service is enabled on startup\n\t   * @returns {object} this\n\t   */\n\t  this.enable = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.enabled : arguments[0];\n\n\t    options.enabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#disableAutoConnect\n\t   *\n\t   * @description\n\t   * Disables the auto connection feature.\n\t   *\n\t   * This feature will be only available if `enable == true`.\n\t   *\n\t   * @param {boolean} [value=true] auto connect on startup\n\t   * @returns {object} this\n\t   */\n\t  this.disableAutoConnect = function () {\n\t    options.initialConnectEnabled = false;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useDebug\n\t   *\n\t   * @description\n\t   * Enables a verbose mode in which certain events will be logged to `$log`.\n\t   *\n\t   * @param {boolean} [value=false] verbose mode (using `$log`)\n\t   * @returns {object} this\n\t   */\n\t  this.useDebug = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.debugEnabled : arguments[0];\n\n\t    options.debugEnabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useUrlServer\n\t   *\n\t   * @description\n\t   * Overrides the url part \"server\" for connecting. The default is based on\n\t   * - `location.protocol`\n\t   * - `location.hostname`\n\t   * - `location.port`\n\t   *\n\t   * i.e. `http://domain.tld` or `http://domain.tld:port`\n\t   *\n\t   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n\t   * @returns {object} this\n\t   */\n\t  this.useUrlServer = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.urlServer : arguments[0];\n\n\t    options.urlServer = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useUrlPath\n\t   *\n\t   * @description\n\t   * Overrides the url part \"path\" for connection.\n\t   *\n\t   * @param {boolean} [value='/eventbus'] path to connect\n\t   * @returns {object} this\n\t   */\n\t  this.useUrlPath = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.urlPath : arguments[0];\n\n\t    options.urlPath = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useReconnect\n\t   *\n\t   * @description\n\t   * Enables or disables the automatic reconnect handling.\n\t   *\n\t   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n\t   * @returns {object} this\n\t   */\n\t  this.useReconnect = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.reconnectEnabled : arguments[0];\n\n\t    options.reconnectEnabled = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useSockJsReconnectInterval\n\t   *\n\t   * @description\n\t   * Overrides the timeout for reconnecting after a disconnect was found.\n\t   *\n\t   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsReconnectInterval = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsReconnectInterval : arguments[0];\n\n\t    options.sockjsReconnectInterval = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n\t   * @name .#useSockJsOptions\n\t   *\n\t   * @description\n\t   * Sets additional params for the `SockJS` instance.\n\t   *\n\t   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n\t   *\n\t   * @param {boolean} [value={}]  optional params for raw SockJS options\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsOptions = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsOptions : arguments[0];\n\n\t    options.sockjsOptions = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc service\n\t   * @module knalli.angular-vertxbus\n\t   * @name knalli.angular-vertxbus.vertxEventBus\n\t   * @description\n\t   * A stub representing the Vert.x EventBus (core functionality)\n\t   *\n\t   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n\t   * new instance of the bus have to be created.\n\t   * This stub ensures only one object holding the current active instance of the bus.\n\t   *\n\t   * The stub supports theses Vert.x Event Bus APIs:\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n\t   *\n\t   * Furthermore, the stub supports theses extra APIs:\n\t   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n\t   *\n\t   * @requires $timeout\n\t   * @requires $log\n\t   */\n\t  /* @ngInject */\n\t  this.$get = function ($timeout, $log, $q) {\n\t    // Current options (merged defaults with application-wide settings)\n\t    var instanceOptions = angular.extend({}, DEFAULTS, options);\n\t    if (instanceOptions.enabled && _vertxEventbus2.default) {\n\t      if (instanceOptions.debugEnabled) {\n\t        $log.debug('[Vert.x EB Stub] Enabled');\n\t      }\n\n\t      // aggregate server connection params\n\t      instanceOptions.connectionConfig = new _ConnectionConfigHolder2.default({\n\t        urlServer: instanceOptions.urlServer,\n\t        urlPath: instanceOptions.urlPath\n\t      });\n\t      delete instanceOptions.urlServer;\n\t      delete instanceOptions.urlPath;\n\n\t      return new _EventBusAdapter2.default(_vertxEventbus2.default, $timeout, $log, $q, instanceOptions);\n\t    } else {\n\t      if (instanceOptions.debugEnabled) {\n\t        $log.debug('[Vert.x EB Stub] Disabled');\n\t      }\n\t      return new _NoopAdapter2.default(_vertxEventbus2.default, $q);\n\t    }\n\t  };\n\t  this.$get.$inject = [\"$timeout\", \"$log\", \"$q\"];\n\t};\n\n\texports.default = VertxEventBusWrapperProvider;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _BaseAdapter2 = __webpack_require__(5);\n\n\tvar _BaseAdapter3 = _interopRequireDefault(_BaseAdapter2);\n\n\tvar _ConnectionConfigHolder = __webpack_require__(6);\n\n\tvar _ConnectionConfigHolder2 = _interopRequireDefault(_ConnectionConfigHolder);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\t/**\n\t * @ngdoc service\n\t * @module global\n\t * @name global.EventBus\n\t *\n\t * @description\n\t * This is the interface of `EventBus`. It is not included.\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#close\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#send\n\t *\n\t * @param {string} address target address\n\t * @param {object} message payload message\n\t * @param {object=} headers headers\n\t * @param {function=} replyHandler optional callback\n\t * @param {function=} failureHandler optional callback\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#publish\n\t *\n\t * @param {string} address target address\n\t * @param {object} message payload message\n\t * @param {object=} headers headers\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#registerHandler\n\t *\n\t * @param {string} address target address\n\t * @param {function} handler callback handler\n\t * @param {object=} headers headers\n\t */\n\n\t/**\n\t * @ngdoc method\n\t * @module global\n\t * @methodOf global.EventBus\n\t * @name .#unregisterHandler\n\t *\n\t * @param {string} address target address\n\t * @param {function} handler callback handler to be removed\n\t * @param {object=} headers headers\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onopen\n\t * @description\n\t * Defines the callback called on opening the connection.\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onclose\n\t * @description\n\t * Defines the callback called on closing the connection.\n\t */\n\n\t/**\n\t * @ngdoc property\n\t * @module global\n\t * @propertyOf global.EventBus\n\t * @name .#onerror\n\t * @description\n\t * Defines the callback called on any error.\n\t */\n\n\tvar EventBusAdapter = function (_BaseAdapter) {\n\t  _inherits(EventBusAdapter, _BaseAdapter);\n\n\t  function EventBusAdapter(EventBus, $timeout, $log, $q, _ref) {\n\t    var enabled = _ref.enabled;\n\t    var debugEnabled = _ref.debugEnabled;\n\t    var initialConnectEnabled = _ref.initialConnectEnabled;\n\t    var connectionConfig = _ref.connectionConfig;\n\t    var reconnectEnabled = _ref.reconnectEnabled;\n\t    var sockjsReconnectInterval = _ref.sockjsReconnectInterval;\n\t    var sockjsOptions = _ref.sockjsOptions;\n\n\t    _classCallCheck(this, EventBusAdapter);\n\n\t    // actual EventBus type\n\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventBusAdapter).call(this, $q));\n\n\t    _this.EventBus = EventBus;\n\t    _this.$timeout = $timeout;\n\t    _this.$log = $log;\n\t    _this.$q = $q;\n\t    _this.options = {\n\t      enabled: enabled,\n\t      debugEnabled: debugEnabled,\n\t      initialConnectEnabled: initialConnectEnabled,\n\t      connectionConfig: connectionConfig,\n\t      reconnectEnabled: reconnectEnabled,\n\t      sockjsReconnectInterval: sockjsReconnectInterval,\n\t      sockjsOptions: sockjsOptions\n\t    };\n\t    _this.disconnectTimeoutEnabled = true;\n\t    _this.applyDefaultHeaders();\n\t    if (initialConnectEnabled) {\n\t      // asap create connection\n\t      _this.connect();\n\t    }\n\t    return _this;\n\t  }\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t   * @name .#configureConnect\n\t   *\n\t   * @description\n\t   * Reconfigure the connection details.\n\t   *\n\t   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n\t   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n\t   */\n\n\n\t  _createClass(EventBusAdapter, [{\n\t    key: 'configureConnection',\n\t    value: function configureConnection(urlServer) {\n\t      var urlPath = arguments.length <= 1 || arguments[1] === undefined ? '/eventbus' : arguments[1];\n\n\t      this.options.connectionConfig = new _ConnectionConfigHolder2.default({ urlServer: urlServer, urlPath: urlPath });\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\n\t      // connect promise\n\t      var deferred = this.$q.defer();\n\t      // currently valid url\n\t      var url = '' + this.options.connectionConfig.urlServer + this.options.connectionConfig.urlPath;\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Stub] Enabled: connecting \\'' + url + '\\'');\n\t      }\n\t      // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n\t      // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n\t      this.instance = new this.EventBus(url, this.options.sockjsOptions);\n\t      this.instance.onopen = function () {\n\t        if (_this2.options.debugEnabled) {\n\t          _this2.$log.debug('[Vert.x EB Stub] Connected');\n\t        }\n\t        if (angular.isFunction(_this2.onopen)) {\n\t          _this2.onopen();\n\t        }\n\t        deferred.resolve();\n\t      };\n\t      // instance onClose handler\n\t      this.instance.onclose = function () {\n\t        if (_this2.options.debugEnabled) {\n\t          _this2.$log.debug('[Vert.x EB Stub] Reconnect in ' + _this2.options.sockjsReconnectInterval + 'ms');\n\t        }\n\t        if (angular.isFunction(_this2.onclose)) {\n\t          _this2.onclose();\n\t        }\n\t        _this2.instance = undefined;\n\n\t        if (!_this2.disconnectTimeoutEnabled) {\n\t          // reconnect required asap\n\t          if (_this2.options.debugEnabled) {\n\t            _this2.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n\t          }\n\t          _this2.disconnectTimeoutEnabled = true;\n\t          _this2.connect();\n\t        } else if (_this2.options.reconnectEnabled) {\n\t          // automatic reconnect after timeout\n\t          if (_this2.options.debugEnabled) {\n\t            _this2.$log.debug('[Vert.x EB Stub] Reconnect in ' + _this2.options.sockjsReconnectInterval + 'ms');\n\t          }\n\t          _this2.$timeout(function () {\n\t            return _this2.connect();\n\t          }, _this2.options.sockjsReconnectInterval);\n\t        }\n\t      };\n\t      // instance onError handler\n\t      this.instance.onerror = function (message) {\n\t        if (angular.isFunction(_this2.onerror)) {\n\t          _this2.onerror(message);\n\t        }\n\t      };\n\t      return deferred.promise;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#reconnect\n\t     *\n\t     * @description\n\t     * Reconnects the underlying connection.\n\t     *\n\t     * Unless a connection is open, it will connect using a new one.\n\t     *\n\t     * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n\t     * default timeout for reconnect will be skipped.\n\t     *\n\t     * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n\t     */\n\n\t  }, {\n\t    key: 'reconnect',\n\t    value: function reconnect() {\n\t      var immediately = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n\t      if (this.instance && this.instance.state === this.EventBus.OPEN) {\n\t        if (immediately) {\n\t          this.disconnectTimeoutEnabled = false;\n\t        }\n\t        this.instance.close();\n\t      } else {\n\t        this.connect();\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#close\n\t     *\n\t     * @description\n\t     * Closes the underlying connection.\n\t     *\n\t     * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n\t     *\n\t     * See also:\n\t     * - {@link EventBus#methods_close EventBus.close()}\n\t     */\n\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      if (this.instance) {\n\t        this.instance.close();\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#send\n\t     *\n\t     * @description\n\t     * Sends a message\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_send EventBus.send()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object} headers optional headers\n\t     * @param {function=} replyHandler optional callback\n\t     */\n\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message, headers, replyHandler) {\n\t      if (this.instance) {\n\t        var mergedHeaders = this.getMergedHeaders(headers);\n\t        this.instance.send(address, message, mergedHeaders, replyHandler);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#publish\n\t     *\n\t     * @description\n\t     * Publishes a message\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_publish EventBus.publish()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers optional headers\n\t     */\n\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message, headers) {\n\t      if (this.instance) {\n\t        var mergedHeaders = this.getMergedHeaders(headers);\n\t        this.instance.publish(address, message, mergedHeaders);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#registerHandler\n\t     *\n\t     * @description\n\t     * Registers a listener\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object=} headers optional headers\n\t     * @param {function} handler callback handler\n\t     */\n\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, handler) {\n\t      var _this3 = this;\n\n\t      if (this.instance) {\n\t        var _ret = function () {\n\t          if (angular.isFunction(headers) && !handler) {\n\t            handler = headers;\n\t            headers = undefined;\n\t          }\n\t          var mergedHeaders = _this3.getMergedHeaders(headers);\n\t          _this3.instance.registerHandler(address, mergedHeaders, handler);\n\t          // and return the deregister callback\n\t          var deconstructor = function deconstructor() {\n\t            _this3.unregisterHandler(address, mergedHeaders, handler);\n\t          };\n\t          deconstructor.displayName = _config.moduleName + '.wrapper.eventbus.registerHandler.deconstructor';\n\t          return {\n\t            v: deconstructor\n\t          };\n\t        }();\n\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#unregisterHandler\n\t     *\n\t     * @description\n\t     * Removes a registered a listener\n\t     *\n\t     * See also:\n\t     * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object=} headers optional headers\n\t     * @param {function} handler callback handler to be removed\n\t     */\n\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, handler) {\n\t      if (this.instance && this.instance.state === this.EventBus.OPEN) {\n\t        if (angular.isFunction(headers) && !handler) {\n\t          handler = headers;\n\t          headers = undefined;\n\t        }\n\t        var mergedHeaders = this.getMergedHeaders(headers);\n\t        this.instance.unregisterHandler(address, mergedHeaders, handler);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#readyState\n\t     *\n\t     * @description\n\t     * Returns the current connection state\n\t     *\n\t     * @returns {number} value of vertx-eventbus connection states\n\t     */\n\n\t  }, {\n\t    key: 'readyState',\n\t    value: function readyState() {\n\t      if (this.instance) {\n\t        return this.instance.state;\n\t      } else {\n\t        return this.EventBus.CLOSED;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getOptions',\n\n\n\t    // private\n\t    value: function getOptions() {\n\t      // clone options\n\t      return angular.extend({}, this.options);\n\t    }\n\t  }, {\n\t    key: 'state',\n\t    get: function get() {\n\t      return this.readyState();\n\t    }\n\t  }]);\n\n\t  return EventBusAdapter;\n\t}(_BaseAdapter3.default);\n\n\texports.default = EventBusAdapter;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar BaseAdapter = function () {\n\t  function BaseAdapter($q) {\n\t    _classCallCheck(this, BaseAdapter);\n\n\t    this.$q = $q;\n\t  }\n\n\t  _createClass(BaseAdapter, [{\n\t    key: \"configureConnection\",\n\t    value: function configureConnection() {}\n\t  }, {\n\t    key: \"connect\",\n\t    value: function connect() {\n\t      return this.$q.reject();\n\t    }\n\t  }, {\n\t    key: \"reconnect\",\n\t    value: function reconnect() {}\n\t  }, {\n\t    key: \"close\",\n\t    value: function close() {}\n\t  }, {\n\t    key: \"send\",\n\t    value: function send() {}\n\t  }, {\n\t    key: \"publish\",\n\t    value: function publish() {}\n\t  }, {\n\t    key: \"registerHandler\",\n\t    value: function registerHandler() {}\n\t  }, {\n\t    key: \"unregisterHandler\",\n\t    value: function unregisterHandler() {}\n\t  }, {\n\t    key: \"readyState\",\n\t    value: function readyState() {}\n\t  }, {\n\t    key: \"getOptions\",\n\t    value: function getOptions() {\n\t      return {};\n\t    }\n\n\t    // empty: can be overriden by externals\n\n\t  }, {\n\t    key: \"onopen\",\n\t    value: function onopen() {}\n\n\t    // empty: can be overriden by externals\n\n\t  }, {\n\t    key: \"onclose\",\n\t    value: function onclose() {}\n\n\t    // private\n\n\t  }, {\n\t    key: \"getDefaultHeaders\",\n\t    value: function getDefaultHeaders() {\n\t      return this.defaultHeaders;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBus\n\t     * @name .#applyDefaultHeaders\n\t     *\n\t     * @description\n\t     * Stores the given default headers\n\t     *\n\t     * @param {object} headers additional standard headers\n\t     */\n\n\t  }, {\n\t    key: \"applyDefaultHeaders\",\n\t    value: function applyDefaultHeaders() {\n\t      var headers = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t      this.defaultHeaders = angular.extend({}, headers);\n\t    }\n\n\t    // private\n\n\t  }, {\n\t    key: \"getMergedHeaders\",\n\t    value: function getMergedHeaders() {\n\t      var headers = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t      return angular.extend({}, this.defaultHeaders, headers);\n\t    }\n\t  }]);\n\n\t  return BaseAdapter;\n\t}();\n\n\texports.default = BaseAdapter;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar ConnectionConfigHolder = function () {\n\t  function ConnectionConfigHolder(_ref) {\n\t    var urlServer = _ref.urlServer;\n\t    var urlPath = _ref.urlPath;\n\n\t    _classCallCheck(this, ConnectionConfigHolder);\n\n\t    this._urlServer = urlServer;\n\t    this._urlPath = urlPath;\n\t  }\n\n\t  _createClass(ConnectionConfigHolder, [{\n\t    key: \"urlServer\",\n\t    get: function get() {\n\t      return this._urlServer;\n\t    }\n\t  }, {\n\t    key: \"urlPath\",\n\t    get: function get() {\n\t      return this._urlPath;\n\t    }\n\t  }]);\n\n\t  return ConnectionConfigHolder;\n\t}();\n\n\texports.default = ConnectionConfigHolder;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _BaseAdapter2 = __webpack_require__(5);\n\n\tvar _BaseAdapter3 = _interopRequireDefault(_BaseAdapter2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tvar NoopAdapter = function (_BaseAdapter) {\n\t  _inherits(NoopAdapter, _BaseAdapter);\n\n\t  function NoopAdapter(EventBus, $q) {\n\t    _classCallCheck(this, NoopAdapter);\n\n\t    // actual EventBus type\n\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NoopAdapter).call(this, $q));\n\n\t    _this.EventBus = EventBus;\n\t    return _this;\n\t  }\n\n\t  return NoopAdapter;\n\t}(_BaseAdapter3.default);\n\n\texports.default = NoopAdapter;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _EventBusDelegate = __webpack_require__(10);\n\n\tvar _EventBusDelegate2 = _interopRequireDefault(_EventBusDelegate);\n\n\tvar _NoopDelegate = __webpack_require__(14);\n\n\tvar _NoopDelegate2 = _interopRequireDefault(_NoopDelegate);\n\n\tvar _Delegator = __webpack_require__(15);\n\n\tvar _Delegator2 = _interopRequireDefault(_Delegator);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/**\n\t * @ngdoc service\n\t * @module knalli.angular-vertxbus\n\t * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t * @description\n\t * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n\t */\n\n\tvar DEFAULTS = {\n\t  enabled: true,\n\t  debugEnabled: false,\n\t  authRequired: false,\n\t  prefix: 'vertx-eventbus.',\n\t  sockjsStateInterval: 10000,\n\t  messageBuffer: 10000\n\t};\n\n\tvar VertxEventBusServiceProvider = function VertxEventBusServiceProvider() {\n\t  var _this = this;\n\n\t  // options (globally, application-wide)\n\t  var options = angular.extend({}, DEFAULTS);\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#enable\n\t   *\n\t   * @description\n\t   * Enables or disables the service. This setup is immutable.\n\t   *\n\t   * @param {boolean} [value=true] service is enabled on startup\n\t   * @returns {object} this\n\t   */\n\t  this.enable = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.enabled : arguments[0];\n\n\t    options.enabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useDebug\n\t   *\n\t   * @description\n\t   * Enables a verbose mode in which certain events will be logged to `$log`.\n\t   *\n\t   * @param {boolean} [value=false] verbose mode (using `$log`)\n\t   * @returns {object} this\n\t   */\n\t  this.useDebug = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.debugEnabled : arguments[0];\n\n\t    options.debugEnabled = value === true;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#usePrefix\n\t   *\n\t   * @description\n\t   * Overrides the default prefix which will be used for emitted events.\n\t   *\n\t   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n\t   * @returns {object} this\n\t   */\n\t  this.usePrefix = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.prefix : arguments[0];\n\n\t    options.prefix = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useSockJsStateInterval\n\t   *\n\t   *\n\t   * @description\n\t   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n\t   *\n\t   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n\t   * @returns {object} this\n\t   */\n\t  this.useSockJsStateInterval = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.sockjsStateInterval : arguments[0];\n\n\t    options.sockjsStateInterval = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#useMessageBuffer\n\t   *\n\t   * @description\n\t   * Enables buffering of (sending) messages.\n\t   *\n\t   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n\t   * connection is still in progress, the connection is stale or a login is required/pending.\n\t   *\n\t   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n\t   * @returns {object} this\n\t   */\n\t  this.useMessageBuffer = function () {\n\t    var value = arguments.length <= 0 || arguments[0] === undefined ? DEFAULTS.messageBuffer : arguments[0];\n\n\t    options.messageBuffer = value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc method\n\t   * @module knalli.angular-vertxbus\n\t   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n\t   * @name .#authHandler\n\t   *\n\t   * @description\n\t   * Function or service reference name for function checking the authorization state.\n\t   *\n\t   * The result of the function must be a boolean or promise. The handler can (but is not required) to create authorization on demand.\n\t   * If it is resolved, the authorization is valid.\n\t   * If it is rejected, the authorization is invalid.\n\t   *\n\t   * @param {string|function} value authorization handler (either a function or a service name)\n\t   * @returns {object} promise\n\t   */\n\t  this.authHandler = function (value) {\n\t    options.authHandler = value;\n\t    options.authRequired = !!value;\n\t    return _this;\n\t  };\n\n\t  /**\n\t   * @ngdoc service\n\t   * @module knalli.angular-vertxbus\n\t   * @name knalli.angular-vertxbus.vertxEventBusService\n\t   * @description\n\t   * A service utilizing an underlying Vert.x Event Bus\n\t   *\n\t   * The advanced features of this service are:\n\t   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n\t   *  - registering all handlers again when a reconnect had been required\n\t   *  - supporting a promise when using send()\n\t   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n\t   *\n\t   * Basic usage:\n\t   * <pre>\n\t   * module.controller('MyController', function('vertxEventService') {\n\t  *   vertxEventService.on('my.address', function(message) {\n\t  *     console.log(\"JSON Message received: \", message)\n\t  *   });\n\t  *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n\t  * });\n\t   * </pre>\n\t   *\n\t   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n\t   *\n\t   * @requires knalli.angular-vertxbus.vertxEventBus\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires $interval\n\t   * @requires $log\n\t   * @requires $injector\n\t   */\n\t  /* @ngInject */\n\t  this.$get = function ($rootScope, $q, $interval, vertxEventBus, $log, $injector) {\n\t    // Current options (merged defaults with application-wide settings)\n\t    var instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n\t    if (instanceOptions.enabled) {\n\t      return new _Delegator2.default(new _EventBusDelegate2.default($rootScope, $interval, $log, $q, $injector, vertxEventBus, instanceOptions), $log);\n\t    } else {\n\t      return new _Delegator2.default(new _NoopDelegate2.default());\n\t    }\n\t  };\n\t  this.$get.$inject = [\"$rootScope\", \"$q\", \"$interval\", \"vertxEventBus\", \"$log\", \"$injector\"];\n\t};\n\n\texports.default = VertxEventBusServiceProvider;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _Queue = __webpack_require__(11);\n\n\tvar _Queue2 = _interopRequireDefault(_Queue);\n\n\tvar _SimpleMap = __webpack_require__(12);\n\n\tvar _SimpleMap2 = _interopRequireDefault(_SimpleMap);\n\n\tvar _BaseDelegate2 = __webpack_require__(13);\n\n\tvar _BaseDelegate3 = _interopRequireDefault(_BaseDelegate2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name disconnected\n\t *\n\t * @description\n\t * After a connection was being terminated.\n\t *\n\t * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name connected\n\t *\n\t * @description\n\t * After a connection was being established\n\t *\n\t * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name login-succeeded\n\t *\n\t * @description\n\t * After a login has been validated successfully\n\t *\n\t * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t *\n\t * @param {object} data data\n\t * @param {boolean} data.status must be `'ok'`\n\t */\n\n\t/**\n\t * @ngdoc event\n\t * @module knalli.angular-vertxbus\n\t * @eventOf knalli.angular-vertxbus.vertxEventBusService\n\t * @eventType broadcast on $rootScope\n\t * @name login-failed\n\t *\n\t * @description\n\t * After a login has been destroyed or was invalidated\n\t *\n\t * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n\t *\n\t * @param {object} data data\n\t * @param {boolean} data.status must be not`'ok'`\n\t */\n\n\tvar EventBusDelegate = function (_BaseDelegate) {\n\t  _inherits(EventBusDelegate, _BaseDelegate);\n\n\t  function EventBusDelegate($rootScope, $interval, $log, $q, $injector, eventBus, _ref) {\n\t    var enabled = _ref.enabled;\n\t    var debugEnabled = _ref.debugEnabled;\n\t    var prefix = _ref.prefix;\n\t    var sockjsStateInterval = _ref.sockjsStateInterval;\n\t    var messageBuffer = _ref.messageBuffer;\n\t    var authRequired = _ref.authRequired;\n\t    var authHandler = _ref.authHandler;\n\n\t    _classCallCheck(this, EventBusDelegate);\n\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventBusDelegate).call(this));\n\n\t    _this.$rootScope = $rootScope;\n\t    _this.$interval = $interval;\n\t    _this.$log = $log;\n\t    _this.$q = $q;\n\t    _this.eventBus = eventBus;\n\t    _this.options = {\n\t      enabled: enabled,\n\t      debugEnabled: debugEnabled,\n\t      prefix: prefix,\n\t      sockjsStateInterval: sockjsStateInterval,\n\t      messageBuffer: messageBuffer,\n\t      authRequired: authRequired\n\t    };\n\t    if (angular.isFunction(authHandler)) {\n\t      _this.authHandler = authHandler;\n\t    } else if (angular.isString(authHandler)) {\n\t      try {\n\t        _this.authHandler = $injector.get(authHandler);\n\t      } catch (e) {\n\t        if (_this.options.debugEnabled) {\n\t          _this.$log.debug('[Vert.x EB Service] Failed to resolve authHandler: %s', e.message);\n\t        }\n\t      }\n\t    }\n\t    _this.connectionState = _this.eventBus.EventBus.CLOSED;\n\t    _this.states = {\n\t      connected: false,\n\t      authorized: false\n\t    };\n\t    _this.observers = [];\n\t    // internal store of buffered messages\n\t    _this.messageQueue = new _Queue2.default(_this.options.messageBuffer);\n\t    // internal map of callbacks\n\t    _this.callbackMap = new _SimpleMap2.default();\n\t    // asap\n\t    _this.initialize();\n\t    return _this;\n\t  }\n\n\t  // internal\n\n\n\t  _createClass(EventBusDelegate, [{\n\t    key: 'initialize',\n\t    value: function initialize() {\n\t      var _this2 = this;\n\n\t      this.eventBus.onopen = function () {\n\t        return _this2.onEventbusOpen();\n\t      };\n\t      this.eventBus.onclose = function () {\n\t        return _this2.onEventbusClose();\n\t      };\n\n\t      // Update the current connection state periodically.\n\t      var connectionIntervalCheck = function connectionIntervalCheck() {\n\t        return _this2.getConnectionState(true);\n\t      };\n\t      connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n\t      this.$interval(function () {\n\t        return connectionIntervalCheck();\n\t      }, this.options.sockjsStateInterval);\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'onEventbusOpen',\n\t    value: function onEventbusOpen() {\n\t      var connectionStateFlipped = false;\n\t      this.getConnectionState(true);\n\t      if (!this.states.connected) {\n\t        this.states.connected = true;\n\t        connectionStateFlipped = true;\n\t      }\n\t      // Ensure all events will be re-attached\n\t      this.afterEventbusConnected();\n\t      // Everything is online and registered again, let's notify everybody\n\t      if (connectionStateFlipped) {\n\t        this.$rootScope.$broadcast(this.options.prefix + 'system.connected');\n\t      }\n\t      this.$rootScope.$digest(); // explicitly\n\t      // consume message queue?\n\t      if (this.options.messageBuffer && this.messageQueue.size()) {\n\t        while (this.messageQueue.size()) {\n\t          var fn = this.messageQueue.first();\n\t          if (angular.isFunction(fn)) {\n\t            fn();\n\t          }\n\t        }\n\t        this.$rootScope.$digest();\n\t      }\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'onEventbusClose',\n\t    value: function onEventbusClose() {\n\t      this.getConnectionState(true);\n\t      if (this.states.connected) {\n\t        this.states.connected = false;\n\t        this.$rootScope.$broadcast(this.options.prefix + 'system.disconnected');\n\t      }\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'observe',\n\t    value: function observe(observer) {\n\t      this.observers.push(observer);\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'afterEventbusConnected',\n\t    value: function afterEventbusConnected() {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\n\t      try {\n\t        for (var _iterator = this.observers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var observer = _step.value;\n\n\t          if (angular.isFunction(observer.afterEventbusConnected)) {\n\t            observer.afterEventbusConnected();\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, callback) {\n\t      var _this3 = this;\n\n\t      if (angular.isFunction(headers) && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      if (!angular.isFunction(callback)) {\n\t        return;\n\t      }\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Service] Register handler for ' + address);\n\t      }\n\t      var callbackWrapper = function callbackWrapper(err, _ref2, replyTo) {\n\t        var body = _ref2.body;\n\n\t        callback(body, replyTo);\n\t        _this3.$rootScope.$digest();\n\t      };\n\t      callbackWrapper.displayName = _config.moduleName + '.service.delegate.live.registerHandler.callbackWrapper';\n\t      this.callbackMap.put(callback, callbackWrapper);\n\t      return this.eventBus.registerHandler(address, headers, callbackWrapper);\n\t    }\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, callback) {\n\t      if (angular.isFunction(headers) && !callback) {\n\t        callback = headers;\n\t        headers = undefined;\n\t      }\n\t      if (!angular.isFunction(callback)) {\n\t        return;\n\t      }\n\t      if (this.options.debugEnabled) {\n\t        this.$log.debug('[Vert.x EB Service] Unregister handler for ' + address);\n\t      }\n\t      this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n\t      this.callbackMap.remove(callback);\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message, headers) {\n\t      var _this4 = this;\n\n\t      var timeout = arguments.length <= 3 || arguments[3] === undefined ? 10000 : arguments[3];\n\t      var expectReply = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];\n\n\t      var deferred = this.$q.defer();\n\t      var next = function next() {\n\t        if (expectReply) {\n\t          (function () {\n\t            // Register timeout for promise rejecting\n\t            var timer = _this4.$interval(function () {\n\t              if (_this4.options.debugEnabled) {\n\t                _this4.$log.debug('[Vert.x EB Service] send(\\'' + address + '\\') timed out');\n\t              }\n\t              deferred.reject();\n\t            }, timeout, 1);\n\t            // Send message\n\t            _this4.eventBus.send(address, message, headers, function (err, reply) {\n\t              _this4.$interval.cancel(timer); // because it's resolved\n\t              if (err) {\n\t                deferred.reject(err);\n\t              } else {\n\t                deferred.resolve(reply);\n\t              }\n\t            });\n\t          })();\n\t        } else {\n\t          _this4.eventBus.send(address, message, headers);\n\t          deferred.resolve(); // we don't care\n\t        }\n\t      };\n\t      next.displayName = _config.moduleName + '.service.delegate.live.send.next';\n\t      this.ensureOpenAuthConnection(next).then(null, deferred.reject);\n\t      return deferred.promise;\n\t    }\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message, headers) {\n\t      var _this5 = this;\n\n\t      return this.ensureOpenAuthConnection(function () {\n\t        return _this5.eventBus.publish(address, message, headers);\n\t      });\n\t    }\n\n\t    /**\n\t     * Ensures the callback will be performed with an open connection.\n\t     *\n\t     * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n\t     *\n\t     * @param {function} fn callback\n\t     * @returns {object} promise (resolved on either performed or queued)\n\t     */\n\n\t  }, {\n\t    key: 'ensureOpenConnection',\n\t    value: function ensureOpenConnection(fn) {\n\t      var deferred = this.$q.defer();\n\t      if (this.isConnectionOpen()) {\n\t        fn();\n\t        deferred.resolve({\n\t          inQueue: false\n\t        });\n\t      } else if (this.options.messageBuffer) {\n\t        this.messageQueue.push(fn);\n\t        deferred.resolve({\n\t          inQueue: true\n\t        });\n\t      } else {\n\t        deferred.reject();\n\t      }\n\t      return deferred.promise;\n\t    }\n\n\t    /**\n\t     * Ensures the callback will be performed with a valid session.\n\t     *\n\t     * Unless `authRequired` is enabled, this will be simple forward.\n\t     *\n\t     * Unless a valid session exist (but required), the callback will be not invoked.\n\t     *\n\t     * @param {function} fn callback\n\t     * @returns {object} promise (resolved on either performed or queued)\n\t     */\n\n\t  }, {\n\t    key: 'ensureOpenAuthConnection',\n\t    value: function ensureOpenAuthConnection(fn) {\n\t      var _this6 = this;\n\n\t      if (!this.options.authRequired) {\n\t        // easy: no login required\n\t        return this.ensureOpenConnection(fn);\n\t      } else {\n\t        var fnWrapper = function fnWrapper() {\n\t          if (_this6.authHandler) {\n\t            var onValidAuth = function onValidAuth() {\n\t              _this6.states.authorized = true;\n\t              fn();\n\t            };\n\t            var onInvalidAuth = function onInvalidAuth() {\n\t              _this6.states.authorized = false;\n\t              if (_this6.options.debugEnabled) {\n\t                _this6.$log.debug('[Vert.x EB Service] Message was not sent due authHandler rejected');\n\t              }\n\t            };\n\t            var authResult = _this6.authHandler(_this6.eventBus);\n\t            if (!(authResult && angular.isFunction(authResult.then))) {\n\t              if (_this6.options.debugEnabled) {\n\t                _this6.$log.debug('[Vert.x EB Service] Message was not sent because authHandler is returning not a promise');\n\t              }\n\t              return false;\n\t            }\n\t            authResult.then(onValidAuth, onInvalidAuth);\n\t            return true;\n\t          } else {\n\t            // ignore this message\n\t            if (_this6.options.debugEnabled) {\n\t              _this6.$log.debug('[Vert.x EB Service] Message was not sent because no authHandler is defined');\n\t            }\n\t            return false;\n\t          }\n\t        };\n\t        fnWrapper.displayName = _config.moduleName + '.service.delegate.live.ensureOpenAuthConnection.fnWrapper';\n\t        return this.ensureOpenConnection(fnWrapper);\n\t      }\n\t    }\n\n\t    /**\n\t     * Returns the current connection state. The state is being cached internally.\n\t     *\n\t     * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n\t     * @returns {number} state type of vertx.EventBus\n\t     */\n\n\t  }, {\n\t    key: 'getConnectionState',\n\t    value: function getConnectionState(immediate) {\n\t      if (this.options.enabled) {\n\t        if (immediate) {\n\t          this.connectionState = this.eventBus.state;\n\t        }\n\t      } else {\n\t        this.connectionState = this.eventBus.EventBus.CLOSED;\n\t      }\n\t      return this.connectionState;\n\t    }\n\n\t    /**\n\t     * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n\t     *\n\t     * @returns {boolean} connection open state\n\t     */\n\n\t  }, {\n\t    key: 'isConnectionOpen',\n\t    value: function isConnectionOpen() {\n\t      return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n\t    }\n\n\t    /**\n\t     * Returns true if the session is valid\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isAuthorized',\n\t    value: function isAuthorized() {\n\t      return this.states.authorized;\n\t    }\n\n\t    // internal\n\n\t  }, {\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return this.states.connected;\n\t    }\n\t  }, {\n\t    key: 'isEnabled',\n\t    value: function isEnabled() {\n\t      return this.options.enabled;\n\t    }\n\n\t    /**\n\t     * Returns the current amount of messages in the internal buffer.\n\t     *\n\t     * @returns {number} amount\n\t     */\n\n\t  }, {\n\t    key: 'getMessageQueueLength',\n\t    value: function getMessageQueueLength() {\n\t      return this.messageQueue.size();\n\t    }\n\t  }]);\n\n\t  return EventBusDelegate;\n\t}(_BaseDelegate3.default);\n\n\texports.default = EventBusDelegate;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/*\n\t Simple queue implementation\n\n\t FIFO: #push() + #first()\n\t LIFO: #push() + #last()\n\t */\n\n\tvar Queue = function () {\n\t  function Queue() {\n\t    var maxSize = arguments.length <= 0 || arguments[0] === undefined ? 10 : arguments[0];\n\n\t    _classCallCheck(this, Queue);\n\n\t    this.maxSize = maxSize;\n\t    this.items = [];\n\t  }\n\n\t  _createClass(Queue, [{\n\t    key: \"push\",\n\t    value: function push(item) {\n\t      this.items.push(item);\n\t      return this.recalibrateBufferSize();\n\t    }\n\t  }, {\n\t    key: \"recalibrateBufferSize\",\n\t    value: function recalibrateBufferSize() {\n\t      while (this.items.length > this.maxSize) {\n\t        this.first();\n\t      }\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"last\",\n\t    value: function last() {\n\t      return this.items.pop();\n\t    }\n\t  }, {\n\t    key: \"first\",\n\t    value: function first() {\n\t      return this.items.shift(0);\n\t    }\n\t  }, {\n\t    key: \"size\",\n\t    value: function size() {\n\t      return this.items.length;\n\t    }\n\t  }]);\n\n\t  return Queue;\n\t}();\n\n\texports.default = Queue;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/*\n\t Simple Map implementation\n\n\t This implementation allows usage of non serializable keys for values.\n\t */\n\n\tvar SimpleMap = function () {\n\t  function SimpleMap() {\n\t    _classCallCheck(this, SimpleMap);\n\n\t    this.clear();\n\t  }\n\n\t  // Stores the value under the key.\n\t  // Chainable\n\n\n\t  _createClass(SimpleMap, [{\n\t    key: \"put\",\n\t    value: function put(key, value) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        this.values[idx] = value;\n\t      } else {\n\t        this.keys.push(key);\n\t        this.values.push(value);\n\t      }\n\t      return this;\n\t    }\n\n\t    // Returns value for key, otherwise undefined.\n\n\t  }, {\n\t    key: \"get\",\n\t    value: function get(key) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        return this.values[idx];\n\t      }\n\t    }\n\n\t    // Returns true if the key exists.\n\n\t  }, {\n\t    key: \"containsKey\",\n\t    value: function containsKey(key) {\n\t      var idx = this._indexForKey(key);\n\t      return idx > -1;\n\t    }\n\n\t    // Returns true if the value exists.\n\n\t  }, {\n\t    key: \"containsValue\",\n\t    value: function containsValue(value) {\n\t      var idx = this._indexForValue(value);\n\t      return idx > -1;\n\t    }\n\n\t    // Removes the key and its value.\n\n\t  }, {\n\t    key: \"remove\",\n\t    value: function remove(key) {\n\t      var idx = this._indexForKey(key);\n\t      if (idx > -1) {\n\t        this.keys[idx] = undefined;\n\t        this.values[idx] = undefined;\n\t      }\n\t    }\n\n\t    // Clears all keys and values.\n\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      this.keys = [];\n\t      this.values = [];\n\t      return this;\n\t    }\n\n\t    // Returns index of key, otherwise -1.\n\n\t  }, {\n\t    key: \"_indexForKey\",\n\t    value: function _indexForKey(key) {\n\t      for (var i in this.keys) {\n\t        if (key === this.keys[i]) {\n\t          return i;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }, {\n\t    key: \"_indexForValue\",\n\t    value: function _indexForValue(value) {\n\t      for (var i in this.values) {\n\t        if (value === this.values[i]) {\n\t          return i;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }]);\n\n\t  return SimpleMap;\n\t}();\n\n\texports.default = SimpleMap;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar BaseDelegate = function () {\n\t  function BaseDelegate() {\n\t    _classCallCheck(this, BaseDelegate);\n\t  }\n\n\t  _createClass(BaseDelegate, [{\n\t    key: \"observe\",\n\t    value: function observe() {}\n\t  }, {\n\t    key: \"getConnectionState\",\n\t    value: function getConnectionState() {\n\t      return 3; // CLOSED\n\t    }\n\t  }, {\n\t    key: \"isConnectionOpen\",\n\t    value: function isConnectionOpen() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isAuthorized\",\n\t    value: function isAuthorized() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isEnabled\",\n\t    value: function isEnabled() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"isConnected\",\n\t    value: function isConnected() {\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"send\",\n\t    value: function send() {}\n\t  }, {\n\t    key: \"publish\",\n\t    value: function publish() {}\n\t  }]);\n\n\t  return BaseDelegate;\n\t}();\n\n\texports.default = BaseDelegate;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _BaseDelegate2 = __webpack_require__(13);\n\n\tvar _BaseDelegate3 = _interopRequireDefault(_BaseDelegate2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tvar NoopDelegate = function (_BaseDelegate) {\n\t  _inherits(NoopDelegate, _BaseDelegate);\n\n\t  function NoopDelegate() {\n\t    _classCallCheck(this, NoopDelegate);\n\n\t    return _possibleConstructorReturn(this, Object.getPrototypeOf(NoopDelegate).apply(this, arguments));\n\t  }\n\n\t  return NoopDelegate;\n\t}(_BaseDelegate3.default);\n\n\texports.default = NoopDelegate;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar Delegator = function () {\n\t  function Delegator(delegate, $log) {\n\t    var _this = this;\n\n\t    _classCallCheck(this, Delegator);\n\n\t    this.delegate = delegate;\n\t    this.$log = $log;\n\t    this.handlers = [];\n\t    this.delegate.observe({\n\t      afterEventbusConnected: function afterEventbusConnected() {\n\t        return _this.afterEventbusConnected();\n\t      }\n\t    });\n\t  }\n\n\t  _createClass(Delegator, [{\n\t    key: 'afterEventbusConnected',\n\t    value: function afterEventbusConnected() {\n\t      for (var address in this.handlers) {\n\t        var callbacks = this.handlers[address];\n\t        if (callbacks && callbacks.length) {\n\t          var _iteratorNormalCompletion = true;\n\t          var _didIteratorError = false;\n\t          var _iteratorError = undefined;\n\n\t          try {\n\t            for (var _iterator = callbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t              var _step$value = _step.value;\n\t              var headers = _step$value.headers;\n\t              var callback = _step$value.callback;\n\n\t              this.delegate.registerHandler(address, headers, callback);\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError) {\n\t                throw _iteratorError;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#registerHandler\n\t     *\n\t     * @description\n\t     * Registers a callback handler for the specified address match.\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} callback handler with params `(message, replyTo)`\n\t     * @returns {function} deconstructor\n\t     */\n\n\t  }, {\n\t    key: 'registerHandler',\n\t    value: function registerHandler(address, headers, callback) {\n\t      var _this2 = this;\n\n\t      if (!this.handlers[address]) {\n\t        this.handlers[address] = [];\n\t      }\n\t      var handler = { headers: headers, callback: callback };\n\t      this.handlers[address].push(handler);\n\t      var unregisterFn = null;\n\t      if (this.delegate.isConnectionOpen()) {\n\t        this.delegate.registerHandler(address, headers, callback);\n\t        unregisterFn = function unregisterFn() {\n\t          return _this2.delegate.unregisterHandler(address, headers, callback);\n\t        };\n\t      }\n\t      // and return the deregister callback\n\t      var deconstructor = function deconstructor() {\n\t        if (unregisterFn) {\n\t          unregisterFn();\n\t          unregisterFn = undefined;\n\t        }\n\t        // Remove from internal map\n\t        if (_this2.handlers[address]) {\n\t          var index = _this2.handlers[address].indexOf(handler);\n\t          if (index > -1) {\n\t            _this2.handlers[address].splice(index, 1);\n\t          }\n\t          if (_this2.handlers[address].length < 1) {\n\t            _this2.handlers[address] = undefined;\n\t          }\n\t        }\n\t      };\n\t      deconstructor.displayName = _config.moduleName + '.service.registerHandler.deconstructor';\n\t      return deconstructor;\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#on\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'on',\n\t    value: function on(address, headers, callback) {\n\t      return this.registerHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#addListener\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(address, headers, callback) {\n\t      return this.registerHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#unregisterHandler\n\t     *\n\t     * @description\n\t     * Removes a callback handler for the specified address match.\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} headers optional headers\n\t     * @param {function} callback handler with params `(message, replyTo)`\n\t     */\n\n\t  }, {\n\t    key: 'unregisterHandler',\n\t    value: function unregisterHandler(address, headers, callback) {\n\t      // Remove from internal map\n\t      if (this.handlers[address]) {\n\t        var index = this.handlers[address].indexOf({ headers: headers, callback: callback });\n\t        if (index > -1) {\n\t          this.handlers[address].splice(index, 1);\n\t        }\n\t        if (this.handlers[address].length < 1) {\n\t          this.handlers[address] = undefined;\n\t        }\n\t      }\n\t      // Remove from real instance\n\t      if (this.delegate.isConnectionOpen()) {\n\t        this.delegate.unregisterHandler(address, headers, callback);\n\t      }\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#un\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'un',\n\t    value: function un(address, headers, callback) {\n\t      return this.unregisterHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#removeListener\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n\t     */\n\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(address, headers, callback) {\n\t      return this.unregisterHandler(address, headers, callback);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#send\n\t     *\n\t     * @description\n\t     * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object} headers headers\n\t     * @param {number=} [options.timeout=10000] (in ms) after which the promise will be rejected\n\t     * @param {boolean=} [options.expectReply=true] if false, the promise will be resolved directly and\n\t     *                                       no replyHandler will be created\n\t     * @returns {object} promise\n\t     */\n\n\t  }, {\n\t    key: 'send',\n\t    value: function send(address, message) {\n\t      var headers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t      var options = arguments.length <= 3 || arguments[3] === undefined ? { timeout: 10000, expectReply: true } : arguments[3];\n\n\t      return this.delegate.send(address, message, headers, options.timeout, options.expectReply);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#publish\n\t     *\n\t     * @description\n\t     * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n\t     *\n\t     * @param {string} address target address\n\t     * @param {object} message payload message\n\t     * @param {object=} headers headers\n\t     * @returns {object} promise (resolved on either performed or queued)\n\t     */\n\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(address, message) {\n\t      var headers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      return this.delegate.publish(address, message, headers);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#emit\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_publish publish()})\n\t     */\n\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(address, message) {\n\t      var headers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      return this.publish(address, message, headers);\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#getConnectionState\n\t     *\n\t     * @description\n\t     * Returns the current connection state. The state is being cached internally.\n\t     *\n\t     * @returns {number} state type of vertx.EventBus\n\t     */\n\n\t  }, {\n\t    key: 'getConnectionState',\n\t    value: function getConnectionState() {\n\t      return this.delegate.getConnectionState();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#readyState\n\t     *\n\t     * @description\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()})\n\t     */\n\n\t  }, {\n\t    key: 'readyState',\n\t    value: function readyState() {\n\t      return this.getConnectionState();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isConnectionOpen\n\t     *\n\t     * @description\n\t     * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n\t     *\n\t     * @returns {boolean} connection open state\n\t     */\n\n\t  }, {\n\t    key: 'isConnectionOpen',\n\t    value: function isConnectionOpen() {\n\t      return this.isConnectionOpen();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isEnabled\n\t     *\n\t     * @description\n\t     * Returns true if service is being enabled.\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isEnabled',\n\t    value: function isEnabled() {\n\t      return this.delegate.isEnabled();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isConnected\n\t     *\n\t     * @description\n\t     * Returns true if service (and the eventbus) is being connected.\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return this.delegate.isConnected();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isAuthorized\n\t     *\n\t     * @description\n\t     * Returns true if the authorization is valid\n\t     *\n\t     * @returns {boolean} state\n\t     */\n\n\t  }, {\n\t    key: 'isAuthorized',\n\t    value: function isAuthorized() {\n\t      return this.delegate.isAuthorized();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#isValidSession\n\t     *\n\t     * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_isAuthorized isAuthorized()})\n\t     */\n\n\t  }, {\n\t    key: 'isValidSession',\n\t    value: function isValidSession() {\n\t      return this.delegate.isAuthorized();\n\t    }\n\n\t    /**\n\t     * @ngdoc method\n\t     * @module knalli.angular-vertxbus\n\t     * @methodOf knalli.angular-vertxbus.vertxEventBusService\n\t     * @name .#getMessageQueueLength\n\t     *\n\t     * @description\n\t     * Returns the current amount of messages in the internal buffer.\n\t     *\n\t     * @returns {number} amount\n\t     */\n\n\t  }, {\n\t    key: 'getMessageQueueLength',\n\t    value: function getMessageQueueLength() {\n\t      return this.delegate.getMessageQueueLength();\n\t    }\n\t  }]);\n\n\t  return Delegator;\n\t}();\n\n\texports.default = Delegator;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-vertxbus.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 411fd831f717e46099b9\n **/","import moduleName from './module';\n\nexport default moduleName;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import {moduleName} from './config';\n\nimport VertxEventBusWrapperProvider from './lib/VertxEventBusWrapperProvider';\nimport VertxEventBusServiceProvider from './lib/VertxEventBusServiceProvider';\n\n/**\n * @ngdoc overview\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus\n * @description\n *\n * Client side library using VertX Event Bus as an Angular Service module\n *\n * You have to define the module dependency, this module is named `knalli.angular-vertxbus`.\n *\n * <pre>\n *   angular.module('app', ['knalli.angular-vertxbus'])\n *     .controller('MyCtrl', function(vertxEventBus, vertxEventBusService) {\n *\n *       // using the EventBus directly\n *       vertxEventBus.send('my.address', {data: 123}, function (reply) {\n *         // your reply comes here\n *       });\n *\n *       // using the service\n *       vertxEventBusService.send('my.address', {data: 123}, {timeout: 500})\n *         .then(function (reply) {\n *           // your reply comes here\n *         })\n *         .catch(function (err) {\n *           // something went wrong, no connection, no login, timed out, or so\n *         });\n *     });\n * </pre>\n *\n * The module itself provides following components:\n * - {@link knalli.angular-vertxbus.vertxEventBus vertxEventBus}: a low level wrapper around `vertx.EventBus`\n * - {@link knalli.angular-vertxbus.vertxEventBusService vertxEventBusService}: a high level service around the wrapper\n *\n * While the wrapper only provides one single instance (even on reconnects), the service supports automatically\n * reconnect management, authorization and a clean promise based api.\n *\n * If you are looking for a low integration of `vertxbus.EventBus` as an AngularJS component, the wrapper will be your\n * choice. The only difference (and requirement for the wrapper actually) is how it will manage and replace the\n * underlying instance of the current `vertx.EventBus`.\n *\n * However, if you are looking for a simple, clean and promised based high api, the service is much better you.\n */\nexport default angular\n\n  .module(moduleName, ['ng'])\n\n  .provider('vertxEventBus', VertxEventBusWrapperProvider)\n  .provider('vertxEventBusService', VertxEventBusServiceProvider)\n\n  .name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/module.js\n **/","const moduleName = 'knalli.angular-vertxbus';\n\nexport {moduleName};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/config.js\n **/","import EventBusAdapter from './adapter/EventBusAdapter';\nimport NoopAdapter from './adapter/NoopAdapter';\nimport ConnectionConfigHolder from './support/ConnectionConfigHolder';\n\nimport EventBus from 'vertx-eventbus';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusProvider\n * @description\n * An AngularJS wrapper for projects using the VertX Event Bus\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  initialConnectEnabled : true,\n  urlServer : `${location.protocol}//${location.hostname}` + ((() => {\n    if (location.port) {\n      return `:${location.port}`;\n    }\n  })() || ''),\n  urlPath : '/eventbus',\n  reconnectEnabled : true,\n  sockjsReconnectInterval : 10000,\n  sockjsOptions : {}\n};\n\nlet VertxEventBusWrapperProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#disableAutoConnect\n   *\n   * @description\n   * Disables the auto connection feature.\n   *\n   * This feature will be only available if `enable == true`.\n   *\n   * @param {boolean} [value=true] auto connect on startup\n   * @returns {object} this\n   */\n  this.disableAutoConnect = () => {\n    options.initialConnectEnabled = false;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlServer\n   *\n   * @description\n   * Overrides the url part \"server\" for connecting. The default is based on\n   * - `location.protocol`\n   * - `location.hostname`\n   * - `location.port`\n   *\n   * i.e. `http://domain.tld` or `http://domain.tld:port`\n   *\n   * @param {boolean} [value=$computed] server to connect (default based on `location.protocol`, `location.hostname` and `location.port`)\n   * @returns {object} this\n   */\n  this.useUrlServer = (value = DEFAULTS.urlServer) => {\n    options.urlServer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useUrlPath\n   *\n   * @description\n   * Overrides the url part \"path\" for connection.\n   *\n   * @param {boolean} [value='/eventbus'] path to connect\n   * @returns {object} this\n   */\n  this.useUrlPath = (value = DEFAULTS.urlPath) => {\n    options.urlPath = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useReconnect\n   *\n   * @description\n   * Enables or disables the automatic reconnect handling.\n   *\n   * @param {boolean} [value=true] if a disconnect was being noted, a reconnect will be enforced automatically\n   * @returns {object} this\n   */\n  this.useReconnect = (value = DEFAULTS.reconnectEnabled) => {\n    options.reconnectEnabled = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsReconnectInterval\n   *\n   * @description\n   * Overrides the timeout for reconnecting after a disconnect was found.\n   *\n   * @param {boolean} [value=10000] time between a disconnect and the next try to reconnect (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsReconnectInterval = (value = DEFAULTS.sockjsReconnectInterval) => {\n    options.sockjsReconnectInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusProvider\n   * @name .#useSockJsOptions\n   *\n   * @description\n   * Sets additional params for the `SockJS` instance.\n   *\n   * Internally, it will be applied (as `options`) like `new SockJS(url, undefined, options)`.\n   *\n   * @param {boolean} [value={}]  optional params for raw SockJS options\n   * @returns {object} this\n   */\n  this.useSockJsOptions = (value = DEFAULTS.sockjsOptions) => {\n    options.sockjsOptions = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBus\n   * @description\n   * A stub representing the Vert.x EventBus (core functionality)\n   *\n   * Because the Event Bus cannot handle a reconnect (because of the underlaying SockJS), a\n   * new instance of the bus have to be created.\n   * This stub ensures only one object holding the current active instance of the bus.\n   *\n   * The stub supports theses Vert.x Event Bus APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_close close()}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_send send(address, message, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_publish publish(address, message)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_registerHandler registerHandler(adress, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_unregisterHandler unregisterHandler(address, handler)}\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_readyState readyState()}\n   *\n   * Furthermore, the stub supports theses extra APIs:\n   *  - {@link knalli.angular-vertxbus.vertxEventBus#methods_reconnect reconnect()}\n   *\n   * @requires $timeout\n   * @requires $log\n   */\n  /* @ngInject */\n  this.$get = ($timeout, $log, $q) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, DEFAULTS, options);\n    if (instanceOptions.enabled && EventBus) {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Enabled');\n      }\n\n      // aggregate server connection params\n      instanceOptions.connectionConfig = new ConnectionConfigHolder({\n        urlServer : instanceOptions.urlServer,\n        urlPath : instanceOptions.urlPath\n      });\n      delete instanceOptions.urlServer;\n      delete instanceOptions.urlPath;\n\n      return new EventBusAdapter(EventBus, $timeout, $log, $q, instanceOptions);\n    } else {\n      if (instanceOptions.debugEnabled) {\n        $log.debug('[Vert.x EB Stub] Disabled');\n      }\n      return new NoopAdapter(EventBus, $q);\n    }\n  };\n\n};\n\nexport default VertxEventBusWrapperProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusWrapperProvider.js\n **/","import {moduleName} from '../../config.js';\n\nimport BaseAdapter from './BaseAdapter';\nimport ConnectionConfigHolder from './../support/ConnectionConfigHolder';\n\n/**\n * @ngdoc service\n * @module global\n * @name global.EventBus\n *\n * @description\n * This is the interface of `EventBus`. It is not included.\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#close\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#send\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n * @param {function=} replyHandler optional callback\n * @param {function=} failureHandler optional callback\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#publish\n *\n * @param {string} address target address\n * @param {object} message payload message\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#registerHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc method\n * @module global\n * @methodOf global.EventBus\n * @name .#unregisterHandler\n *\n * @param {string} address target address\n * @param {function} handler callback handler to be removed\n * @param {object=} headers headers\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onopen\n * @description\n * Defines the callback called on opening the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onclose\n * @description\n * Defines the callback called on closing the connection.\n */\n\n/**\n * @ngdoc property\n * @module global\n * @propertyOf global.EventBus\n * @name .#onerror\n * @description\n * Defines the callback called on any error.\n */\n\nexport default class EventBusAdapter extends BaseAdapter {\n\n  constructor(EventBus, $timeout, $log, $q, {\n    enabled,\n    debugEnabled,\n    initialConnectEnabled,\n    connectionConfig,\n    reconnectEnabled,\n    sockjsReconnectInterval,\n    sockjsOptions\n    }) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n    this.$timeout = $timeout;\n    this.$log = $log;\n    this.$q = $q;\n    this.options = {\n      enabled,\n      debugEnabled,\n      initialConnectEnabled,\n      connectionConfig,\n      reconnectEnabled,\n      sockjsReconnectInterval,\n      sockjsOptions\n    };\n    this.disconnectTimeoutEnabled = true;\n    this.applyDefaultHeaders();\n    if (initialConnectEnabled) {\n      // asap create connection\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#configureConnect\n   *\n   * @description\n   * Reconfigure the connection details.\n   *\n   * @param {string} urlServer see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlServer vertxEventBusProvider.useUrlServer()}\n   * @param {string} [urlPath=/eventbus] see {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useUrlPath vertxEventBusProvider.useUrlPath()}\n   */\n  configureConnection(urlServer, urlPath = '/eventbus') {\n    this.options.connectionConfig = new ConnectionConfigHolder({urlServer, urlPath});\n    return this;\n  }\n\n  connect() {\n    // connect promise\n    let deferred = this.$q.defer();\n    // currently valid url\n    let url = `${this.options.connectionConfig.urlServer}${this.options.connectionConfig.urlPath}`;\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Stub] Enabled: connecting '${url}'`);\n    }\n    // Because we have rebuild an EventBus object (because it have to rebuild a SockJS object)\n    // we must wrap the object. Therefore, we have to mimic the behavior of onopen and onclose each time.\n    this.instance = new this.EventBus(url, this.options.sockjsOptions);\n    this.instance.onopen = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug('[Vert.x EB Stub] Connected');\n      }\n      if (angular.isFunction(this.onopen)) {\n        this.onopen();\n      }\n      deferred.resolve();\n    };\n    // instance onClose handler\n    this.instance.onclose = () => {\n      if (this.options.debugEnabled) {\n        this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n      }\n      if (angular.isFunction(this.onclose)) {\n        this.onclose();\n      }\n      this.instance = undefined;\n\n      if (!this.disconnectTimeoutEnabled) {\n        // reconnect required asap\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Stub] Reconnect immediately');\n        }\n        this.disconnectTimeoutEnabled = true;\n        this.connect();\n      } else if (this.options.reconnectEnabled) {\n        // automatic reconnect after timeout\n        if (this.options.debugEnabled) {\n          this.$log.debug(`[Vert.x EB Stub] Reconnect in ${this.options.sockjsReconnectInterval}ms`);\n        }\n        this.$timeout((() => this.connect()), this.options.sockjsReconnectInterval);\n      }\n    };\n    // instance onError handler\n    this.instance.onerror = (message) => {\n      if (angular.isFunction(this.onerror)) {\n        this.onerror(message);\n      }\n    };\n    return deferred.promise;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#reconnect\n   *\n   * @description\n   * Reconnects the underlying connection.\n   *\n   * Unless a connection is open, it will connect using a new one.\n   *\n   * If a connection is already open, it will close this one and opens a new one. If `immediately` is `true`, the\n   * default timeout for reconnect will be skipped.\n   *\n   * @param {boolean} [immediately=false] optionally enforce a reconnect asap instead of using the timeout\n   */\n  reconnect(immediately = false) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (immediately) {\n        this.disconnectTimeoutEnabled = false;\n      }\n      this.instance.close();\n    } else {\n      this.connect();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#close\n   *\n   * @description\n   * Closes the underlying connection.\n   *\n   * Note: If automatic reconnection is active, a new connection will be established after the {@link knalli.angular-vertxbus.vertxEventBusProvider#methods_useReconnect reconnect timeout}.\n   *\n   * See also:\n   * - {@link EventBus#methods_close EventBus.close()}\n   */\n  close() {\n    if (this.instance) {\n      this.instance.close();\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#send\n   *\n   * @description\n   * Sends a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_send EventBus.send()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers optional headers\n   * @param {function=} replyHandler optional callback\n   */\n  send(address, message, headers, replyHandler) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.send(address, message, mergedHeaders, replyHandler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message\n   *\n   * See also:\n   * - {@link global.EventBus#methods_publish EventBus.publish()}\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers optional headers\n   */\n  publish(address, message, headers) {\n    if (this.instance) {\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.publish(address, message, mergedHeaders);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_registerHandler EventBus.registerHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler\n   */\n  registerHandler(address, headers, handler) {\n    if (this.instance) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.registerHandler(address, mergedHeaders, handler);\n      // and return the deregister callback\n      let deconstructor = () => {\n        this.unregisterHandler(address, mergedHeaders, handler);\n      };\n      deconstructor.displayName = `${moduleName}.wrapper.eventbus.registerHandler.deconstructor`;\n      return deconstructor;\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a registered a listener\n   *\n   * See also:\n   * - {@link global.EventBus#methods_unregisterHandler EventBus.unregisterHandler()}\n   *\n   * @param {string} address target address\n   * @param {object=} headers optional headers\n   * @param {function} handler callback handler to be removed\n   */\n  unregisterHandler(address, headers, handler) {\n    if (this.instance && this.instance.state === this.EventBus.OPEN) {\n      if (angular.isFunction(headers) && !handler) {\n        handler = headers;\n        headers = undefined;\n      }\n      const mergedHeaders = this.getMergedHeaders(headers);\n      this.instance.unregisterHandler(address, mergedHeaders, handler);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#readyState\n   *\n   * @description\n   * Returns the current connection state\n   *\n   * @returns {number} value of vertx-eventbus connection states\n   */\n  readyState() {\n    if (this.instance) {\n      return this.instance.state;\n    } else {\n      return this.EventBus.CLOSED;\n    }\n  }\n\n  get state() {\n    return this.readyState();\n  }\n\n  // private\n  getOptions() {\n    // clone options\n    return angular.extend({}, this.options);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/EventBusAdapter.js\n **/","export default class BaseAdapter {\n\n  constructor($q) {\n    this.$q = $q;\n  }\n\n  configureConnection() {\n  }\n\n  connect() {\n    return this.$q.reject();\n  }\n\n  reconnect() {\n  }\n\n  close() {\n  }\n\n  send() {\n  }\n\n  publish() {\n  }\n\n  registerHandler() {\n  }\n\n  unregisterHandler() {\n  }\n\n  readyState() {\n  }\n\n  getOptions() {\n    return {};\n  }\n\n  // empty: can be overriden by externals\n  onopen() {\n  }\n\n  // empty: can be overriden by externals\n  onclose() {\n  }\n\n  // private\n  getDefaultHeaders() {\n    return this.defaultHeaders;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBus\n   * @name .#applyDefaultHeaders\n   *\n   * @description\n   * Stores the given default headers\n   *\n   * @param {object} headers additional standard headers\n   */\n  applyDefaultHeaders(headers = {}) {\n    this.defaultHeaders = angular.extend({}, headers);\n  }\n\n  // private\n  getMergedHeaders(headers = {}) {\n    return angular.extend({}, this.defaultHeaders, headers);\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/BaseAdapter.js\n **/","export default class ConnectionConfigHolder {\n\n  constructor({urlServer, urlPath}) {\n    this._urlServer = urlServer;\n    this._urlPath = urlPath;\n  }\n\n  get urlServer() {\n    return this._urlServer;\n  }\n\n  get urlPath() {\n    return this._urlPath;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/ConnectionConfigHolder.js\n **/","import BaseAdapter from './BaseAdapter';\n\nexport default class NoopAdapter extends BaseAdapter {\n\n  constructor(EventBus, $q) {\n    super($q);\n    // actual EventBus type\n    this.EventBus = EventBus;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/adapter/NoopAdapter.js\n **/","import EventBusDelegate from './service/delegate/EventBusDelegate';\nimport NoopDelegate from './service/delegate/NoopDelegate';\nimport Delegator from './service/Delegator';\n\n/**\n * @ngdoc service\n * @module knalli.angular-vertxbus\n * @name knalli.angular-vertxbus.vertxEventBusServiceProvider\n * @description\n * This is the configuration provider for {@link knalli.angular-vertxbus.vertxEventBusService}.\n */\n\nconst DEFAULTS = {\n  enabled : true,\n  debugEnabled : false,\n  authRequired : false,\n  prefix : 'vertx-eventbus.',\n  sockjsStateInterval : 10000,\n  messageBuffer : 10000\n};\n\nlet VertxEventBusServiceProvider = function () {\n\n  // options (globally, application-wide)\n  var options = angular.extend({}, DEFAULTS);\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#enable\n   *\n   * @description\n   * Enables or disables the service. This setup is immutable.\n   *\n   * @param {boolean} [value=true] service is enabled on startup\n   * @returns {object} this\n   */\n  this.enable = (value = DEFAULTS.enabled) => {\n    options.enabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useDebug\n   *\n   * @description\n   * Enables a verbose mode in which certain events will be logged to `$log`.\n   *\n   * @param {boolean} [value=false] verbose mode (using `$log`)\n   * @returns {object} this\n   */\n  this.useDebug = (value = DEFAULTS.debugEnabled) => {\n    options.debugEnabled = (value === true);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#usePrefix\n   *\n   * @description\n   * Overrides the default prefix which will be used for emitted events.\n   *\n   * @param {string} [value='vertx-eventbus.'] prefix used in event names\n   * @returns {object} this\n   */\n  this.usePrefix = (value = DEFAULTS.prefix) => {\n    options.prefix = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useSockJsStateInterval\n   *\n   *\n   * @description\n   * Overrides the interval of checking the connection is still valid (required for reconnecting automatically).\n   *\n   * @param {boolean} [value=10000] interval of checking the underlying connection's state (in ms)\n   * @returns {object} this\n   */\n  this.useSockJsStateInterval = (value = DEFAULTS.sockjsStateInterval) => {\n    options.sockjsStateInterval = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#useMessageBuffer\n   *\n   * @description\n   * Enables buffering of (sending) messages.\n   *\n   * The setting defines the total amount of buffered messages (`0` no buffering). A message will be buffered if\n   * connection is still in progress, the connection is stale or a login is required/pending.\n   *\n   * @param {boolean} [value=0] allowed total amount of messages in the buffer\n   * @returns {object} this\n   */\n  this.useMessageBuffer = (value = DEFAULTS.messageBuffer) => {\n    options.messageBuffer = value;\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusServiceProvider\n   * @name .#authHandler\n   *\n   * @description\n   * Function or service reference name for function checking the authorization state.\n   *\n   * The result of the function must be a boolean or promise. The handler can (but is not required) to create authorization on demand.\n   * If it is resolved, the authorization is valid.\n   * If it is rejected, the authorization is invalid.\n   *\n   * @param {string|function} value authorization handler (either a function or a service name)\n   * @returns {object} promise\n   */\n  this.authHandler = (value) => {\n    options.authHandler = value;\n    options.authRequired = !!value;\n    return this;\n  };\n\n  /**\n   * @ngdoc service\n   * @module knalli.angular-vertxbus\n   * @name knalli.angular-vertxbus.vertxEventBusService\n   * @description\n   * A service utilizing an underlying Vert.x Event Bus\n   *\n   * The advanced features of this service are:\n   *  - broadcasting the connection changes (vertx-eventbus.system.connected, vertx-eventbus.system.disconnected) on $rootScope\n   *  - registering all handlers again when a reconnect had been required\n   *  - supporting a promise when using send()\n   *  - adding aliases on (registerHandler), un (unregisterHandler) and emit (publish)\n   *\n   * Basic usage:\n   * <pre>\n   * module.controller('MyController', function('vertxEventService') {\n *   vertxEventService.on('my.address', function(message) {\n *     console.log(\"JSON Message received: \", message)\n *   });\n *   vertxEventService.publish('my.other.address', {type: 'foo', data: 'bar'});\n * });\n   * </pre>\n   *\n   * Note the additional {@link knalli.angular-vertxbus.vertxEventBusServiceProvider configuration} of the module itself.\n   *\n   * @requires knalli.angular-vertxbus.vertxEventBus\n   * @requires $rootScope\n   * @requires $q\n   * @requires $interval\n   * @requires $log\n   * @requires $injector\n   */\n  /* @ngInject */\n  this.$get = ($rootScope, $q, $interval, vertxEventBus, $log, $injector) => {\n    // Current options (merged defaults with application-wide settings)\n    let instanceOptions = angular.extend({}, vertxEventBus.getOptions(), options);\n    if (instanceOptions.enabled) {\n      return new Delegator(\n        new EventBusDelegate($rootScope, $interval, $log, $q, $injector, vertxEventBus, instanceOptions),\n        $log\n      );\n    } else {\n      return new Delegator(new NoopDelegate());\n    }\n  };\n\n};\n\nexport default VertxEventBusServiceProvider;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/VertxEventBusServiceProvider.js\n **/","import {moduleName} from '../../../config';\n\nimport Queue from './../../support/Queue';\nimport SimpleMap from './../../support/SimpleMap';\nimport BaseDelegate from './BaseDelegate';\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name disconnected\n *\n * @description\n * After a connection was being terminated.\n *\n * Event name is `prefix + 'system.disconnected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name connected\n *\n * @description\n * After a connection was being established\n *\n * Event name is `prefix + 'system.connected'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-succeeded\n *\n * @description\n * After a login has been validated successfully\n *\n * Event name is `prefix + 'system.login.succeeded'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be `'ok'`\n */\n\n/**\n * @ngdoc event\n * @module knalli.angular-vertxbus\n * @eventOf knalli.angular-vertxbus.vertxEventBusService\n * @eventType broadcast on $rootScope\n * @name login-failed\n *\n * @description\n * After a login has been destroyed or was invalidated\n *\n * Event name is `prefix + 'system.login.failed'` (see {@link knalli.angular-vertxbus.vertxEventBusServiceProvider#methods_usePrefix prefix})\n *\n * @param {object} data data\n * @param {boolean} data.status must be not`'ok'`\n */\n\nexport default class EventBusDelegate extends BaseDelegate {\n\n  constructor($rootScope, $interval, $log, $q, $injector, eventBus, {\n    enabled,\n    debugEnabled,\n    prefix,\n    sockjsStateInterval,\n    messageBuffer,\n    authRequired,\n    authHandler\n    }) {\n    super();\n    this.$rootScope = $rootScope;\n    this.$interval = $interval;\n    this.$log = $log;\n    this.$q = $q;\n    this.eventBus = eventBus;\n    this.options = {\n      enabled,\n      debugEnabled,\n      prefix,\n      sockjsStateInterval,\n      messageBuffer,\n      authRequired\n    };\n    if (angular.isFunction(authHandler)) {\n      this.authHandler = authHandler;\n    } else if (angular.isString(authHandler)) {\n      try {\n        this.authHandler = $injector.get(authHandler);\n      } catch (e) {\n        if (this.options.debugEnabled) {\n          this.$log.debug('[Vert.x EB Service] Failed to resolve authHandler: %s', e.message);\n        }\n      }\n    }\n    this.connectionState = this.eventBus.EventBus.CLOSED;\n    this.states = {\n      connected: false,\n      authorized: false\n    };\n    this.observers = [];\n    // internal store of buffered messages\n    this.messageQueue = new Queue(this.options.messageBuffer);\n    // internal map of callbacks\n    this.callbackMap = new SimpleMap();\n    // asap\n    this.initialize();\n  }\n\n  // internal\n  initialize() {\n    this.eventBus.onopen = () => this.onEventbusOpen();\n    this.eventBus.onclose = () => this.onEventbusClose();\n\n    // Update the current connection state periodically.\n    let connectionIntervalCheck = () => this.getConnectionState(true);\n    connectionIntervalCheck.displayName = 'connectionIntervalCheck';\n    this.$interval((() => connectionIntervalCheck()), this.options.sockjsStateInterval);\n  }\n\n  // internal\n  onEventbusOpen() {\n    let connectionStateFlipped = false;\n    this.getConnectionState(true);\n    if (!this.states.connected) {\n      this.states.connected = true;\n      connectionStateFlipped = true;\n    }\n    // Ensure all events will be re-attached\n    this.afterEventbusConnected();\n    // Everything is online and registered again, let's notify everybody\n    if (connectionStateFlipped) {\n      this.$rootScope.$broadcast(`${this.options.prefix}system.connected`);\n    }\n    this.$rootScope.$digest(); // explicitly\n    // consume message queue?\n    if (this.options.messageBuffer && this.messageQueue.size()) {\n      while (this.messageQueue.size()) {\n        let fn = this.messageQueue.first();\n        if (angular.isFunction(fn)) {\n          fn();\n        }\n      }\n      this.$rootScope.$digest();\n    }\n  }\n\n  // internal\n  onEventbusClose() {\n    this.getConnectionState(true);\n    if (this.states.connected) {\n      this.states.connected = false;\n      this.$rootScope.$broadcast(`${this.options.prefix}system.disconnected`);\n    }\n  }\n\n  // internal\n  observe(observer) {\n    this.observers.push(observer);\n  }\n\n  // internal\n  afterEventbusConnected() {\n    for (let observer of this.observers) {\n      if (angular.isFunction(observer.afterEventbusConnected)) {\n        observer.afterEventbusConnected();\n      }\n    }\n  }\n\n  registerHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Register handler for ${address}`);\n    }\n    var callbackWrapper = (err, {body}, replyTo) => {\n      callback(body, replyTo);\n      this.$rootScope.$digest();\n    };\n    callbackWrapper.displayName = `${moduleName}.service.delegate.live.registerHandler.callbackWrapper`;\n    this.callbackMap.put(callback, callbackWrapper);\n    return this.eventBus.registerHandler(address, headers, callbackWrapper);\n  }\n\n  unregisterHandler(address, headers, callback) {\n    if (angular.isFunction(headers) && !callback) {\n      callback = headers;\n      headers = undefined;\n    }\n    if (!angular.isFunction(callback)) {\n      return;\n    }\n    if (this.options.debugEnabled) {\n      this.$log.debug(`[Vert.x EB Service] Unregister handler for ${address}`);\n    }\n    this.eventBus.unregisterHandler(address, headers, this.callbackMap.get(callback));\n    this.callbackMap.remove(callback);\n  }\n\n  send(address, message, headers, timeout = 10000, expectReply = true) {\n    let deferred = this.$q.defer();\n    let next = () => {\n      if (expectReply) {\n        // Register timeout for promise rejecting\n        let timer = this.$interval((() => {\n          if (this.options.debugEnabled) {\n            this.$log.debug(`[Vert.x EB Service] send('${address}') timed out`);\n          }\n          deferred.reject();\n        }), timeout, 1);\n        // Send message\n        this.eventBus.send(address, message, headers, (err, reply) => {\n          this.$interval.cancel(timer); // because it's resolved\n          if (err) {\n            deferred.reject(err);\n          } else {\n            deferred.resolve(reply);\n          }\n        });\n      } else {\n        this.eventBus.send(address, message, headers);\n        deferred.resolve(); // we don't care\n      }\n    };\n    next.displayName = `${moduleName}.service.delegate.live.send.next`;\n    this.ensureOpenAuthConnection(next).then(null, deferred.reject);\n    return deferred.promise;\n  }\n\n  publish(address, message, headers) {\n    return this.ensureOpenAuthConnection(() => this.eventBus.publish(address, message, headers));\n  }\n\n  /**\n   * Ensures the callback will be performed with an open connection.\n   *\n   * Unless an open connection was found, the callback will be queued in the message buffer (if available).\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenConnection(fn) {\n    const deferred = this.$q.defer();\n    if (this.isConnectionOpen()) {\n      fn();\n      deferred.resolve({\n        inQueue: false\n      });\n    } else if (this.options.messageBuffer) {\n      this.messageQueue.push(fn);\n      deferred.resolve({\n        inQueue: true\n      });\n    } else {\n      deferred.reject();\n    }\n    return deferred.promise;\n  }\n\n  /**\n   * Ensures the callback will be performed with a valid session.\n   *\n   * Unless `authRequired` is enabled, this will be simple forward.\n   *\n   * Unless a valid session exist (but required), the callback will be not invoked.\n   *\n   * @param {function} fn callback\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  ensureOpenAuthConnection(fn) {\n    if (!this.options.authRequired) {\n      // easy: no login required\n      return this.ensureOpenConnection(fn);\n    } else {\n      let fnWrapper = () => {\n        if (this.authHandler) {\n          const onValidAuth = () => {\n            this.states.authorized = true;\n            fn();\n          };\n          const onInvalidAuth = () => {\n            this.states.authorized = false;\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent due authHandler rejected');\n            }\n          };\n          const authResult = this.authHandler(this.eventBus);\n          if (!(authResult && angular.isFunction(authResult.then))) {\n            if (this.options.debugEnabled) {\n              this.$log.debug('[Vert.x EB Service] Message was not sent because authHandler is returning not a promise');\n            }\n            return false;\n          }\n          authResult.then(onValidAuth, onInvalidAuth);\n          return true;\n        } else {\n          // ignore this message\n          if (this.options.debugEnabled) {\n            this.$log.debug('[Vert.x EB Service] Message was not sent because no authHandler is defined');\n          }\n          return false;\n        }\n      };\n      fnWrapper.displayName = `${moduleName}.service.delegate.live.ensureOpenAuthConnection.fnWrapper`;\n      return this.ensureOpenConnection(fnWrapper);\n    }\n  }\n\n  /**\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @param {boolean=} [immediate=false] if true, the connection state will be queried directly.\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState(immediate) {\n    if (this.options.enabled) {\n      if (immediate) {\n        this.connectionState = this.eventBus.state;\n      }\n    } else {\n      this.connectionState = this.eventBus.EventBus.CLOSED;\n    }\n    return this.connectionState;\n  }\n\n  /**\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.getConnectionState() === this.eventBus.EventBus.OPEN;\n  }\n\n  /**\n   * Returns true if the session is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.states.authorized;\n  }\n\n  // internal\n  isConnected() {\n    return this.states.connected;\n  }\n\n  isEnabled() {\n    return this.options.enabled;\n  }\n\n  /**\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.messageQueue.size();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/EventBusDelegate.js\n **/","/*\n Simple queue implementation\n\n FIFO: #push() + #first()\n LIFO: #push() + #last()\n */\nexport default class Queue {\n\n  constructor(maxSize = 10) {\n    this.maxSize = maxSize;\n    this.items = [];\n  }\n\n  push(item) {\n    this.items.push(item);\n    return this.recalibrateBufferSize();\n  }\n\n  recalibrateBufferSize() {\n    while (this.items.length > this.maxSize) {\n      this.first();\n    }\n    return this;\n  }\n\n  last() {\n    return this.items.pop();\n  }\n\n  first() {\n    return this.items.shift(0);\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/Queue.js\n **/","/*\n Simple Map implementation\n\n This implementation allows usage of non serializable keys for values.\n */\nexport default class SimpleMap {\n\n  constructor() {\n    this.clear();\n  }\n\n  // Stores the value under the key.\n  // Chainable\n  put(key, value) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.values[idx] = value;\n    } else {\n      this.keys.push(key);\n      this.values.push(value);\n    }\n    return this;\n  }\n\n  // Returns value for key, otherwise undefined.\n  get(key) {\n    var idx = this._indexForKey(key);\n    if (idx > -1) {\n      return this.values[idx];\n    }\n  }\n\n  // Returns true if the key exists.\n  containsKey(key) {\n    let idx = this._indexForKey(key);\n    return idx > -1;\n  }\n\n  // Returns true if the value exists.\n  containsValue(value) {\n    let idx = this._indexForValue(value);\n    return idx > -1;\n  }\n\n  // Removes the key and its value.\n  remove(key) {\n    let idx = this._indexForKey(key);\n    if (idx > -1) {\n      this.keys[idx] = undefined;\n      this.values[idx] = undefined;\n    }\n\n  }\n\n  // Clears all keys and values.\n  clear() {\n    this.keys = [];\n    this.values = [];\n    return this;\n  }\n\n  // Returns index of key, otherwise -1.\n  _indexForKey(key) {\n    for (let i in this.keys) {\n      if (key === this.keys[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  _indexForValue(value) {\n    for (let i in this.values) {\n      if (value === this.values[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/support/SimpleMap.js\n **/","export default class BaseDelegate {\n\n  observe() {}\n\n  getConnectionState() {\n    return 3; // CLOSED\n  }\n\n  isConnectionOpen() {\n    return false;\n  }\n\n  isAuthorized() {\n    return false;\n  }\n\n  isEnabled() {\n    return false;\n  }\n\n  isConnected() {\n    return false;\n  }\n\n  send() {}\n\n  publish() {}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/BaseDelegate.js\n **/","import BaseDelegate from './BaseDelegate';\n\nexport default class NoopDelegate extends BaseDelegate {}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/delegate/NoopDelegate.js\n **/","import {moduleName} from '../../config';\n\nexport default class Delegator {\n\n  constructor(delegate, $log) {\n    this.delegate = delegate;\n    this.$log = $log;\n    this.handlers = [];\n    this.delegate.observe({\n      afterEventbusConnected: () => this.afterEventbusConnected()\n    });\n  }\n\n  afterEventbusConnected() {\n    for (let address in this.handlers) {\n      let callbacks = this.handlers[address];\n      if (callbacks && callbacks.length) {\n        for (let {headers, callback} of callbacks) {\n          this.delegate.registerHandler(address, headers, callback);\n        }\n      }\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#registerHandler\n   *\n   * @description\n   * Registers a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   * @returns {function} deconstructor\n   */\n  registerHandler(address, headers, callback) {\n    if (!this.handlers[address]) {\n      this.handlers[address] = [];\n    }\n    var handler = {headers, callback};\n    this.handlers[address].push(handler);\n    var unregisterFn = null;\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.registerHandler(address, headers, callback);\n      unregisterFn = () => this.delegate.unregisterHandler(address, headers, callback);\n    }\n    // and return the deregister callback\n    var deconstructor = () => {\n      if (unregisterFn) {\n        unregisterFn();\n        unregisterFn = undefined;\n      }\n      // Remove from internal map\n      if (this.handlers[address]) {\n        var index = this.handlers[address].indexOf(handler);\n        if (index > -1) {\n          this.handlers[address].splice(index, 1);\n        }\n        if (this.handlers[address].length < 1) {\n          this.handlers[address] = undefined;\n        }\n      }\n    };\n    deconstructor.displayName = `${moduleName}.service.registerHandler.deconstructor`;\n    return deconstructor;\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#on\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  on(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#addListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler registerHandler()})\n   */\n  addListener(address, headers, callback) {\n    return this.registerHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#unregisterHandler\n   *\n   * @description\n   * Removes a callback handler for the specified address match.\n   *\n   * @param {string} address target address\n   * @param {object} headers optional headers\n   * @param {function} callback handler with params `(message, replyTo)`\n   */\n  unregisterHandler(address, headers, callback) {\n    // Remove from internal map\n    if (this.handlers[address]) {\n      var index = this.handlers[address].indexOf({headers, callback});\n      if (index > -1) {\n        this.handlers[address].splice(index, 1);\n      }\n      if (this.handlers[address].length < 1) {\n        this.handlers[address] = undefined;\n      }\n    }\n    // Remove from real instance\n    if (this.delegate.isConnectionOpen()) {\n      this.delegate.unregisterHandler(address, headers, callback);\n    }\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#un\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  un(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#removeListener\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_registerHandler unregisterHandler()})\n   */\n  removeListener(address, headers, callback) {\n    return this.unregisterHandler(address, headers, callback);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#send\n   *\n   * @description\n   * Sends a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_send vertxEventBus.send()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object} headers headers\n   * @param {number=} [options.timeout=10000] (in ms) after which the promise will be rejected\n   * @param {boolean=} [options.expectReply=true] if false, the promise will be resolved directly and\n   *                                       no replyHandler will be created\n   * @returns {object} promise\n   */\n  send(address, message, headers = {}, options = {timeout: 10000, expectReply: true}) {\n    return this.delegate.send(address, message, headers, options.timeout, options.expectReply);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#publish\n   *\n   * @description\n   * Publishes a message to the specified address (using {@link knalli.angular-vertxbus.vertxEventBus#methods_publish vertxEventBus.publish()}).\n   *\n   * @param {string} address target address\n   * @param {object} message payload message\n   * @param {object=} headers headers\n   * @returns {object} promise (resolved on either performed or queued)\n   */\n  publish(address, message, headers = {}) {\n    return this.delegate.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#emit\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_publish publish()})\n   */\n  emit(address, message, headers = {}) {\n    return this.publish(address, message, headers);\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getConnectionState\n   *\n   * @description\n   * Returns the current connection state. The state is being cached internally.\n   *\n   * @returns {number} state type of vertx.EventBus\n   */\n  getConnectionState() {\n    return this.delegate.getConnectionState();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#readyState\n   *\n   * @description\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()})\n   */\n  readyState() {\n    return this.getConnectionState();\n  }\n\n\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnectionOpen\n   *\n   * @description\n   * Returns true if the current connection state ({@link knalli.angular-vertxbus.vertxEventBusService#methods_getConnectionState getConnectionState()}) is `OPEN`.\n   *\n   * @returns {boolean} connection open state\n   */\n  isConnectionOpen() {\n    return this.isConnectionOpen();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isEnabled\n   *\n   * @description\n   * Returns true if service is being enabled.\n   *\n   * @returns {boolean} state\n   */\n  isEnabled() {\n    return this.delegate.isEnabled();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isConnected\n   *\n   * @description\n   * Returns true if service (and the eventbus) is being connected.\n   *\n   * @returns {boolean} state\n   */\n  isConnected() {\n    return this.delegate.isConnected();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isAuthorized\n   *\n   * @description\n   * Returns true if the authorization is valid\n   *\n   * @returns {boolean} state\n   */\n  isAuthorized() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#isValidSession\n   *\n   * See (using {@link knalli.angular-vertxbus.vertxEventBusService#methods_isAuthorized isAuthorized()})\n   */\n  isValidSession() {\n    return this.delegate.isAuthorized();\n  }\n\n  /**\n   * @ngdoc method\n   * @module knalli.angular-vertxbus\n   * @methodOf knalli.angular-vertxbus.vertxEventBusService\n   * @name .#getMessageQueueLength\n   *\n   * @description\n   * Returns the current amount of messages in the internal buffer.\n   *\n   * @returns {number} amount\n   */\n  getMessageQueueLength() {\n    return this.delegate.getMessageQueueLength();\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/service/Delegator.js\n **/"],"sourceRoot":""}