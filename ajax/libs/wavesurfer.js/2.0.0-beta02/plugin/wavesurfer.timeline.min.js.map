{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///wavesurfer.timeline.min.js","webpack:///webpack/bootstrap eef2a76fa4bb7fc480b0","webpack:///./src/plugin/timeline.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","6","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","TimelinePlugin","params","ws","_this","container","document","querySelector","Error","wavesurfer","util","extend","height","notchPercentHeight","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","formatTimeCallback","seconds","minutes","parseInt","Math","round","timeInterval","pxPerSec","ceil","primaryLabelInterval","secondaryLabelInterval","canvases","_onZoom","render","_onScroll","wrapper","drawer","scrollLeft","_onRedraw","_onReady","pixelRatio","maxCanvasWidth","width","maxCanvasElementWidth","createWrapper","addEventListener","on","deferInit","isReady","unAll","un","removeEventListener","parentNode","removeChild","_this2","wsParams","appendChild","createElement","style","display","position","userSelect","webkitUserSelect","fillParent","scrollParent","overflowX","overflowY","_onClick","e","preventDefault","relX","offsetX","layerX","fireEvent","scrollWidth","canvas","pop","parentElement","removeOldCanvases","totalWidth","requiredCanvases","push","zIndex","createCanvases","updateCanvasStyle","drawTimeCanvases","canvasWidth","left","backend","duration","getDuration","totalSeconds","getWidth","pixelsPerSecond","formatTime","intervalFnOrVal","option","curPixel","curSeconds","height1","height2","setFillStyles","fillRect","setFonts","fillText","fillStyle","forEach","getContext","font","x","y","_this3","leftOffset","intersection","x1","max","y1","x2","min","y2","text","textWidth","xOffset","context","measureText","default"],"mappings":"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","file":"wavesurfer.timeline.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"timeline\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"timeline\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"timeline\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"timeline\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 6:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {function} formatTimeCallback=→00:00\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nvar TimelinePlugin = function () {\n    _createClass(TimelinePlugin, null, [{\n        key: 'create',\n\n        /**\n         * Timeline plugin definition factory\n         *\n         * This function must be used to create a plugin definition which can be\n         * used by wavesurfer to correctly instantiate the plugin.\n         *\n         * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n         * @return {PluginDefinition} an object representing the plugin\n         */\n        value: function create(params) {\n            return {\n                name: 'timeline',\n                deferInit: params && params.deferInit ? params.deferInit : false,\n                params: params,\n                instance: TimelinePlugin\n            };\n        }\n    }]);\n\n    function TimelinePlugin(params, ws) {\n        var _this = this;\n\n        _classCallCheck(this, TimelinePlugin);\n\n        this.container = 'string' == typeof params.container ? document.querySelector(params.container) : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n        this.wavesurfer = ws;\n        this.util = ws.util;\n        this.params = this.util.extend({}, {\n            height: 20,\n            notchPercentHeight: 90,\n            primaryColor: '#000',\n            secondaryColor: '#c0c0c0',\n            primaryFontColor: '#000',\n            secondaryFontColor: '#000',\n            fontFamily: 'Arial',\n            fontSize: 10,\n            formatTimeCallback: function formatTimeCallback(seconds) {\n                if (seconds / 60 > 1) {\n                    // calculate minutes and seconds from seconds count\n                    var minutes = parseInt(seconds / 60, 10);\n                    seconds = parseInt(seconds % 60, 10);\n                    // fill up seconds with zeroes\n                    seconds = seconds < 10 ? '0' + seconds : seconds;\n                    return minutes + ':' + seconds;\n                }\n                return Math.round(seconds * 1000) / 1000;\n            },\n            timeInterval: function timeInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 1;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 5;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 15;\n                }\n                return Math.ceil(0.5 / pxPerSec) * 60;\n            },\n            primaryLabelInterval: function primaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 10;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 6;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 4;\n                }\n                return 4;\n            },\n            secondaryLabelInterval: function secondaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 5;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 2;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 2;\n                }\n                return 2;\n            }\n        }, params);\n\n        this.canvases = [];\n\n        this._onZoom = function () {\n            return _this.render();\n        };\n        this._onScroll = function () {\n            if (_this.wrapper && _this.drawer.wrapper) {\n                _this.wrapper.scrollLeft = _this.drawer.wrapper.scrollLeft;\n            }\n        };\n        this._onRedraw = function () {\n            return _this.render();\n        };\n        this._onReady = function () {\n            _this.drawer = ws.drawer;\n            _this.pixelRatio = ws.drawer.params.pixelRatio;\n            _this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n            _this.maxCanvasElementWidth = ws.drawer.maxCanvasElementWidth || Math.round(_this.maxCanvasWidth / _this.pixelRatio);\n\n            _this.createWrapper();\n            _this.render();\n            ws.drawer.wrapper.addEventListener('scroll', _this._onScroll);\n            ws.on('redraw', _this._onRedraw);\n            ws.on('zoom', _this._onZoom);\n        };\n    }\n\n    _createClass(TimelinePlugin, [{\n        key: 'init',\n        value: function init() {\n            this.wavesurfer.on('ready', this._onReady);\n            // Check if ws is ready\n            if (this.wavesurfer.isReady) {\n                this._onReady();\n            }\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.unAll();\n            this.wavesurfer.un('redraw', this._onRedraw);\n            this.wavesurfer.un('zoom', this._onZoom);\n            this.wavesurfer.un('ready', this._onReady);\n            this.wavesurfer.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n            if (this.wrapper && this.wrapper.parentNode) {\n                this.wrapper.parentNode.removeChild(this.wrapper);\n                this.wrapper = null;\n            }\n        }\n    }, {\n        key: 'createWrapper',\n        value: function createWrapper() {\n            var _this2 = this;\n\n            var wsParams = this.wavesurfer.params;\n            this.wrapper = this.container.appendChild(document.createElement('timeline'));\n            this.util.style(this.wrapper, {\n                display: 'block',\n                position: 'relative',\n                userSelect: 'none',\n                webkitUserSelect: 'none',\n                height: this.params.height + 'px'\n            });\n\n            if (wsParams.fillParent || wsParams.scrollParent) {\n                this.util.style(this.wrapper, {\n                    width: '100%',\n                    overflowX: 'hidden',\n                    overflowY: 'hidden'\n                });\n            }\n\n            this._onClick = function (e) {\n                e.preventDefault();\n                var relX = 'offsetX' in e ? e.offsetX : e.layerX;\n                _this2.fireEvent('click', relX / _this2.wrapper.scrollWidth || 0);\n            };\n            this.wrapper.addEventListener('click', this._onClick);\n        }\n    }, {\n        key: 'removeOldCanvases',\n        value: function removeOldCanvases() {\n            while (this.canvases.length > 0) {\n                var canvas = this.canvases.pop();\n                canvas.parentElement.removeChild(canvas);\n            }\n        }\n    }, {\n        key: 'createCanvases',\n        value: function createCanvases() {\n            this.removeOldCanvases();\n\n            var totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n            var requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);\n            var i = void 0;\n\n            for (i = 0; i < requiredCanvases; i++) {\n                var canvas = this.wrapper.appendChild(document.createElement('canvas'));\n                this.canvases.push(canvas);\n                this.util.style(canvas, {\n                    position: 'absolute',\n                    zIndex: 4\n                });\n            }\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            this.createCanvases();\n            this.updateCanvasStyle();\n            this.drawTimeCanvases();\n        }\n    }, {\n        key: 'updateCanvasStyle',\n        value: function updateCanvasStyle() {\n            var requiredCanvases = this.canvases.length;\n            var i = void 0;\n            for (i = 0; i < requiredCanvases; i++) {\n                var canvas = this.canvases[i];\n                var canvasWidth = this.maxCanvasElementWidth;\n\n                if (i === requiredCanvases - 1) {\n                    canvasWidth = this.drawer.wrapper.scrollWidth - this.maxCanvasElementWidth * (requiredCanvases - 1);\n                }\n\n                canvas.width = canvasWidth * this.pixelRatio;\n                canvas.height = this.params.height * this.pixelRatio;\n                this.util.style(canvas, {\n                    width: canvasWidth + 'px',\n                    height: this.params.height + 'px',\n                    left: i * this.maxCanvasElementWidth + 'px'\n                });\n            }\n        }\n    }, {\n        key: 'drawTimeCanvases',\n        value: function drawTimeCanvases() {\n            var backend = this.wavesurfer.backend;\n            var wsParams = this.wavesurfer.params;\n            var duration = this.wavesurfer.backend.getDuration();\n            var totalSeconds = parseInt(duration, 10) + 1;\n            var width = wsParams.fillParent && !wsParams.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n            var pixelsPerSecond = width / duration;\n\n            var formatTime = this.params.formatTimeCallback;\n            // if parameter is function, call the function with\n            // pixelsPerSecond, otherwise simply take the value as-is\n            var intervalFnOrVal = function intervalFnOrVal(option) {\n                return typeof option === 'function' ? option(pixelsPerSecond) : option;\n            };\n            var timeInterval = intervalFnOrVal(this.params.timeInterval);\n            var primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);\n            var secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);\n\n            var curPixel = 0;\n            var curSeconds = 0;\n\n            if (duration <= 0) {\n                return;\n            }\n\n            var height1 = this.params.height - 4;\n            var height2 = this.params.height * (this.params.notchPercentHeight / 100) - 4;\n            var fontSize = this.params.fontSize * wsParams.pixelRatio;\n            var i = void 0;\n\n            for (i = 0; i < totalSeconds / timeInterval; i++) {\n                if (i % primaryLabelInterval == 0) {\n                    this.setFillStyles(this.params.primaryColor);\n                    this.fillRect(curPixel, 0, 1, height1);\n                    this.setFonts(fontSize + 'px ' + this.params.fontFamily);\n                    this.setFillStyles(this.params.primaryFontColor);\n                    this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n                } else if (i % secondaryLabelInterval == 0) {\n                    this.setFillStyles(this.params.secondaryColor);\n                    this.fillRect(curPixel, 0, 1, height1);\n                    this.setFonts(fontSize + 'px ' + this.params.fontFamily);\n                    this.setFillStyles(this.params.secondaryFontColor);\n                    this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n                } else {\n                    this.setFillStyles(this.params.secondaryColor);\n                    this.fillRect(curPixel, 0, 1, height2);\n                }\n\n                curSeconds += timeInterval;\n                curPixel += pixelsPerSecond * timeInterval;\n            }\n        }\n    }, {\n        key: 'setFillStyles',\n        value: function setFillStyles(fillStyle) {\n            this.canvases.forEach(function (canvas) {\n                canvas.getContext('2d').fillStyle = fillStyle;\n            });\n        }\n    }, {\n        key: 'setFonts',\n        value: function setFonts(font) {\n            this.canvases.forEach(function (canvas) {\n                canvas.getContext('2d').font = font;\n            });\n        }\n    }, {\n        key: 'fillRect',\n        value: function fillRect(x, y, width, height) {\n            var _this3 = this;\n\n            this.canvases.forEach(function (canvas, i) {\n                var leftOffset = i * _this3.maxCanvasWidth;\n\n                var intersection = {\n                    x1: Math.max(x, i * _this3.maxCanvasWidth),\n                    y1: y,\n                    x2: Math.min(x + width, i * _this3.maxCanvasWidth + canvas.width),\n                    y2: y + height\n                };\n\n                if (intersection.x1 < intersection.x2) {\n                    canvas.getContext('2d').fillRect(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);\n                }\n            });\n        }\n    }, {\n        key: 'fillText',\n        value: function fillText(text, x, y) {\n            var textWidth = void 0;\n            var xOffset = 0;\n            var i = void 0;\n\n            for (i in this.canvases) {\n                var context = this.canvases[i].getContext('2d');\n                var canvasWidth = context.canvas.width;\n\n                if (xOffset > x + textWidth) {\n                    break;\n                }\n\n                if (xOffset + canvasWidth > x) {\n                    textWidth = context.measureText(text).width;\n                    context.fillText(text, x - xOffset, y);\n                }\n\n                xOffset += canvasWidth;\n            }\n        }\n    }]);\n\n    return TimelinePlugin;\n}();\n\nexports.default = TimelinePlugin;\nmodule.exports = exports['default'];\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// wavesurfer.timeline.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap eef2a76fa4bb7fc480b0","/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {function} formatTimeCallback=→00:00\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n    /**\n     * Timeline plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'timeline',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            instance: TimelinePlugin\n        };\n    }\n\n    constructor(params, ws) {\n        this.container = 'string' == typeof params.container\n            ? document.querySelector(params.container)\n            : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n        this.wavesurfer = ws;\n        this.util = ws.util;\n        this.params = this.util.extend({}, {\n            height: 20,\n            notchPercentHeight: 90,\n            primaryColor: '#000',\n            secondaryColor: '#c0c0c0',\n            primaryFontColor: '#000',\n            secondaryFontColor: '#000',\n            fontFamily: 'Arial',\n            fontSize: 10,\n            formatTimeCallback(seconds) {\n                if (seconds / 60 > 1) {\n                    // calculate minutes and seconds from seconds count\n                    const minutes = parseInt(seconds / 60, 10);\n                    seconds = parseInt(seconds % 60, 10);\n                    // fill up seconds with zeroes\n                    seconds = (seconds < 10) ? '0' + seconds : seconds;\n                    return `${minutes}:${seconds}`;\n                }\n                return Math.round(seconds * 1000) / 1000;\n            },\n            timeInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 1;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 5;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 15;\n                }\n                return Math.ceil(0.5 / pxPerSec) * 60;\n            },\n            primaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 10;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 6;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 4;\n                }\n                return 4;\n            },\n            secondaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 5;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 2;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 2;\n                }\n                return 2;\n            }\n        }, params);\n\n        this.canvases = [];\n\n        this._onZoom = () => this.render();\n        this._onScroll = () => {\n            if (this.wrapper && this.drawer.wrapper) {\n                this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;\n            }\n        };\n        this._onRedraw = () => this.render();\n        this._onReady = () => {\n            this.drawer = ws.drawer;\n            this.pixelRatio = ws.drawer.params.pixelRatio;\n            this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n            this.maxCanvasElementWidth = ws.drawer.maxCanvasElementWidth || Math.round(this.maxCanvasWidth / this.pixelRatio);\n\n            this.createWrapper();\n            this.render();\n            ws.drawer.wrapper.addEventListener('scroll', this._onScroll);\n            ws.on('redraw', this._onRedraw);\n            ws.on('zoom', this._onZoom);\n        };\n    }\n\n    init() {\n        this.wavesurfer.on('ready', this._onReady);\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        }\n    }\n\n    destroy() {\n        this.unAll();\n        this.wavesurfer.un('redraw', this._onRedraw);\n        this.wavesurfer.un('zoom', this._onZoom);\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n        if (this.wrapper && this.wrapper.parentNode) {\n            this.wrapper.parentNode.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    createWrapper() {\n        const wsParams = this.wavesurfer.params;\n        this.wrapper = this.container.appendChild(\n            document.createElement('timeline')\n        );\n        this.util.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: `${this.params.height}px`\n        });\n\n        if (wsParams.fillParent || wsParams.scrollParent) {\n            this.util.style(this.wrapper, {\n                width: '100%',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            });\n        }\n\n        this._onClick = e => {\n            e.preventDefault();\n            const relX = 'offsetX' in e ? e.offsetX : e.layerX;\n            this.fireEvent('click', (relX / this.wrapper.scrollWidth) || 0);\n        };\n        this.wrapper.addEventListener('click', this._onClick);\n    }\n\n    removeOldCanvases() {\n        while (this.canvases.length > 0) {\n            const canvas = this.canvases.pop();\n            canvas.parentElement.removeChild(canvas);\n        }\n    }\n\n    createCanvases() {\n        this.removeOldCanvases();\n\n        const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n        const requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);\n        let i;\n\n        for (i = 0; i < requiredCanvases; i++) {\n            const canvas = this.wrapper.appendChild(document.createElement('canvas'));\n            this.canvases.push(canvas);\n            this.util.style(canvas, {\n                position: 'absolute',\n                zIndex: 4\n            });\n        }\n    }\n\n    render() {\n        this.createCanvases();\n        this.updateCanvasStyle();\n        this.drawTimeCanvases();\n    }\n\n    updateCanvasStyle() {\n        const requiredCanvases = this.canvases.length;\n        let i;\n        for (i = 0; i < requiredCanvases; i++) {\n            const canvas = this.canvases[i];\n            let canvasWidth = this.maxCanvasElementWidth;\n\n            if (i === requiredCanvases - 1) {\n                canvasWidth = this.drawer.wrapper.scrollWidth - (this.maxCanvasElementWidth * (requiredCanvases - 1));\n            }\n\n            canvas.width = canvasWidth * this.pixelRatio;\n            canvas.height = this.params.height * this.pixelRatio;\n            this.util.style(canvas, {\n                width: `${canvasWidth}px`,\n                height: `${this.params.height}px`,\n                left: `${i * this.maxCanvasElementWidth}px`\n            });\n        }\n    }\n\n    drawTimeCanvases() {\n        const backend = this.wavesurfer.backend;\n        const wsParams = this.wavesurfer.params;\n        const duration = this.wavesurfer.backend.getDuration();\n        const totalSeconds = parseInt(duration, 10) + 1;\n        const width = wsParams.fillParent && !wsParams.scrollParent\n            ? this.drawer.getWidth()\n            : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n        const pixelsPerSecond = width / duration;\n\n        const formatTime = this.params.formatTimeCallback;\n        // if parameter is function, call the function with\n        // pixelsPerSecond, otherwise simply take the value as-is\n        const intervalFnOrVal = option => (typeof option === 'function' ? option(pixelsPerSecond) : option);\n        const timeInterval = intervalFnOrVal(this.params.timeInterval);\n        const primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);\n        const secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);\n\n        let curPixel = 0;\n        let curSeconds = 0;\n\n        if (duration <= 0) {\n            return;\n        }\n\n        const height1 = this.params.height - 4;\n        const height2 = (this.params.height * (this.params.notchPercentHeight / 100)) - 4;\n        const fontSize = this.params.fontSize * wsParams.pixelRatio;\n        let i;\n\n        for (i = 0; i < totalSeconds / timeInterval; i++) {\n            if (i % primaryLabelInterval == 0) {\n                this.setFillStyles(this.params.primaryColor);\n                this.fillRect(curPixel, 0, 1, height1);\n                this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n                this.setFillStyles(this.params.primaryFontColor);\n                this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n            } else if (i % secondaryLabelInterval == 0) {\n                this.setFillStyles(this.params.secondaryColor);\n                this.fillRect(curPixel, 0, 1, height1);\n                this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n                this.setFillStyles(this.params.secondaryFontColor);\n                this.fillText(formatTime(curSeconds), curPixel + 5, height1);\n            } else {\n                this.setFillStyles(this.params.secondaryColor);\n                this.fillRect(curPixel, 0, 1, height2);\n            }\n\n            curSeconds += timeInterval;\n            curPixel += pixelsPerSecond * timeInterval;\n        }\n    }\n\n    setFillStyles(fillStyle) {\n        this.canvases.forEach(canvas => {\n            canvas.getContext('2d').fillStyle = fillStyle;\n        });\n    }\n\n    setFonts(font) {\n        this.canvases.forEach(canvas => {\n            canvas.getContext('2d').font = font;\n        });\n    }\n\n    fillRect(x, y, width, height) {\n        this.canvases.forEach((canvas, i) => {\n            const leftOffset = i * this.maxCanvasWidth;\n\n            const intersection = {\n                x1: Math.max(x, i * this.maxCanvasWidth),\n                y1: y,\n                x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),\n                y2: y + height\n            };\n\n            if (intersection.x1 < intersection.x2) {\n                canvas.getContext('2d').fillRect(\n                    intersection.x1 - leftOffset,\n                    intersection.y1,\n                    intersection.x2 - intersection.x1,\n                    intersection.y2 - intersection.y1\n                );\n            }\n        });\n    }\n\n    fillText(text, x, y) {\n        let textWidth;\n        let xOffset = 0;\n        let i;\n\n        for (i in this.canvases) {\n            const context = this.canvases[i].getContext('2d');\n            const canvasWidth = context.canvas.width;\n\n            if (xOffset > x + textWidth) {\n                break;\n            }\n\n            if (xOffset + canvasWidth > x) {\n                textWidth = context.measureText(text).width;\n                context.fillText(text, x - xOffset, y);\n            }\n\n            xOffset += canvasWidth;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugin/timeline.js"],"sourceRoot":""}